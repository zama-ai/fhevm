name: test-suite-orchestrate-e2e-tests

on:
  workflow_dispatch:
  pull_request:
    branches:
      - main

permissions: {} # No permissions needed at workflow level

concurrency:
  group: test-suite-orchestrate-e2e-tests-${{ github.ref }}
  cancel-in-progress: ${{ github.ref != 'refs/heads/main' }}

jobs:
  trigger-builds:
    name: test-suite-orchestrate-e2e-tests/trigger-builds
    # to be activated before merging this PR
    # if: ${{ startsWith(github.head_ref, 'mergify/merge-queue/') }}
    permissions:
      actions: 'write' # Required to trigger other workflows via workflow_dispatch
      contents: 'read' # Required to read repository information and refs
    runs-on: ubuntu-latest
    outputs:
      built-images: ${{ steps.collect.outputs.built-images }}
      image-tag: ${{ steps.collect.outputs.image-tag }}
    steps:
      - name: Trigger build workflows and collect results
        id: collect
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const workflows = [
              'coprocessor-db-migration-docker-build.yml',
              'coprocessor-gw-listener-docker-build.yml',
              'coprocessor-host-listener-docker-build.yml',
              'coprocessor-sns-worker-docker-build.yml',
              'coprocessor-tfhe-worker-docker-build.yml',
              'coprocessor-tx-sender-docker-build.yml',
              'coprocessor-zkproof-worker-docker-build.yml',
              'gateway-contracts-docker-build.yml',
              'host-contracts-docker-build.yml',
              'kms-connector-db-migration-docker-build.yml',
              'kms-connector-gw-listener-docker-build.yml',
              'kms-connector-kms-worker-docker-build.yml',
              'kms-connector-tx-sender-docker-build.yml',
              'test-suite-docker-build.yml'
            ];
            
            // Map workflow files to component version names
            const workflowToImageName = {
              'coprocessor-db-migration-docker-build.yml': 'db_migration_version',
              'coprocessor-gw-listener-docker-build.yml': 'gateway_listener_version',
              'coprocessor-host-listener-docker-build.yml': 'host_listener_version',
              'coprocessor-sns-worker-docker-build.yml': 'sns_worker_version',
              'coprocessor-tfhe-worker-docker-build.yml': 'tfhe_worker_version',
              'coprocessor-tx-sender-docker-build.yml': 'tx_sender_version',
              'coprocessor-zkproof-worker-docker-build.yml': 'zkproof_worker_version',
              'gateway-contracts-docker-build.yml': 'gateway_version',
              'host-contracts-docker-build.yml': 'host_version',
              'kms-connector-db-migration-docker-build.yml': 'connector_db_migration_version',
              'kms-connector-gw-listener-docker-build.yml': 'connector_gw_listener_version',
              'kms-connector-kms-worker-docker-build.yml': 'connector_kms_worker_version',
              'kms-connector-tx-sender-docker-build.yml': 'connector_tx_sender_version',
              'test-suite-docker-build.yml': 'test_suite_version'
            };
            
            // Determine target ref
            let ref;
            if (context.eventName === 'pull_request') {
              const pr = context.payload.pull_request;
              if (pr.head.repo.full_name !== `${context.repo.owner}/${context.repo.repo}`) {
                core.warning('PR from fork; skipping dispatch of internal build workflows.');
                return;
              }
              ref = pr.head.ref;
            } else {
              ref = process.env.GITHUB_REF_NAME || context.ref.replace('refs/heads/','');
            }

            console.log(`ğŸš€ Triggering builds using ref: ${ref}`);
            
            // Trigger all build workflows
            for (const workflow of workflows) {
              console.log(`\nTriggering ${workflow} on ref: ${ref}`);
              
              try {
                const response = await github.rest.actions.createWorkflowDispatch({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  workflow_id: workflow,
                  ref: ref,
                  inputs: {
                    ref: ref,
                    trigger_source: 'test-suite-orchestrate-e2e-tests'
                  }
                });
                
                console.log(`âœ… Successfully triggered ${workflow} (status: ${response.status})`);
              } catch (error) {
                console.log(`âŒ Failed to trigger ${workflow}: ${error.message}`);
              }
            }
            
            // Wait for workflows to start
            console.log('\nâ³ Waiting 30 seconds for workflows to start...');
            await new Promise(resolve => setTimeout(resolve, 30000));
            
            // Wait for builds to complete and collect results
            const maxAttempts = 60;
            let attempt = 1;
            let builtImages = [];
            let imageTag = '';
            
            while (attempt <= maxAttempts) {
              console.log(`\nAttempt ${attempt}/${maxAttempts}: Checking workflow results`);
              let allDone = true;
              const currentBuiltImages = [];
              let currentImageTag = '';
              
              for (const workflowName of workflows) {
                console.log(`Checking workflow: ${workflowName}`);
                
                // Look for recent workflow_dispatch runs (last 45 minutes)
                const sinceTime = new Date(Date.now() - 45 * 60 * 1000).toISOString();
                
                try {
                  const runs = await github.rest.actions.listWorkflowRuns({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    workflow_id: workflowName,
                    event: 'workflow_dispatch',
                    created: `>=${sinceTime}`,
                    per_page: 5
                  });
                  
                  const recentRun = runs.data.workflow_runs[0];
                  
                  if (recentRun) {
                    console.log(`   Found run: ID=${recentRun.id}, Status=${recentRun.status}, Conclusion=${recentRun.conclusion || 'null'}`);
                    
                    if (recentRun.conclusion === 'success') {
                      // Check specifically for the output-build-status job
                      const jobs = await github.rest.actions.listJobsForWorkflowRun({
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        run_id: recentRun.id
                      });
                      
                      const outputJob = jobs.data.jobs.find(job => 
                        job.name.includes('output-build-status')
                      );
                      
                      if (outputJob && outputJob.conclusion === 'success') {
                        // Get the actual SHA from the workflow run to determine the correct tag
                        const buildSha = recentRun.head_sha;
                        const tag = buildSha.substring(0, 7);
                        
                        const imageName = workflowToImageName[workflowName];
                        if (imageName) {
                          currentBuiltImages.push(imageName);
                          currentImageTag = tag;
                          console.log(`   âœ… ${workflowName} built image: ${imageName} with tag: ${tag} (from SHA: ${buildSha})`);
                        } else {
                          console.log(`   âš ï¸ ${workflowName} has no image mapping`);
                        }
                      } else if (outputJob && outputJob.conclusion === 'failure') {
                        console.log(`   ğŸ”¶ ${workflowName} completed but output-build-status indicates no image was built`);
                      } else {
                        console.log(`   ğŸ”¶ ${workflowName} completed but no output-build-status job found`);
                      }
                    } else if (recentRun.conclusion === 'failure' || recentRun.conclusion === 'cancelled') {
                      console.log(`   âŒ ${workflowName} failed with conclusion: ${recentRun.conclusion}`);
                    } else if (recentRun.status === 'in_progress' || recentRun.status === 'queued') {
                      console.log(`   â³ ${workflowName} still running (status: ${recentRun.status})`);
                      allDone = false;
                    }
                  } else {
                    console.log(`   âš ï¸ No recent workflow_dispatch run found for ${workflowName}`);
                    allDone = false;
                  }
                } catch (error) {
                  console.log(`   âŒ Error checking ${workflowName}: ${error.message}`);
                  allDone = false;
                }
              }
              
              if (allDone) {
                builtImages = currentBuiltImages;
                imageTag = currentImageTag;
                break;
              }
              
              console.log('Not all workflows complete yet, waiting 30 seconds...');
              await new Promise(resolve => setTimeout(resolve, 30000));
              attempt++;
            }
            
            if (attempt > maxAttempts) {
              console.log('âš ï¸ Timeout waiting for workflows to complete, using current results');
              builtImages = currentBuiltImages || [];
              imageTag = currentImageTag || '';
            }
            
            // Create outputs
            const jsonArray = JSON.stringify([...new Set(builtImages)]);
            
            console.log(`\nğŸ“Š Final results:`);
            console.log(`   Image tag: ${imageTag || 'none'}`);
            console.log(`   Built images: ${jsonArray}`);
            
            // Set GitHub outputs
            core.setOutput('built-images', jsonArray);
            core.setOutput('image-tag', imageTag);

  orchestrate-e2e-tests:
    name: test-suite-orchestrate-e2e-tests/orchestrate-e2e-tests
    needs: trigger-builds
    if: always()
    permissions:
      actions: 'write' # Required to trigger E2E test workflows via workflow_dispatch
      contents: 'read' # Required to read repository information and refs
    runs-on: ubuntu-latest
    steps:
      - name: Orchestrate E2E Tests
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1
        env:
          IMAGE_TAG: ${{ needs.trigger-builds.outputs.image-tag }}
          BUILT_IMAGES: ${{ needs.trigger-builds.outputs.built-images }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const imageTag = process.env.IMAGE_TAG;
            const builtImagesStr = process.env.BUILT_IMAGES || '[]';
            
            console.log(`ğŸ“Š Image tag: ${imageTag}`);
            console.log(`ğŸ“¦ Built images string: ${builtImagesStr}`);
            
            // Parse built images
            let builtImages;
            try {
              builtImages = JSON.parse(builtImagesStr);
            } catch (e) {
              console.log(`âŒ Failed to parse BUILT_IMAGES: ${e.message}`);
              return;
            }

            if (!Array.isArray(builtImages)) {
              console.log(`âŒ BUILT_IMAGES is not an array: ${typeof builtImages}`);
              return;
            }
            
            console.log(`ğŸ“‹ Parsed built images:`, builtImages);

            // Check if any images were built
            if (builtImages.length === 0) {
              console.log('â­ï¸ No images were built (path filters skipped all builds)');
              console.log('â­ï¸ Skipping E2E tests as there are no new images to test');
              core.notice('E2E tests skipped: No new images were built due to path filters');
              return;
            }

            // Initialize the 7 inputs that match test-suite-e2e-tests-mq.yml exactly
            const inputs = {};
            
            // Map built images to the exact 7-input structure from test-suite-e2e-tests-mq.yml
            const componentMapping = {
              'db_migration_version': { type: 'coprocessor', index: 0 },
              'gateway_listener_version': { type: 'coprocessor', index: 1 },  
              'host_listener_version': { type: 'coprocessor', index: 2 },
              'tx_sender_version': { type: 'coprocessor', index: 3 },
              'tfhe_worker_version': { type: 'coprocessor', index: 4 },
              'sns_worker_version': { type: 'coprocessor', index: 5 },
              'zkproof_worker_version': { type: 'coprocessor', index: 6 },
              'gateway_version': { type: 'gateway' },
              'host_version': { type: 'host' },
              'connector_db_migration_version': { type: 'connector', index: 0 },
              'connector_gw_listener_version': { type: 'connector', index: 1 },
              'connector_tx_sender_version': { type: 'connector', index: 2 },
              'connector_kms_worker_version': { type: 'connector', index: 3 },
              'test_suite_version': { type: 'test-suite' }
            };

            // Initialize arrays - but only add to inputs if we have actual built images
            const coprocessorArray = new Array(7).fill(null);
            const connectorArray = new Array(4).fill(null);
            let hasCoprocessorBuilds = false;
            let hasConnectorBuilds = false;
            let hasGatewayBuild = false;
            let hasHostBuild = false;
            let hasTestSuiteBuild = false;

            // Map built images to components
            for (const builtImage of builtImages) {
              const mapping = componentMapping[builtImage];
              if (mapping) {
                console.log(`âœ… Processing ${builtImage} â†’ ${mapping.type}${mapping.index !== undefined ? `[${mapping.index}]` : ''} = ${imageTag}`);
                
                switch (mapping.type) {
                  case 'coprocessor':
                    coprocessorArray[mapping.index] = imageTag;
                    hasCoprocessorBuilds = true;
                    break;
                  case 'gateway':
                    hasGatewayBuild = true;
                    break;
                  case 'host':
                    hasHostBuild = true;
                    break;
                  case 'connector':
                    connectorArray[mapping.index] = imageTag;
                    hasConnectorBuilds = true;
                    break;
                  case 'test-suite':
                    hasTestSuiteBuild = true;
                    break;
                }
              } else {
                console.log(`â­ï¸  Skipping ${builtImage} (no component mapping)`);
              }
            }

            // Only add inputs for components that were actually built
            
            if (hasCoprocessorBuilds) {
              inputs.coprocessor = JSON.stringify(coprocessorArray);
              console.log(`ğŸ“ Input 1 - coprocessor: ${inputs.coprocessor}`);
            }
            
            if (hasGatewayBuild) {
              inputs.gateway = imageTag;
              console.log(`ğŸ“ Input 2 - gateway: ${imageTag}`);
            }
            
            if (hasHostBuild) {
              inputs.host = imageTag;
              console.log(`ğŸ“ Input 3 - host: ${imageTag}`);
            }
            
            if (hasConnectorBuilds) {
              inputs.connector = JSON.stringify(connectorArray);
              console.log(`ğŸ“ Input 4 - connector: ${inputs.connector}`);
            }
            
            if (hasTestSuiteBuild) {
              inputs['test-suite'] = imageTag;
              console.log(`ğŸ“ Input 5 - test-suite: ${imageTag}`);
            }

            // Determine target ref
            let ref;
            if (context.eventName === 'pull_request') {
              ref = context.payload.pull_request.head.ref;
            } else {
              ref = process.env.GITHUB_REF_NAME || context.ref.replace('refs/heads/','');
            }
            
            console.log(`ğŸš€ Dispatching E2E tests on ref: ${ref}`);
            console.log(`ğŸ“ Final inputs (${Object.keys(inputs).length}/5 possible):`, inputs);
            console.log(`ğŸ“Š Dispatching with ${Object.keys(inputs).length} component overrides, others will use fhevm-cli defaults`);

            try {
              await github.rest.actions.createWorkflowDispatch({
                owner: context.repo.owner,
                repo: context.repo.repo,
                workflow_id: 'test-suite-e2e-tests-mq.yml',
                ref: ref,
                inputs: inputs
              });

              console.log('âœ… E2E tests workflow dispatched successfully!');
              
              console.log('ğŸ“‹ E2E tests will use these overridden versions:');
              Object.entries(inputs).forEach(([key, value]) => {
                console.log(`   ${key}: ${value}`);
              });
              console.log('ğŸ“‹ All other components will use fhevm-cli defaults');
              
            } catch (error) {
              console.log(`âŒ Failed to dispatch E2E tests: ${error.message}`);
              
              if (error.message.includes('Unexpected inputs provided')) {
                console.log('ğŸ’¡ The E2E workflow rejected some inputs.');
                console.log('ğŸ” This indicates a mismatch between input names.');
                console.log('ğŸ“‹ Attempted inputs:', Object.keys(inputs));
                console.log('ğŸ“‹ Expected inputs: coprocessor, gateway, host, connector, test-suite');
              }
              
              core.setFailed(`Failed to dispatch E2E tests: ${error.message}`);
            }
