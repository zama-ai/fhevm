name: check-changes-for-docker-build

on:
  workflow_call:
    secrets:
      GHCR_READ_TOKEN:
        required: true
    inputs:
      caller-workflow-event-name:
        description: "The github.name of the caller workflow"
        type: string
        required: true
      caller-workflow-event-before:
        description: "The github.event.before sha of the caller workflow"
        type: string
        required: true
      docker-image:
        description: "The name of the docker image of the service"
        type: string
        required: true
      max-commit-count:
        description: Maximum number of commits to search for an image
        type: number
        default: 50
        required: false
      filters:
        description: "The filters for the dorny/paths-filter action"
        type: string
        required: true
    outputs:
      base-commit:
        description: "The base commit of the previous docker image"
        value: ${{ jobs.check-changes.outputs.base-commit }}
      changes:
        description: "Output of the dorny/paths-filter action"
        value: ${{ jobs.check-changes.outputs.changes }}

permissions: {}

jobs:
  check-changes:
    name: check-changes
    permissions:
      actions: 'read' # Required to read workflow run information
      contents: 'read' # Required to checkout repository code
      pull-requests: 'read' # Required to read pull request information
    runs-on: ubuntu-latest
    outputs:
      changes: ${{ steps.set-changes-output.outputs.changes }}
      base-commit: ${{ steps.set-base-commit.outputs.base-commit }}
    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
        with:
          persist-credentials: 'false'

      - name: Install Docker (push only)
        if: inputs.caller-workflow-event-name == 'push'
        uses: docker/setup-docker-action@efe9e3891a4f7307e689f2100b33a155b900a608 # v4.5.0

      - name: Login to GitHub Container Registry (push only)
        if: inputs.caller-workflow-event-name == 'push'
        uses: docker/login-action@9780b0c442fbb1117ed29e0efdff1e18412f7567 # v3.3.0
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GHCR_READ_TOKEN }}

      - name: Find latest commit with existing image (push only)
        id: find-latest-image-commit
        if: inputs.caller-workflow-event-name == 'push'
        shell: bash
        env:
          BASE_BRANCH_COMMIT: ${{ inputs.caller-workflow-event-before }}
          IMAGE: ghcr.io/zama-ai/${{ inputs.docker-image }}
          MAX_COMMIT_COUNT: ${{ inputs.max-commit-count }}
        run: |
          git fetch origin main
          mapfile -t CANDIDATES < <(git rev-list "${BASE_BRANCH_COMMIT}" --max-count="${MAX_COMMIT_COUNT}")

          LATEST_IMAGE_COMMIT=""
          for commit in "${CANDIDATES[@]}"; do
            short_commit=${commit:0:7}
            echo "Checking if ${IMAGE}:${short_commit} image exists..."
            if docker manifest inspect "${IMAGE}:${short_commit}"; then
              LATEST_IMAGE_COMMIT="${commit}"
              echo "${IMAGE}:${short_commit} was found!"
              break
            fi
          done

          if [[ -z "${LATEST_IMAGE_COMMIT}" ]]; then
            echo "No images found for ${IMAGE} with the last ${MAX_COMMIT_COUNT} commits!"
            exit 1
          fi

          echo "latest-image-commit=${LATEST_IMAGE_COMMIT}" >> "$GITHUB_OUTPUT"

      - id: set-base-commit
        shell: bash
        env:
          LATEST_IMAGE_COMMIT: ${{ steps.find-latest-image-commit.outputs.latest-image-commit }}
          BASE_BRANCH_COMMIT: ${{ inputs.caller-workflow-event-before }}
        run: |
          echo "base-commit=${LATEST_IMAGE_COMMIT:-$BASE_BRANCH_COMMIT}" >> "$GITHUB_OUTPUT"

      - uses: dorny/paths-filter@de90cc6fb38fc0963ad72b210f1f284cd68cea36 # v3.0.2
        id: filter
        with:
          base: ${{ steps.set-base-commit.outputs.base-commit }}
          filters: ${{ inputs.filters }}

      - id: set-changes-output
        shell: bash
        env:
          INPUT_FILTERS: ${{ inputs.filters }}
          FILTER_OUTPUTS_JSON: ${{ toJSON(steps.filter.outputs) }}
        run: |
          # Ensure inputs.filters has exactly one top-level key and get it
          key_count=$(yq -r 'keys | length' <<< "$INPUT_FILTERS")
          if [[ "$key_count" -ne 1 ]]; then
            echo "Error: inputs.filters must contain exactly 1 top-level key, found $key_count" >&2
            exit 1
          fi
          first_key=$(yq -r 'keys | .[0]' <<< "$INPUT_FILTERS")

          # Use the key to retrieve the corresponding output from paths-filter
          first_value=$(jq -r --arg k "$first_key" '.[$k]' <<< "$FILTER_OUTPUTS_JSON")
          if [[ -z "$first_value" || "$first_value" == "null" ]]; then
            echo "Error: Output for filter key '$first_key' not found in paths-filter outputs." >&2
            echo "Available outputs: $(jq -r 'keys | join(",")' <<< "$FILTER_OUTPUTS_JSON")" >&2
            exit 1
          fi

          echo "changes=$first_value" >> "$GITHUB_OUTPUT"
