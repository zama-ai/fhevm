/**

Generated by the following Solidity interface...
```solidity
interface FHEVMExecutor {
    type FheType is uint8;

    error ACLNotAllowed(bytes32 handle, address account);
    error AddressEmptyCode(address target);
    error DivisionByZero();
    error ERC1967InvalidImplementation(address implementation);
    error ERC1967NonPayable();
    error FailedCall();
    error IncompatibleTypes();
    error InvalidByteLength(FheType typeOf, uint256 length);
    error InvalidInitialization();
    error InvalidType();
    error IsNotScalar();
    error NotHostOwner(address sender);
    error NotInitializing();
    error NotInitializingFromEmptyProxy();
    error NotPowerOfTwo();
    error ScalarByteIsNotBoolean();
    error SecondOperandIsNotScalar();
    error UUPSUnauthorizedCallContext();
    error UUPSUnsupportedProxiableUUID(bytes32 slot);
    error UnsupportedType();
    error UpperBoundAboveMaxTypeValue();

    event Cast(address indexed caller, bytes32 ct, FheType toType, bytes32 result);
    event FheAdd(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
    event FheBitAnd(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
    event FheBitOr(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
    event FheBitXor(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
    event FheDiv(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
    event FheEq(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
    event FheGe(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
    event FheGt(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
    event FheIfThenElse(address indexed caller, bytes32 control, bytes32 ifTrue, bytes32 ifFalse, bytes32 result);
    event FheLe(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
    event FheLt(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
    event FheMax(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
    event FheMin(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
    event FheMul(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
    event FheNe(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
    event FheNeg(address indexed caller, bytes32 ct, bytes32 result);
    event FheNot(address indexed caller, bytes32 ct, bytes32 result);
    event FheRand(address indexed caller, FheType randType, bytes16 seed, bytes32 result);
    event FheRandBounded(address indexed caller, uint256 upperBound, FheType randType, bytes16 seed, bytes32 result);
    event FheRem(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
    event FheRotl(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
    event FheRotr(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
    event FheShl(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
    event FheShr(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
    event FheSub(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
    event Initialized(uint64 version);
    event TrivialEncrypt(address indexed caller, uint256 pt, FheType toType, bytes32 result);
    event Upgraded(address indexed implementation);
    event VerifyInput(address indexed caller, bytes32 inputHandle, address userAddress, bytes inputProof, FheType inputType, bytes32 result);

    constructor();

    function UPGRADE_INTERFACE_VERSION() external view returns (string memory);
    function cast(bytes32 ct, FheType toType) external returns (bytes32 result);
    function fheAdd(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
    function fheBitAnd(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
    function fheBitOr(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
    function fheBitXor(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
    function fheDiv(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
    function fheEq(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
    function fheGe(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
    function fheGt(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
    function fheIfThenElse(bytes32 control, bytes32 ifTrue, bytes32 ifFalse) external returns (bytes32 result);
    function fheLe(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
    function fheLt(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
    function fheMax(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
    function fheMin(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
    function fheMul(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
    function fheNe(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
    function fheNeg(bytes32 ct) external returns (bytes32 result);
    function fheNot(bytes32 ct) external returns (bytes32 result);
    function fheRand(FheType randType) external returns (bytes32 result);
    function fheRandBounded(uint256 upperBound, FheType randType) external returns (bytes32 result);
    function fheRem(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
    function fheRotl(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
    function fheRotr(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
    function fheShl(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
    function fheShr(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
    function fheSub(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
    function getACLAddress() external view returns (address);
    function getHCULimitAddress() external view returns (address);
    function getHandleVersion() external pure returns (uint8);
    function getInputVerifierAddress() external view returns (address);
    function getVersion() external pure returns (string memory);
    function initializeFromEmptyProxy() external;
    function proxiableUUID() external view returns (bytes32);
    function trivialEncrypt(uint256 pt, FheType toType) external returns (bytes32 result);
    function upgradeToAndCall(address newImplementation, bytes memory data) external payable;
    function verifyInput(bytes32 inputHandle, address userAddress, bytes memory inputProof, FheType inputType) external returns (bytes32 result);
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "constructor",
    "inputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "UPGRADE_INTERFACE_VERSION",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "cast",
    "inputs": [
      {
        "name": "ct",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "toType",
        "type": "uint8",
        "internalType": "enum FheType"
      }
    ],
    "outputs": [
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "fheAdd",
    "inputs": [
      {
        "name": "lhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "internalType": "bytes1"
      }
    ],
    "outputs": [
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "fheBitAnd",
    "inputs": [
      {
        "name": "lhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "internalType": "bytes1"
      }
    ],
    "outputs": [
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "fheBitOr",
    "inputs": [
      {
        "name": "lhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "internalType": "bytes1"
      }
    ],
    "outputs": [
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "fheBitXor",
    "inputs": [
      {
        "name": "lhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "internalType": "bytes1"
      }
    ],
    "outputs": [
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "fheDiv",
    "inputs": [
      {
        "name": "lhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "internalType": "bytes1"
      }
    ],
    "outputs": [
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "fheEq",
    "inputs": [
      {
        "name": "lhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "internalType": "bytes1"
      }
    ],
    "outputs": [
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "fheGe",
    "inputs": [
      {
        "name": "lhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "internalType": "bytes1"
      }
    ],
    "outputs": [
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "fheGt",
    "inputs": [
      {
        "name": "lhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "internalType": "bytes1"
      }
    ],
    "outputs": [
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "fheIfThenElse",
    "inputs": [
      {
        "name": "control",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "ifTrue",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "ifFalse",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "fheLe",
    "inputs": [
      {
        "name": "lhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "internalType": "bytes1"
      }
    ],
    "outputs": [
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "fheLt",
    "inputs": [
      {
        "name": "lhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "internalType": "bytes1"
      }
    ],
    "outputs": [
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "fheMax",
    "inputs": [
      {
        "name": "lhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "internalType": "bytes1"
      }
    ],
    "outputs": [
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "fheMin",
    "inputs": [
      {
        "name": "lhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "internalType": "bytes1"
      }
    ],
    "outputs": [
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "fheMul",
    "inputs": [
      {
        "name": "lhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "internalType": "bytes1"
      }
    ],
    "outputs": [
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "fheNe",
    "inputs": [
      {
        "name": "lhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "internalType": "bytes1"
      }
    ],
    "outputs": [
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "fheNeg",
    "inputs": [
      {
        "name": "ct",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "fheNot",
    "inputs": [
      {
        "name": "ct",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "fheRand",
    "inputs": [
      {
        "name": "randType",
        "type": "uint8",
        "internalType": "enum FheType"
      }
    ],
    "outputs": [
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "fheRandBounded",
    "inputs": [
      {
        "name": "upperBound",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "randType",
        "type": "uint8",
        "internalType": "enum FheType"
      }
    ],
    "outputs": [
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "fheRem",
    "inputs": [
      {
        "name": "lhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "internalType": "bytes1"
      }
    ],
    "outputs": [
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "fheRotl",
    "inputs": [
      {
        "name": "lhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "internalType": "bytes1"
      }
    ],
    "outputs": [
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "fheRotr",
    "inputs": [
      {
        "name": "lhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "internalType": "bytes1"
      }
    ],
    "outputs": [
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "fheShl",
    "inputs": [
      {
        "name": "lhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "internalType": "bytes1"
      }
    ],
    "outputs": [
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "fheShr",
    "inputs": [
      {
        "name": "lhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "internalType": "bytes1"
      }
    ],
    "outputs": [
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "fheSub",
    "inputs": [
      {
        "name": "lhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "internalType": "bytes1"
      }
    ],
    "outputs": [
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "getACLAddress",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getHCULimitAddress",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getHandleVersion",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint8",
        "internalType": "uint8"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "getInputVerifierAddress",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getVersion",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "initializeFromEmptyProxy",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "proxiableUUID",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "trivialEncrypt",
    "inputs": [
      {
        "name": "pt",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "toType",
        "type": "uint8",
        "internalType": "enum FheType"
      }
    ],
    "outputs": [
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "upgradeToAndCall",
    "inputs": [
      {
        "name": "newImplementation",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "data",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [],
    "stateMutability": "payable"
  },
  {
    "type": "function",
    "name": "verifyInput",
    "inputs": [
      {
        "name": "inputHandle",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "userAddress",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "inputProof",
        "type": "bytes",
        "internalType": "bytes"
      },
      {
        "name": "inputType",
        "type": "uint8",
        "internalType": "enum FheType"
      }
    ],
    "outputs": [
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "event",
    "name": "Cast",
    "inputs": [
      {
        "name": "caller",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "ct",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "toType",
        "type": "uint8",
        "indexed": false,
        "internalType": "enum FheType"
      },
      {
        "name": "result",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "FheAdd",
    "inputs": [
      {
        "name": "caller",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "lhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "indexed": false,
        "internalType": "bytes1"
      },
      {
        "name": "result",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "FheBitAnd",
    "inputs": [
      {
        "name": "caller",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "lhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "indexed": false,
        "internalType": "bytes1"
      },
      {
        "name": "result",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "FheBitOr",
    "inputs": [
      {
        "name": "caller",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "lhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "indexed": false,
        "internalType": "bytes1"
      },
      {
        "name": "result",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "FheBitXor",
    "inputs": [
      {
        "name": "caller",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "lhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "indexed": false,
        "internalType": "bytes1"
      },
      {
        "name": "result",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "FheDiv",
    "inputs": [
      {
        "name": "caller",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "lhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "indexed": false,
        "internalType": "bytes1"
      },
      {
        "name": "result",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "FheEq",
    "inputs": [
      {
        "name": "caller",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "lhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "indexed": false,
        "internalType": "bytes1"
      },
      {
        "name": "result",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "FheGe",
    "inputs": [
      {
        "name": "caller",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "lhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "indexed": false,
        "internalType": "bytes1"
      },
      {
        "name": "result",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "FheGt",
    "inputs": [
      {
        "name": "caller",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "lhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "indexed": false,
        "internalType": "bytes1"
      },
      {
        "name": "result",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "FheIfThenElse",
    "inputs": [
      {
        "name": "caller",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "control",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "ifTrue",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "ifFalse",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "result",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "FheLe",
    "inputs": [
      {
        "name": "caller",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "lhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "indexed": false,
        "internalType": "bytes1"
      },
      {
        "name": "result",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "FheLt",
    "inputs": [
      {
        "name": "caller",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "lhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "indexed": false,
        "internalType": "bytes1"
      },
      {
        "name": "result",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "FheMax",
    "inputs": [
      {
        "name": "caller",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "lhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "indexed": false,
        "internalType": "bytes1"
      },
      {
        "name": "result",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "FheMin",
    "inputs": [
      {
        "name": "caller",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "lhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "indexed": false,
        "internalType": "bytes1"
      },
      {
        "name": "result",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "FheMul",
    "inputs": [
      {
        "name": "caller",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "lhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "indexed": false,
        "internalType": "bytes1"
      },
      {
        "name": "result",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "FheNe",
    "inputs": [
      {
        "name": "caller",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "lhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "indexed": false,
        "internalType": "bytes1"
      },
      {
        "name": "result",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "FheNeg",
    "inputs": [
      {
        "name": "caller",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "ct",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "result",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "FheNot",
    "inputs": [
      {
        "name": "caller",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "ct",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "result",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "FheRand",
    "inputs": [
      {
        "name": "caller",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "randType",
        "type": "uint8",
        "indexed": false,
        "internalType": "enum FheType"
      },
      {
        "name": "seed",
        "type": "bytes16",
        "indexed": false,
        "internalType": "bytes16"
      },
      {
        "name": "result",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "FheRandBounded",
    "inputs": [
      {
        "name": "caller",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "upperBound",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "randType",
        "type": "uint8",
        "indexed": false,
        "internalType": "enum FheType"
      },
      {
        "name": "seed",
        "type": "bytes16",
        "indexed": false,
        "internalType": "bytes16"
      },
      {
        "name": "result",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "FheRem",
    "inputs": [
      {
        "name": "caller",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "lhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "indexed": false,
        "internalType": "bytes1"
      },
      {
        "name": "result",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "FheRotl",
    "inputs": [
      {
        "name": "caller",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "lhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "indexed": false,
        "internalType": "bytes1"
      },
      {
        "name": "result",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "FheRotr",
    "inputs": [
      {
        "name": "caller",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "lhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "indexed": false,
        "internalType": "bytes1"
      },
      {
        "name": "result",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "FheShl",
    "inputs": [
      {
        "name": "caller",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "lhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "indexed": false,
        "internalType": "bytes1"
      },
      {
        "name": "result",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "FheShr",
    "inputs": [
      {
        "name": "caller",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "lhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "indexed": false,
        "internalType": "bytes1"
      },
      {
        "name": "result",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "FheSub",
    "inputs": [
      {
        "name": "caller",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "lhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "indexed": false,
        "internalType": "bytes1"
      },
      {
        "name": "result",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Initialized",
    "inputs": [
      {
        "name": "version",
        "type": "uint64",
        "indexed": false,
        "internalType": "uint64"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "TrivialEncrypt",
    "inputs": [
      {
        "name": "caller",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "pt",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "toType",
        "type": "uint8",
        "indexed": false,
        "internalType": "enum FheType"
      },
      {
        "name": "result",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Upgraded",
    "inputs": [
      {
        "name": "implementation",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "VerifyInput",
    "inputs": [
      {
        "name": "caller",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "inputHandle",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "userAddress",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      },
      {
        "name": "inputProof",
        "type": "bytes",
        "indexed": false,
        "internalType": "bytes"
      },
      {
        "name": "inputType",
        "type": "uint8",
        "indexed": false,
        "internalType": "enum FheType"
      },
      {
        "name": "result",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "error",
    "name": "ACLNotAllowed",
    "inputs": [
      {
        "name": "handle",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "AddressEmptyCode",
    "inputs": [
      {
        "name": "target",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "DivisionByZero",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ERC1967InvalidImplementation",
    "inputs": [
      {
        "name": "implementation",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "ERC1967NonPayable",
    "inputs": []
  },
  {
    "type": "error",
    "name": "FailedCall",
    "inputs": []
  },
  {
    "type": "error",
    "name": "IncompatibleTypes",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidByteLength",
    "inputs": [
      {
        "name": "typeOf",
        "type": "uint8",
        "internalType": "enum FheType"
      },
      {
        "name": "length",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "InvalidInitialization",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidType",
    "inputs": []
  },
  {
    "type": "error",
    "name": "IsNotScalar",
    "inputs": []
  },
  {
    "type": "error",
    "name": "NotHostOwner",
    "inputs": [
      {
        "name": "sender",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "NotInitializing",
    "inputs": []
  },
  {
    "type": "error",
    "name": "NotInitializingFromEmptyProxy",
    "inputs": []
  },
  {
    "type": "error",
    "name": "NotPowerOfTwo",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ScalarByteIsNotBoolean",
    "inputs": []
  },
  {
    "type": "error",
    "name": "SecondOperandIsNotScalar",
    "inputs": []
  },
  {
    "type": "error",
    "name": "UUPSUnauthorizedCallContext",
    "inputs": []
  },
  {
    "type": "error",
    "name": "UUPSUnsupportedProxiableUUID",
    "inputs": [
      {
        "name": "slot",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ]
  },
  {
    "type": "error",
    "name": "UnsupportedType",
    "inputs": []
  },
  {
    "type": "error",
    "name": "UpperBoundAboveMaxTypeValue",
    "inputs": []
  }
]
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod FHEVMExecutor {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x60a06040523073ffffffffffffffffffffffffffffffffffffffff1660809073ffffffffffffffffffffffffffffffffffffffff1681525034801562000043575f80fd5b50620000546200005a60201b60201c565b620001c4565b5f6200006b6200015e60201b60201c565b9050805f0160089054906101000a900460ff1615620000b6576040517ff92ee8a900000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b67ffffffffffffffff8016815f015f9054906101000a900467ffffffffffffffff1667ffffffffffffffff16146200015b5767ffffffffffffffff815f015f6101000a81548167ffffffffffffffff021916908367ffffffffffffffff1602179055507fc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d267ffffffffffffffff604051620001529190620001a9565b60405180910390a15b50565b5f7ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00905090565b5f67ffffffffffffffff82169050919050565b620001a38162000185565b82525050565b5f602082019050620001be5f83018462000198565b92915050565b608051617099620001eb5f395f8181614b6c01528181614bc10152614e6301526170995ff3fe608060405260043610610219575f3560e01c80637702dcff11610122578063ccc480a1116100aa578063d99882d51161006e578063d99882d5146108fd578063e078697214610939578063f51ccfb014610963578063f6859bdc1461099f578063f77f3f1d146109c957610219565b8063ccc480a1146107d1578063cf4d18aa1461080d578063d580c06314610849578063d75d6e8a14610885578063d8092cbc146108c157610219565b806391f98ffe116100f157806391f98ffe146106c95780639cd07acb14610705578063a8c7c2c114610741578063ad3cb1cc1461076b578063c021329e1461079557610219565b80637702dcff146105eb5780637a297f4b1461062757806385362ee7146106515780638b49ceb41461068d57610219565b806348eef47e116101a55780635a53accb116101745780635a53accb146104bf57806363a2db29146104fb5780636754b3601461053757806372107681146105735780637513a404146105af57610219565b806348eef47e146104015780634f1ef2861461043d57806352d1902d1461045957806357f0a5681461048357610219565b80631391547f116101ec5780631391547f146102fb578063182b6d98146103375780631c89ee441461037357806336318d64146103af57806339f73810146103eb57610219565b806304559f711461021d57806308bf832a146102595780630d8e6e2c14610295578063117b2f38146102bf575b5f80fd5b348015610228575f80fd5b50610243600480360381019061023e9190615e78565b610a05565b6040516102509190615ed7565b60405180910390f35b348015610264575f80fd5b5061027f600480360381019061027a91906160a9565b610bb4565b60405161028c9190615ed7565b60405180910390f35b3480156102a0575f80fd5b506102a9610dd1565b6040516102b691906161a3565b60405180910390f35b3480156102ca575f80fd5b506102e560048036038101906102e09190615e78565b610e4c565b6040516102f29190615ed7565b60405180910390f35b348015610306575f80fd5b50610321600480360381019061031c9190615e78565b610ffa565b60405161032e9190615ed7565b60405180910390f35b348015610342575f80fd5b5061035d60048036038101906103589190615e78565b6111a9565b60405161036a9190615ed7565b60405180910390f35b34801561037e575f80fd5b50610399600480360381019061039491906161c3565b611358565b6040516103a69190615ed7565b60405180910390f35b3480156103ba575f80fd5b506103d560048036038101906103d09190615e78565b611861565b6040516103e29190615ed7565b60405180910390f35b3480156103f6575f80fd5b506103ff611a10565b005b34801561040c575f80fd5b5061042760048036038101906104229190616234565b611b80565b6040516104349190615ed7565b60405180910390f35b61045760048036038101906104529190616272565b611bf4565b005b348015610464575f80fd5b5061046d611c13565b60405161047a9190615ed7565b60405180910390f35b34801561048e575f80fd5b506104a960048036038101906104a49190615e78565b611c44565b6040516104b69190615ed7565b60405180910390f35b3480156104ca575f80fd5b506104e560048036038101906104e09190615e78565b611df3565b6040516104f29190615ed7565b60405180910390f35b348015610506575f80fd5b50610521600480360381019061051c9190615e78565b61203c565b60405161052e9190615ed7565b60405180910390f35b348015610542575f80fd5b5061055d60048036038101906105589190615e78565b612234565b60405161056a9190615ed7565b60405180910390f35b34801561057e575f80fd5b5061059960048036038101906105949190615e78565b612408565b6040516105a69190615ed7565b60405180910390f35b3480156105ba575f80fd5b506105d560048036038101906105d09190615e78565b6125b7565b6040516105e29190615ed7565b60405180910390f35b3480156105f6575f80fd5b50610611600480360381019061060c91906162cc565b612766565b60405161061e9190615ed7565b60405180910390f35b348015610632575f80fd5b5061063b612982565b6040516106489190616337565b60405180910390f35b34801561065c575f80fd5b5061067760048036038101906106729190615e78565b612986565b6040516106849190615ed7565b60405180910390f35b348015610698575f80fd5b506106b360048036038101906106ae9190615e78565b612b35565b6040516106c09190615ed7565b60405180910390f35b3480156106d4575f80fd5b506106ef60048036038101906106ea9190615e78565b612d2d565b6040516106fc9190615ed7565b60405180910390f35b348015610710575f80fd5b5061072b60048036038101906107269190616234565b612f01565b6040516107389190615ed7565b60405180910390f35b34801561074c575f80fd5b50610755613219565b604051610762919061635f565b60405180910390f35b348015610776575f80fd5b5061077f613234565b60405161078c91906161a3565b60405180910390f35b3480156107a0575f80fd5b506107bb60048036038101906107b69190615e78565b61326d565b6040516107c89190615ed7565b60405180910390f35b3480156107dc575f80fd5b506107f760048036038101906107f29190615e78565b613441565b6040516108049190615ed7565b60405180910390f35b348015610818575f80fd5b50610833600480360381019061082e9190615e78565b613615565b6040516108409190615ed7565b60405180910390f35b348015610854575f80fd5b5061086f600480360381019061086a9190616378565b61385e565b60405161087c9190615ed7565b60405180910390f35b348015610890575f80fd5b506108ab60048036038101906108a691906163a3565b613a25565b6040516108b89190615ed7565b60405180910390f35b3480156108cc575f80fd5b506108e760048036038101906108e29190615e78565b613a95565b6040516108f49190615ed7565b60405180910390f35b348015610908575f80fd5b50610923600480360381019061091e9190615e78565b613cb2565b6040516109309190615ed7565b60405180910390f35b348015610944575f80fd5b5061094d613eaa565b60405161095a919061635f565b60405180910390f35b34801561096e575f80fd5b5061098960048036038101906109849190616378565b613ec5565b6040516109969190615ed7565b60405180910390f35b3480156109aa575f80fd5b506109b36140b0565b6040516109c0919061635f565b60405180910390f35b3480156109d4575f80fd5b506109ef60048036038101906109ea9190615e78565b6140cb565b6040516109fc9190615ed7565b60405180910390f35b5f8060066053811115610a1b57610a1a6163ce565b5b60ff166001901b60056053811115610a3657610a356163ce565b5b60ff166001901b60046053811115610a5157610a506163ce565b5b60ff166001901b60036053811115610a6c57610a6b6163ce565b5b60ff166001901b60026053811115610a8757610a866163ce565b5b60ff166001901b610a989190616428565b610aa29190616428565b610aac9190616428565b610ab69190616428565b90505f610ac386836142e8565b9050610ad360128787878561434e565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff1663642b149082868989886040518663ffffffff1660e01b8152600401610b2a9594939291906164b0565b5f604051808303815f87803b158015610b41575f80fd5b505af1158015610b53573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167fc11d62b13c360a83082487064be1ec0878b2f0be4f012bf59f89e128063d47ff87878787604051610ba39493929190616501565b60405180910390a250509392505050565b5f8060405180604001604052808673ffffffffffffffffffffffffffffffffffffffff1681526020013373ffffffffffffffffffffffffffffffffffffffff1681525090505f610c0387614676565b9050806053811115610c1857610c176163ce565b5b846053811115610c2b57610c2a6163ce565b5b14610c62576040517fb968846100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b7336772142b74871f255cbd7a3e89b401d3e45825f73ffffffffffffffffffffffffffffffffffffffff1663e6317df58389886040518463ffffffff1660e01b8152600401610cb3939291906165d2565b6020604051808303815f875af1158015610ccf573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610cf39190616622565b92507350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff16633e395cec84336040518363ffffffff1660e01b8152600401610d4492919061664d565b5f604051808303815f87803b158015610d5b575f80fd5b505af1158015610d6d573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167fdc370db33589e73371dc3ee42c789c003d336eefcb7c3f56fe0f51ae5b1d97028888888888604051610dbf959493929190616674565b60405180910390a25050949350505050565b60606040518060400160405280600d81526020017f464845564d4578656375746f7200000000000000000000000000000000000000815250610e125f6146ae565b610e1c60016146ae565b610e255f6146ae565b604051602001610e38949392919061679a565b604051602081830303815290604052905090565b5f8060066053811115610e6257610e616163ce565b5b60ff166001901b60056053811115610e7d57610e7c6163ce565b5b60ff166001901b60046053811115610e9857610e976163ce565b5b60ff166001901b60036053811115610eb357610eb26163ce565b5b60ff166001901b60026053811115610ece57610ecd6163ce565b5b60ff166001901b610edf9190616428565b610ee99190616428565b610ef39190616428565b610efd9190616428565b90505f610f0a86836142e8565b9050610f195f8787878561434e565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff1663fdad4c9682868989886040518663ffffffff1660e01b8152600401610f709594939291906164b0565b5f604051808303815f87803b158015610f87575f80fd5b505af1158015610f99573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167fdb9050d65240431621d61d6f94b970e63f53a67a5766614ee6e5c5bbd41c8e2e87878787604051610fe99493929190616501565b60405180910390a250509392505050565b5f80600660538111156110105761100f6163ce565b5b60ff166001901b6005605381111561102b5761102a6163ce565b5b60ff166001901b60046053811115611046576110456163ce565b5b60ff166001901b60036053811115611061576110606163ce565b5b60ff166001901b6002605381111561107c5761107b6163ce565b5b60ff166001901b61108d9190616428565b6110979190616428565b6110a19190616428565b6110ab9190616428565b90505f6110b886836142e8565b90506110c8600e8787875f61434e565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff16636bb3c61182868989886040518663ffffffff1660e01b815260040161111f9594939291906164b0565b5f604051808303815f87803b158015611136575f80fd5b505af1158015611148573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167f38c3a63c4230de5b741f494ffb54e3087104030279bc7bccee8ad9ad31712b21878787876040516111989493929190616501565b60405180910390a250509392505050565b5f80600660538111156111bf576111be6163ce565b5b60ff166001901b600560538111156111da576111d96163ce565b5b60ff166001901b600460538111156111f5576111f46163ce565b5b60ff166001901b600360538111156112105761120f6163ce565b5b60ff166001901b6002605381111561122b5761122a6163ce565b5b60ff166001901b61123c9190616428565b6112469190616428565b6112509190616428565b61125a9190616428565b90505f61126786836142e8565b905061127760018787878561434e565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff16639075310882868989886040518663ffffffff1660e01b81526004016112ce9594939291906164b0565b5f604051808303815f87803b1580156112e5575f80fd5b505af11580156112f7573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167feb6d37bd271abe1395b21d6d78f3487d6584862872c29ffd3f90736ee99b7393878787876040516113479493929190616501565b60405180910390a250509392505050565b5f7350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff166382027b6d84336040518363ffffffff1660e01b81526004016113a892919061664d565b602060405180830381865afa1580156113c3573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906113e7919061682d565b61142a5782336040517f9de3392c00000000000000000000000000000000000000000000000000000000815260040161142192919061664d565b60405180910390fd5b5f6008605381111561143f5761143e6163ce565b5b60ff166001901b6006605381111561145a576114596163ce565b5b60ff166001901b60056053811115611475576114746163ce565b5b60ff166001901b600460538111156114905761148f6163ce565b5b60ff166001901b600360538111156114ab576114aa6163ce565b5b60ff166001901b600260538111156114c6576114c56163ce565b5b60ff166001901b5f60538111156114e0576114df6163ce565b5b60ff166001901b6114f19190616428565b6114fb9190616428565b6115059190616428565b61150f9190616428565b6115199190616428565b6115239190616428565b90505f61153085836142e8565b90505f60086053811115611547576115466163ce565b5b60ff166001901b60066053811115611562576115616163ce565b5b60ff166001901b6005605381111561157d5761157c6163ce565b5b60ff166001901b60046053811115611598576115976163ce565b5b60ff166001901b600360538111156115b3576115b26163ce565b5b60ff166001901b600260538111156115ce576115cd6163ce565b5b60ff166001901b6115df9190616428565b6115e99190616428565b6115f39190616428565b6115fd9190616428565b6116079190616428565b90505f8186605381111561161e5761161d6163ce565b5b60ff166001901b160361165d576040517fc6de466a00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b8460538111156116705761166f6163ce565b5b826053811115611683576116826163ce565b5b036116ba576040517fb968846100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b601786867350157cffd6bbfa2dece204a89ec419c23ef5755d466040516020016116e89594939291906169ab565b60405160208183030381529060405280519060200120935061170a8486614778565b935073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff166302dd62768688876040518463ffffffff1660e01b815260040161175d93929190616a09565b5f604051808303815f87803b158015611774575f80fd5b505af1158015611786573d5f803e3d5ffd5b505050507350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff16633e395cec85336040518363ffffffff1660e01b81526004016117d992919061664d565b5f604051808303815f87803b1580156117f0575f80fd5b505af1158015611802573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167f31ccae6a2f8e3ced1692f77c8f668133e4afdaaa35afe844ff4659a6c27e627f87878760405161185093929190616a3e565b60405180910390a250505092915050565b5f8060066053811115611877576118766163ce565b5b60ff166001901b60056053811115611892576118916163ce565b5b60ff166001901b600460538111156118ad576118ac6163ce565b5b60ff166001901b600360538111156118c8576118c76163ce565b5b60ff166001901b600260538111156118e3576118e26163ce565b5b60ff166001901b6118f49190616428565b6118fe9190616428565b6119089190616428565b6119129190616428565b90505f61191f86836142e8565b905061192f60138787878561434e565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff1663acb5f38882868989886040518663ffffffff1660e01b81526004016119869594939291906164b0565b5f604051808303815f87803b15801561199d575f80fd5b505af11580156119af573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167ffd7c9208f956bf0c6ab76a667f04361245ad3e0a2d0eff92eb827acfcca68ea9878787876040516119ff9493929190616501565b60405180910390a250509392505050565b6001611a1a6147f1565b67ffffffffffffffff1614611a5b576040517f6f4f731f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60025f611a66614815565b9050805f0160089054906101000a900460ff1680611aae57508167ffffffffffffffff16815f015f9054906101000a900467ffffffffffffffff1667ffffffffffffffff1610155b15611ae5576040517ff92ee8a900000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b81815f015f6101000a81548167ffffffffffffffff021916908367ffffffffffffffff1602179055506001815f0160086101000a81548160ff0219169083151502179055505f815f0160086101000a81548160ff0219169083151502179055507fc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d282604051611b749190616a95565b60405180910390a15050565b5f80611b8a61483c565b9050611b978484836148b9565b91503373ffffffffffffffffffffffffffffffffffffffff167f5222d96b836727a1d6fe1ee9aef27f9bb507bd41794defa376ff6c648aaf8ff185858486604051611be59493929190616af7565b60405180910390a25092915050565b611bfc614b6a565b611c0582614c50565b611c0f8282614d43565b5050565b5f611c1c614e61565b7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5f1b905090565b5f8060066053811115611c5a57611c596163ce565b5b60ff166001901b60056053811115611c7557611c746163ce565b5b60ff166001901b60046053811115611c9057611c8f6163ce565b5b60ff166001901b60036053811115611cab57611caa6163ce565b5b60ff166001901b60026053811115611cc657611cc56163ce565b5b60ff166001901b611cd79190616428565b611ce19190616428565b611ceb9190616428565b611cf59190616428565b90505f611d0286836142e8565b9050611d1260028787878561434e565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff16633c16ff0d82868989886040518663ffffffff1660e01b8152600401611d699594939291906164b0565b5f604051808303815f87803b158015611d80575f80fd5b505af1158015611d92573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167f215346a4f9f975e6d5484e290bd4e53ca14453a9d282ebd3ccedb2a0f171753d87878787604051611de29493929190616501565b60405180910390a250509392505050565b5f600160f81b827effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191614611e53576040517f4f224e5300000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f801b8303611e8e576040517f23d359a300000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f60066053811115611ea357611ea26163ce565b5b60ff166001901b60056053811115611ebe57611ebd6163ce565b5b60ff166001901b60046053811115611ed957611ed86163ce565b5b60ff166001901b60036053811115611ef457611ef36163ce565b5b60ff166001901b60026053811115611f0f57611f0e6163ce565b5b60ff166001901b611f209190616428565b611f2a9190616428565b611f349190616428565b611f3e9190616428565b90505f611f4b86836142e8565b9050611f5b60038787878561434e565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff1663406b451382868989886040518663ffffffff1660e01b8152600401611fb29594939291906164b0565b5f604051808303815f87803b158015611fc9575f80fd5b505af1158015611fdb573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167f3bab2ee0e2f90f4690c6a87bf63cf1a6b626086e95f231860b152966e8dabbf78787878760405161202b9493929190616501565b60405180910390a250509392505050565b5f8060086053811115612052576120516163ce565b5b60ff166001901b6006605381111561206d5761206c6163ce565b5b60ff166001901b60056053811115612088576120876163ce565b5b60ff166001901b600460538111156120a3576120a26163ce565b5b60ff166001901b600360538111156120be576120bd6163ce565b5b60ff166001901b600260538111156120d9576120d86163ce565b5b60ff166001901b5f60538111156120f3576120f26163ce565b5b60ff166001901b6121049190616428565b61210e9190616428565b6121189190616428565b6121229190616428565b61212c9190616428565b6121369190616428565b90505f61214386836142e8565b905061215360068787878561434e565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff1663e8e399ad82868989886040518663ffffffff1660e01b81526004016121aa9594939291906164b0565b5f604051808303815f87803b1580156121c1575f80fd5b505af11580156121d3573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167f56df279bbfb03d9ed097bbe2f28d520ca0c1161206327926e98664d70d2c24c4878787876040516122239493929190616501565b60405180910390a250509392505050565b5f806008605381111561224a576122496163ce565b5b60ff166001901b60066053811115612265576122646163ce565b5b60ff166001901b600560538111156122805761227f6163ce565b5b60ff166001901b6004605381111561229b5761229a6163ce565b5b60ff166001901b600360538111156122b6576122b56163ce565b5b60ff166001901b600260538111156122d1576122d06163ce565b5b60ff166001901b6122e29190616428565b6122ec9190616428565b6122f69190616428565b6123009190616428565b61230a9190616428565b90505f61231786836142e8565b9050612327600a8787878561434e565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff166314526e8782868989886040518663ffffffff1660e01b815260040161237e9594939291906164b0565b5f604051808303815f87803b158015612395575f80fd5b505af11580156123a7573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167feb0e4f8dc74058194d0602425fe602f955c222200f7f10c6fe67992f7b24c7e9878787876040516123f79493929190616501565b60405180910390a250509392505050565b5f806006605381111561241e5761241d6163ce565b5b60ff166001901b60056053811115612439576124386163ce565b5b60ff166001901b60046053811115612454576124536163ce565b5b60ff166001901b6003605381111561246f5761246e6163ce565b5b60ff166001901b6002605381111561248a576124896163ce565b5b60ff166001901b61249b9190616428565b6124a59190616428565b6124af9190616428565b6124b99190616428565b90505f6124c686836142e8565b90506124d660118787875f61434e565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff16631339c5ee82868989886040518663ffffffff1660e01b815260040161252d9594939291906164b0565b5f604051808303815f87803b158015612544575f80fd5b505af1158015612556573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167f0d483b100d8c73b208984ec697caa3091521ee5525ce69edcf97d7e395d3d059878787876040516125a69493929190616501565b60405180910390a250509392505050565b5f80600660538111156125cd576125cc6163ce565b5b60ff166001901b600560538111156125e8576125e76163ce565b5b60ff166001901b60046053811115612603576126026163ce565b5b60ff166001901b6003605381111561261e5761261d6163ce565b5b60ff166001901b60026053811115612639576126386163ce565b5b60ff166001901b61264a9190616428565b6126549190616428565b61265e9190616428565b6126689190616428565b90505f61267586836142e8565b905061268560108787875f61434e565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff1663d47f3d5982868989886040518663ffffffff1660e01b81526004016126dc9594939291906164b0565b5f604051808303815f87803b1580156126f3575f80fd5b505af1158015612705573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167fdef2e704a077284a07f3d0b436db88f5d981b69f58ab7c1ae623252718a6de01878787876040516127559493929190616501565b60405180910390a250509392505050565b5f806008605381111561277c5761277b6163ce565b5b60ff166001901b60076053811115612797576127966163ce565b5b60ff166001901b600660538111156127b2576127b16163ce565b5b60ff166001901b600560538111156127cd576127cc6163ce565b5b60ff166001901b600460538111156127e8576127e76163ce565b5b60ff166001901b60036053811115612803576128026163ce565b5b60ff166001901b6002605381111561281e5761281d6163ce565b5b60ff166001901b5f6053811115612838576128376163ce565b5b60ff166001901b6128499190616428565b6128539190616428565b61285d9190616428565b6128679190616428565b6128719190616428565b61287b9190616428565b6128859190616428565b90505f61289285836142e8565b90506128a16019878787614ee8565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff16634e72676982888888886040518663ffffffff1660e01b81526004016128f8959493929190616b3a565b5f604051808303815f87803b15801561290f575f80fd5b505af1158015612921573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167f60be9d61aad849facc28c38b048cb5c4be3420b8fa2233e08cfa06be1b6d1c3e878787876040516129719493929190616b8b565b60405180910390a250509392505050565b5f90565b5f806006605381111561299c5761299b6163ce565b5b60ff166001901b600560538111156129b7576129b66163ce565b5b60ff166001901b600460538111156129d2576129d16163ce565b5b60ff166001901b600360538111156129ed576129ec6163ce565b5b60ff166001901b60026053811115612a0857612a076163ce565b5b60ff166001901b612a199190616428565b612a239190616428565b612a2d9190616428565b612a379190616428565b90505f612a4486836142e8565b9050612a54600f8787875f61434e565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff1663859a1b7082868989886040518663ffffffff1660e01b8152600401612aab9594939291906164b0565b5f604051808303815f87803b158015612ac2575f80fd5b505af1158015612ad4573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167fc9ff8f0d18a3f766ce5de3de216076050140e4fc2652f5e0e745f6fc836cda8b87878787604051612b249493929190616501565b60405180910390a250509392505050565b5f8060086053811115612b4b57612b4a6163ce565b5b60ff166001901b60066053811115612b6657612b656163ce565b5b60ff166001901b60056053811115612b8157612b806163ce565b5b60ff166001901b60046053811115612b9c57612b9b6163ce565b5b60ff166001901b60036053811115612bb757612bb66163ce565b5b60ff166001901b60026053811115612bd257612bd16163ce565b5b60ff166001901b5f6053811115612bec57612beb6163ce565b5b60ff166001901b612bfd9190616428565b612c079190616428565b612c119190616428565b612c1b9190616428565b612c259190616428565b612c2f9190616428565b90505f612c3c86836142e8565b9050612c4c60078787878561434e565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff16631434ba4d82868989886040518663ffffffff1660e01b8152600401612ca39594939291906164b0565b5f604051808303815f87803b158015612cba575f80fd5b505af1158015612ccc573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167f4d32284bd3193ecaa44e1ceca32f41c5d6c32803a92e07967dd3ee422972158287878787604051612d1c9493929190616501565b60405180910390a250509392505050565b5f8060086053811115612d4357612d426163ce565b5b60ff166001901b60066053811115612d5e57612d5d6163ce565b5b60ff166001901b60056053811115612d7957612d786163ce565b5b60ff166001901b60046053811115612d9457612d936163ce565b5b60ff166001901b60036053811115612daf57612dae6163ce565b5b60ff166001901b60026053811115612dca57612dc96163ce565b5b60ff166001901b612ddb9190616428565b612de59190616428565b612def9190616428565b612df99190616428565b612e039190616428565b90505f612e1086836142e8565b9050612e2060098787878561434e565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff16631ed91ff682868989886040518663ffffffff1660e01b8152600401612e779594939291906164b0565b5f604051808303815f87803b158015612e8e575f80fd5b505af1158015612ea0573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167f324220bfc9cb158b492991c03c309cd86e5345cac45aacae2092ddabe31fa3d887878787604051612ef09493929190616501565b60405180910390a250509392505050565b5f8060086053811115612f1757612f166163ce565b5b60ff166001901b60076053811115612f3257612f316163ce565b5b60ff166001901b60066053811115612f4d57612f4c6163ce565b5b60ff166001901b60056053811115612f6857612f676163ce565b5b60ff166001901b60046053811115612f8357612f826163ce565b5b60ff166001901b60036053811115612f9e57612f9d6163ce565b5b60ff166001901b60026053811115612fb957612fb86163ce565b5b60ff166001901b5f6053811115612fd357612fd26163ce565b5b60ff166001901b612fe49190616428565b612fee9190616428565b612ff89190616428565b6130029190616428565b61300c9190616428565b6130169190616428565b6130209190616428565b90505f81846053811115613037576130366163ce565b5b60ff166001901b1603613076576040517fc6de466a00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b601884847350157cffd6bbfa2dece204a89ec419c23ef5755d466040516020016130a4959493929190616bce565b6040516020818303038152906040528051906020012091506130c68284614778565b915073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff1663348c318584846040518363ffffffff1660e01b8152600401613117929190616c2c565b5f604051808303815f87803b15801561312e575f80fd5b505af1158015613140573d5f803e3d5ffd5b505050507350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff16633e395cec83336040518363ffffffff1660e01b815260040161319392919061664d565b5f604051808303815f87803b1580156131aa575f80fd5b505af11580156131bc573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167f063ccd1bba45151d91f6a418065047a3d048d058a922535747bb2b575a01d23685858560405161320a93929190616c53565b60405180910390a25092915050565b5f7336772142b74871f255cbd7a3e89b401d3e45825f905090565b6040518060400160405280600581526020017f352e302e3000000000000000000000000000000000000000000000000000000081525081565b5f8060086053811115613283576132826163ce565b5b60ff166001901b6006605381111561329e5761329d6163ce565b5b60ff166001901b600560538111156132b9576132b86163ce565b5b60ff166001901b600460538111156132d4576132d36163ce565b5b60ff166001901b600360538111156132ef576132ee6163ce565b5b60ff166001901b6002605381111561330a576133096163ce565b5b60ff166001901b61331b9190616428565b6133259190616428565b61332f9190616428565b6133399190616428565b6133439190616428565b90505f61335086836142e8565b9050613360600b8787878561434e565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff1663669181c082868989886040518663ffffffff1660e01b81526004016133b79594939291906164b0565b5f604051808303815f87803b1580156133ce575f80fd5b505af11580156133e0573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167fc148675905d07ad5496f8ef4d8195c907503f3ec12fd10ed5f21240abc693634878787876040516134309493929190616501565b60405180910390a250509392505050565b5f8060086053811115613457576134566163ce565b5b60ff166001901b60066053811115613472576134716163ce565b5b60ff166001901b6005605381111561348d5761348c6163ce565b5b60ff166001901b600460538111156134a8576134a76163ce565b5b60ff166001901b600360538111156134c3576134c26163ce565b5b60ff166001901b600260538111156134de576134dd6163ce565b5b60ff166001901b6134ef9190616428565b6134f99190616428565b6135039190616428565b61350d9190616428565b6135179190616428565b90505f61352486836142e8565b905061353460088787878561434e565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff166383e6a72082868989886040518663ffffffff1660e01b815260040161358b9594939291906164b0565b5f604051808303815f87803b1580156135a2575f80fd5b505af11580156135b4573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167fe84282aaebcca698443e39a2a948a345d0d2ebc654af5cb657a2d7e8053bf6cb878787876040516136049493929190616501565b60405180910390a250509392505050565b5f600160f81b827effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191614613675576040517f4f224e5300000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f801b83036136b0576040517f23d359a300000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f600660538111156136c5576136c46163ce565b5b60ff166001901b600560538111156136e0576136df6163ce565b5b60ff166001901b600460538111156136fb576136fa6163ce565b5b60ff166001901b60036053811115613716576137156163ce565b5b60ff166001901b60026053811115613731576137306163ce565b5b60ff166001901b6137429190616428565b61374c9190616428565b6137569190616428565b6137609190616428565b90505f61376d86836142e8565b905061377d60048787878561434e565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff1663fa08e38d82868989886040518663ffffffff1660e01b81526004016137d49594939291906164b0565b5f604051808303815f87803b1580156137eb575f80fd5b505af11580156137fd573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167f0e691cd0bf8c4e9308e4ced1bb9c964117dc5c5bb9b9ab5bdfebf2c9b13a897c8787878760405161384d9493929190616501565b60405180910390a250509392505050565b5f8060086053811115613874576138736163ce565b5b60ff166001901b6006605381111561388f5761388e6163ce565b5b60ff166001901b600560538111156138aa576138a96163ce565b5b60ff166001901b600460538111156138c5576138c46163ce565b5b60ff166001901b600360538111156138e0576138df6163ce565b5b60ff166001901b600260538111156138fb576138fa6163ce565b5b60ff166001901b61390c9190616428565b6139169190616428565b6139209190616428565b61392a9190616428565b6139349190616428565b90505f61394184836142e8565b905061394e601485615314565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff1663a4c98f3e8286866040518463ffffffff1660e01b81526004016139a193929190616a09565b5f604051808303815f87803b1580156139b8575f80fd5b505af11580156139ca573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167f8c664d3c3ca583fc5803b8a91c49644bbd9550bfa87967c73ad1de83027768c08585604051613a16929190616c88565b60405180910390a25050919050565b5f80613a2f61483c565b9050613a3b83826154c4565b91503373ffffffffffffffffffffffffffffffffffffffff167f0c8aca6017003326051e19913ef02631f24b801125e1fa8a1d812e868319fda6848385604051613a8793929190616caf565b60405180910390a250919050565b5f8060086053811115613aab57613aaa6163ce565b5b60ff166001901b60076053811115613ac657613ac56163ce565b5b60ff166001901b60066053811115613ae157613ae06163ce565b5b60ff166001901b60056053811115613afc57613afb6163ce565b5b60ff166001901b60046053811115613b1757613b166163ce565b5b60ff166001901b60036053811115613b3257613b316163ce565b5b60ff166001901b60026053811115613b4d57613b4c6163ce565b5b60ff166001901b5f6053811115613b6757613b666163ce565b5b60ff166001901b613b789190616428565b613b829190616428565b613b8c9190616428565b613b969190616428565b613ba09190616428565b613baa9190616428565b613bb49190616428565b90505f613bc186836142e8565b9050613bd1600d8787875f61434e565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff1663fa5defdb82868989886040518663ffffffff1660e01b8152600401613c289594939291906164b0565b5f604051808303815f87803b158015613c3f575f80fd5b505af1158015613c51573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167f6960c1e88f61c352dba34d1bbf6753e302795264d5d8ae82f7983c7004651e5d87878787604051613ca19493929190616501565b60405180910390a250509392505050565b5f8060086053811115613cc857613cc76163ce565b5b60ff166001901b60066053811115613ce357613ce26163ce565b5b60ff166001901b60056053811115613cfe57613cfd6163ce565b5b60ff166001901b60046053811115613d1957613d186163ce565b5b60ff166001901b60036053811115613d3457613d336163ce565b5b60ff166001901b60026053811115613d4f57613d4e6163ce565b5b60ff166001901b5f6053811115613d6957613d686163ce565b5b60ff166001901b613d7a9190616428565b613d849190616428565b613d8e9190616428565b613d989190616428565b613da29190616428565b613dac9190616428565b90505f613db986836142e8565b9050613dc960058787878561434e565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff16631856d91d82868989886040518663ffffffff1660e01b8152600401613e209594939291906164b0565b5f604051808303815f87803b158015613e37575f80fd5b505af1158015613e49573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167fe42486b0ccdbef81a2075c48c8e515c079aea73c8b82429997c72a2fe1bf4fef87878787604051613e999493929190616501565b60405180910390a250509392505050565b5f73233ff88a48c172d29f675403e6a8e302b0f032d9905090565b5f8060086053811115613edb57613eda6163ce565b5b60ff166001901b60066053811115613ef657613ef56163ce565b5b60ff166001901b60056053811115613f1157613f106163ce565b5b60ff166001901b60046053811115613f2c57613f2b6163ce565b5b60ff166001901b60036053811115613f4757613f466163ce565b5b60ff166001901b60026053811115613f6257613f616163ce565b5b60ff166001901b5f6053811115613f7c57613f7b6163ce565b5b60ff166001901b613f8d9190616428565b613f979190616428565b613fa19190616428565b613fab9190616428565b613fb59190616428565b613fbf9190616428565b90505f613fcc84836142e8565b9050613fd9601585615314565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff1663fc063c628286866040518463ffffffff1660e01b815260040161402c93929190616a09565b5f604051808303815f87803b158015614043575f80fd5b505af1158015614055573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167f55aff4cc7a3d160c83f1f15b818011ede841a0b4597fb14dcd3603df3a11e5e085856040516140a1929190616c88565b60405180910390a25050919050565b5f7350157cffd6bbfa2dece204a89ec419c23ef5755d905090565b5f80600860538111156140e1576140e06163ce565b5b60ff166001901b600760538111156140fc576140fb6163ce565b5b60ff166001901b60066053811115614117576141166163ce565b5b60ff166001901b60056053811115614132576141316163ce565b5b60ff166001901b6004605381111561414d5761414c6163ce565b5b60ff166001901b60036053811115614168576141676163ce565b5b60ff166001901b60026053811115614183576141826163ce565b5b60ff166001901b5f605381111561419d5761419c6163ce565b5b60ff166001901b6141ae9190616428565b6141b89190616428565b6141c29190616428565b6141cc9190616428565b6141d69190616428565b6141e09190616428565b6141ea9190616428565b90505f6141f786836142e8565b9050614207600c8787875f61434e565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff166394e70e4f82868989886040518663ffffffff1660e01b815260040161425e9594939291906164b0565b5f604051808303815f87803b158015614275575f80fd5b505af1158015614287573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167fb3d5c664ec86575818e8d75ff25c5f867250df8954088549c41c848cd10e76cb878787876040516142d79493929190616501565b60405180910390a250509392505050565b5f6142f283614676565b90505f82826053811115614309576143086163ce565b5b60ff166001901b1603614348576040517fc6de466a00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b92915050565b5f6143588361574d565b7350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff166382027b6d86336040518363ffffffff1660e01b81526004016143a792919061664d565b602060405180830381865afa1580156143c2573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906143e6919061682d565b6144295784336040517f9de3392c00000000000000000000000000000000000000000000000000000000815260040161442092919061664d565b60405180910390fd5b5f60f81b837effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff19160361459e577350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff166382027b6d85336040518363ffffffff1660e01b81526004016144a492919061664d565b602060405180830381865afa1580156144bf573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906144e3919061682d565b6145265783336040517f9de3392c00000000000000000000000000000000000000000000000000000000815260040161451d92919061664d565b60405180910390fd5b5f61453085614676565b90505f61453c87614676565b9050816053811115614551576145506163ce565b5b816053811115614564576145636163ce565b5b1461459b576040517f1f3158c700000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b50505b858585857350157cffd6bbfa2dece204a89ec419c23ef5755d466040516020016145cd96959493929190616d04565b6040516020818303038152906040528051906020012090506145ef8183614778565b90507350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff16633e395cec82336040518363ffffffff1660e01b815260040161464092919061664d565b5f604051808303815f87803b158015614657575f80fd5b505af1158015614669573d5f803e3d5ffd5b5050505095945050505050565b5f81601e6020811061468b5761468a616d73565b5b1a60f81b60f81c60ff1660538111156146a7576146a66163ce565b5b9050919050565b60605f60016146bc84615791565b0190505f8167ffffffffffffffff8111156146da576146d9615f62565b5b6040519080825280601f01601f19166020018201604052801561470c5781602001600182028036833780820191505090505b5090505f82602001820190505b60011561476d578080600190039150507f3031323334353637383961626364656600000000000000000000000000000000600a86061a8153600a858161476257614761616da0565b5b0494505f8503614719575b819350505050919050565b5f7fffffffffffffffffffffffffffffffffffffffffff00000000000000000000005f1b83169050605060ff5f1b901b8117905060104667ffffffffffffffff165f1b901b8117905060088260538111156147d6576147d56163ce565b5b60ff165f1b901b811790505f60ff165f1b8117905092915050565b5f6147fa614815565b5f015f9054906101000a900467ffffffffffffffff16905090565b5f7ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00905090565b5f806148466158e2565b9050805f01547350157cffd6bbfa2dece204a89ec419c23ef5755d4660014361486f9190616dcd565b4042604051602001614885959493929190616e00565b604051602081830303815290604052805190602001209150805f015f8154809291906148b090616e5e565b91905055505090565b5f80600860538111156148cf576148ce6163ce565b5b60ff166001901b600660538111156148ea576148e96163ce565b5b60ff166001901b60056053811115614905576149046163ce565b5b60ff166001901b600460538111156149205761491f6163ce565b5b60ff166001901b6003605381111561493b5761493a6163ce565b5b60ff166001901b60026053811115614956576149556163ce565b5b60ff166001901b6149679190616428565b6149719190616428565b61497b9190616428565b6149859190616428565b61498f9190616428565b90505f818560538111156149a6576149a56163ce565b5b60ff166001901b16036149e5576040517fc6de466a00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6149ee85615909565b614a24576040517f24e8e74200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b614a2e858561592d565b601b858585604051602001614a469493929190616ec5565b604051602081830303815290604052805190602001209150614a688285614778565b915073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff1663cc86678285846040518363ffffffff1660e01b8152600401614ab9929190616c2c565b5f604051808303815f87803b158015614ad0575f80fd5b505af1158015614ae2573d5f803e3d5ffd5b505050507350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff16633e395cec83336040518363ffffffff1660e01b8152600401614b3592919061664d565b5f604051808303815f87803b158015614b4c575f80fd5b505af1158015614b5e573d5f803e3d5ffd5b50505050509392505050565b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff163073ffffffffffffffffffffffffffffffffffffffff161480614c1757507f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16614bfe615a7d565b73ffffffffffffffffffffffffffffffffffffffff1614155b15614c4e576040517fe07c8dba00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b565b7350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff16638da5cb5b6040518163ffffffff1660e01b8152600401602060405180830381865afa158015614cad573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190614cd19190616f26565b73ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614614d4057336040517f21bfda10000000000000000000000000000000000000000000000000000000008152600401614d37919061635f565b60405180910390fd5b50565b8173ffffffffffffffffffffffffffffffffffffffff166352d1902d6040518163ffffffff1660e01b8152600401602060405180830381865afa925050508015614dab57506040513d601f19601f82011682018060405250810190614da89190616622565b60015b614dec57816040517f4c9c8ce3000000000000000000000000000000000000000000000000000000008152600401614de3919061635f565b60405180910390fd5b7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5f1b8114614e5257806040517faa1d49a4000000000000000000000000000000000000000000000000000000008152600401614e499190615ed7565b60405180910390fd5b614e5c8383615ad0565b505050565b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff163073ffffffffffffffffffffffffffffffffffffffff1614614ee6576040517fe07c8dba00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b565b5f7350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff166382027b6d85336040518363ffffffff1660e01b8152600401614f3892919061664d565b602060405180830381865afa158015614f53573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190614f77919061682d565b614fba5783336040517f9de3392c000000000000000000000000000000000000000000000000000000008152600401614fb192919061664d565b60405180910390fd5b7350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff166382027b6d84336040518363ffffffff1660e01b815260040161500992919061664d565b602060405180830381865afa158015615024573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190615048919061682d565b61508b5782336040517f9de3392c00000000000000000000000000000000000000000000000000000000815260040161508292919061664d565b60405180910390fd5b7350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff166382027b6d83336040518363ffffffff1660e01b81526004016150da92919061664d565b602060405180830381865afa1580156150f5573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190615119919061682d565b61515c5781336040517f9de3392c00000000000000000000000000000000000000000000000000000000815260040161515392919061664d565b60405180910390fd5b5f61516685614676565b90505f61517285614676565b90505f61517e85614676565b90505f6053811115615193576151926163ce565b5b8360538111156151a6576151a56163ce565b5b146151dd576040517fc6de466a00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b8060538111156151f0576151ef6163ce565b5b826053811115615203576152026163ce565b5b1461523a576040517f1f3158c700000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b878787877350157cffd6bbfa2dece204a89ec419c23ef5755d4660405160200161526996959493929190616f51565b60405160208183030381529060405280519060200120935061528b8483614778565b93507350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff16633e395cec85336040518363ffffffff1660e01b81526004016152dc92919061664d565b5f604051808303815f87803b1580156152f3575f80fd5b505af1158015615305573d5f803e3d5ffd5b50505050505050949350505050565b5f7350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff166382027b6d83336040518363ffffffff1660e01b815260040161536492919061664d565b602060405180830381865afa15801561537f573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906153a3919061682d565b6153e65781336040517f9de3392c0000000000000000000000000000000000000000000000000000000081526004016153dd92919061664d565b60405180910390fd5b82827350157cffd6bbfa2dece204a89ec419c23ef5755d466040516020016154119493929190616fc0565b6040516020818303038152906040528051906020012090505f61543383614676565b905061543f8282614778565b91507350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff16633e395cec83336040518363ffffffff1660e01b815260040161549092919061664d565b5f604051808303815f87803b1580156154a7575f80fd5b505af11580156154b9573d5f803e3d5ffd5b505050505092915050565b5f80600860538111156154da576154d96163ce565b5b60ff166001901b600660538111156154f5576154f46163ce565b5b60ff166001901b600560538111156155105761550f6163ce565b5b60ff166001901b6004605381111561552b5761552a6163ce565b5b60ff166001901b60036053811115615546576155456163ce565b5b60ff166001901b60026053811115615561576155606163ce565b5b60ff166001901b5f605381111561557b5761557a6163ce565b5b60ff166001901b61558c9190616428565b6155969190616428565b6155a09190616428565b6155aa9190616428565b6155b49190616428565b6155be9190616428565b90505f818560538111156155d5576155d46163ce565b5b60ff166001901b1603615614576040517fc6de466a00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b601a848460405160200161562a9392919061700d565b60405160208183030381529060405280519060200120915061564c8285614778565b915073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff166309b04e8f85846040518363ffffffff1660e01b815260040161569d929190616c2c565b5f604051808303815f87803b1580156156b4575f80fd5b505af11580156156c6573d5f803e3d5ffd5b505050507350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff16633e395cec83336040518363ffffffff1660e01b815260040161571992919061664d565b5f604051808303815f87803b158015615730575f80fd5b505af1158015615742573d5f803e3d5ffd5b505050505092915050565b60018160f81c60ff16111561578e576040517fdf7bf32500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b50565b5f805f90507a184f03e93ff9f4daa797ed6e38ed64bf6a1f01000000000000000083106157ed577a184f03e93ff9f4daa797ed6e38ed64bf6a1f01000000000000000083816157e3576157e2616da0565b5b0492506040810190505b6d04ee2d6d415b85acef8100000000831061582a576d04ee2d6d415b85acef810000000083816158205761581f616da0565b5b0492506020810190505b662386f26fc10000831061585957662386f26fc10000838161584f5761584e616da0565b5b0492506010810190505b6305f5e1008310615882576305f5e100838161587857615877616da0565b5b0492506008810190505b61271083106158a757612710838161589d5761589c616da0565b5b0492506004810190505b606483106158ca57606483816158c0576158bf616da0565b5b0492506002810190505b600a83106158d9576001810190505b80915050919050565b5f7f4613e1771f6b755d243e536fb5a23c5b15e2826575fee921e8fe7a22a760c800905090565b5f808211801561592657505f6001836159229190616dcd565b8316145b9050919050565b60026053811115615941576159406163ce565b5b816053811115615954576159536163ce565b5b0361596a5761596582610100615b42565b615a79565b6003605381111561597e5761597d6163ce565b5b816053811115615991576159906163ce565b5b036159a8576159a38262010000615b42565b615a79565b600460538111156159bc576159bb6163ce565b5b8160538111156159cf576159ce6163ce565b5b036159e8576159e382640100000000615b42565b615a79565b600560538111156159fc576159fb6163ce565b5b816053811115615a0f57615a0e6163ce565b5b03615a2c57615a278268010000000000000000615b42565b615a79565b60066053811115615a4057615a3f6163ce565b5b816053811115615a5357615a526163ce565b5b03615a7857615a7382700100000000000000000000000000000000615b42565b615a79565b5b5050565b5f615aa97f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5f1b615b80565b5f015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905090565b615ad982615b89565b8173ffffffffffffffffffffffffffffffffffffffff167fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b60405160405180910390a25f81511115615b3557615b2f8282615c52565b50615b3e565b615b3d615cd2565b5b5050565b80821115615b7c576040517fc7dadf4500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5050565b5f819050919050565b5f8173ffffffffffffffffffffffffffffffffffffffff163b03615be457806040517f4c9c8ce3000000000000000000000000000000000000000000000000000000008152600401615bdb919061635f565b60405180910390fd5b80615c107f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5f1b615b80565b5f015f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555050565b60605f808473ffffffffffffffffffffffffffffffffffffffff1684604051615c7b9190617083565b5f60405180830381855af49150503d805f8114615cb3576040519150601f19603f3d011682016040523d82523d5f602084013e615cb8565b606091505b5091509150615cc8858383615d0e565b9250505092915050565b5f341115615d0c576040517fb398979f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b565b606082615d2357615d1e82615d9b565b615d93565b5f8251148015615d4957505f8473ffffffffffffffffffffffffffffffffffffffff163b145b15615d8b57836040517f9996b315000000000000000000000000000000000000000000000000000000008152600401615d82919061635f565b60405180910390fd5b819050615d94565b5b9392505050565b5f81511115615dad5780518082602001fd5b6040517fd6bda27500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f604051905090565b5f80fd5b5f80fd5b5f819050919050565b615e0281615df0565b8114615e0c575f80fd5b50565b5f81359050615e1d81615df9565b92915050565b5f7fff0000000000000000000000000000000000000000000000000000000000000082169050919050565b615e5781615e23565b8114615e61575f80fd5b50565b5f81359050615e7281615e4e565b92915050565b5f805f60608486031215615e8f57615e8e615de8565b5b5f615e9c86828701615e0f565b9350506020615ead86828701615e0f565b9250506040615ebe86828701615e64565b9150509250925092565b615ed181615df0565b82525050565b5f602082019050615eea5f830184615ec8565b92915050565b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f615f1982615ef0565b9050919050565b615f2981615f0f565b8114615f33575f80fd5b50565b5f81359050615f4481615f20565b92915050565b5f80fd5b5f80fd5b5f601f19601f8301169050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b615f9882615f52565b810181811067ffffffffffffffff82111715615fb757615fb6615f62565b5b80604052505050565b5f615fc9615ddf565b9050615fd58282615f8f565b919050565b5f67ffffffffffffffff821115615ff457615ff3615f62565b5b615ffd82615f52565b9050602081019050919050565b828183375f83830152505050565b5f61602a61602584615fda565b615fc0565b90508281526020810184848401111561604657616045615f4e565b5b61605184828561600a565b509392505050565b5f82601f83011261606d5761606c615f4a565b5b813561607d848260208601616018565b91505092915050565b60548110616092575f80fd5b50565b5f813590506160a381616086565b92915050565b5f805f80608085870312156160c1576160c0615de8565b5b5f6160ce87828801615e0f565b94505060206160df87828801615f36565b935050604085013567ffffffffffffffff811115616100576160ff615dec565b5b61610c87828801616059565b925050606061611d87828801616095565b91505092959194509250565b5f81519050919050565b5f82825260208201905092915050565b5f5b83811015616160578082015181840152602081019050616145565b5f8484015250505050565b5f61617582616129565b61617f8185616133565b935061618f818560208601616143565b61619881615f52565b840191505092915050565b5f6020820190508181035f8301526161bb818461616b565b905092915050565b5f80604083850312156161d9576161d8615de8565b5b5f6161e685828601615e0f565b92505060206161f785828601616095565b9150509250929050565b5f819050919050565b61621381616201565b811461621d575f80fd5b50565b5f8135905061622e8161620a565b92915050565b5f806040838503121561624a57616249615de8565b5b5f61625785828601616220565b925050602061626885828601616095565b9150509250929050565b5f806040838503121561628857616287615de8565b5b5f61629585828601615f36565b925050602083013567ffffffffffffffff8111156162b6576162b5615dec565b5b6162c285828601616059565b9150509250929050565b5f805f606084860312156162e3576162e2615de8565b5b5f6162f086828701615e0f565b935050602061630186828701615e0f565b925050604061631286828701615e0f565b9150509250925092565b5f60ff82169050919050565b6163318161631c565b82525050565b5f60208201905061634a5f830184616328565b92915050565b61635981615f0f565b82525050565b5f6020820190506163725f830184616350565b92915050565b5f6020828403121561638d5761638c615de8565b5b5f61639a84828501615e0f565b91505092915050565b5f602082840312156163b8576163b7615de8565b5b5f6163c584828501616095565b91505092915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52602160045260245ffd5b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5f61643282616201565b915061643d83616201565b9250828201905080821115616455576164546163fb565b5b92915050565b6054811061646c5761646b6163ce565b5b50565b5f81905061647c8261645b565b919050565b5f61648b8261646f565b9050919050565b61649b81616481565b82525050565b6164aa81615e23565b82525050565b5f60a0820190506164c35f830188616492565b6164d060208301876164a1565b6164dd6040830186615ec8565b6164ea6060830185615ec8565b6164f76080830184615ec8565b9695505050505050565b5f6080820190506165145f830187615ec8565b6165216020830186615ec8565b61652e60408301856164a1565b61653b6060830184615ec8565b95945050505050565b61654d81615f0f565b82525050565b604082015f8201516165675f850182616544565b50602082015161657a6020850182616544565b50505050565b5f81519050919050565b5f82825260208201905092915050565b5f6165a482616580565b6165ae818561658a565b93506165be818560208601616143565b6165c781615f52565b840191505092915050565b5f6080820190506165e55f830186616553565b6165f26040830185615ec8565b8181036060830152616604818461659a565b9050949350505050565b5f8151905061661c81615df9565b92915050565b5f6020828403121561663757616636615de8565b5b5f6166448482850161660e565b91505092915050565b5f6040820190506166605f830185615ec8565b61666d6020830184616350565b9392505050565b5f60a0820190506166875f830188615ec8565b6166946020830187616350565b81810360408301526166a6818661659a565b90506166b56060830185616492565b6166c26080830184615ec8565b9695505050505050565b5f81905092915050565b5f6166e082616129565b6166ea81856166cc565b93506166fa818560208601616143565b80840191505092915050565b7f20760000000000000000000000000000000000000000000000000000000000005f82015250565b5f61673a6002836166cc565b915061674582616706565b600282019050919050565b7f2e000000000000000000000000000000000000000000000000000000000000005f82015250565b5f6167846001836166cc565b915061678f82616750565b600182019050919050565b5f6167a582876166d6565b91506167b08261672e565b91506167bc82866166d6565b91506167c782616778565b91506167d382856166d6565b91506167de82616778565b91506167ea82846166d6565b915081905095945050505050565b5f8115159050919050565b61680c816167f8565b8114616816575f80fd5b50565b5f8151905061682781616803565b92915050565b5f6020828403121561684257616841615de8565b5b5f61684f84828501616819565b91505092915050565b601c8110616869576168686163ce565b5b50565b5f81905061687982616858565b919050565b5f6168888261686c565b9050919050565b5f8160f81b9050919050565b5f6168a58261688f565b9050919050565b6168bd6168b88261687e565b61689b565b82525050565b5f819050919050565b6168dd6168d882615df0565b6168c3565b82525050565b6168f46168ef82616481565b61689b565b82525050565b5f819050919050565b5f61691d61691861691384615ef0565b6168fa565b615ef0565b9050919050565b5f61692e82616903565b9050919050565b5f61693f82616924565b9050919050565b5f8160601b9050919050565b5f61695c82616946565b9050919050565b5f61696d82616952565b9050919050565b61698561698082616935565b616963565b82525050565b5f819050919050565b6169a56169a082616201565b61698b565b82525050565b5f6169b682886168ac565b6001820191506169c682876168cc565b6020820191506169d682866168e3565b6001820191506169e68285616974565b6014820191506169f68284616994565b6020820191508190509695505050505050565b5f606082019050616a1c5f830186616492565b616a296020830185615ec8565b616a366040830184615ec8565b949350505050565b5f606082019050616a515f830186615ec8565b616a5e6020830185616492565b616a6b6040830184615ec8565b949350505050565b5f67ffffffffffffffff82169050919050565b616a8f81616a73565b82525050565b5f602082019050616aa85f830184616a86565b92915050565b616ab781616201565b82525050565b5f7fffffffffffffffffffffffffffffffff0000000000000000000000000000000082169050919050565b616af181616abd565b82525050565b5f608082019050616b0a5f830187616aae565b616b176020830186616492565b616b246040830185616ae8565b616b316060830184615ec8565b95945050505050565b5f60a082019050616b4d5f830188616492565b616b5a6020830187615ec8565b616b676040830186615ec8565b616b746060830185615ec8565b616b816080830184615ec8565b9695505050505050565b5f608082019050616b9e5f830187615ec8565b616bab6020830186615ec8565b616bb86040830185615ec8565b616bc56060830184615ec8565b95945050505050565b5f616bd982886168ac565b600182019150616be98287616994565b602082019150616bf982866168e3565b600182019150616c098285616974565b601482019150616c198284616994565b6020820191508190509695505050505050565b5f604082019050616c3f5f830185616492565b616c4c6020830184615ec8565b9392505050565b5f606082019050616c665f830186616aae565b616c736020830185616492565b616c806040830184615ec8565b949350505050565b5f604082019050616c9b5f830185615ec8565b616ca86020830184615ec8565b9392505050565b5f606082019050616cc25f830186616492565b616ccf6020830185616ae8565b616cdc6040830184615ec8565b949350505050565b5f819050919050565b616cfe616cf982615e23565b616ce4565b82525050565b5f616d0f82896168ac565b600182019150616d1f82886168cc565b602082019150616d2f82876168cc565b602082019150616d3f8286616ced565b600182019150616d4f8285616974565b601482019150616d5f8284616994565b602082019150819050979650505050505050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603260045260245ffd5b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601260045260245ffd5b5f616dd782616201565b9150616de283616201565b9250828203905081811115616dfa57616df96163fb565b5b92915050565b5f616e0b8288616994565b602082019150616e1b8287616974565b601482019150616e2b8286616994565b602082019150616e3b82856168cc565b602082019150616e4b8284616994565b6020820191508190509695505050505050565b5f616e6882616201565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8203616e9a57616e996163fb565b5b600182019050919050565b5f819050919050565b616ebf616eba82616abd565b616ea5565b82525050565b5f616ed082876168ac565b600182019150616ee08286616994565b602082019150616ef082856168e3565b600182019150616f008284616eae565b60108201915081905095945050505050565b5f81519050616f2081615f20565b92915050565b5f60208284031215616f3b57616f3a615de8565b5b5f616f4884828501616f12565b91505092915050565b5f616f5c82896168ac565b600182019150616f6c82886168cc565b602082019150616f7c82876168cc565b602082019150616f8c82866168cc565b602082019150616f9c8285616974565b601482019150616fac8284616994565b602082019150819050979650505050505050565b5f616fcb82876168ac565b600182019150616fdb82866168cc565b602082019150616feb8285616974565b601482019150616ffb8284616994565b60208201915081905095945050505050565b5f61701882866168ac565b60018201915061702882856168e3565b6001820191506170388284616eae565b601082019150819050949350505050565b5f81905092915050565b5f61705d82616580565b6170678185617049565b9350617077818560208601616143565b80840191505092915050565b5f61708e8284617053565b91508190509291505056
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\xA0`@R0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`\x80\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81RP4\x80\x15b\0\0CW_\x80\xFD[Pb\0\0Tb\0\0Z` \x1B` \x1CV[b\0\x01\xC4V[_b\0\0kb\0\x01^` \x1B` \x1CV[\x90P\x80_\x01`\x08\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x15b\0\0\xB6W`@Q\x7F\xF9.\xE8\xA9\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\x16\x81_\x01_\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14b\0\x01[Wg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81_\x01_a\x01\0\n\x81T\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP\x7F\xC7\xF5\x05\xB2\xF3q\xAE!u\xEEI\x13\xF4I\x9E\x1F&3\xA7\xB5\x93c!\xEE\xD1\xCD\xAE\xB6\x11Q\x81\xD2g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@Qb\0\x01R\x91\x90b\0\x01\xA9V[`@Q\x80\x91\x03\x90\xA1[PV[_\x7F\xF0\xC5~\x16\x84\r\xF0@\xF1P\x88\xDC/\x81\xFE9\x1C9#\xBE\xC7>#\xA9f.\xFC\x9C\"\x9Cj\0\x90P\x90V[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[b\0\x01\xA3\x81b\0\x01\x85V[\x82RPPV[_` \x82\x01\x90Pb\0\x01\xBE_\x83\x01\x84b\0\x01\x98V[\x92\x91PPV[`\x80Qap\x99b\0\x01\xEB_9_\x81\x81aKl\x01R\x81\x81aK\xC1\x01RaNc\x01Rap\x99_\xF3\xFE`\x80`@R`\x046\x10a\x02\x19W_5`\xE0\x1C\x80cw\x02\xDC\xFF\x11a\x01\"W\x80c\xCC\xC4\x80\xA1\x11a\0\xAAW\x80c\xD9\x98\x82\xD5\x11a\0nW\x80c\xD9\x98\x82\xD5\x14a\x08\xFDW\x80c\xE0xir\x14a\t9W\x80c\xF5\x1C\xCF\xB0\x14a\tcW\x80c\xF6\x85\x9B\xDC\x14a\t\x9FW\x80c\xF7\x7F?\x1D\x14a\t\xC9Wa\x02\x19V[\x80c\xCC\xC4\x80\xA1\x14a\x07\xD1W\x80c\xCFM\x18\xAA\x14a\x08\rW\x80c\xD5\x80\xC0c\x14a\x08IW\x80c\xD7]n\x8A\x14a\x08\x85W\x80c\xD8\t,\xBC\x14a\x08\xC1Wa\x02\x19V[\x80c\x91\xF9\x8F\xFE\x11a\0\xF1W\x80c\x91\xF9\x8F\xFE\x14a\x06\xC9W\x80c\x9C\xD0z\xCB\x14a\x07\x05W\x80c\xA8\xC7\xC2\xC1\x14a\x07AW\x80c\xAD<\xB1\xCC\x14a\x07kW\x80c\xC0!2\x9E\x14a\x07\x95Wa\x02\x19V[\x80cw\x02\xDC\xFF\x14a\x05\xEBW\x80cz)\x7FK\x14a\x06'W\x80c\x856.\xE7\x14a\x06QW\x80c\x8BI\xCE\xB4\x14a\x06\x8DWa\x02\x19V[\x80cH\xEE\xF4~\x11a\x01\xA5W\x80cZS\xAC\xCB\x11a\x01tW\x80cZS\xAC\xCB\x14a\x04\xBFW\x80cc\xA2\xDB)\x14a\x04\xFBW\x80cgT\xB3`\x14a\x057W\x80cr\x10v\x81\x14a\x05sW\x80cu\x13\xA4\x04\x14a\x05\xAFWa\x02\x19V[\x80cH\xEE\xF4~\x14a\x04\x01W\x80cO\x1E\xF2\x86\x14a\x04=W\x80cR\xD1\x90-\x14a\x04YW\x80cW\xF0\xA5h\x14a\x04\x83Wa\x02\x19V[\x80c\x13\x91T\x7F\x11a\x01\xECW\x80c\x13\x91T\x7F\x14a\x02\xFBW\x80c\x18+m\x98\x14a\x037W\x80c\x1C\x89\xEED\x14a\x03sW\x80c61\x8Dd\x14a\x03\xAFW\x80c9\xF78\x10\x14a\x03\xEBWa\x02\x19V[\x80c\x04U\x9Fq\x14a\x02\x1DW\x80c\x08\xBF\x83*\x14a\x02YW\x80c\r\x8En,\x14a\x02\x95W\x80c\x11{/8\x14a\x02\xBFW[_\x80\xFD[4\x80\x15a\x02(W_\x80\xFD[Pa\x02C`\x04\x806\x03\x81\x01\x90a\x02>\x91\x90a^xV[a\n\x05V[`@Qa\x02P\x91\x90a^\xD7V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x02dW_\x80\xFD[Pa\x02\x7F`\x04\x806\x03\x81\x01\x90a\x02z\x91\x90a`\xA9V[a\x0B\xB4V[`@Qa\x02\x8C\x91\x90a^\xD7V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x02\xA0W_\x80\xFD[Pa\x02\xA9a\r\xD1V[`@Qa\x02\xB6\x91\x90aa\xA3V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x02\xCAW_\x80\xFD[Pa\x02\xE5`\x04\x806\x03\x81\x01\x90a\x02\xE0\x91\x90a^xV[a\x0ELV[`@Qa\x02\xF2\x91\x90a^\xD7V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x03\x06W_\x80\xFD[Pa\x03!`\x04\x806\x03\x81\x01\x90a\x03\x1C\x91\x90a^xV[a\x0F\xFAV[`@Qa\x03.\x91\x90a^\xD7V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x03BW_\x80\xFD[Pa\x03]`\x04\x806\x03\x81\x01\x90a\x03X\x91\x90a^xV[a\x11\xA9V[`@Qa\x03j\x91\x90a^\xD7V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x03~W_\x80\xFD[Pa\x03\x99`\x04\x806\x03\x81\x01\x90a\x03\x94\x91\x90aa\xC3V[a\x13XV[`@Qa\x03\xA6\x91\x90a^\xD7V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x03\xBAW_\x80\xFD[Pa\x03\xD5`\x04\x806\x03\x81\x01\x90a\x03\xD0\x91\x90a^xV[a\x18aV[`@Qa\x03\xE2\x91\x90a^\xD7V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x03\xF6W_\x80\xFD[Pa\x03\xFFa\x1A\x10V[\0[4\x80\x15a\x04\x0CW_\x80\xFD[Pa\x04'`\x04\x806\x03\x81\x01\x90a\x04\"\x91\x90ab4V[a\x1B\x80V[`@Qa\x044\x91\x90a^\xD7V[`@Q\x80\x91\x03\x90\xF3[a\x04W`\x04\x806\x03\x81\x01\x90a\x04R\x91\x90abrV[a\x1B\xF4V[\0[4\x80\x15a\x04dW_\x80\xFD[Pa\x04ma\x1C\x13V[`@Qa\x04z\x91\x90a^\xD7V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x04\x8EW_\x80\xFD[Pa\x04\xA9`\x04\x806\x03\x81\x01\x90a\x04\xA4\x91\x90a^xV[a\x1CDV[`@Qa\x04\xB6\x91\x90a^\xD7V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x04\xCAW_\x80\xFD[Pa\x04\xE5`\x04\x806\x03\x81\x01\x90a\x04\xE0\x91\x90a^xV[a\x1D\xF3V[`@Qa\x04\xF2\x91\x90a^\xD7V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x05\x06W_\x80\xFD[Pa\x05!`\x04\x806\x03\x81\x01\x90a\x05\x1C\x91\x90a^xV[a <V[`@Qa\x05.\x91\x90a^\xD7V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x05BW_\x80\xFD[Pa\x05]`\x04\x806\x03\x81\x01\x90a\x05X\x91\x90a^xV[a\"4V[`@Qa\x05j\x91\x90a^\xD7V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x05~W_\x80\xFD[Pa\x05\x99`\x04\x806\x03\x81\x01\x90a\x05\x94\x91\x90a^xV[a$\x08V[`@Qa\x05\xA6\x91\x90a^\xD7V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x05\xBAW_\x80\xFD[Pa\x05\xD5`\x04\x806\x03\x81\x01\x90a\x05\xD0\x91\x90a^xV[a%\xB7V[`@Qa\x05\xE2\x91\x90a^\xD7V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x05\xF6W_\x80\xFD[Pa\x06\x11`\x04\x806\x03\x81\x01\x90a\x06\x0C\x91\x90ab\xCCV[a'fV[`@Qa\x06\x1E\x91\x90a^\xD7V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x062W_\x80\xFD[Pa\x06;a)\x82V[`@Qa\x06H\x91\x90ac7V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x06\\W_\x80\xFD[Pa\x06w`\x04\x806\x03\x81\x01\x90a\x06r\x91\x90a^xV[a)\x86V[`@Qa\x06\x84\x91\x90a^\xD7V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x06\x98W_\x80\xFD[Pa\x06\xB3`\x04\x806\x03\x81\x01\x90a\x06\xAE\x91\x90a^xV[a+5V[`@Qa\x06\xC0\x91\x90a^\xD7V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x06\xD4W_\x80\xFD[Pa\x06\xEF`\x04\x806\x03\x81\x01\x90a\x06\xEA\x91\x90a^xV[a--V[`@Qa\x06\xFC\x91\x90a^\xD7V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x07\x10W_\x80\xFD[Pa\x07+`\x04\x806\x03\x81\x01\x90a\x07&\x91\x90ab4V[a/\x01V[`@Qa\x078\x91\x90a^\xD7V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x07LW_\x80\xFD[Pa\x07Ua2\x19V[`@Qa\x07b\x91\x90ac_V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x07vW_\x80\xFD[Pa\x07\x7Fa24V[`@Qa\x07\x8C\x91\x90aa\xA3V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x07\xA0W_\x80\xFD[Pa\x07\xBB`\x04\x806\x03\x81\x01\x90a\x07\xB6\x91\x90a^xV[a2mV[`@Qa\x07\xC8\x91\x90a^\xD7V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x07\xDCW_\x80\xFD[Pa\x07\xF7`\x04\x806\x03\x81\x01\x90a\x07\xF2\x91\x90a^xV[a4AV[`@Qa\x08\x04\x91\x90a^\xD7V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x08\x18W_\x80\xFD[Pa\x083`\x04\x806\x03\x81\x01\x90a\x08.\x91\x90a^xV[a6\x15V[`@Qa\x08@\x91\x90a^\xD7V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x08TW_\x80\xFD[Pa\x08o`\x04\x806\x03\x81\x01\x90a\x08j\x91\x90acxV[a8^V[`@Qa\x08|\x91\x90a^\xD7V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x08\x90W_\x80\xFD[Pa\x08\xAB`\x04\x806\x03\x81\x01\x90a\x08\xA6\x91\x90ac\xA3V[a:%V[`@Qa\x08\xB8\x91\x90a^\xD7V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x08\xCCW_\x80\xFD[Pa\x08\xE7`\x04\x806\x03\x81\x01\x90a\x08\xE2\x91\x90a^xV[a:\x95V[`@Qa\x08\xF4\x91\x90a^\xD7V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\t\x08W_\x80\xFD[Pa\t#`\x04\x806\x03\x81\x01\x90a\t\x1E\x91\x90a^xV[a<\xB2V[`@Qa\t0\x91\x90a^\xD7V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\tDW_\x80\xFD[Pa\tMa>\xAAV[`@Qa\tZ\x91\x90ac_V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\tnW_\x80\xFD[Pa\t\x89`\x04\x806\x03\x81\x01\x90a\t\x84\x91\x90acxV[a>\xC5V[`@Qa\t\x96\x91\x90a^\xD7V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\t\xAAW_\x80\xFD[Pa\t\xB3a@\xB0V[`@Qa\t\xC0\x91\x90ac_V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\t\xD4W_\x80\xFD[Pa\t\xEF`\x04\x806\x03\x81\x01\x90a\t\xEA\x91\x90a^xV[a@\xCBV[`@Qa\t\xFC\x91\x90a^\xD7V[`@Q\x80\x91\x03\x90\xF3[_\x80`\x06`S\x81\x11\x15a\n\x1BWa\n\x1Aac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a\n6Wa\n5ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a\nQWa\nPac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a\nlWa\nkac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a\n\x87Wa\n\x86ac\xCEV[[`\xFF\x16`\x01\x90\x1Ba\n\x98\x91\x90ad(V[a\n\xA2\x91\x90ad(V[a\n\xAC\x91\x90ad(V[a\n\xB6\x91\x90ad(V[\x90P_a\n\xC3\x86\x83aB\xE8V[\x90Pa\n\xD3`\x12\x87\x87\x87\x85aCNV[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16cd+\x14\x90\x82\x86\x89\x89\x88`@Q\x86c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x0B*\x95\x94\x93\x92\x91\x90ad\xB0V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x0BAW_\x80\xFD[PZ\xF1\x15\x80\x15a\x0BSW=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xC1\x1Db\xB1<6\n\x83\x08$\x87\x06K\xE1\xEC\x08x\xB2\xF0\xBEO\x01+\xF5\x9F\x89\xE1(\x06=G\xFF\x87\x87\x87\x87`@Qa\x0B\xA3\x94\x93\x92\x91\x90ae\x01V[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_\x80`@Q\x80`@\x01`@R\x80\x86s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x013s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81RP\x90P_a\x0C\x03\x87aFvV[\x90P\x80`S\x81\x11\x15a\x0C\x18Wa\x0C\x17ac\xCEV[[\x84`S\x81\x11\x15a\x0C+Wa\x0C*ac\xCEV[[\x14a\x0CbW`@Q\x7F\xB9h\x84a\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[s6w!B\xB7Hq\xF2U\xCB\xD7\xA3\xE8\x9B@\x1D>E\x82_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xE61}\xF5\x83\x89\x88`@Q\x84c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x0C\xB3\x93\x92\x91\x90ae\xD2V[` `@Q\x80\x83\x03\x81_\x87Z\xF1\x15\x80\x15a\x0C\xCFW=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x0C\xF3\x91\x90af\"V[\x92PsP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c>9\\\xEC\x843`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\rD\x92\x91\x90afMV[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\r[W_\x80\xFD[PZ\xF1\x15\x80\x15a\rmW=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xDC7\r\xB35\x89\xE73q\xDC>\xE4,x\x9C\0=3n\xEF\xCB|?V\xFE\x0FQ\xAE[\x1D\x97\x02\x88\x88\x88\x88\x88`@Qa\r\xBF\x95\x94\x93\x92\x91\x90aftV[`@Q\x80\x91\x03\x90\xA2PP\x94\x93PPPPV[```@Q\x80`@\x01`@R\x80`\r\x81R` \x01\x7FFHEVMExecutor\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81RPa\x0E\x12_aF\xAEV[a\x0E\x1C`\x01aF\xAEV[a\x0E%_aF\xAEV[`@Q` \x01a\x0E8\x94\x93\x92\x91\x90ag\x9AV[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x90P\x90V[_\x80`\x06`S\x81\x11\x15a\x0EbWa\x0Eaac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a\x0E}Wa\x0E|ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a\x0E\x98Wa\x0E\x97ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a\x0E\xB3Wa\x0E\xB2ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a\x0E\xCEWa\x0E\xCDac\xCEV[[`\xFF\x16`\x01\x90\x1Ba\x0E\xDF\x91\x90ad(V[a\x0E\xE9\x91\x90ad(V[a\x0E\xF3\x91\x90ad(V[a\x0E\xFD\x91\x90ad(V[\x90P_a\x0F\n\x86\x83aB\xE8V[\x90Pa\x0F\x19_\x87\x87\x87\x85aCNV[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xFD\xADL\x96\x82\x86\x89\x89\x88`@Q\x86c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x0Fp\x95\x94\x93\x92\x91\x90ad\xB0V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x0F\x87W_\x80\xFD[PZ\xF1\x15\x80\x15a\x0F\x99W=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xDB\x90P\xD6R@C\x16!\xD6\x1Do\x94\xB9p\xE6?S\xA6zWfaN\xE6\xE5\xC5\xBB\xD4\x1C\x8E.\x87\x87\x87\x87`@Qa\x0F\xE9\x94\x93\x92\x91\x90ae\x01V[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_\x80`\x06`S\x81\x11\x15a\x10\x10Wa\x10\x0Fac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a\x10+Wa\x10*ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a\x10FWa\x10Eac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a\x10aWa\x10`ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a\x10|Wa\x10{ac\xCEV[[`\xFF\x16`\x01\x90\x1Ba\x10\x8D\x91\x90ad(V[a\x10\x97\x91\x90ad(V[a\x10\xA1\x91\x90ad(V[a\x10\xAB\x91\x90ad(V[\x90P_a\x10\xB8\x86\x83aB\xE8V[\x90Pa\x10\xC8`\x0E\x87\x87\x87_aCNV[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16ck\xB3\xC6\x11\x82\x86\x89\x89\x88`@Q\x86c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x11\x1F\x95\x94\x93\x92\x91\x90ad\xB0V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x116W_\x80\xFD[PZ\xF1\x15\x80\x15a\x11HW=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F8\xC3\xA6<B0\xDE[t\x1FIO\xFBT\xE3\x08q\x04\x03\x02y\xBC{\xCC\xEE\x8A\xD9\xAD1q+!\x87\x87\x87\x87`@Qa\x11\x98\x94\x93\x92\x91\x90ae\x01V[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_\x80`\x06`S\x81\x11\x15a\x11\xBFWa\x11\xBEac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a\x11\xDAWa\x11\xD9ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a\x11\xF5Wa\x11\xF4ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a\x12\x10Wa\x12\x0Fac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a\x12+Wa\x12*ac\xCEV[[`\xFF\x16`\x01\x90\x1Ba\x12<\x91\x90ad(V[a\x12F\x91\x90ad(V[a\x12P\x91\x90ad(V[a\x12Z\x91\x90ad(V[\x90P_a\x12g\x86\x83aB\xE8V[\x90Pa\x12w`\x01\x87\x87\x87\x85aCNV[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x90u1\x08\x82\x86\x89\x89\x88`@Q\x86c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x12\xCE\x95\x94\x93\x92\x91\x90ad\xB0V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x12\xE5W_\x80\xFD[PZ\xF1\x15\x80\x15a\x12\xF7W=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xEBm7\xBD'\x1A\xBE\x13\x95\xB2\x1Dmx\xF3H}e\x84\x86(r\xC2\x9F\xFD?\x90sn\xE9\x9Bs\x93\x87\x87\x87\x87`@Qa\x13G\x94\x93\x92\x91\x90ae\x01V[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_sP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x82\x02{m\x843`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x13\xA8\x92\x91\x90afMV[` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x13\xC3W=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x13\xE7\x91\x90ah-V[a\x14*W\x823`@Q\x7F\x9D\xE39,\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x14!\x92\x91\x90afMV[`@Q\x80\x91\x03\x90\xFD[_`\x08`S\x81\x11\x15a\x14?Wa\x14>ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x06`S\x81\x11\x15a\x14ZWa\x14Yac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a\x14uWa\x14tac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a\x14\x90Wa\x14\x8Fac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a\x14\xABWa\x14\xAAac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a\x14\xC6Wa\x14\xC5ac\xCEV[[`\xFF\x16`\x01\x90\x1B_`S\x81\x11\x15a\x14\xE0Wa\x14\xDFac\xCEV[[`\xFF\x16`\x01\x90\x1Ba\x14\xF1\x91\x90ad(V[a\x14\xFB\x91\x90ad(V[a\x15\x05\x91\x90ad(V[a\x15\x0F\x91\x90ad(V[a\x15\x19\x91\x90ad(V[a\x15#\x91\x90ad(V[\x90P_a\x150\x85\x83aB\xE8V[\x90P_`\x08`S\x81\x11\x15a\x15GWa\x15Fac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x06`S\x81\x11\x15a\x15bWa\x15aac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a\x15}Wa\x15|ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a\x15\x98Wa\x15\x97ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a\x15\xB3Wa\x15\xB2ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a\x15\xCEWa\x15\xCDac\xCEV[[`\xFF\x16`\x01\x90\x1Ba\x15\xDF\x91\x90ad(V[a\x15\xE9\x91\x90ad(V[a\x15\xF3\x91\x90ad(V[a\x15\xFD\x91\x90ad(V[a\x16\x07\x91\x90ad(V[\x90P_\x81\x86`S\x81\x11\x15a\x16\x1EWa\x16\x1Dac\xCEV[[`\xFF\x16`\x01\x90\x1B\x16\x03a\x16]W`@Q\x7F\xC6\xDEFj\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x84`S\x81\x11\x15a\x16pWa\x16oac\xCEV[[\x82`S\x81\x11\x15a\x16\x83Wa\x16\x82ac\xCEV[[\x03a\x16\xBAW`@Q\x7F\xB9h\x84a\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x17\x86\x86sP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]F`@Q` \x01a\x16\xE8\x95\x94\x93\x92\x91\x90ai\xABV[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x93Pa\x17\n\x84\x86aGxV[\x93Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x02\xDDbv\x86\x88\x87`@Q\x84c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x17]\x93\x92\x91\x90aj\tV[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x17tW_\x80\xFD[PZ\xF1\x15\x80\x15a\x17\x86W=_\x80>=_\xFD[PPPPsP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c>9\\\xEC\x853`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x17\xD9\x92\x91\x90afMV[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x17\xF0W_\x80\xFD[PZ\xF1\x15\x80\x15a\x18\x02W=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F1\xCC\xAEj/\x8E<\xED\x16\x92\xF7|\x8Ff\x813\xE4\xAF\xDA\xAA5\xAF\xE8D\xFFFY\xA6\xC2~b\x7F\x87\x87\x87`@Qa\x18P\x93\x92\x91\x90aj>V[`@Q\x80\x91\x03\x90\xA2PPP\x92\x91PPV[_\x80`\x06`S\x81\x11\x15a\x18wWa\x18vac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a\x18\x92Wa\x18\x91ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a\x18\xADWa\x18\xACac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a\x18\xC8Wa\x18\xC7ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a\x18\xE3Wa\x18\xE2ac\xCEV[[`\xFF\x16`\x01\x90\x1Ba\x18\xF4\x91\x90ad(V[a\x18\xFE\x91\x90ad(V[a\x19\x08\x91\x90ad(V[a\x19\x12\x91\x90ad(V[\x90P_a\x19\x1F\x86\x83aB\xE8V[\x90Pa\x19/`\x13\x87\x87\x87\x85aCNV[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xAC\xB5\xF3\x88\x82\x86\x89\x89\x88`@Q\x86c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x19\x86\x95\x94\x93\x92\x91\x90ad\xB0V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x19\x9DW_\x80\xFD[PZ\xF1\x15\x80\x15a\x19\xAFW=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xFD|\x92\x08\xF9V\xBF\x0Cj\xB7jf\x7F\x046\x12E\xAD>\n-\x0E\xFF\x92\xEB\x82z\xCF\xCC\xA6\x8E\xA9\x87\x87\x87\x87`@Qa\x19\xFF\x94\x93\x92\x91\x90ae\x01V[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[`\x01a\x1A\x1AaG\xF1V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x1A[W`@Q\x7FoOs\x1F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x02_a\x1AfaH\x15V[\x90P\x80_\x01`\x08\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x80a\x1A\xAEWP\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81_\x01_\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x10\x15[\x15a\x1A\xE5W`@Q\x7F\xF9.\xE8\xA9\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x81\x81_\x01_a\x01\0\n\x81T\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP`\x01\x81_\x01`\x08a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP_\x81_\x01`\x08a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP\x7F\xC7\xF5\x05\xB2\xF3q\xAE!u\xEEI\x13\xF4I\x9E\x1F&3\xA7\xB5\x93c!\xEE\xD1\xCD\xAE\xB6\x11Q\x81\xD2\x82`@Qa\x1Bt\x91\x90aj\x95V[`@Q\x80\x91\x03\x90\xA1PPV[_\x80a\x1B\x8AaH<V[\x90Pa\x1B\x97\x84\x84\x83aH\xB9V[\x91P3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7FR\"\xD9k\x83g'\xA1\xD6\xFE\x1E\xE9\xAE\xF2\x7F\x9B\xB5\x07\xBDAyM\xEF\xA3v\xFFld\x8A\xAF\x8F\xF1\x85\x85\x84\x86`@Qa\x1B\xE5\x94\x93\x92\x91\x90aj\xF7V[`@Q\x80\x91\x03\x90\xA2P\x92\x91PPV[a\x1B\xFCaKjV[a\x1C\x05\x82aLPV[a\x1C\x0F\x82\x82aMCV[PPV[_a\x1C\x1CaNaV[\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC_\x1B\x90P\x90V[_\x80`\x06`S\x81\x11\x15a\x1CZWa\x1CYac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a\x1CuWa\x1Ctac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a\x1C\x90Wa\x1C\x8Fac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a\x1C\xABWa\x1C\xAAac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a\x1C\xC6Wa\x1C\xC5ac\xCEV[[`\xFF\x16`\x01\x90\x1Ba\x1C\xD7\x91\x90ad(V[a\x1C\xE1\x91\x90ad(V[a\x1C\xEB\x91\x90ad(V[a\x1C\xF5\x91\x90ad(V[\x90P_a\x1D\x02\x86\x83aB\xE8V[\x90Pa\x1D\x12`\x02\x87\x87\x87\x85aCNV[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c<\x16\xFF\r\x82\x86\x89\x89\x88`@Q\x86c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x1Di\x95\x94\x93\x92\x91\x90ad\xB0V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x1D\x80W_\x80\xFD[PZ\xF1\x15\x80\x15a\x1D\x92W=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F!SF\xA4\xF9\xF9u\xE6\xD5HN)\x0B\xD4\xE5<\xA1DS\xA9\xD2\x82\xEB\xD3\xCC\xED\xB2\xA0\xF1qu=\x87\x87\x87\x87`@Qa\x1D\xE2\x94\x93\x92\x91\x90ae\x01V[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_`\x01`\xF8\x1B\x82~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x14a\x1ESW`@Q\x7FO\"NS\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x80\x1B\x83\x03a\x1E\x8EW`@Q\x7F#\xD3Y\xA3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\x06`S\x81\x11\x15a\x1E\xA3Wa\x1E\xA2ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a\x1E\xBEWa\x1E\xBDac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a\x1E\xD9Wa\x1E\xD8ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a\x1E\xF4Wa\x1E\xF3ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a\x1F\x0FWa\x1F\x0Eac\xCEV[[`\xFF\x16`\x01\x90\x1Ba\x1F \x91\x90ad(V[a\x1F*\x91\x90ad(V[a\x1F4\x91\x90ad(V[a\x1F>\x91\x90ad(V[\x90P_a\x1FK\x86\x83aB\xE8V[\x90Pa\x1F[`\x03\x87\x87\x87\x85aCNV[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c@kE\x13\x82\x86\x89\x89\x88`@Q\x86c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x1F\xB2\x95\x94\x93\x92\x91\x90ad\xB0V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x1F\xC9W_\x80\xFD[PZ\xF1\x15\x80\x15a\x1F\xDBW=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F;\xAB.\xE0\xE2\xF9\x0FF\x90\xC6\xA8{\xF6<\xF1\xA6\xB6&\x08n\x95\xF21\x86\x0B\x15)f\xE8\xDA\xBB\xF7\x87\x87\x87\x87`@Qa +\x94\x93\x92\x91\x90ae\x01V[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_\x80`\x08`S\x81\x11\x15a RWa Qac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x06`S\x81\x11\x15a mWa lac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a \x88Wa \x87ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a \xA3Wa \xA2ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a \xBEWa \xBDac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a \xD9Wa \xD8ac\xCEV[[`\xFF\x16`\x01\x90\x1B_`S\x81\x11\x15a \xF3Wa \xF2ac\xCEV[[`\xFF\x16`\x01\x90\x1Ba!\x04\x91\x90ad(V[a!\x0E\x91\x90ad(V[a!\x18\x91\x90ad(V[a!\"\x91\x90ad(V[a!,\x91\x90ad(V[a!6\x91\x90ad(V[\x90P_a!C\x86\x83aB\xE8V[\x90Pa!S`\x06\x87\x87\x87\x85aCNV[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xE8\xE3\x99\xAD\x82\x86\x89\x89\x88`@Q\x86c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a!\xAA\x95\x94\x93\x92\x91\x90ad\xB0V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a!\xC1W_\x80\xFD[PZ\xF1\x15\x80\x15a!\xD3W=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7FV\xDF'\x9B\xBF\xB0=\x9E\xD0\x97\xBB\xE2\xF2\x8DR\x0C\xA0\xC1\x16\x12\x062y&\xE9\x86d\xD7\r,$\xC4\x87\x87\x87\x87`@Qa\"#\x94\x93\x92\x91\x90ae\x01V[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_\x80`\x08`S\x81\x11\x15a\"JWa\"Iac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x06`S\x81\x11\x15a\"eWa\"dac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a\"\x80Wa\"\x7Fac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a\"\x9BWa\"\x9Aac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a\"\xB6Wa\"\xB5ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a\"\xD1Wa\"\xD0ac\xCEV[[`\xFF\x16`\x01\x90\x1Ba\"\xE2\x91\x90ad(V[a\"\xEC\x91\x90ad(V[a\"\xF6\x91\x90ad(V[a#\0\x91\x90ad(V[a#\n\x91\x90ad(V[\x90P_a#\x17\x86\x83aB\xE8V[\x90Pa#'`\n\x87\x87\x87\x85aCNV[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x14Rn\x87\x82\x86\x89\x89\x88`@Q\x86c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a#~\x95\x94\x93\x92\x91\x90ad\xB0V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a#\x95W_\x80\xFD[PZ\xF1\x15\x80\x15a#\xA7W=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xEB\x0EO\x8D\xC7@X\x19M\x06\x02B_\xE6\x02\xF9U\xC2\" \x0F\x7F\x10\xC6\xFEg\x99/{$\xC7\xE9\x87\x87\x87\x87`@Qa#\xF7\x94\x93\x92\x91\x90ae\x01V[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_\x80`\x06`S\x81\x11\x15a$\x1EWa$\x1Dac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a$9Wa$8ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a$TWa$Sac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a$oWa$nac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a$\x8AWa$\x89ac\xCEV[[`\xFF\x16`\x01\x90\x1Ba$\x9B\x91\x90ad(V[a$\xA5\x91\x90ad(V[a$\xAF\x91\x90ad(V[a$\xB9\x91\x90ad(V[\x90P_a$\xC6\x86\x83aB\xE8V[\x90Pa$\xD6`\x11\x87\x87\x87_aCNV[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x139\xC5\xEE\x82\x86\x89\x89\x88`@Q\x86c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a%-\x95\x94\x93\x92\x91\x90ad\xB0V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a%DW_\x80\xFD[PZ\xF1\x15\x80\x15a%VW=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\rH;\x10\r\x8Cs\xB2\x08\x98N\xC6\x97\xCA\xA3\t\x15!\xEEU%\xCEi\xED\xCF\x97\xD7\xE3\x95\xD3\xD0Y\x87\x87\x87\x87`@Qa%\xA6\x94\x93\x92\x91\x90ae\x01V[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_\x80`\x06`S\x81\x11\x15a%\xCDWa%\xCCac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a%\xE8Wa%\xE7ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a&\x03Wa&\x02ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a&\x1EWa&\x1Dac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a&9Wa&8ac\xCEV[[`\xFF\x16`\x01\x90\x1Ba&J\x91\x90ad(V[a&T\x91\x90ad(V[a&^\x91\x90ad(V[a&h\x91\x90ad(V[\x90P_a&u\x86\x83aB\xE8V[\x90Pa&\x85`\x10\x87\x87\x87_aCNV[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xD4\x7F=Y\x82\x86\x89\x89\x88`@Q\x86c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a&\xDC\x95\x94\x93\x92\x91\x90ad\xB0V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a&\xF3W_\x80\xFD[PZ\xF1\x15\x80\x15a'\x05W=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xDE\xF2\xE7\x04\xA0w(J\x07\xF3\xD0\xB46\xDB\x88\xF5\xD9\x81\xB6\x9FX\xAB|\x1A\xE6#%'\x18\xA6\xDE\x01\x87\x87\x87\x87`@Qa'U\x94\x93\x92\x91\x90ae\x01V[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_\x80`\x08`S\x81\x11\x15a'|Wa'{ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x07`S\x81\x11\x15a'\x97Wa'\x96ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x06`S\x81\x11\x15a'\xB2Wa'\xB1ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a'\xCDWa'\xCCac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a'\xE8Wa'\xE7ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a(\x03Wa(\x02ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a(\x1EWa(\x1Dac\xCEV[[`\xFF\x16`\x01\x90\x1B_`S\x81\x11\x15a(8Wa(7ac\xCEV[[`\xFF\x16`\x01\x90\x1Ba(I\x91\x90ad(V[a(S\x91\x90ad(V[a(]\x91\x90ad(V[a(g\x91\x90ad(V[a(q\x91\x90ad(V[a({\x91\x90ad(V[a(\x85\x91\x90ad(V[\x90P_a(\x92\x85\x83aB\xE8V[\x90Pa(\xA1`\x19\x87\x87\x87aN\xE8V[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16cNrgi\x82\x88\x88\x88\x88`@Q\x86c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a(\xF8\x95\x94\x93\x92\x91\x90ak:V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a)\x0FW_\x80\xFD[PZ\xF1\x15\x80\x15a)!W=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F`\xBE\x9Da\xAA\xD8I\xFA\xCC(\xC3\x8B\x04\x8C\xB5\xC4\xBE4 \xB8\xFA\"3\xE0\x8C\xFA\x06\xBE\x1Bm\x1C>\x87\x87\x87\x87`@Qa)q\x94\x93\x92\x91\x90ak\x8BV[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_\x90V[_\x80`\x06`S\x81\x11\x15a)\x9CWa)\x9Bac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a)\xB7Wa)\xB6ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a)\xD2Wa)\xD1ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a)\xEDWa)\xECac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a*\x08Wa*\x07ac\xCEV[[`\xFF\x16`\x01\x90\x1Ba*\x19\x91\x90ad(V[a*#\x91\x90ad(V[a*-\x91\x90ad(V[a*7\x91\x90ad(V[\x90P_a*D\x86\x83aB\xE8V[\x90Pa*T`\x0F\x87\x87\x87_aCNV[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x85\x9A\x1Bp\x82\x86\x89\x89\x88`@Q\x86c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a*\xAB\x95\x94\x93\x92\x91\x90ad\xB0V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a*\xC2W_\x80\xFD[PZ\xF1\x15\x80\x15a*\xD4W=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xC9\xFF\x8F\r\x18\xA3\xF7f\xCE]\xE3\xDE!`v\x05\x01@\xE4\xFC&R\xF5\xE0\xE7E\xF6\xFC\x83l\xDA\x8B\x87\x87\x87\x87`@Qa+$\x94\x93\x92\x91\x90ae\x01V[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_\x80`\x08`S\x81\x11\x15a+KWa+Jac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x06`S\x81\x11\x15a+fWa+eac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a+\x81Wa+\x80ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a+\x9CWa+\x9Bac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a+\xB7Wa+\xB6ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a+\xD2Wa+\xD1ac\xCEV[[`\xFF\x16`\x01\x90\x1B_`S\x81\x11\x15a+\xECWa+\xEBac\xCEV[[`\xFF\x16`\x01\x90\x1Ba+\xFD\x91\x90ad(V[a,\x07\x91\x90ad(V[a,\x11\x91\x90ad(V[a,\x1B\x91\x90ad(V[a,%\x91\x90ad(V[a,/\x91\x90ad(V[\x90P_a,<\x86\x83aB\xE8V[\x90Pa,L`\x07\x87\x87\x87\x85aCNV[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x144\xBAM\x82\x86\x89\x89\x88`@Q\x86c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a,\xA3\x95\x94\x93\x92\x91\x90ad\xB0V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a,\xBAW_\x80\xFD[PZ\xF1\x15\x80\x15a,\xCCW=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7FM2(K\xD3\x19>\xCA\xA4N\x1C\xEC\xA3/A\xC5\xD6\xC3(\x03\xA9.\x07\x96}\xD3\xEEB)r\x15\x82\x87\x87\x87\x87`@Qa-\x1C\x94\x93\x92\x91\x90ae\x01V[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_\x80`\x08`S\x81\x11\x15a-CWa-Bac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x06`S\x81\x11\x15a-^Wa-]ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a-yWa-xac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a-\x94Wa-\x93ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a-\xAFWa-\xAEac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a-\xCAWa-\xC9ac\xCEV[[`\xFF\x16`\x01\x90\x1Ba-\xDB\x91\x90ad(V[a-\xE5\x91\x90ad(V[a-\xEF\x91\x90ad(V[a-\xF9\x91\x90ad(V[a.\x03\x91\x90ad(V[\x90P_a.\x10\x86\x83aB\xE8V[\x90Pa. `\t\x87\x87\x87\x85aCNV[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x1E\xD9\x1F\xF6\x82\x86\x89\x89\x88`@Q\x86c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a.w\x95\x94\x93\x92\x91\x90ad\xB0V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a.\x8EW_\x80\xFD[PZ\xF1\x15\x80\x15a.\xA0W=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F2B \xBF\xC9\xCB\x15\x8BI)\x91\xC0<0\x9C\xD8nSE\xCA\xC4Z\xAC\xAE \x92\xDD\xAB\xE3\x1F\xA3\xD8\x87\x87\x87\x87`@Qa.\xF0\x94\x93\x92\x91\x90ae\x01V[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_\x80`\x08`S\x81\x11\x15a/\x17Wa/\x16ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x07`S\x81\x11\x15a/2Wa/1ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x06`S\x81\x11\x15a/MWa/Lac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a/hWa/gac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a/\x83Wa/\x82ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a/\x9EWa/\x9Dac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a/\xB9Wa/\xB8ac\xCEV[[`\xFF\x16`\x01\x90\x1B_`S\x81\x11\x15a/\xD3Wa/\xD2ac\xCEV[[`\xFF\x16`\x01\x90\x1Ba/\xE4\x91\x90ad(V[a/\xEE\x91\x90ad(V[a/\xF8\x91\x90ad(V[a0\x02\x91\x90ad(V[a0\x0C\x91\x90ad(V[a0\x16\x91\x90ad(V[a0 \x91\x90ad(V[\x90P_\x81\x84`S\x81\x11\x15a07Wa06ac\xCEV[[`\xFF\x16`\x01\x90\x1B\x16\x03a0vW`@Q\x7F\xC6\xDEFj\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x18\x84\x84sP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]F`@Q` \x01a0\xA4\x95\x94\x93\x92\x91\x90ak\xCEV[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x91Pa0\xC6\x82\x84aGxV[\x91Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c4\x8C1\x85\x84\x84`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a1\x17\x92\x91\x90al,V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a1.W_\x80\xFD[PZ\xF1\x15\x80\x15a1@W=_\x80>=_\xFD[PPPPsP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c>9\\\xEC\x833`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a1\x93\x92\x91\x90afMV[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a1\xAAW_\x80\xFD[PZ\xF1\x15\x80\x15a1\xBCW=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\x06<\xCD\x1B\xBAE\x15\x1D\x91\xF6\xA4\x18\x06PG\xA3\xD0H\xD0X\xA9\"SWG\xBB+WZ\x01\xD26\x85\x85\x85`@Qa2\n\x93\x92\x91\x90alSV[`@Q\x80\x91\x03\x90\xA2P\x92\x91PPV[_s6w!B\xB7Hq\xF2U\xCB\xD7\xA3\xE8\x9B@\x1D>E\x82_\x90P\x90V[`@Q\x80`@\x01`@R\x80`\x05\x81R` \x01\x7F5.0.0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81RP\x81V[_\x80`\x08`S\x81\x11\x15a2\x83Wa2\x82ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x06`S\x81\x11\x15a2\x9EWa2\x9Dac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a2\xB9Wa2\xB8ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a2\xD4Wa2\xD3ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a2\xEFWa2\xEEac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a3\nWa3\tac\xCEV[[`\xFF\x16`\x01\x90\x1Ba3\x1B\x91\x90ad(V[a3%\x91\x90ad(V[a3/\x91\x90ad(V[a39\x91\x90ad(V[a3C\x91\x90ad(V[\x90P_a3P\x86\x83aB\xE8V[\x90Pa3``\x0B\x87\x87\x87\x85aCNV[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16cf\x91\x81\xC0\x82\x86\x89\x89\x88`@Q\x86c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a3\xB7\x95\x94\x93\x92\x91\x90ad\xB0V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a3\xCEW_\x80\xFD[PZ\xF1\x15\x80\x15a3\xE0W=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xC1HgY\x05\xD0z\xD5Io\x8E\xF4\xD8\x19\\\x90u\x03\xF3\xEC\x12\xFD\x10\xED_!$\n\xBCi64\x87\x87\x87\x87`@Qa40\x94\x93\x92\x91\x90ae\x01V[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_\x80`\x08`S\x81\x11\x15a4WWa4Vac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x06`S\x81\x11\x15a4rWa4qac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a4\x8DWa4\x8Cac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a4\xA8Wa4\xA7ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a4\xC3Wa4\xC2ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a4\xDEWa4\xDDac\xCEV[[`\xFF\x16`\x01\x90\x1Ba4\xEF\x91\x90ad(V[a4\xF9\x91\x90ad(V[a5\x03\x91\x90ad(V[a5\r\x91\x90ad(V[a5\x17\x91\x90ad(V[\x90P_a5$\x86\x83aB\xE8V[\x90Pa54`\x08\x87\x87\x87\x85aCNV[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x83\xE6\xA7 \x82\x86\x89\x89\x88`@Q\x86c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a5\x8B\x95\x94\x93\x92\x91\x90ad\xB0V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a5\xA2W_\x80\xFD[PZ\xF1\x15\x80\x15a5\xB4W=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xE8B\x82\xAA\xEB\xCC\xA6\x98D>9\xA2\xA9H\xA3E\xD0\xD2\xEB\xC6T\xAF\\\xB6W\xA2\xD7\xE8\x05;\xF6\xCB\x87\x87\x87\x87`@Qa6\x04\x94\x93\x92\x91\x90ae\x01V[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_`\x01`\xF8\x1B\x82~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x14a6uW`@Q\x7FO\"NS\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x80\x1B\x83\x03a6\xB0W`@Q\x7F#\xD3Y\xA3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\x06`S\x81\x11\x15a6\xC5Wa6\xC4ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a6\xE0Wa6\xDFac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a6\xFBWa6\xFAac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a7\x16Wa7\x15ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a71Wa70ac\xCEV[[`\xFF\x16`\x01\x90\x1Ba7B\x91\x90ad(V[a7L\x91\x90ad(V[a7V\x91\x90ad(V[a7`\x91\x90ad(V[\x90P_a7m\x86\x83aB\xE8V[\x90Pa7}`\x04\x87\x87\x87\x85aCNV[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xFA\x08\xE3\x8D\x82\x86\x89\x89\x88`@Q\x86c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a7\xD4\x95\x94\x93\x92\x91\x90ad\xB0V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a7\xEBW_\x80\xFD[PZ\xF1\x15\x80\x15a7\xFDW=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\x0Ei\x1C\xD0\xBF\x8CN\x93\x08\xE4\xCE\xD1\xBB\x9C\x96A\x17\xDC\\[\xB9\xB9\xAB[\xDF\xEB\xF2\xC9\xB1:\x89|\x87\x87\x87\x87`@Qa8M\x94\x93\x92\x91\x90ae\x01V[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_\x80`\x08`S\x81\x11\x15a8tWa8sac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x06`S\x81\x11\x15a8\x8FWa8\x8Eac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a8\xAAWa8\xA9ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a8\xC5Wa8\xC4ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a8\xE0Wa8\xDFac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a8\xFBWa8\xFAac\xCEV[[`\xFF\x16`\x01\x90\x1Ba9\x0C\x91\x90ad(V[a9\x16\x91\x90ad(V[a9 \x91\x90ad(V[a9*\x91\x90ad(V[a94\x91\x90ad(V[\x90P_a9A\x84\x83aB\xE8V[\x90Pa9N`\x14\x85aS\x14V[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xA4\xC9\x8F>\x82\x86\x86`@Q\x84c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a9\xA1\x93\x92\x91\x90aj\tV[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a9\xB8W_\x80\xFD[PZ\xF1\x15\x80\x15a9\xCAW=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\x8CfM<<\xA5\x83\xFCX\x03\xB8\xA9\x1CIdK\xBD\x95P\xBF\xA8yg\xC7:\xD1\xDE\x83\x02wh\xC0\x85\x85`@Qa:\x16\x92\x91\x90al\x88V[`@Q\x80\x91\x03\x90\xA2PP\x91\x90PV[_\x80a:/aH<V[\x90Pa:;\x83\x82aT\xC4V[\x91P3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\x0C\x8A\xCA`\x17\x003&\x05\x1E\x19\x91>\xF0&1\xF2K\x80\x11%\xE1\xFA\x8A\x1D\x81.\x86\x83\x19\xFD\xA6\x84\x83\x85`@Qa:\x87\x93\x92\x91\x90al\xAFV[`@Q\x80\x91\x03\x90\xA2P\x91\x90PV[_\x80`\x08`S\x81\x11\x15a:\xABWa:\xAAac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x07`S\x81\x11\x15a:\xC6Wa:\xC5ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x06`S\x81\x11\x15a:\xE1Wa:\xE0ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a:\xFCWa:\xFBac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a;\x17Wa;\x16ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a;2Wa;1ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a;MWa;Lac\xCEV[[`\xFF\x16`\x01\x90\x1B_`S\x81\x11\x15a;gWa;fac\xCEV[[`\xFF\x16`\x01\x90\x1Ba;x\x91\x90ad(V[a;\x82\x91\x90ad(V[a;\x8C\x91\x90ad(V[a;\x96\x91\x90ad(V[a;\xA0\x91\x90ad(V[a;\xAA\x91\x90ad(V[a;\xB4\x91\x90ad(V[\x90P_a;\xC1\x86\x83aB\xE8V[\x90Pa;\xD1`\r\x87\x87\x87_aCNV[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xFA]\xEF\xDB\x82\x86\x89\x89\x88`@Q\x86c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a<(\x95\x94\x93\x92\x91\x90ad\xB0V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a<?W_\x80\xFD[PZ\xF1\x15\x80\x15a<QW=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7Fi`\xC1\xE8\x8Fa\xC3R\xDB\xA3M\x1B\xBFgS\xE3\x02yRd\xD5\xD8\xAE\x82\xF7\x98<p\x04e\x1E]\x87\x87\x87\x87`@Qa<\xA1\x94\x93\x92\x91\x90ae\x01V[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_\x80`\x08`S\x81\x11\x15a<\xC8Wa<\xC7ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x06`S\x81\x11\x15a<\xE3Wa<\xE2ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a<\xFEWa<\xFDac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a=\x19Wa=\x18ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a=4Wa=3ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a=OWa=Nac\xCEV[[`\xFF\x16`\x01\x90\x1B_`S\x81\x11\x15a=iWa=hac\xCEV[[`\xFF\x16`\x01\x90\x1Ba=z\x91\x90ad(V[a=\x84\x91\x90ad(V[a=\x8E\x91\x90ad(V[a=\x98\x91\x90ad(V[a=\xA2\x91\x90ad(V[a=\xAC\x91\x90ad(V[\x90P_a=\xB9\x86\x83aB\xE8V[\x90Pa=\xC9`\x05\x87\x87\x87\x85aCNV[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x18V\xD9\x1D\x82\x86\x89\x89\x88`@Q\x86c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a> \x95\x94\x93\x92\x91\x90ad\xB0V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a>7W_\x80\xFD[PZ\xF1\x15\x80\x15a>IW=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xE4$\x86\xB0\xCC\xDB\xEF\x81\xA2\x07\\H\xC8\xE5\x15\xC0y\xAE\xA7<\x8B\x82B\x99\x97\xC7*/\xE1\xBFO\xEF\x87\x87\x87\x87`@Qa>\x99\x94\x93\x92\x91\x90ae\x01V[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_s#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9\x90P\x90V[_\x80`\x08`S\x81\x11\x15a>\xDBWa>\xDAac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x06`S\x81\x11\x15a>\xF6Wa>\xF5ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a?\x11Wa?\x10ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a?,Wa?+ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a?GWa?Fac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a?bWa?aac\xCEV[[`\xFF\x16`\x01\x90\x1B_`S\x81\x11\x15a?|Wa?{ac\xCEV[[`\xFF\x16`\x01\x90\x1Ba?\x8D\x91\x90ad(V[a?\x97\x91\x90ad(V[a?\xA1\x91\x90ad(V[a?\xAB\x91\x90ad(V[a?\xB5\x91\x90ad(V[a?\xBF\x91\x90ad(V[\x90P_a?\xCC\x84\x83aB\xE8V[\x90Pa?\xD9`\x15\x85aS\x14V[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xFC\x06<b\x82\x86\x86`@Q\x84c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a@,\x93\x92\x91\x90aj\tV[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a@CW_\x80\xFD[PZ\xF1\x15\x80\x15a@UW=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7FU\xAF\xF4\xCCz=\x16\x0C\x83\xF1\xF1[\x81\x80\x11\xED\xE8A\xA0\xB4Y\x7F\xB1M\xCD6\x03\xDF:\x11\xE5\xE0\x85\x85`@Qa@\xA1\x92\x91\x90al\x88V[`@Q\x80\x91\x03\x90\xA2PP\x91\x90PV[_sP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]\x90P\x90V[_\x80`\x08`S\x81\x11\x15a@\xE1Wa@\xE0ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x07`S\x81\x11\x15a@\xFCWa@\xFBac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x06`S\x81\x11\x15aA\x17WaA\x16ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15aA2WaA1ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15aAMWaALac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15aAhWaAgac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15aA\x83WaA\x82ac\xCEV[[`\xFF\x16`\x01\x90\x1B_`S\x81\x11\x15aA\x9DWaA\x9Cac\xCEV[[`\xFF\x16`\x01\x90\x1BaA\xAE\x91\x90ad(V[aA\xB8\x91\x90ad(V[aA\xC2\x91\x90ad(V[aA\xCC\x91\x90ad(V[aA\xD6\x91\x90ad(V[aA\xE0\x91\x90ad(V[aA\xEA\x91\x90ad(V[\x90P_aA\xF7\x86\x83aB\xE8V[\x90PaB\x07`\x0C\x87\x87\x87_aCNV[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x94\xE7\x0EO\x82\x86\x89\x89\x88`@Q\x86c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01aB^\x95\x94\x93\x92\x91\x90ad\xB0V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15aBuW_\x80\xFD[PZ\xF1\x15\x80\x15aB\x87W=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xB3\xD5\xC6d\xEC\x86WX\x18\xE8\xD7_\xF2\\_\x86rP\xDF\x89T\x08\x85I\xC4\x1C\x84\x8C\xD1\x0Ev\xCB\x87\x87\x87\x87`@QaB\xD7\x94\x93\x92\x91\x90ae\x01V[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_aB\xF2\x83aFvV[\x90P_\x82\x82`S\x81\x11\x15aC\tWaC\x08ac\xCEV[[`\xFF\x16`\x01\x90\x1B\x16\x03aCHW`@Q\x7F\xC6\xDEFj\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x92\x91PPV[_aCX\x83aWMV[sP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x82\x02{m\x863`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01aC\xA7\x92\x91\x90afMV[` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15aC\xC2W=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90aC\xE6\x91\x90ah-V[aD)W\x843`@Q\x7F\x9D\xE39,\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aD \x92\x91\x90afMV[`@Q\x80\x91\x03\x90\xFD[_`\xF8\x1B\x83~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x03aE\x9EWsP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x82\x02{m\x853`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01aD\xA4\x92\x91\x90afMV[` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15aD\xBFW=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90aD\xE3\x91\x90ah-V[aE&W\x833`@Q\x7F\x9D\xE39,\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aE\x1D\x92\x91\x90afMV[`@Q\x80\x91\x03\x90\xFD[_aE0\x85aFvV[\x90P_aE<\x87aFvV[\x90P\x81`S\x81\x11\x15aEQWaEPac\xCEV[[\x81`S\x81\x11\x15aEdWaEcac\xCEV[[\x14aE\x9BW`@Q\x7F\x1F1X\xC7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[PP[\x85\x85\x85\x85sP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]F`@Q` \x01aE\xCD\x96\x95\x94\x93\x92\x91\x90am\x04V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x90PaE\xEF\x81\x83aGxV[\x90PsP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c>9\\\xEC\x823`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01aF@\x92\x91\x90afMV[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15aFWW_\x80\xFD[PZ\xF1\x15\x80\x15aFiW=_\x80>=_\xFD[PPPP\x95\x94PPPPPV[_\x81`\x1E` \x81\x10aF\x8BWaF\x8AamsV[[\x1A`\xF8\x1B`\xF8\x1C`\xFF\x16`S\x81\x11\x15aF\xA7WaF\xA6ac\xCEV[[\x90P\x91\x90PV[``_`\x01aF\xBC\x84aW\x91V[\x01\x90P_\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15aF\xDAWaF\xD9a_bV[[`@Q\x90\x80\x82R\x80`\x1F\x01`\x1F\x19\x16` \x01\x82\x01`@R\x80\x15aG\x0CW\x81` \x01`\x01\x82\x02\x806\x837\x80\x82\x01\x91PP\x90P[P\x90P_\x82` \x01\x82\x01\x90P[`\x01\x15aGmW\x80\x80`\x01\x90\x03\x91PP\x7F0123456789abcdef\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\n\x86\x06\x1A\x81S`\n\x85\x81aGbWaGaam\xA0V[[\x04\x94P_\x85\x03aG\x19W[\x81\x93PPPP\x91\x90PV[_\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0_\x1B\x83\x16\x90P`P`\xFF_\x1B\x90\x1B\x81\x17\x90P`\x10Fg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16_\x1B\x90\x1B\x81\x17\x90P`\x08\x82`S\x81\x11\x15aG\xD6WaG\xD5ac\xCEV[[`\xFF\x16_\x1B\x90\x1B\x81\x17\x90P_`\xFF\x16_\x1B\x81\x17\x90P\x92\x91PPV[_aG\xFAaH\x15V[_\x01_\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P\x90V[_\x7F\xF0\xC5~\x16\x84\r\xF0@\xF1P\x88\xDC/\x81\xFE9\x1C9#\xBE\xC7>#\xA9f.\xFC\x9C\"\x9Cj\0\x90P\x90V[_\x80aHFaX\xE2V[\x90P\x80_\x01TsP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]F`\x01CaHo\x91\x90am\xCDV[@B`@Q` \x01aH\x85\x95\x94\x93\x92\x91\x90an\0V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x91P\x80_\x01_\x81T\x80\x92\x91\x90aH\xB0\x90an^V[\x91\x90PUPP\x90V[_\x80`\x08`S\x81\x11\x15aH\xCFWaH\xCEac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x06`S\x81\x11\x15aH\xEAWaH\xE9ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15aI\x05WaI\x04ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15aI WaI\x1Fac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15aI;WaI:ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15aIVWaIUac\xCEV[[`\xFF\x16`\x01\x90\x1BaIg\x91\x90ad(V[aIq\x91\x90ad(V[aI{\x91\x90ad(V[aI\x85\x91\x90ad(V[aI\x8F\x91\x90ad(V[\x90P_\x81\x85`S\x81\x11\x15aI\xA6WaI\xA5ac\xCEV[[`\xFF\x16`\x01\x90\x1B\x16\x03aI\xE5W`@Q\x7F\xC6\xDEFj\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[aI\xEE\x85aY\tV[aJ$W`@Q\x7F$\xE8\xE7B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[aJ.\x85\x85aY-V[`\x1B\x85\x85\x85`@Q` \x01aJF\x94\x93\x92\x91\x90an\xC5V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x91PaJh\x82\x85aGxV[\x91Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xCC\x86g\x82\x85\x84`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01aJ\xB9\x92\x91\x90al,V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15aJ\xD0W_\x80\xFD[PZ\xF1\x15\x80\x15aJ\xE2W=_\x80>=_\xFD[PPPPsP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c>9\\\xEC\x833`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01aK5\x92\x91\x90afMV[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15aKLW_\x80\xFD[PZ\xF1\x15\x80\x15aK^W=_\x80>=_\xFD[PPPPP\x93\x92PPPV[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x160s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14\x80aL\x17WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16aK\xFEaZ}V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14\x15[\x15aLNW`@Q\x7F\xE0|\x8D\xBA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[V[sP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x8D\xA5\xCB[`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15aL\xADW=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90aL\xD1\x91\x90ao&V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14aM@W3`@Q\x7F!\xBF\xDA\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aM7\x91\x90ac_V[`@Q\x80\x91\x03\x90\xFD[PV[\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16cR\xD1\x90-`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x92PPP\x80\x15aM\xABWP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90aM\xA8\x91\x90af\"V[`\x01[aM\xECW\x81`@Q\x7FL\x9C\x8C\xE3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aM\xE3\x91\x90ac_V[`@Q\x80\x91\x03\x90\xFD[\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC_\x1B\x81\x14aNRW\x80`@Q\x7F\xAA\x1DI\xA4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aNI\x91\x90a^\xD7V[`@Q\x80\x91\x03\x90\xFD[aN\\\x83\x83aZ\xD0V[PPPV[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x160s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14aN\xE6W`@Q\x7F\xE0|\x8D\xBA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[V[_sP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x82\x02{m\x853`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01aO8\x92\x91\x90afMV[` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15aOSW=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90aOw\x91\x90ah-V[aO\xBAW\x833`@Q\x7F\x9D\xE39,\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aO\xB1\x92\x91\x90afMV[`@Q\x80\x91\x03\x90\xFD[sP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x82\x02{m\x843`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01aP\t\x92\x91\x90afMV[` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15aP$W=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90aPH\x91\x90ah-V[aP\x8BW\x823`@Q\x7F\x9D\xE39,\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aP\x82\x92\x91\x90afMV[`@Q\x80\x91\x03\x90\xFD[sP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x82\x02{m\x833`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01aP\xDA\x92\x91\x90afMV[` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15aP\xF5W=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90aQ\x19\x91\x90ah-V[aQ\\W\x813`@Q\x7F\x9D\xE39,\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aQS\x92\x91\x90afMV[`@Q\x80\x91\x03\x90\xFD[_aQf\x85aFvV[\x90P_aQr\x85aFvV[\x90P_aQ~\x85aFvV[\x90P_`S\x81\x11\x15aQ\x93WaQ\x92ac\xCEV[[\x83`S\x81\x11\x15aQ\xA6WaQ\xA5ac\xCEV[[\x14aQ\xDDW`@Q\x7F\xC6\xDEFj\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x80`S\x81\x11\x15aQ\xF0WaQ\xEFac\xCEV[[\x82`S\x81\x11\x15aR\x03WaR\x02ac\xCEV[[\x14aR:W`@Q\x7F\x1F1X\xC7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x87\x87\x87\x87sP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]F`@Q` \x01aRi\x96\x95\x94\x93\x92\x91\x90aoQV[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x93PaR\x8B\x84\x83aGxV[\x93PsP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c>9\\\xEC\x853`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01aR\xDC\x92\x91\x90afMV[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15aR\xF3W_\x80\xFD[PZ\xF1\x15\x80\x15aS\x05W=_\x80>=_\xFD[PPPPPPP\x94\x93PPPPV[_sP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x82\x02{m\x833`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01aSd\x92\x91\x90afMV[` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15aS\x7FW=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90aS\xA3\x91\x90ah-V[aS\xE6W\x813`@Q\x7F\x9D\xE39,\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aS\xDD\x92\x91\x90afMV[`@Q\x80\x91\x03\x90\xFD[\x82\x82sP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]F`@Q` \x01aT\x11\x94\x93\x92\x91\x90ao\xC0V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x90P_aT3\x83aFvV[\x90PaT?\x82\x82aGxV[\x91PsP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c>9\\\xEC\x833`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01aT\x90\x92\x91\x90afMV[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15aT\xA7W_\x80\xFD[PZ\xF1\x15\x80\x15aT\xB9W=_\x80>=_\xFD[PPPPP\x92\x91PPV[_\x80`\x08`S\x81\x11\x15aT\xDAWaT\xD9ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x06`S\x81\x11\x15aT\xF5WaT\xF4ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15aU\x10WaU\x0Fac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15aU+WaU*ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15aUFWaUEac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15aUaWaU`ac\xCEV[[`\xFF\x16`\x01\x90\x1B_`S\x81\x11\x15aU{WaUzac\xCEV[[`\xFF\x16`\x01\x90\x1BaU\x8C\x91\x90ad(V[aU\x96\x91\x90ad(V[aU\xA0\x91\x90ad(V[aU\xAA\x91\x90ad(V[aU\xB4\x91\x90ad(V[aU\xBE\x91\x90ad(V[\x90P_\x81\x85`S\x81\x11\x15aU\xD5WaU\xD4ac\xCEV[[`\xFF\x16`\x01\x90\x1B\x16\x03aV\x14W`@Q\x7F\xC6\xDEFj\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x1A\x84\x84`@Q` \x01aV*\x93\x92\x91\x90ap\rV[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x91PaVL\x82\x85aGxV[\x91Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\t\xB0N\x8F\x85\x84`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01aV\x9D\x92\x91\x90al,V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15aV\xB4W_\x80\xFD[PZ\xF1\x15\x80\x15aV\xC6W=_\x80>=_\xFD[PPPPsP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c>9\\\xEC\x833`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01aW\x19\x92\x91\x90afMV[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15aW0W_\x80\xFD[PZ\xF1\x15\x80\x15aWBW=_\x80>=_\xFD[PPPPP\x92\x91PPV[`\x01\x81`\xF8\x1C`\xFF\x16\x11\x15aW\x8EW`@Q\x7F\xDF{\xF3%\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[PV[_\x80_\x90Pz\x18O\x03\xE9?\xF9\xF4\xDA\xA7\x97\xEDn8\xEDd\xBFj\x1F\x01\0\0\0\0\0\0\0\0\x83\x10aW\xEDWz\x18O\x03\xE9?\xF9\xF4\xDA\xA7\x97\xEDn8\xEDd\xBFj\x1F\x01\0\0\0\0\0\0\0\0\x83\x81aW\xE3WaW\xE2am\xA0V[[\x04\x92P`@\x81\x01\x90P[m\x04\xEE-mA[\x85\xAC\xEF\x81\0\0\0\0\x83\x10aX*Wm\x04\xEE-mA[\x85\xAC\xEF\x81\0\0\0\0\x83\x81aX WaX\x1Fam\xA0V[[\x04\x92P` \x81\x01\x90P[f#\x86\xF2o\xC1\0\0\x83\x10aXYWf#\x86\xF2o\xC1\0\0\x83\x81aXOWaXNam\xA0V[[\x04\x92P`\x10\x81\x01\x90P[c\x05\xF5\xE1\0\x83\x10aX\x82Wc\x05\xF5\xE1\0\x83\x81aXxWaXwam\xA0V[[\x04\x92P`\x08\x81\x01\x90P[a'\x10\x83\x10aX\xA7Wa'\x10\x83\x81aX\x9DWaX\x9Cam\xA0V[[\x04\x92P`\x04\x81\x01\x90P[`d\x83\x10aX\xCAW`d\x83\x81aX\xC0WaX\xBFam\xA0V[[\x04\x92P`\x02\x81\x01\x90P[`\n\x83\x10aX\xD9W`\x01\x81\x01\x90P[\x80\x91PP\x91\x90PV[_\x7FF\x13\xE1w\x1Fku]$>So\xB5\xA2<[\x15\xE2\x82eu\xFE\xE9!\xE8\xFEz\"\xA7`\xC8\0\x90P\x90V[_\x80\x82\x11\x80\x15aY&WP_`\x01\x83aY\"\x91\x90am\xCDV[\x83\x16\x14[\x90P\x91\x90PV[`\x02`S\x81\x11\x15aYAWaY@ac\xCEV[[\x81`S\x81\x11\x15aYTWaYSac\xCEV[[\x03aYjWaYe\x82a\x01\0a[BV[aZyV[`\x03`S\x81\x11\x15aY~WaY}ac\xCEV[[\x81`S\x81\x11\x15aY\x91WaY\x90ac\xCEV[[\x03aY\xA8WaY\xA3\x82b\x01\0\0a[BV[aZyV[`\x04`S\x81\x11\x15aY\xBCWaY\xBBac\xCEV[[\x81`S\x81\x11\x15aY\xCFWaY\xCEac\xCEV[[\x03aY\xE8WaY\xE3\x82d\x01\0\0\0\0a[BV[aZyV[`\x05`S\x81\x11\x15aY\xFCWaY\xFBac\xCEV[[\x81`S\x81\x11\x15aZ\x0FWaZ\x0Eac\xCEV[[\x03aZ,WaZ'\x82h\x01\0\0\0\0\0\0\0\0a[BV[aZyV[`\x06`S\x81\x11\x15aZ@WaZ?ac\xCEV[[\x81`S\x81\x11\x15aZSWaZRac\xCEV[[\x03aZxWaZs\x82p\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a[BV[aZyV[[PPV[_aZ\xA9\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC_\x1Ba[\x80V[_\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P\x90V[aZ\xD9\x82a[\x89V[\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xBC|\xD7Z \xEE'\xFD\x9A\xDE\xBA\xB3 A\xF7U!M\xBCk\xFF\xA9\x0C\xC0\"[9\xDA.\\-;`@Q`@Q\x80\x91\x03\x90\xA2_\x81Q\x11\x15a[5Wa[/\x82\x82a\\RV[Pa[>V[a[=a\\\xD2V[[PPV[\x80\x82\x11\x15a[|W`@Q\x7F\xC7\xDA\xDFE\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[PPV[_\x81\x90P\x91\x90PV[_\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16;\x03a[\xE4W\x80`@Q\x7FL\x9C\x8C\xE3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a[\xDB\x91\x90ac_V[`@Q\x80\x91\x03\x90\xFD[\x80a\\\x10\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC_\x1Ba[\x80V[_\x01_a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UPPV[``_\x80\x84s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x84`@Qa\\{\x91\x90ap\x83V[_`@Q\x80\x83\x03\x81\x85Z\xF4\x91PP=\x80_\x81\x14a\\\xB3W`@Q\x91P`\x1F\x19`?=\x01\x16\x82\x01`@R=\x82R=_` \x84\x01>a\\\xB8V[``\x91P[P\x91P\x91Pa\\\xC8\x85\x83\x83a]\x0EV[\x92PPP\x92\x91PPV[_4\x11\x15a]\x0CW`@Q\x7F\xB3\x98\x97\x9F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[V[``\x82a]#Wa]\x1E\x82a]\x9BV[a]\x93V[_\x82Q\x14\x80\x15a]IWP_\x84s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16;\x14[\x15a]\x8BW\x83`@Q\x7F\x99\x96\xB3\x15\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a]\x82\x91\x90ac_V[`@Q\x80\x91\x03\x90\xFD[\x81\x90Pa]\x94V[[\x93\x92PPPV[_\x81Q\x11\x15a]\xADW\x80Q\x80\x82` \x01\xFD[`@Q\x7F\xD6\xBD\xA2u\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`@Q\x90P\x90V[_\x80\xFD[_\x80\xFD[_\x81\x90P\x91\x90PV[a^\x02\x81a]\xF0V[\x81\x14a^\x0CW_\x80\xFD[PV[_\x815\x90Pa^\x1D\x81a]\xF9V[\x92\x91PPV[_\x7F\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\x16\x90P\x91\x90PV[a^W\x81a^#V[\x81\x14a^aW_\x80\xFD[PV[_\x815\x90Pa^r\x81a^NV[\x92\x91PPV[_\x80_``\x84\x86\x03\x12\x15a^\x8FWa^\x8Ea]\xE8V[[_a^\x9C\x86\x82\x87\x01a^\x0FV[\x93PP` a^\xAD\x86\x82\x87\x01a^\x0FV[\x92PP`@a^\xBE\x86\x82\x87\x01a^dV[\x91PP\x92P\x92P\x92V[a^\xD1\x81a]\xF0V[\x82RPPV[_` \x82\x01\x90Pa^\xEA_\x83\x01\x84a^\xC8V[\x92\x91PPV[_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[_a_\x19\x82a^\xF0V[\x90P\x91\x90PV[a_)\x81a_\x0FV[\x81\x14a_3W_\x80\xFD[PV[_\x815\x90Pa_D\x81a_ V[\x92\x91PPV[_\x80\xFD[_\x80\xFD[_`\x1F\x19`\x1F\x83\x01\x16\x90P\x91\x90PV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`A`\x04R`$_\xFD[a_\x98\x82a_RV[\x81\x01\x81\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17\x15a_\xB7Wa_\xB6a_bV[[\x80`@RPPPV[_a_\xC9a]\xDFV[\x90Pa_\xD5\x82\x82a_\x8FV[\x91\x90PV[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15a_\xF4Wa_\xF3a_bV[[a_\xFD\x82a_RV[\x90P` \x81\x01\x90P\x91\x90PV[\x82\x81\x837_\x83\x83\x01RPPPV[_a`*a`%\x84a_\xDAV[a_\xC0V[\x90P\x82\x81R` \x81\x01\x84\x84\x84\x01\x11\x15a`FWa`Ea_NV[[a`Q\x84\x82\x85a`\nV[P\x93\x92PPPV[_\x82`\x1F\x83\x01\x12a`mWa`la_JV[[\x815a`}\x84\x82` \x86\x01a`\x18V[\x91PP\x92\x91PPV[`T\x81\x10a`\x92W_\x80\xFD[PV[_\x815\x90Pa`\xA3\x81a`\x86V[\x92\x91PPV[_\x80_\x80`\x80\x85\x87\x03\x12\x15a`\xC1Wa`\xC0a]\xE8V[[_a`\xCE\x87\x82\x88\x01a^\x0FV[\x94PP` a`\xDF\x87\x82\x88\x01a_6V[\x93PP`@\x85\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15aa\0Wa`\xFFa]\xECV[[aa\x0C\x87\x82\x88\x01a`YV[\x92PP``aa\x1D\x87\x82\x88\x01a`\x95V[\x91PP\x92\x95\x91\x94P\x92PV[_\x81Q\x90P\x91\x90PV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[_[\x83\x81\x10\x15aa`W\x80\x82\x01Q\x81\x84\x01R` \x81\x01\x90PaaEV[_\x84\x84\x01RPPPPV[_aau\x82aa)V[aa\x7F\x81\x85aa3V[\x93Paa\x8F\x81\x85` \x86\x01aaCV[aa\x98\x81a_RV[\x84\x01\x91PP\x92\x91PPV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Raa\xBB\x81\x84aakV[\x90P\x92\x91PPV[_\x80`@\x83\x85\x03\x12\x15aa\xD9Waa\xD8a]\xE8V[[_aa\xE6\x85\x82\x86\x01a^\x0FV[\x92PP` aa\xF7\x85\x82\x86\x01a`\x95V[\x91PP\x92P\x92\x90PV[_\x81\x90P\x91\x90PV[ab\x13\x81ab\x01V[\x81\x14ab\x1DW_\x80\xFD[PV[_\x815\x90Pab.\x81ab\nV[\x92\x91PPV[_\x80`@\x83\x85\x03\x12\x15abJWabIa]\xE8V[[_abW\x85\x82\x86\x01ab V[\x92PP` abh\x85\x82\x86\x01a`\x95V[\x91PP\x92P\x92\x90PV[_\x80`@\x83\x85\x03\x12\x15ab\x88Wab\x87a]\xE8V[[_ab\x95\x85\x82\x86\x01a_6V[\x92PP` \x83\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15ab\xB6Wab\xB5a]\xECV[[ab\xC2\x85\x82\x86\x01a`YV[\x91PP\x92P\x92\x90PV[_\x80_``\x84\x86\x03\x12\x15ab\xE3Wab\xE2a]\xE8V[[_ab\xF0\x86\x82\x87\x01a^\x0FV[\x93PP` ac\x01\x86\x82\x87\x01a^\x0FV[\x92PP`@ac\x12\x86\x82\x87\x01a^\x0FV[\x91PP\x92P\x92P\x92V[_`\xFF\x82\x16\x90P\x91\x90PV[ac1\x81ac\x1CV[\x82RPPV[_` \x82\x01\x90PacJ_\x83\x01\x84ac(V[\x92\x91PPV[acY\x81a_\x0FV[\x82RPPV[_` \x82\x01\x90Pacr_\x83\x01\x84acPV[\x92\x91PPV[_` \x82\x84\x03\x12\x15ac\x8DWac\x8Ca]\xE8V[[_ac\x9A\x84\x82\x85\x01a^\x0FV[\x91PP\x92\x91PPV[_` \x82\x84\x03\x12\x15ac\xB8Wac\xB7a]\xE8V[[_ac\xC5\x84\x82\x85\x01a`\x95V[\x91PP\x92\x91PPV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`!`\x04R`$_\xFD[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x11`\x04R`$_\xFD[_ad2\x82ab\x01V[\x91Pad=\x83ab\x01V[\x92P\x82\x82\x01\x90P\x80\x82\x11\x15adUWadTac\xFBV[[\x92\x91PPV[`T\x81\x10adlWadkac\xCEV[[PV[_\x81\x90Pad|\x82ad[V[\x91\x90PV[_ad\x8B\x82adoV[\x90P\x91\x90PV[ad\x9B\x81ad\x81V[\x82RPPV[ad\xAA\x81a^#V[\x82RPPV[_`\xA0\x82\x01\x90Pad\xC3_\x83\x01\x88ad\x92V[ad\xD0` \x83\x01\x87ad\xA1V[ad\xDD`@\x83\x01\x86a^\xC8V[ad\xEA``\x83\x01\x85a^\xC8V[ad\xF7`\x80\x83\x01\x84a^\xC8V[\x96\x95PPPPPPV[_`\x80\x82\x01\x90Pae\x14_\x83\x01\x87a^\xC8V[ae!` \x83\x01\x86a^\xC8V[ae.`@\x83\x01\x85ad\xA1V[ae;``\x83\x01\x84a^\xC8V[\x95\x94PPPPPV[aeM\x81a_\x0FV[\x82RPPV[`@\x82\x01_\x82\x01Qaeg_\x85\x01\x82aeDV[P` \x82\x01Qaez` \x85\x01\x82aeDV[PPPPV[_\x81Q\x90P\x91\x90PV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[_ae\xA4\x82ae\x80V[ae\xAE\x81\x85ae\x8AV[\x93Pae\xBE\x81\x85` \x86\x01aaCV[ae\xC7\x81a_RV[\x84\x01\x91PP\x92\x91PPV[_`\x80\x82\x01\x90Pae\xE5_\x83\x01\x86aeSV[ae\xF2`@\x83\x01\x85a^\xC8V[\x81\x81\x03``\x83\x01Raf\x04\x81\x84ae\x9AV[\x90P\x94\x93PPPPV[_\x81Q\x90Paf\x1C\x81a]\xF9V[\x92\x91PPV[_` \x82\x84\x03\x12\x15af7Waf6a]\xE8V[[_afD\x84\x82\x85\x01af\x0EV[\x91PP\x92\x91PPV[_`@\x82\x01\x90Paf`_\x83\x01\x85a^\xC8V[afm` \x83\x01\x84acPV[\x93\x92PPPV[_`\xA0\x82\x01\x90Paf\x87_\x83\x01\x88a^\xC8V[af\x94` \x83\x01\x87acPV[\x81\x81\x03`@\x83\x01Raf\xA6\x81\x86ae\x9AV[\x90Paf\xB5``\x83\x01\x85ad\x92V[af\xC2`\x80\x83\x01\x84a^\xC8V[\x96\x95PPPPPPV[_\x81\x90P\x92\x91PPV[_af\xE0\x82aa)V[af\xEA\x81\x85af\xCCV[\x93Paf\xFA\x81\x85` \x86\x01aaCV[\x80\x84\x01\x91PP\x92\x91PPV[\x7F v\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_ag:`\x02\x83af\xCCV[\x91PagE\x82ag\x06V[`\x02\x82\x01\x90P\x91\x90PV[\x7F.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_ag\x84`\x01\x83af\xCCV[\x91Pag\x8F\x82agPV[`\x01\x82\x01\x90P\x91\x90PV[_ag\xA5\x82\x87af\xD6V[\x91Pag\xB0\x82ag.V[\x91Pag\xBC\x82\x86af\xD6V[\x91Pag\xC7\x82agxV[\x91Pag\xD3\x82\x85af\xD6V[\x91Pag\xDE\x82agxV[\x91Pag\xEA\x82\x84af\xD6V[\x91P\x81\x90P\x95\x94PPPPPV[_\x81\x15\x15\x90P\x91\x90PV[ah\x0C\x81ag\xF8V[\x81\x14ah\x16W_\x80\xFD[PV[_\x81Q\x90Pah'\x81ah\x03V[\x92\x91PPV[_` \x82\x84\x03\x12\x15ahBWahAa]\xE8V[[_ahO\x84\x82\x85\x01ah\x19V[\x91PP\x92\x91PPV[`\x1C\x81\x10ahiWahhac\xCEV[[PV[_\x81\x90Pahy\x82ahXV[\x91\x90PV[_ah\x88\x82ahlV[\x90P\x91\x90PV[_\x81`\xF8\x1B\x90P\x91\x90PV[_ah\xA5\x82ah\x8FV[\x90P\x91\x90PV[ah\xBDah\xB8\x82ah~V[ah\x9BV[\x82RPPV[_\x81\x90P\x91\x90PV[ah\xDDah\xD8\x82a]\xF0V[ah\xC3V[\x82RPPV[ah\xF4ah\xEF\x82ad\x81V[ah\x9BV[\x82RPPV[_\x81\x90P\x91\x90PV[_ai\x1Dai\x18ai\x13\x84a^\xF0V[ah\xFAV[a^\xF0V[\x90P\x91\x90PV[_ai.\x82ai\x03V[\x90P\x91\x90PV[_ai?\x82ai$V[\x90P\x91\x90PV[_\x81``\x1B\x90P\x91\x90PV[_ai\\\x82aiFV[\x90P\x91\x90PV[_aim\x82aiRV[\x90P\x91\x90PV[ai\x85ai\x80\x82ai5V[aicV[\x82RPPV[_\x81\x90P\x91\x90PV[ai\xA5ai\xA0\x82ab\x01V[ai\x8BV[\x82RPPV[_ai\xB6\x82\x88ah\xACV[`\x01\x82\x01\x91Pai\xC6\x82\x87ah\xCCV[` \x82\x01\x91Pai\xD6\x82\x86ah\xE3V[`\x01\x82\x01\x91Pai\xE6\x82\x85aitV[`\x14\x82\x01\x91Pai\xF6\x82\x84ai\x94V[` \x82\x01\x91P\x81\x90P\x96\x95PPPPPPV[_``\x82\x01\x90Paj\x1C_\x83\x01\x86ad\x92V[aj)` \x83\x01\x85a^\xC8V[aj6`@\x83\x01\x84a^\xC8V[\x94\x93PPPPV[_``\x82\x01\x90PajQ_\x83\x01\x86a^\xC8V[aj^` \x83\x01\x85ad\x92V[ajk`@\x83\x01\x84a^\xC8V[\x94\x93PPPPV[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[aj\x8F\x81ajsV[\x82RPPV[_` \x82\x01\x90Paj\xA8_\x83\x01\x84aj\x86V[\x92\x91PPV[aj\xB7\x81ab\x01V[\x82RPPV[_\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\x16\x90P\x91\x90PV[aj\xF1\x81aj\xBDV[\x82RPPV[_`\x80\x82\x01\x90Pak\n_\x83\x01\x87aj\xAEV[ak\x17` \x83\x01\x86ad\x92V[ak$`@\x83\x01\x85aj\xE8V[ak1``\x83\x01\x84a^\xC8V[\x95\x94PPPPPV[_`\xA0\x82\x01\x90PakM_\x83\x01\x88ad\x92V[akZ` \x83\x01\x87a^\xC8V[akg`@\x83\x01\x86a^\xC8V[akt``\x83\x01\x85a^\xC8V[ak\x81`\x80\x83\x01\x84a^\xC8V[\x96\x95PPPPPPV[_`\x80\x82\x01\x90Pak\x9E_\x83\x01\x87a^\xC8V[ak\xAB` \x83\x01\x86a^\xC8V[ak\xB8`@\x83\x01\x85a^\xC8V[ak\xC5``\x83\x01\x84a^\xC8V[\x95\x94PPPPPV[_ak\xD9\x82\x88ah\xACV[`\x01\x82\x01\x91Pak\xE9\x82\x87ai\x94V[` \x82\x01\x91Pak\xF9\x82\x86ah\xE3V[`\x01\x82\x01\x91Pal\t\x82\x85aitV[`\x14\x82\x01\x91Pal\x19\x82\x84ai\x94V[` \x82\x01\x91P\x81\x90P\x96\x95PPPPPPV[_`@\x82\x01\x90Pal?_\x83\x01\x85ad\x92V[alL` \x83\x01\x84a^\xC8V[\x93\x92PPPV[_``\x82\x01\x90Palf_\x83\x01\x86aj\xAEV[als` \x83\x01\x85ad\x92V[al\x80`@\x83\x01\x84a^\xC8V[\x94\x93PPPPV[_`@\x82\x01\x90Pal\x9B_\x83\x01\x85a^\xC8V[al\xA8` \x83\x01\x84a^\xC8V[\x93\x92PPPV[_``\x82\x01\x90Pal\xC2_\x83\x01\x86ad\x92V[al\xCF` \x83\x01\x85aj\xE8V[al\xDC`@\x83\x01\x84a^\xC8V[\x94\x93PPPPV[_\x81\x90P\x91\x90PV[al\xFEal\xF9\x82a^#V[al\xE4V[\x82RPPV[_am\x0F\x82\x89ah\xACV[`\x01\x82\x01\x91Pam\x1F\x82\x88ah\xCCV[` \x82\x01\x91Pam/\x82\x87ah\xCCV[` \x82\x01\x91Pam?\x82\x86al\xEDV[`\x01\x82\x01\x91PamO\x82\x85aitV[`\x14\x82\x01\x91Pam_\x82\x84ai\x94V[` \x82\x01\x91P\x81\x90P\x97\x96PPPPPPPV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`2`\x04R`$_\xFD[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x12`\x04R`$_\xFD[_am\xD7\x82ab\x01V[\x91Pam\xE2\x83ab\x01V[\x92P\x82\x82\x03\x90P\x81\x81\x11\x15am\xFAWam\xF9ac\xFBV[[\x92\x91PPV[_an\x0B\x82\x88ai\x94V[` \x82\x01\x91Pan\x1B\x82\x87aitV[`\x14\x82\x01\x91Pan+\x82\x86ai\x94V[` \x82\x01\x91Pan;\x82\x85ah\xCCV[` \x82\x01\x91PanK\x82\x84ai\x94V[` \x82\x01\x91P\x81\x90P\x96\x95PPPPPPV[_anh\x82ab\x01V[\x91P\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x03an\x9AWan\x99ac\xFBV[[`\x01\x82\x01\x90P\x91\x90PV[_\x81\x90P\x91\x90PV[an\xBFan\xBA\x82aj\xBDV[an\xA5V[\x82RPPV[_an\xD0\x82\x87ah\xACV[`\x01\x82\x01\x91Pan\xE0\x82\x86ai\x94V[` \x82\x01\x91Pan\xF0\x82\x85ah\xE3V[`\x01\x82\x01\x91Pao\0\x82\x84an\xAEV[`\x10\x82\x01\x91P\x81\x90P\x95\x94PPPPPV[_\x81Q\x90Pao \x81a_ V[\x92\x91PPV[_` \x82\x84\x03\x12\x15ao;Wao:a]\xE8V[[_aoH\x84\x82\x85\x01ao\x12V[\x91PP\x92\x91PPV[_ao\\\x82\x89ah\xACV[`\x01\x82\x01\x91Paol\x82\x88ah\xCCV[` \x82\x01\x91Pao|\x82\x87ah\xCCV[` \x82\x01\x91Pao\x8C\x82\x86ah\xCCV[` \x82\x01\x91Pao\x9C\x82\x85aitV[`\x14\x82\x01\x91Pao\xAC\x82\x84ai\x94V[` \x82\x01\x91P\x81\x90P\x97\x96PPPPPPPV[_ao\xCB\x82\x87ah\xACV[`\x01\x82\x01\x91Pao\xDB\x82\x86ah\xCCV[` \x82\x01\x91Pao\xEB\x82\x85aitV[`\x14\x82\x01\x91Pao\xFB\x82\x84ai\x94V[` \x82\x01\x91P\x81\x90P\x95\x94PPPPPV[_ap\x18\x82\x86ah\xACV[`\x01\x82\x01\x91Pap(\x82\x85ah\xE3V[`\x01\x82\x01\x91Pap8\x82\x84an\xAEV[`\x10\x82\x01\x91P\x81\x90P\x94\x93PPPPV[_\x81\x90P\x92\x91PPV[_ap]\x82ae\x80V[apg\x81\x85apIV[\x93Papw\x81\x85` \x86\x01aaCV[\x80\x84\x01\x91PP\x92\x91PPV[_ap\x8E\x82\x84apSV[\x91P\x81\x90P\x92\x91PPV",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x608060405260043610610219575f3560e01c80637702dcff11610122578063ccc480a1116100aa578063d99882d51161006e578063d99882d5146108fd578063e078697214610939578063f51ccfb014610963578063f6859bdc1461099f578063f77f3f1d146109c957610219565b8063ccc480a1146107d1578063cf4d18aa1461080d578063d580c06314610849578063d75d6e8a14610885578063d8092cbc146108c157610219565b806391f98ffe116100f157806391f98ffe146106c95780639cd07acb14610705578063a8c7c2c114610741578063ad3cb1cc1461076b578063c021329e1461079557610219565b80637702dcff146105eb5780637a297f4b1461062757806385362ee7146106515780638b49ceb41461068d57610219565b806348eef47e116101a55780635a53accb116101745780635a53accb146104bf57806363a2db29146104fb5780636754b3601461053757806372107681146105735780637513a404146105af57610219565b806348eef47e146104015780634f1ef2861461043d57806352d1902d1461045957806357f0a5681461048357610219565b80631391547f116101ec5780631391547f146102fb578063182b6d98146103375780631c89ee441461037357806336318d64146103af57806339f73810146103eb57610219565b806304559f711461021d57806308bf832a146102595780630d8e6e2c14610295578063117b2f38146102bf575b5f80fd5b348015610228575f80fd5b50610243600480360381019061023e9190615e78565b610a05565b6040516102509190615ed7565b60405180910390f35b348015610264575f80fd5b5061027f600480360381019061027a91906160a9565b610bb4565b60405161028c9190615ed7565b60405180910390f35b3480156102a0575f80fd5b506102a9610dd1565b6040516102b691906161a3565b60405180910390f35b3480156102ca575f80fd5b506102e560048036038101906102e09190615e78565b610e4c565b6040516102f29190615ed7565b60405180910390f35b348015610306575f80fd5b50610321600480360381019061031c9190615e78565b610ffa565b60405161032e9190615ed7565b60405180910390f35b348015610342575f80fd5b5061035d60048036038101906103589190615e78565b6111a9565b60405161036a9190615ed7565b60405180910390f35b34801561037e575f80fd5b50610399600480360381019061039491906161c3565b611358565b6040516103a69190615ed7565b60405180910390f35b3480156103ba575f80fd5b506103d560048036038101906103d09190615e78565b611861565b6040516103e29190615ed7565b60405180910390f35b3480156103f6575f80fd5b506103ff611a10565b005b34801561040c575f80fd5b5061042760048036038101906104229190616234565b611b80565b6040516104349190615ed7565b60405180910390f35b61045760048036038101906104529190616272565b611bf4565b005b348015610464575f80fd5b5061046d611c13565b60405161047a9190615ed7565b60405180910390f35b34801561048e575f80fd5b506104a960048036038101906104a49190615e78565b611c44565b6040516104b69190615ed7565b60405180910390f35b3480156104ca575f80fd5b506104e560048036038101906104e09190615e78565b611df3565b6040516104f29190615ed7565b60405180910390f35b348015610506575f80fd5b50610521600480360381019061051c9190615e78565b61203c565b60405161052e9190615ed7565b60405180910390f35b348015610542575f80fd5b5061055d60048036038101906105589190615e78565b612234565b60405161056a9190615ed7565b60405180910390f35b34801561057e575f80fd5b5061059960048036038101906105949190615e78565b612408565b6040516105a69190615ed7565b60405180910390f35b3480156105ba575f80fd5b506105d560048036038101906105d09190615e78565b6125b7565b6040516105e29190615ed7565b60405180910390f35b3480156105f6575f80fd5b50610611600480360381019061060c91906162cc565b612766565b60405161061e9190615ed7565b60405180910390f35b348015610632575f80fd5b5061063b612982565b6040516106489190616337565b60405180910390f35b34801561065c575f80fd5b5061067760048036038101906106729190615e78565b612986565b6040516106849190615ed7565b60405180910390f35b348015610698575f80fd5b506106b360048036038101906106ae9190615e78565b612b35565b6040516106c09190615ed7565b60405180910390f35b3480156106d4575f80fd5b506106ef60048036038101906106ea9190615e78565b612d2d565b6040516106fc9190615ed7565b60405180910390f35b348015610710575f80fd5b5061072b60048036038101906107269190616234565b612f01565b6040516107389190615ed7565b60405180910390f35b34801561074c575f80fd5b50610755613219565b604051610762919061635f565b60405180910390f35b348015610776575f80fd5b5061077f613234565b60405161078c91906161a3565b60405180910390f35b3480156107a0575f80fd5b506107bb60048036038101906107b69190615e78565b61326d565b6040516107c89190615ed7565b60405180910390f35b3480156107dc575f80fd5b506107f760048036038101906107f29190615e78565b613441565b6040516108049190615ed7565b60405180910390f35b348015610818575f80fd5b50610833600480360381019061082e9190615e78565b613615565b6040516108409190615ed7565b60405180910390f35b348015610854575f80fd5b5061086f600480360381019061086a9190616378565b61385e565b60405161087c9190615ed7565b60405180910390f35b348015610890575f80fd5b506108ab60048036038101906108a691906163a3565b613a25565b6040516108b89190615ed7565b60405180910390f35b3480156108cc575f80fd5b506108e760048036038101906108e29190615e78565b613a95565b6040516108f49190615ed7565b60405180910390f35b348015610908575f80fd5b50610923600480360381019061091e9190615e78565b613cb2565b6040516109309190615ed7565b60405180910390f35b348015610944575f80fd5b5061094d613eaa565b60405161095a919061635f565b60405180910390f35b34801561096e575f80fd5b5061098960048036038101906109849190616378565b613ec5565b6040516109969190615ed7565b60405180910390f35b3480156109aa575f80fd5b506109b36140b0565b6040516109c0919061635f565b60405180910390f35b3480156109d4575f80fd5b506109ef60048036038101906109ea9190615e78565b6140cb565b6040516109fc9190615ed7565b60405180910390f35b5f8060066053811115610a1b57610a1a6163ce565b5b60ff166001901b60056053811115610a3657610a356163ce565b5b60ff166001901b60046053811115610a5157610a506163ce565b5b60ff166001901b60036053811115610a6c57610a6b6163ce565b5b60ff166001901b60026053811115610a8757610a866163ce565b5b60ff166001901b610a989190616428565b610aa29190616428565b610aac9190616428565b610ab69190616428565b90505f610ac386836142e8565b9050610ad360128787878561434e565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff1663642b149082868989886040518663ffffffff1660e01b8152600401610b2a9594939291906164b0565b5f604051808303815f87803b158015610b41575f80fd5b505af1158015610b53573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167fc11d62b13c360a83082487064be1ec0878b2f0be4f012bf59f89e128063d47ff87878787604051610ba39493929190616501565b60405180910390a250509392505050565b5f8060405180604001604052808673ffffffffffffffffffffffffffffffffffffffff1681526020013373ffffffffffffffffffffffffffffffffffffffff1681525090505f610c0387614676565b9050806053811115610c1857610c176163ce565b5b846053811115610c2b57610c2a6163ce565b5b14610c62576040517fb968846100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b7336772142b74871f255cbd7a3e89b401d3e45825f73ffffffffffffffffffffffffffffffffffffffff1663e6317df58389886040518463ffffffff1660e01b8152600401610cb3939291906165d2565b6020604051808303815f875af1158015610ccf573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610cf39190616622565b92507350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff16633e395cec84336040518363ffffffff1660e01b8152600401610d4492919061664d565b5f604051808303815f87803b158015610d5b575f80fd5b505af1158015610d6d573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167fdc370db33589e73371dc3ee42c789c003d336eefcb7c3f56fe0f51ae5b1d97028888888888604051610dbf959493929190616674565b60405180910390a25050949350505050565b60606040518060400160405280600d81526020017f464845564d4578656375746f7200000000000000000000000000000000000000815250610e125f6146ae565b610e1c60016146ae565b610e255f6146ae565b604051602001610e38949392919061679a565b604051602081830303815290604052905090565b5f8060066053811115610e6257610e616163ce565b5b60ff166001901b60056053811115610e7d57610e7c6163ce565b5b60ff166001901b60046053811115610e9857610e976163ce565b5b60ff166001901b60036053811115610eb357610eb26163ce565b5b60ff166001901b60026053811115610ece57610ecd6163ce565b5b60ff166001901b610edf9190616428565b610ee99190616428565b610ef39190616428565b610efd9190616428565b90505f610f0a86836142e8565b9050610f195f8787878561434e565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff1663fdad4c9682868989886040518663ffffffff1660e01b8152600401610f709594939291906164b0565b5f604051808303815f87803b158015610f87575f80fd5b505af1158015610f99573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167fdb9050d65240431621d61d6f94b970e63f53a67a5766614ee6e5c5bbd41c8e2e87878787604051610fe99493929190616501565b60405180910390a250509392505050565b5f80600660538111156110105761100f6163ce565b5b60ff166001901b6005605381111561102b5761102a6163ce565b5b60ff166001901b60046053811115611046576110456163ce565b5b60ff166001901b60036053811115611061576110606163ce565b5b60ff166001901b6002605381111561107c5761107b6163ce565b5b60ff166001901b61108d9190616428565b6110979190616428565b6110a19190616428565b6110ab9190616428565b90505f6110b886836142e8565b90506110c8600e8787875f61434e565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff16636bb3c61182868989886040518663ffffffff1660e01b815260040161111f9594939291906164b0565b5f604051808303815f87803b158015611136575f80fd5b505af1158015611148573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167f38c3a63c4230de5b741f494ffb54e3087104030279bc7bccee8ad9ad31712b21878787876040516111989493929190616501565b60405180910390a250509392505050565b5f80600660538111156111bf576111be6163ce565b5b60ff166001901b600560538111156111da576111d96163ce565b5b60ff166001901b600460538111156111f5576111f46163ce565b5b60ff166001901b600360538111156112105761120f6163ce565b5b60ff166001901b6002605381111561122b5761122a6163ce565b5b60ff166001901b61123c9190616428565b6112469190616428565b6112509190616428565b61125a9190616428565b90505f61126786836142e8565b905061127760018787878561434e565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff16639075310882868989886040518663ffffffff1660e01b81526004016112ce9594939291906164b0565b5f604051808303815f87803b1580156112e5575f80fd5b505af11580156112f7573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167feb6d37bd271abe1395b21d6d78f3487d6584862872c29ffd3f90736ee99b7393878787876040516113479493929190616501565b60405180910390a250509392505050565b5f7350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff166382027b6d84336040518363ffffffff1660e01b81526004016113a892919061664d565b602060405180830381865afa1580156113c3573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906113e7919061682d565b61142a5782336040517f9de3392c00000000000000000000000000000000000000000000000000000000815260040161142192919061664d565b60405180910390fd5b5f6008605381111561143f5761143e6163ce565b5b60ff166001901b6006605381111561145a576114596163ce565b5b60ff166001901b60056053811115611475576114746163ce565b5b60ff166001901b600460538111156114905761148f6163ce565b5b60ff166001901b600360538111156114ab576114aa6163ce565b5b60ff166001901b600260538111156114c6576114c56163ce565b5b60ff166001901b5f60538111156114e0576114df6163ce565b5b60ff166001901b6114f19190616428565b6114fb9190616428565b6115059190616428565b61150f9190616428565b6115199190616428565b6115239190616428565b90505f61153085836142e8565b90505f60086053811115611547576115466163ce565b5b60ff166001901b60066053811115611562576115616163ce565b5b60ff166001901b6005605381111561157d5761157c6163ce565b5b60ff166001901b60046053811115611598576115976163ce565b5b60ff166001901b600360538111156115b3576115b26163ce565b5b60ff166001901b600260538111156115ce576115cd6163ce565b5b60ff166001901b6115df9190616428565b6115e99190616428565b6115f39190616428565b6115fd9190616428565b6116079190616428565b90505f8186605381111561161e5761161d6163ce565b5b60ff166001901b160361165d576040517fc6de466a00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b8460538111156116705761166f6163ce565b5b826053811115611683576116826163ce565b5b036116ba576040517fb968846100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b601786867350157cffd6bbfa2dece204a89ec419c23ef5755d466040516020016116e89594939291906169ab565b60405160208183030381529060405280519060200120935061170a8486614778565b935073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff166302dd62768688876040518463ffffffff1660e01b815260040161175d93929190616a09565b5f604051808303815f87803b158015611774575f80fd5b505af1158015611786573d5f803e3d5ffd5b505050507350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff16633e395cec85336040518363ffffffff1660e01b81526004016117d992919061664d565b5f604051808303815f87803b1580156117f0575f80fd5b505af1158015611802573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167f31ccae6a2f8e3ced1692f77c8f668133e4afdaaa35afe844ff4659a6c27e627f87878760405161185093929190616a3e565b60405180910390a250505092915050565b5f8060066053811115611877576118766163ce565b5b60ff166001901b60056053811115611892576118916163ce565b5b60ff166001901b600460538111156118ad576118ac6163ce565b5b60ff166001901b600360538111156118c8576118c76163ce565b5b60ff166001901b600260538111156118e3576118e26163ce565b5b60ff166001901b6118f49190616428565b6118fe9190616428565b6119089190616428565b6119129190616428565b90505f61191f86836142e8565b905061192f60138787878561434e565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff1663acb5f38882868989886040518663ffffffff1660e01b81526004016119869594939291906164b0565b5f604051808303815f87803b15801561199d575f80fd5b505af11580156119af573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167ffd7c9208f956bf0c6ab76a667f04361245ad3e0a2d0eff92eb827acfcca68ea9878787876040516119ff9493929190616501565b60405180910390a250509392505050565b6001611a1a6147f1565b67ffffffffffffffff1614611a5b576040517f6f4f731f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60025f611a66614815565b9050805f0160089054906101000a900460ff1680611aae57508167ffffffffffffffff16815f015f9054906101000a900467ffffffffffffffff1667ffffffffffffffff1610155b15611ae5576040517ff92ee8a900000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b81815f015f6101000a81548167ffffffffffffffff021916908367ffffffffffffffff1602179055506001815f0160086101000a81548160ff0219169083151502179055505f815f0160086101000a81548160ff0219169083151502179055507fc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d282604051611b749190616a95565b60405180910390a15050565b5f80611b8a61483c565b9050611b978484836148b9565b91503373ffffffffffffffffffffffffffffffffffffffff167f5222d96b836727a1d6fe1ee9aef27f9bb507bd41794defa376ff6c648aaf8ff185858486604051611be59493929190616af7565b60405180910390a25092915050565b611bfc614b6a565b611c0582614c50565b611c0f8282614d43565b5050565b5f611c1c614e61565b7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5f1b905090565b5f8060066053811115611c5a57611c596163ce565b5b60ff166001901b60056053811115611c7557611c746163ce565b5b60ff166001901b60046053811115611c9057611c8f6163ce565b5b60ff166001901b60036053811115611cab57611caa6163ce565b5b60ff166001901b60026053811115611cc657611cc56163ce565b5b60ff166001901b611cd79190616428565b611ce19190616428565b611ceb9190616428565b611cf59190616428565b90505f611d0286836142e8565b9050611d1260028787878561434e565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff16633c16ff0d82868989886040518663ffffffff1660e01b8152600401611d699594939291906164b0565b5f604051808303815f87803b158015611d80575f80fd5b505af1158015611d92573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167f215346a4f9f975e6d5484e290bd4e53ca14453a9d282ebd3ccedb2a0f171753d87878787604051611de29493929190616501565b60405180910390a250509392505050565b5f600160f81b827effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191614611e53576040517f4f224e5300000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f801b8303611e8e576040517f23d359a300000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f60066053811115611ea357611ea26163ce565b5b60ff166001901b60056053811115611ebe57611ebd6163ce565b5b60ff166001901b60046053811115611ed957611ed86163ce565b5b60ff166001901b60036053811115611ef457611ef36163ce565b5b60ff166001901b60026053811115611f0f57611f0e6163ce565b5b60ff166001901b611f209190616428565b611f2a9190616428565b611f349190616428565b611f3e9190616428565b90505f611f4b86836142e8565b9050611f5b60038787878561434e565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff1663406b451382868989886040518663ffffffff1660e01b8152600401611fb29594939291906164b0565b5f604051808303815f87803b158015611fc9575f80fd5b505af1158015611fdb573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167f3bab2ee0e2f90f4690c6a87bf63cf1a6b626086e95f231860b152966e8dabbf78787878760405161202b9493929190616501565b60405180910390a250509392505050565b5f8060086053811115612052576120516163ce565b5b60ff166001901b6006605381111561206d5761206c6163ce565b5b60ff166001901b60056053811115612088576120876163ce565b5b60ff166001901b600460538111156120a3576120a26163ce565b5b60ff166001901b600360538111156120be576120bd6163ce565b5b60ff166001901b600260538111156120d9576120d86163ce565b5b60ff166001901b5f60538111156120f3576120f26163ce565b5b60ff166001901b6121049190616428565b61210e9190616428565b6121189190616428565b6121229190616428565b61212c9190616428565b6121369190616428565b90505f61214386836142e8565b905061215360068787878561434e565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff1663e8e399ad82868989886040518663ffffffff1660e01b81526004016121aa9594939291906164b0565b5f604051808303815f87803b1580156121c1575f80fd5b505af11580156121d3573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167f56df279bbfb03d9ed097bbe2f28d520ca0c1161206327926e98664d70d2c24c4878787876040516122239493929190616501565b60405180910390a250509392505050565b5f806008605381111561224a576122496163ce565b5b60ff166001901b60066053811115612265576122646163ce565b5b60ff166001901b600560538111156122805761227f6163ce565b5b60ff166001901b6004605381111561229b5761229a6163ce565b5b60ff166001901b600360538111156122b6576122b56163ce565b5b60ff166001901b600260538111156122d1576122d06163ce565b5b60ff166001901b6122e29190616428565b6122ec9190616428565b6122f69190616428565b6123009190616428565b61230a9190616428565b90505f61231786836142e8565b9050612327600a8787878561434e565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff166314526e8782868989886040518663ffffffff1660e01b815260040161237e9594939291906164b0565b5f604051808303815f87803b158015612395575f80fd5b505af11580156123a7573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167feb0e4f8dc74058194d0602425fe602f955c222200f7f10c6fe67992f7b24c7e9878787876040516123f79493929190616501565b60405180910390a250509392505050565b5f806006605381111561241e5761241d6163ce565b5b60ff166001901b60056053811115612439576124386163ce565b5b60ff166001901b60046053811115612454576124536163ce565b5b60ff166001901b6003605381111561246f5761246e6163ce565b5b60ff166001901b6002605381111561248a576124896163ce565b5b60ff166001901b61249b9190616428565b6124a59190616428565b6124af9190616428565b6124b99190616428565b90505f6124c686836142e8565b90506124d660118787875f61434e565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff16631339c5ee82868989886040518663ffffffff1660e01b815260040161252d9594939291906164b0565b5f604051808303815f87803b158015612544575f80fd5b505af1158015612556573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167f0d483b100d8c73b208984ec697caa3091521ee5525ce69edcf97d7e395d3d059878787876040516125a69493929190616501565b60405180910390a250509392505050565b5f80600660538111156125cd576125cc6163ce565b5b60ff166001901b600560538111156125e8576125e76163ce565b5b60ff166001901b60046053811115612603576126026163ce565b5b60ff166001901b6003605381111561261e5761261d6163ce565b5b60ff166001901b60026053811115612639576126386163ce565b5b60ff166001901b61264a9190616428565b6126549190616428565b61265e9190616428565b6126689190616428565b90505f61267586836142e8565b905061268560108787875f61434e565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff1663d47f3d5982868989886040518663ffffffff1660e01b81526004016126dc9594939291906164b0565b5f604051808303815f87803b1580156126f3575f80fd5b505af1158015612705573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167fdef2e704a077284a07f3d0b436db88f5d981b69f58ab7c1ae623252718a6de01878787876040516127559493929190616501565b60405180910390a250509392505050565b5f806008605381111561277c5761277b6163ce565b5b60ff166001901b60076053811115612797576127966163ce565b5b60ff166001901b600660538111156127b2576127b16163ce565b5b60ff166001901b600560538111156127cd576127cc6163ce565b5b60ff166001901b600460538111156127e8576127e76163ce565b5b60ff166001901b60036053811115612803576128026163ce565b5b60ff166001901b6002605381111561281e5761281d6163ce565b5b60ff166001901b5f6053811115612838576128376163ce565b5b60ff166001901b6128499190616428565b6128539190616428565b61285d9190616428565b6128679190616428565b6128719190616428565b61287b9190616428565b6128859190616428565b90505f61289285836142e8565b90506128a16019878787614ee8565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff16634e72676982888888886040518663ffffffff1660e01b81526004016128f8959493929190616b3a565b5f604051808303815f87803b15801561290f575f80fd5b505af1158015612921573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167f60be9d61aad849facc28c38b048cb5c4be3420b8fa2233e08cfa06be1b6d1c3e878787876040516129719493929190616b8b565b60405180910390a250509392505050565b5f90565b5f806006605381111561299c5761299b6163ce565b5b60ff166001901b600560538111156129b7576129b66163ce565b5b60ff166001901b600460538111156129d2576129d16163ce565b5b60ff166001901b600360538111156129ed576129ec6163ce565b5b60ff166001901b60026053811115612a0857612a076163ce565b5b60ff166001901b612a199190616428565b612a239190616428565b612a2d9190616428565b612a379190616428565b90505f612a4486836142e8565b9050612a54600f8787875f61434e565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff1663859a1b7082868989886040518663ffffffff1660e01b8152600401612aab9594939291906164b0565b5f604051808303815f87803b158015612ac2575f80fd5b505af1158015612ad4573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167fc9ff8f0d18a3f766ce5de3de216076050140e4fc2652f5e0e745f6fc836cda8b87878787604051612b249493929190616501565b60405180910390a250509392505050565b5f8060086053811115612b4b57612b4a6163ce565b5b60ff166001901b60066053811115612b6657612b656163ce565b5b60ff166001901b60056053811115612b8157612b806163ce565b5b60ff166001901b60046053811115612b9c57612b9b6163ce565b5b60ff166001901b60036053811115612bb757612bb66163ce565b5b60ff166001901b60026053811115612bd257612bd16163ce565b5b60ff166001901b5f6053811115612bec57612beb6163ce565b5b60ff166001901b612bfd9190616428565b612c079190616428565b612c119190616428565b612c1b9190616428565b612c259190616428565b612c2f9190616428565b90505f612c3c86836142e8565b9050612c4c60078787878561434e565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff16631434ba4d82868989886040518663ffffffff1660e01b8152600401612ca39594939291906164b0565b5f604051808303815f87803b158015612cba575f80fd5b505af1158015612ccc573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167f4d32284bd3193ecaa44e1ceca32f41c5d6c32803a92e07967dd3ee422972158287878787604051612d1c9493929190616501565b60405180910390a250509392505050565b5f8060086053811115612d4357612d426163ce565b5b60ff166001901b60066053811115612d5e57612d5d6163ce565b5b60ff166001901b60056053811115612d7957612d786163ce565b5b60ff166001901b60046053811115612d9457612d936163ce565b5b60ff166001901b60036053811115612daf57612dae6163ce565b5b60ff166001901b60026053811115612dca57612dc96163ce565b5b60ff166001901b612ddb9190616428565b612de59190616428565b612def9190616428565b612df99190616428565b612e039190616428565b90505f612e1086836142e8565b9050612e2060098787878561434e565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff16631ed91ff682868989886040518663ffffffff1660e01b8152600401612e779594939291906164b0565b5f604051808303815f87803b158015612e8e575f80fd5b505af1158015612ea0573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167f324220bfc9cb158b492991c03c309cd86e5345cac45aacae2092ddabe31fa3d887878787604051612ef09493929190616501565b60405180910390a250509392505050565b5f8060086053811115612f1757612f166163ce565b5b60ff166001901b60076053811115612f3257612f316163ce565b5b60ff166001901b60066053811115612f4d57612f4c6163ce565b5b60ff166001901b60056053811115612f6857612f676163ce565b5b60ff166001901b60046053811115612f8357612f826163ce565b5b60ff166001901b60036053811115612f9e57612f9d6163ce565b5b60ff166001901b60026053811115612fb957612fb86163ce565b5b60ff166001901b5f6053811115612fd357612fd26163ce565b5b60ff166001901b612fe49190616428565b612fee9190616428565b612ff89190616428565b6130029190616428565b61300c9190616428565b6130169190616428565b6130209190616428565b90505f81846053811115613037576130366163ce565b5b60ff166001901b1603613076576040517fc6de466a00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b601884847350157cffd6bbfa2dece204a89ec419c23ef5755d466040516020016130a4959493929190616bce565b6040516020818303038152906040528051906020012091506130c68284614778565b915073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff1663348c318584846040518363ffffffff1660e01b8152600401613117929190616c2c565b5f604051808303815f87803b15801561312e575f80fd5b505af1158015613140573d5f803e3d5ffd5b505050507350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff16633e395cec83336040518363ffffffff1660e01b815260040161319392919061664d565b5f604051808303815f87803b1580156131aa575f80fd5b505af11580156131bc573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167f063ccd1bba45151d91f6a418065047a3d048d058a922535747bb2b575a01d23685858560405161320a93929190616c53565b60405180910390a25092915050565b5f7336772142b74871f255cbd7a3e89b401d3e45825f905090565b6040518060400160405280600581526020017f352e302e3000000000000000000000000000000000000000000000000000000081525081565b5f8060086053811115613283576132826163ce565b5b60ff166001901b6006605381111561329e5761329d6163ce565b5b60ff166001901b600560538111156132b9576132b86163ce565b5b60ff166001901b600460538111156132d4576132d36163ce565b5b60ff166001901b600360538111156132ef576132ee6163ce565b5b60ff166001901b6002605381111561330a576133096163ce565b5b60ff166001901b61331b9190616428565b6133259190616428565b61332f9190616428565b6133399190616428565b6133439190616428565b90505f61335086836142e8565b9050613360600b8787878561434e565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff1663669181c082868989886040518663ffffffff1660e01b81526004016133b79594939291906164b0565b5f604051808303815f87803b1580156133ce575f80fd5b505af11580156133e0573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167fc148675905d07ad5496f8ef4d8195c907503f3ec12fd10ed5f21240abc693634878787876040516134309493929190616501565b60405180910390a250509392505050565b5f8060086053811115613457576134566163ce565b5b60ff166001901b60066053811115613472576134716163ce565b5b60ff166001901b6005605381111561348d5761348c6163ce565b5b60ff166001901b600460538111156134a8576134a76163ce565b5b60ff166001901b600360538111156134c3576134c26163ce565b5b60ff166001901b600260538111156134de576134dd6163ce565b5b60ff166001901b6134ef9190616428565b6134f99190616428565b6135039190616428565b61350d9190616428565b6135179190616428565b90505f61352486836142e8565b905061353460088787878561434e565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff166383e6a72082868989886040518663ffffffff1660e01b815260040161358b9594939291906164b0565b5f604051808303815f87803b1580156135a2575f80fd5b505af11580156135b4573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167fe84282aaebcca698443e39a2a948a345d0d2ebc654af5cb657a2d7e8053bf6cb878787876040516136049493929190616501565b60405180910390a250509392505050565b5f600160f81b827effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191614613675576040517f4f224e5300000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f801b83036136b0576040517f23d359a300000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f600660538111156136c5576136c46163ce565b5b60ff166001901b600560538111156136e0576136df6163ce565b5b60ff166001901b600460538111156136fb576136fa6163ce565b5b60ff166001901b60036053811115613716576137156163ce565b5b60ff166001901b60026053811115613731576137306163ce565b5b60ff166001901b6137429190616428565b61374c9190616428565b6137569190616428565b6137609190616428565b90505f61376d86836142e8565b905061377d60048787878561434e565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff1663fa08e38d82868989886040518663ffffffff1660e01b81526004016137d49594939291906164b0565b5f604051808303815f87803b1580156137eb575f80fd5b505af11580156137fd573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167f0e691cd0bf8c4e9308e4ced1bb9c964117dc5c5bb9b9ab5bdfebf2c9b13a897c8787878760405161384d9493929190616501565b60405180910390a250509392505050565b5f8060086053811115613874576138736163ce565b5b60ff166001901b6006605381111561388f5761388e6163ce565b5b60ff166001901b600560538111156138aa576138a96163ce565b5b60ff166001901b600460538111156138c5576138c46163ce565b5b60ff166001901b600360538111156138e0576138df6163ce565b5b60ff166001901b600260538111156138fb576138fa6163ce565b5b60ff166001901b61390c9190616428565b6139169190616428565b6139209190616428565b61392a9190616428565b6139349190616428565b90505f61394184836142e8565b905061394e601485615314565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff1663a4c98f3e8286866040518463ffffffff1660e01b81526004016139a193929190616a09565b5f604051808303815f87803b1580156139b8575f80fd5b505af11580156139ca573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167f8c664d3c3ca583fc5803b8a91c49644bbd9550bfa87967c73ad1de83027768c08585604051613a16929190616c88565b60405180910390a25050919050565b5f80613a2f61483c565b9050613a3b83826154c4565b91503373ffffffffffffffffffffffffffffffffffffffff167f0c8aca6017003326051e19913ef02631f24b801125e1fa8a1d812e868319fda6848385604051613a8793929190616caf565b60405180910390a250919050565b5f8060086053811115613aab57613aaa6163ce565b5b60ff166001901b60076053811115613ac657613ac56163ce565b5b60ff166001901b60066053811115613ae157613ae06163ce565b5b60ff166001901b60056053811115613afc57613afb6163ce565b5b60ff166001901b60046053811115613b1757613b166163ce565b5b60ff166001901b60036053811115613b3257613b316163ce565b5b60ff166001901b60026053811115613b4d57613b4c6163ce565b5b60ff166001901b5f6053811115613b6757613b666163ce565b5b60ff166001901b613b789190616428565b613b829190616428565b613b8c9190616428565b613b969190616428565b613ba09190616428565b613baa9190616428565b613bb49190616428565b90505f613bc186836142e8565b9050613bd1600d8787875f61434e565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff1663fa5defdb82868989886040518663ffffffff1660e01b8152600401613c289594939291906164b0565b5f604051808303815f87803b158015613c3f575f80fd5b505af1158015613c51573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167f6960c1e88f61c352dba34d1bbf6753e302795264d5d8ae82f7983c7004651e5d87878787604051613ca19493929190616501565b60405180910390a250509392505050565b5f8060086053811115613cc857613cc76163ce565b5b60ff166001901b60066053811115613ce357613ce26163ce565b5b60ff166001901b60056053811115613cfe57613cfd6163ce565b5b60ff166001901b60046053811115613d1957613d186163ce565b5b60ff166001901b60036053811115613d3457613d336163ce565b5b60ff166001901b60026053811115613d4f57613d4e6163ce565b5b60ff166001901b5f6053811115613d6957613d686163ce565b5b60ff166001901b613d7a9190616428565b613d849190616428565b613d8e9190616428565b613d989190616428565b613da29190616428565b613dac9190616428565b90505f613db986836142e8565b9050613dc960058787878561434e565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff16631856d91d82868989886040518663ffffffff1660e01b8152600401613e209594939291906164b0565b5f604051808303815f87803b158015613e37575f80fd5b505af1158015613e49573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167fe42486b0ccdbef81a2075c48c8e515c079aea73c8b82429997c72a2fe1bf4fef87878787604051613e999493929190616501565b60405180910390a250509392505050565b5f73233ff88a48c172d29f675403e6a8e302b0f032d9905090565b5f8060086053811115613edb57613eda6163ce565b5b60ff166001901b60066053811115613ef657613ef56163ce565b5b60ff166001901b60056053811115613f1157613f106163ce565b5b60ff166001901b60046053811115613f2c57613f2b6163ce565b5b60ff166001901b60036053811115613f4757613f466163ce565b5b60ff166001901b60026053811115613f6257613f616163ce565b5b60ff166001901b5f6053811115613f7c57613f7b6163ce565b5b60ff166001901b613f8d9190616428565b613f979190616428565b613fa19190616428565b613fab9190616428565b613fb59190616428565b613fbf9190616428565b90505f613fcc84836142e8565b9050613fd9601585615314565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff1663fc063c628286866040518463ffffffff1660e01b815260040161402c93929190616a09565b5f604051808303815f87803b158015614043575f80fd5b505af1158015614055573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167f55aff4cc7a3d160c83f1f15b818011ede841a0b4597fb14dcd3603df3a11e5e085856040516140a1929190616c88565b60405180910390a25050919050565b5f7350157cffd6bbfa2dece204a89ec419c23ef5755d905090565b5f80600860538111156140e1576140e06163ce565b5b60ff166001901b600760538111156140fc576140fb6163ce565b5b60ff166001901b60066053811115614117576141166163ce565b5b60ff166001901b60056053811115614132576141316163ce565b5b60ff166001901b6004605381111561414d5761414c6163ce565b5b60ff166001901b60036053811115614168576141676163ce565b5b60ff166001901b60026053811115614183576141826163ce565b5b60ff166001901b5f605381111561419d5761419c6163ce565b5b60ff166001901b6141ae9190616428565b6141b89190616428565b6141c29190616428565b6141cc9190616428565b6141d69190616428565b6141e09190616428565b6141ea9190616428565b90505f6141f786836142e8565b9050614207600c8787875f61434e565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff166394e70e4f82868989886040518663ffffffff1660e01b815260040161425e9594939291906164b0565b5f604051808303815f87803b158015614275575f80fd5b505af1158015614287573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167fb3d5c664ec86575818e8d75ff25c5f867250df8954088549c41c848cd10e76cb878787876040516142d79493929190616501565b60405180910390a250509392505050565b5f6142f283614676565b90505f82826053811115614309576143086163ce565b5b60ff166001901b1603614348576040517fc6de466a00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b92915050565b5f6143588361574d565b7350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff166382027b6d86336040518363ffffffff1660e01b81526004016143a792919061664d565b602060405180830381865afa1580156143c2573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906143e6919061682d565b6144295784336040517f9de3392c00000000000000000000000000000000000000000000000000000000815260040161442092919061664d565b60405180910390fd5b5f60f81b837effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff19160361459e577350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff166382027b6d85336040518363ffffffff1660e01b81526004016144a492919061664d565b602060405180830381865afa1580156144bf573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906144e3919061682d565b6145265783336040517f9de3392c00000000000000000000000000000000000000000000000000000000815260040161451d92919061664d565b60405180910390fd5b5f61453085614676565b90505f61453c87614676565b9050816053811115614551576145506163ce565b5b816053811115614564576145636163ce565b5b1461459b576040517f1f3158c700000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b50505b858585857350157cffd6bbfa2dece204a89ec419c23ef5755d466040516020016145cd96959493929190616d04565b6040516020818303038152906040528051906020012090506145ef8183614778565b90507350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff16633e395cec82336040518363ffffffff1660e01b815260040161464092919061664d565b5f604051808303815f87803b158015614657575f80fd5b505af1158015614669573d5f803e3d5ffd5b5050505095945050505050565b5f81601e6020811061468b5761468a616d73565b5b1a60f81b60f81c60ff1660538111156146a7576146a66163ce565b5b9050919050565b60605f60016146bc84615791565b0190505f8167ffffffffffffffff8111156146da576146d9615f62565b5b6040519080825280601f01601f19166020018201604052801561470c5781602001600182028036833780820191505090505b5090505f82602001820190505b60011561476d578080600190039150507f3031323334353637383961626364656600000000000000000000000000000000600a86061a8153600a858161476257614761616da0565b5b0494505f8503614719575b819350505050919050565b5f7fffffffffffffffffffffffffffffffffffffffffff00000000000000000000005f1b83169050605060ff5f1b901b8117905060104667ffffffffffffffff165f1b901b8117905060088260538111156147d6576147d56163ce565b5b60ff165f1b901b811790505f60ff165f1b8117905092915050565b5f6147fa614815565b5f015f9054906101000a900467ffffffffffffffff16905090565b5f7ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00905090565b5f806148466158e2565b9050805f01547350157cffd6bbfa2dece204a89ec419c23ef5755d4660014361486f9190616dcd565b4042604051602001614885959493929190616e00565b604051602081830303815290604052805190602001209150805f015f8154809291906148b090616e5e565b91905055505090565b5f80600860538111156148cf576148ce6163ce565b5b60ff166001901b600660538111156148ea576148e96163ce565b5b60ff166001901b60056053811115614905576149046163ce565b5b60ff166001901b600460538111156149205761491f6163ce565b5b60ff166001901b6003605381111561493b5761493a6163ce565b5b60ff166001901b60026053811115614956576149556163ce565b5b60ff166001901b6149679190616428565b6149719190616428565b61497b9190616428565b6149859190616428565b61498f9190616428565b90505f818560538111156149a6576149a56163ce565b5b60ff166001901b16036149e5576040517fc6de466a00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6149ee85615909565b614a24576040517f24e8e74200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b614a2e858561592d565b601b858585604051602001614a469493929190616ec5565b604051602081830303815290604052805190602001209150614a688285614778565b915073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff1663cc86678285846040518363ffffffff1660e01b8152600401614ab9929190616c2c565b5f604051808303815f87803b158015614ad0575f80fd5b505af1158015614ae2573d5f803e3d5ffd5b505050507350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff16633e395cec83336040518363ffffffff1660e01b8152600401614b3592919061664d565b5f604051808303815f87803b158015614b4c575f80fd5b505af1158015614b5e573d5f803e3d5ffd5b50505050509392505050565b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff163073ffffffffffffffffffffffffffffffffffffffff161480614c1757507f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16614bfe615a7d565b73ffffffffffffffffffffffffffffffffffffffff1614155b15614c4e576040517fe07c8dba00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b565b7350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff16638da5cb5b6040518163ffffffff1660e01b8152600401602060405180830381865afa158015614cad573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190614cd19190616f26565b73ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614614d4057336040517f21bfda10000000000000000000000000000000000000000000000000000000008152600401614d37919061635f565b60405180910390fd5b50565b8173ffffffffffffffffffffffffffffffffffffffff166352d1902d6040518163ffffffff1660e01b8152600401602060405180830381865afa925050508015614dab57506040513d601f19601f82011682018060405250810190614da89190616622565b60015b614dec57816040517f4c9c8ce3000000000000000000000000000000000000000000000000000000008152600401614de3919061635f565b60405180910390fd5b7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5f1b8114614e5257806040517faa1d49a4000000000000000000000000000000000000000000000000000000008152600401614e499190615ed7565b60405180910390fd5b614e5c8383615ad0565b505050565b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff163073ffffffffffffffffffffffffffffffffffffffff1614614ee6576040517fe07c8dba00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b565b5f7350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff166382027b6d85336040518363ffffffff1660e01b8152600401614f3892919061664d565b602060405180830381865afa158015614f53573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190614f77919061682d565b614fba5783336040517f9de3392c000000000000000000000000000000000000000000000000000000008152600401614fb192919061664d565b60405180910390fd5b7350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff166382027b6d84336040518363ffffffff1660e01b815260040161500992919061664d565b602060405180830381865afa158015615024573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190615048919061682d565b61508b5782336040517f9de3392c00000000000000000000000000000000000000000000000000000000815260040161508292919061664d565b60405180910390fd5b7350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff166382027b6d83336040518363ffffffff1660e01b81526004016150da92919061664d565b602060405180830381865afa1580156150f5573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190615119919061682d565b61515c5781336040517f9de3392c00000000000000000000000000000000000000000000000000000000815260040161515392919061664d565b60405180910390fd5b5f61516685614676565b90505f61517285614676565b90505f61517e85614676565b90505f6053811115615193576151926163ce565b5b8360538111156151a6576151a56163ce565b5b146151dd576040517fc6de466a00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b8060538111156151f0576151ef6163ce565b5b826053811115615203576152026163ce565b5b1461523a576040517f1f3158c700000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b878787877350157cffd6bbfa2dece204a89ec419c23ef5755d4660405160200161526996959493929190616f51565b60405160208183030381529060405280519060200120935061528b8483614778565b93507350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff16633e395cec85336040518363ffffffff1660e01b81526004016152dc92919061664d565b5f604051808303815f87803b1580156152f3575f80fd5b505af1158015615305573d5f803e3d5ffd5b50505050505050949350505050565b5f7350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff166382027b6d83336040518363ffffffff1660e01b815260040161536492919061664d565b602060405180830381865afa15801561537f573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906153a3919061682d565b6153e65781336040517f9de3392c0000000000000000000000000000000000000000000000000000000081526004016153dd92919061664d565b60405180910390fd5b82827350157cffd6bbfa2dece204a89ec419c23ef5755d466040516020016154119493929190616fc0565b6040516020818303038152906040528051906020012090505f61543383614676565b905061543f8282614778565b91507350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff16633e395cec83336040518363ffffffff1660e01b815260040161549092919061664d565b5f604051808303815f87803b1580156154a7575f80fd5b505af11580156154b9573d5f803e3d5ffd5b505050505092915050565b5f80600860538111156154da576154d96163ce565b5b60ff166001901b600660538111156154f5576154f46163ce565b5b60ff166001901b600560538111156155105761550f6163ce565b5b60ff166001901b6004605381111561552b5761552a6163ce565b5b60ff166001901b60036053811115615546576155456163ce565b5b60ff166001901b60026053811115615561576155606163ce565b5b60ff166001901b5f605381111561557b5761557a6163ce565b5b60ff166001901b61558c9190616428565b6155969190616428565b6155a09190616428565b6155aa9190616428565b6155b49190616428565b6155be9190616428565b90505f818560538111156155d5576155d46163ce565b5b60ff166001901b1603615614576040517fc6de466a00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b601a848460405160200161562a9392919061700d565b60405160208183030381529060405280519060200120915061564c8285614778565b915073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff166309b04e8f85846040518363ffffffff1660e01b815260040161569d929190616c2c565b5f604051808303815f87803b1580156156b4575f80fd5b505af11580156156c6573d5f803e3d5ffd5b505050507350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff16633e395cec83336040518363ffffffff1660e01b815260040161571992919061664d565b5f604051808303815f87803b158015615730575f80fd5b505af1158015615742573d5f803e3d5ffd5b505050505092915050565b60018160f81c60ff16111561578e576040517fdf7bf32500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b50565b5f805f90507a184f03e93ff9f4daa797ed6e38ed64bf6a1f01000000000000000083106157ed577a184f03e93ff9f4daa797ed6e38ed64bf6a1f01000000000000000083816157e3576157e2616da0565b5b0492506040810190505b6d04ee2d6d415b85acef8100000000831061582a576d04ee2d6d415b85acef810000000083816158205761581f616da0565b5b0492506020810190505b662386f26fc10000831061585957662386f26fc10000838161584f5761584e616da0565b5b0492506010810190505b6305f5e1008310615882576305f5e100838161587857615877616da0565b5b0492506008810190505b61271083106158a757612710838161589d5761589c616da0565b5b0492506004810190505b606483106158ca57606483816158c0576158bf616da0565b5b0492506002810190505b600a83106158d9576001810190505b80915050919050565b5f7f4613e1771f6b755d243e536fb5a23c5b15e2826575fee921e8fe7a22a760c800905090565b5f808211801561592657505f6001836159229190616dcd565b8316145b9050919050565b60026053811115615941576159406163ce565b5b816053811115615954576159536163ce565b5b0361596a5761596582610100615b42565b615a79565b6003605381111561597e5761597d6163ce565b5b816053811115615991576159906163ce565b5b036159a8576159a38262010000615b42565b615a79565b600460538111156159bc576159bb6163ce565b5b8160538111156159cf576159ce6163ce565b5b036159e8576159e382640100000000615b42565b615a79565b600560538111156159fc576159fb6163ce565b5b816053811115615a0f57615a0e6163ce565b5b03615a2c57615a278268010000000000000000615b42565b615a79565b60066053811115615a4057615a3f6163ce565b5b816053811115615a5357615a526163ce565b5b03615a7857615a7382700100000000000000000000000000000000615b42565b615a79565b5b5050565b5f615aa97f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5f1b615b80565b5f015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905090565b615ad982615b89565b8173ffffffffffffffffffffffffffffffffffffffff167fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b60405160405180910390a25f81511115615b3557615b2f8282615c52565b50615b3e565b615b3d615cd2565b5b5050565b80821115615b7c576040517fc7dadf4500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5050565b5f819050919050565b5f8173ffffffffffffffffffffffffffffffffffffffff163b03615be457806040517f4c9c8ce3000000000000000000000000000000000000000000000000000000008152600401615bdb919061635f565b60405180910390fd5b80615c107f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5f1b615b80565b5f015f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555050565b60605f808473ffffffffffffffffffffffffffffffffffffffff1684604051615c7b9190617083565b5f60405180830381855af49150503d805f8114615cb3576040519150601f19603f3d011682016040523d82523d5f602084013e615cb8565b606091505b5091509150615cc8858383615d0e565b9250505092915050565b5f341115615d0c576040517fb398979f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b565b606082615d2357615d1e82615d9b565b615d93565b5f8251148015615d4957505f8473ffffffffffffffffffffffffffffffffffffffff163b145b15615d8b57836040517f9996b315000000000000000000000000000000000000000000000000000000008152600401615d82919061635f565b60405180910390fd5b819050615d94565b5b9392505050565b5f81511115615dad5780518082602001fd5b6040517fd6bda27500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f604051905090565b5f80fd5b5f80fd5b5f819050919050565b615e0281615df0565b8114615e0c575f80fd5b50565b5f81359050615e1d81615df9565b92915050565b5f7fff0000000000000000000000000000000000000000000000000000000000000082169050919050565b615e5781615e23565b8114615e61575f80fd5b50565b5f81359050615e7281615e4e565b92915050565b5f805f60608486031215615e8f57615e8e615de8565b5b5f615e9c86828701615e0f565b9350506020615ead86828701615e0f565b9250506040615ebe86828701615e64565b9150509250925092565b615ed181615df0565b82525050565b5f602082019050615eea5f830184615ec8565b92915050565b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f615f1982615ef0565b9050919050565b615f2981615f0f565b8114615f33575f80fd5b50565b5f81359050615f4481615f20565b92915050565b5f80fd5b5f80fd5b5f601f19601f8301169050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b615f9882615f52565b810181811067ffffffffffffffff82111715615fb757615fb6615f62565b5b80604052505050565b5f615fc9615ddf565b9050615fd58282615f8f565b919050565b5f67ffffffffffffffff821115615ff457615ff3615f62565b5b615ffd82615f52565b9050602081019050919050565b828183375f83830152505050565b5f61602a61602584615fda565b615fc0565b90508281526020810184848401111561604657616045615f4e565b5b61605184828561600a565b509392505050565b5f82601f83011261606d5761606c615f4a565b5b813561607d848260208601616018565b91505092915050565b60548110616092575f80fd5b50565b5f813590506160a381616086565b92915050565b5f805f80608085870312156160c1576160c0615de8565b5b5f6160ce87828801615e0f565b94505060206160df87828801615f36565b935050604085013567ffffffffffffffff811115616100576160ff615dec565b5b61610c87828801616059565b925050606061611d87828801616095565b91505092959194509250565b5f81519050919050565b5f82825260208201905092915050565b5f5b83811015616160578082015181840152602081019050616145565b5f8484015250505050565b5f61617582616129565b61617f8185616133565b935061618f818560208601616143565b61619881615f52565b840191505092915050565b5f6020820190508181035f8301526161bb818461616b565b905092915050565b5f80604083850312156161d9576161d8615de8565b5b5f6161e685828601615e0f565b92505060206161f785828601616095565b9150509250929050565b5f819050919050565b61621381616201565b811461621d575f80fd5b50565b5f8135905061622e8161620a565b92915050565b5f806040838503121561624a57616249615de8565b5b5f61625785828601616220565b925050602061626885828601616095565b9150509250929050565b5f806040838503121561628857616287615de8565b5b5f61629585828601615f36565b925050602083013567ffffffffffffffff8111156162b6576162b5615dec565b5b6162c285828601616059565b9150509250929050565b5f805f606084860312156162e3576162e2615de8565b5b5f6162f086828701615e0f565b935050602061630186828701615e0f565b925050604061631286828701615e0f565b9150509250925092565b5f60ff82169050919050565b6163318161631c565b82525050565b5f60208201905061634a5f830184616328565b92915050565b61635981615f0f565b82525050565b5f6020820190506163725f830184616350565b92915050565b5f6020828403121561638d5761638c615de8565b5b5f61639a84828501615e0f565b91505092915050565b5f602082840312156163b8576163b7615de8565b5b5f6163c584828501616095565b91505092915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52602160045260245ffd5b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5f61643282616201565b915061643d83616201565b9250828201905080821115616455576164546163fb565b5b92915050565b6054811061646c5761646b6163ce565b5b50565b5f81905061647c8261645b565b919050565b5f61648b8261646f565b9050919050565b61649b81616481565b82525050565b6164aa81615e23565b82525050565b5f60a0820190506164c35f830188616492565b6164d060208301876164a1565b6164dd6040830186615ec8565b6164ea6060830185615ec8565b6164f76080830184615ec8565b9695505050505050565b5f6080820190506165145f830187615ec8565b6165216020830186615ec8565b61652e60408301856164a1565b61653b6060830184615ec8565b95945050505050565b61654d81615f0f565b82525050565b604082015f8201516165675f850182616544565b50602082015161657a6020850182616544565b50505050565b5f81519050919050565b5f82825260208201905092915050565b5f6165a482616580565b6165ae818561658a565b93506165be818560208601616143565b6165c781615f52565b840191505092915050565b5f6080820190506165e55f830186616553565b6165f26040830185615ec8565b8181036060830152616604818461659a565b9050949350505050565b5f8151905061661c81615df9565b92915050565b5f6020828403121561663757616636615de8565b5b5f6166448482850161660e565b91505092915050565b5f6040820190506166605f830185615ec8565b61666d6020830184616350565b9392505050565b5f60a0820190506166875f830188615ec8565b6166946020830187616350565b81810360408301526166a6818661659a565b90506166b56060830185616492565b6166c26080830184615ec8565b9695505050505050565b5f81905092915050565b5f6166e082616129565b6166ea81856166cc565b93506166fa818560208601616143565b80840191505092915050565b7f20760000000000000000000000000000000000000000000000000000000000005f82015250565b5f61673a6002836166cc565b915061674582616706565b600282019050919050565b7f2e000000000000000000000000000000000000000000000000000000000000005f82015250565b5f6167846001836166cc565b915061678f82616750565b600182019050919050565b5f6167a582876166d6565b91506167b08261672e565b91506167bc82866166d6565b91506167c782616778565b91506167d382856166d6565b91506167de82616778565b91506167ea82846166d6565b915081905095945050505050565b5f8115159050919050565b61680c816167f8565b8114616816575f80fd5b50565b5f8151905061682781616803565b92915050565b5f6020828403121561684257616841615de8565b5b5f61684f84828501616819565b91505092915050565b601c8110616869576168686163ce565b5b50565b5f81905061687982616858565b919050565b5f6168888261686c565b9050919050565b5f8160f81b9050919050565b5f6168a58261688f565b9050919050565b6168bd6168b88261687e565b61689b565b82525050565b5f819050919050565b6168dd6168d882615df0565b6168c3565b82525050565b6168f46168ef82616481565b61689b565b82525050565b5f819050919050565b5f61691d61691861691384615ef0565b6168fa565b615ef0565b9050919050565b5f61692e82616903565b9050919050565b5f61693f82616924565b9050919050565b5f8160601b9050919050565b5f61695c82616946565b9050919050565b5f61696d82616952565b9050919050565b61698561698082616935565b616963565b82525050565b5f819050919050565b6169a56169a082616201565b61698b565b82525050565b5f6169b682886168ac565b6001820191506169c682876168cc565b6020820191506169d682866168e3565b6001820191506169e68285616974565b6014820191506169f68284616994565b6020820191508190509695505050505050565b5f606082019050616a1c5f830186616492565b616a296020830185615ec8565b616a366040830184615ec8565b949350505050565b5f606082019050616a515f830186615ec8565b616a5e6020830185616492565b616a6b6040830184615ec8565b949350505050565b5f67ffffffffffffffff82169050919050565b616a8f81616a73565b82525050565b5f602082019050616aa85f830184616a86565b92915050565b616ab781616201565b82525050565b5f7fffffffffffffffffffffffffffffffff0000000000000000000000000000000082169050919050565b616af181616abd565b82525050565b5f608082019050616b0a5f830187616aae565b616b176020830186616492565b616b246040830185616ae8565b616b316060830184615ec8565b95945050505050565b5f60a082019050616b4d5f830188616492565b616b5a6020830187615ec8565b616b676040830186615ec8565b616b746060830185615ec8565b616b816080830184615ec8565b9695505050505050565b5f608082019050616b9e5f830187615ec8565b616bab6020830186615ec8565b616bb86040830185615ec8565b616bc56060830184615ec8565b95945050505050565b5f616bd982886168ac565b600182019150616be98287616994565b602082019150616bf982866168e3565b600182019150616c098285616974565b601482019150616c198284616994565b6020820191508190509695505050505050565b5f604082019050616c3f5f830185616492565b616c4c6020830184615ec8565b9392505050565b5f606082019050616c665f830186616aae565b616c736020830185616492565b616c806040830184615ec8565b949350505050565b5f604082019050616c9b5f830185615ec8565b616ca86020830184615ec8565b9392505050565b5f606082019050616cc25f830186616492565b616ccf6020830185616ae8565b616cdc6040830184615ec8565b949350505050565b5f819050919050565b616cfe616cf982615e23565b616ce4565b82525050565b5f616d0f82896168ac565b600182019150616d1f82886168cc565b602082019150616d2f82876168cc565b602082019150616d3f8286616ced565b600182019150616d4f8285616974565b601482019150616d5f8284616994565b602082019150819050979650505050505050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603260045260245ffd5b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601260045260245ffd5b5f616dd782616201565b9150616de283616201565b9250828203905081811115616dfa57616df96163fb565b5b92915050565b5f616e0b8288616994565b602082019150616e1b8287616974565b601482019150616e2b8286616994565b602082019150616e3b82856168cc565b602082019150616e4b8284616994565b6020820191508190509695505050505050565b5f616e6882616201565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8203616e9a57616e996163fb565b5b600182019050919050565b5f819050919050565b616ebf616eba82616abd565b616ea5565b82525050565b5f616ed082876168ac565b600182019150616ee08286616994565b602082019150616ef082856168e3565b600182019150616f008284616eae565b60108201915081905095945050505050565b5f81519050616f2081615f20565b92915050565b5f60208284031215616f3b57616f3a615de8565b5b5f616f4884828501616f12565b91505092915050565b5f616f5c82896168ac565b600182019150616f6c82886168cc565b602082019150616f7c82876168cc565b602082019150616f8c82866168cc565b602082019150616f9c8285616974565b601482019150616fac8284616994565b602082019150819050979650505050505050565b5f616fcb82876168ac565b600182019150616fdb82866168cc565b602082019150616feb8285616974565b601482019150616ffb8284616994565b60208201915081905095945050505050565b5f61701882866168ac565b60018201915061702882856168e3565b6001820191506170388284616eae565b601082019150819050949350505050565b5f81905092915050565b5f61705d82616580565b6170678185617049565b9350617077818560208601616143565b80840191505092915050565b5f61708e8284617053565b91508190509291505056
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R`\x046\x10a\x02\x19W_5`\xE0\x1C\x80cw\x02\xDC\xFF\x11a\x01\"W\x80c\xCC\xC4\x80\xA1\x11a\0\xAAW\x80c\xD9\x98\x82\xD5\x11a\0nW\x80c\xD9\x98\x82\xD5\x14a\x08\xFDW\x80c\xE0xir\x14a\t9W\x80c\xF5\x1C\xCF\xB0\x14a\tcW\x80c\xF6\x85\x9B\xDC\x14a\t\x9FW\x80c\xF7\x7F?\x1D\x14a\t\xC9Wa\x02\x19V[\x80c\xCC\xC4\x80\xA1\x14a\x07\xD1W\x80c\xCFM\x18\xAA\x14a\x08\rW\x80c\xD5\x80\xC0c\x14a\x08IW\x80c\xD7]n\x8A\x14a\x08\x85W\x80c\xD8\t,\xBC\x14a\x08\xC1Wa\x02\x19V[\x80c\x91\xF9\x8F\xFE\x11a\0\xF1W\x80c\x91\xF9\x8F\xFE\x14a\x06\xC9W\x80c\x9C\xD0z\xCB\x14a\x07\x05W\x80c\xA8\xC7\xC2\xC1\x14a\x07AW\x80c\xAD<\xB1\xCC\x14a\x07kW\x80c\xC0!2\x9E\x14a\x07\x95Wa\x02\x19V[\x80cw\x02\xDC\xFF\x14a\x05\xEBW\x80cz)\x7FK\x14a\x06'W\x80c\x856.\xE7\x14a\x06QW\x80c\x8BI\xCE\xB4\x14a\x06\x8DWa\x02\x19V[\x80cH\xEE\xF4~\x11a\x01\xA5W\x80cZS\xAC\xCB\x11a\x01tW\x80cZS\xAC\xCB\x14a\x04\xBFW\x80cc\xA2\xDB)\x14a\x04\xFBW\x80cgT\xB3`\x14a\x057W\x80cr\x10v\x81\x14a\x05sW\x80cu\x13\xA4\x04\x14a\x05\xAFWa\x02\x19V[\x80cH\xEE\xF4~\x14a\x04\x01W\x80cO\x1E\xF2\x86\x14a\x04=W\x80cR\xD1\x90-\x14a\x04YW\x80cW\xF0\xA5h\x14a\x04\x83Wa\x02\x19V[\x80c\x13\x91T\x7F\x11a\x01\xECW\x80c\x13\x91T\x7F\x14a\x02\xFBW\x80c\x18+m\x98\x14a\x037W\x80c\x1C\x89\xEED\x14a\x03sW\x80c61\x8Dd\x14a\x03\xAFW\x80c9\xF78\x10\x14a\x03\xEBWa\x02\x19V[\x80c\x04U\x9Fq\x14a\x02\x1DW\x80c\x08\xBF\x83*\x14a\x02YW\x80c\r\x8En,\x14a\x02\x95W\x80c\x11{/8\x14a\x02\xBFW[_\x80\xFD[4\x80\x15a\x02(W_\x80\xFD[Pa\x02C`\x04\x806\x03\x81\x01\x90a\x02>\x91\x90a^xV[a\n\x05V[`@Qa\x02P\x91\x90a^\xD7V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x02dW_\x80\xFD[Pa\x02\x7F`\x04\x806\x03\x81\x01\x90a\x02z\x91\x90a`\xA9V[a\x0B\xB4V[`@Qa\x02\x8C\x91\x90a^\xD7V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x02\xA0W_\x80\xFD[Pa\x02\xA9a\r\xD1V[`@Qa\x02\xB6\x91\x90aa\xA3V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x02\xCAW_\x80\xFD[Pa\x02\xE5`\x04\x806\x03\x81\x01\x90a\x02\xE0\x91\x90a^xV[a\x0ELV[`@Qa\x02\xF2\x91\x90a^\xD7V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x03\x06W_\x80\xFD[Pa\x03!`\x04\x806\x03\x81\x01\x90a\x03\x1C\x91\x90a^xV[a\x0F\xFAV[`@Qa\x03.\x91\x90a^\xD7V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x03BW_\x80\xFD[Pa\x03]`\x04\x806\x03\x81\x01\x90a\x03X\x91\x90a^xV[a\x11\xA9V[`@Qa\x03j\x91\x90a^\xD7V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x03~W_\x80\xFD[Pa\x03\x99`\x04\x806\x03\x81\x01\x90a\x03\x94\x91\x90aa\xC3V[a\x13XV[`@Qa\x03\xA6\x91\x90a^\xD7V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x03\xBAW_\x80\xFD[Pa\x03\xD5`\x04\x806\x03\x81\x01\x90a\x03\xD0\x91\x90a^xV[a\x18aV[`@Qa\x03\xE2\x91\x90a^\xD7V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x03\xF6W_\x80\xFD[Pa\x03\xFFa\x1A\x10V[\0[4\x80\x15a\x04\x0CW_\x80\xFD[Pa\x04'`\x04\x806\x03\x81\x01\x90a\x04\"\x91\x90ab4V[a\x1B\x80V[`@Qa\x044\x91\x90a^\xD7V[`@Q\x80\x91\x03\x90\xF3[a\x04W`\x04\x806\x03\x81\x01\x90a\x04R\x91\x90abrV[a\x1B\xF4V[\0[4\x80\x15a\x04dW_\x80\xFD[Pa\x04ma\x1C\x13V[`@Qa\x04z\x91\x90a^\xD7V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x04\x8EW_\x80\xFD[Pa\x04\xA9`\x04\x806\x03\x81\x01\x90a\x04\xA4\x91\x90a^xV[a\x1CDV[`@Qa\x04\xB6\x91\x90a^\xD7V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x04\xCAW_\x80\xFD[Pa\x04\xE5`\x04\x806\x03\x81\x01\x90a\x04\xE0\x91\x90a^xV[a\x1D\xF3V[`@Qa\x04\xF2\x91\x90a^\xD7V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x05\x06W_\x80\xFD[Pa\x05!`\x04\x806\x03\x81\x01\x90a\x05\x1C\x91\x90a^xV[a <V[`@Qa\x05.\x91\x90a^\xD7V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x05BW_\x80\xFD[Pa\x05]`\x04\x806\x03\x81\x01\x90a\x05X\x91\x90a^xV[a\"4V[`@Qa\x05j\x91\x90a^\xD7V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x05~W_\x80\xFD[Pa\x05\x99`\x04\x806\x03\x81\x01\x90a\x05\x94\x91\x90a^xV[a$\x08V[`@Qa\x05\xA6\x91\x90a^\xD7V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x05\xBAW_\x80\xFD[Pa\x05\xD5`\x04\x806\x03\x81\x01\x90a\x05\xD0\x91\x90a^xV[a%\xB7V[`@Qa\x05\xE2\x91\x90a^\xD7V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x05\xF6W_\x80\xFD[Pa\x06\x11`\x04\x806\x03\x81\x01\x90a\x06\x0C\x91\x90ab\xCCV[a'fV[`@Qa\x06\x1E\x91\x90a^\xD7V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x062W_\x80\xFD[Pa\x06;a)\x82V[`@Qa\x06H\x91\x90ac7V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x06\\W_\x80\xFD[Pa\x06w`\x04\x806\x03\x81\x01\x90a\x06r\x91\x90a^xV[a)\x86V[`@Qa\x06\x84\x91\x90a^\xD7V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x06\x98W_\x80\xFD[Pa\x06\xB3`\x04\x806\x03\x81\x01\x90a\x06\xAE\x91\x90a^xV[a+5V[`@Qa\x06\xC0\x91\x90a^\xD7V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x06\xD4W_\x80\xFD[Pa\x06\xEF`\x04\x806\x03\x81\x01\x90a\x06\xEA\x91\x90a^xV[a--V[`@Qa\x06\xFC\x91\x90a^\xD7V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x07\x10W_\x80\xFD[Pa\x07+`\x04\x806\x03\x81\x01\x90a\x07&\x91\x90ab4V[a/\x01V[`@Qa\x078\x91\x90a^\xD7V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x07LW_\x80\xFD[Pa\x07Ua2\x19V[`@Qa\x07b\x91\x90ac_V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x07vW_\x80\xFD[Pa\x07\x7Fa24V[`@Qa\x07\x8C\x91\x90aa\xA3V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x07\xA0W_\x80\xFD[Pa\x07\xBB`\x04\x806\x03\x81\x01\x90a\x07\xB6\x91\x90a^xV[a2mV[`@Qa\x07\xC8\x91\x90a^\xD7V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x07\xDCW_\x80\xFD[Pa\x07\xF7`\x04\x806\x03\x81\x01\x90a\x07\xF2\x91\x90a^xV[a4AV[`@Qa\x08\x04\x91\x90a^\xD7V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x08\x18W_\x80\xFD[Pa\x083`\x04\x806\x03\x81\x01\x90a\x08.\x91\x90a^xV[a6\x15V[`@Qa\x08@\x91\x90a^\xD7V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x08TW_\x80\xFD[Pa\x08o`\x04\x806\x03\x81\x01\x90a\x08j\x91\x90acxV[a8^V[`@Qa\x08|\x91\x90a^\xD7V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x08\x90W_\x80\xFD[Pa\x08\xAB`\x04\x806\x03\x81\x01\x90a\x08\xA6\x91\x90ac\xA3V[a:%V[`@Qa\x08\xB8\x91\x90a^\xD7V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x08\xCCW_\x80\xFD[Pa\x08\xE7`\x04\x806\x03\x81\x01\x90a\x08\xE2\x91\x90a^xV[a:\x95V[`@Qa\x08\xF4\x91\x90a^\xD7V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\t\x08W_\x80\xFD[Pa\t#`\x04\x806\x03\x81\x01\x90a\t\x1E\x91\x90a^xV[a<\xB2V[`@Qa\t0\x91\x90a^\xD7V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\tDW_\x80\xFD[Pa\tMa>\xAAV[`@Qa\tZ\x91\x90ac_V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\tnW_\x80\xFD[Pa\t\x89`\x04\x806\x03\x81\x01\x90a\t\x84\x91\x90acxV[a>\xC5V[`@Qa\t\x96\x91\x90a^\xD7V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\t\xAAW_\x80\xFD[Pa\t\xB3a@\xB0V[`@Qa\t\xC0\x91\x90ac_V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\t\xD4W_\x80\xFD[Pa\t\xEF`\x04\x806\x03\x81\x01\x90a\t\xEA\x91\x90a^xV[a@\xCBV[`@Qa\t\xFC\x91\x90a^\xD7V[`@Q\x80\x91\x03\x90\xF3[_\x80`\x06`S\x81\x11\x15a\n\x1BWa\n\x1Aac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a\n6Wa\n5ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a\nQWa\nPac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a\nlWa\nkac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a\n\x87Wa\n\x86ac\xCEV[[`\xFF\x16`\x01\x90\x1Ba\n\x98\x91\x90ad(V[a\n\xA2\x91\x90ad(V[a\n\xAC\x91\x90ad(V[a\n\xB6\x91\x90ad(V[\x90P_a\n\xC3\x86\x83aB\xE8V[\x90Pa\n\xD3`\x12\x87\x87\x87\x85aCNV[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16cd+\x14\x90\x82\x86\x89\x89\x88`@Q\x86c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x0B*\x95\x94\x93\x92\x91\x90ad\xB0V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x0BAW_\x80\xFD[PZ\xF1\x15\x80\x15a\x0BSW=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xC1\x1Db\xB1<6\n\x83\x08$\x87\x06K\xE1\xEC\x08x\xB2\xF0\xBEO\x01+\xF5\x9F\x89\xE1(\x06=G\xFF\x87\x87\x87\x87`@Qa\x0B\xA3\x94\x93\x92\x91\x90ae\x01V[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_\x80`@Q\x80`@\x01`@R\x80\x86s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x013s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81RP\x90P_a\x0C\x03\x87aFvV[\x90P\x80`S\x81\x11\x15a\x0C\x18Wa\x0C\x17ac\xCEV[[\x84`S\x81\x11\x15a\x0C+Wa\x0C*ac\xCEV[[\x14a\x0CbW`@Q\x7F\xB9h\x84a\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[s6w!B\xB7Hq\xF2U\xCB\xD7\xA3\xE8\x9B@\x1D>E\x82_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xE61}\xF5\x83\x89\x88`@Q\x84c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x0C\xB3\x93\x92\x91\x90ae\xD2V[` `@Q\x80\x83\x03\x81_\x87Z\xF1\x15\x80\x15a\x0C\xCFW=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x0C\xF3\x91\x90af\"V[\x92PsP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c>9\\\xEC\x843`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\rD\x92\x91\x90afMV[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\r[W_\x80\xFD[PZ\xF1\x15\x80\x15a\rmW=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xDC7\r\xB35\x89\xE73q\xDC>\xE4,x\x9C\0=3n\xEF\xCB|?V\xFE\x0FQ\xAE[\x1D\x97\x02\x88\x88\x88\x88\x88`@Qa\r\xBF\x95\x94\x93\x92\x91\x90aftV[`@Q\x80\x91\x03\x90\xA2PP\x94\x93PPPPV[```@Q\x80`@\x01`@R\x80`\r\x81R` \x01\x7FFHEVMExecutor\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81RPa\x0E\x12_aF\xAEV[a\x0E\x1C`\x01aF\xAEV[a\x0E%_aF\xAEV[`@Q` \x01a\x0E8\x94\x93\x92\x91\x90ag\x9AV[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x90P\x90V[_\x80`\x06`S\x81\x11\x15a\x0EbWa\x0Eaac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a\x0E}Wa\x0E|ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a\x0E\x98Wa\x0E\x97ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a\x0E\xB3Wa\x0E\xB2ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a\x0E\xCEWa\x0E\xCDac\xCEV[[`\xFF\x16`\x01\x90\x1Ba\x0E\xDF\x91\x90ad(V[a\x0E\xE9\x91\x90ad(V[a\x0E\xF3\x91\x90ad(V[a\x0E\xFD\x91\x90ad(V[\x90P_a\x0F\n\x86\x83aB\xE8V[\x90Pa\x0F\x19_\x87\x87\x87\x85aCNV[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xFD\xADL\x96\x82\x86\x89\x89\x88`@Q\x86c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x0Fp\x95\x94\x93\x92\x91\x90ad\xB0V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x0F\x87W_\x80\xFD[PZ\xF1\x15\x80\x15a\x0F\x99W=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xDB\x90P\xD6R@C\x16!\xD6\x1Do\x94\xB9p\xE6?S\xA6zWfaN\xE6\xE5\xC5\xBB\xD4\x1C\x8E.\x87\x87\x87\x87`@Qa\x0F\xE9\x94\x93\x92\x91\x90ae\x01V[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_\x80`\x06`S\x81\x11\x15a\x10\x10Wa\x10\x0Fac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a\x10+Wa\x10*ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a\x10FWa\x10Eac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a\x10aWa\x10`ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a\x10|Wa\x10{ac\xCEV[[`\xFF\x16`\x01\x90\x1Ba\x10\x8D\x91\x90ad(V[a\x10\x97\x91\x90ad(V[a\x10\xA1\x91\x90ad(V[a\x10\xAB\x91\x90ad(V[\x90P_a\x10\xB8\x86\x83aB\xE8V[\x90Pa\x10\xC8`\x0E\x87\x87\x87_aCNV[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16ck\xB3\xC6\x11\x82\x86\x89\x89\x88`@Q\x86c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x11\x1F\x95\x94\x93\x92\x91\x90ad\xB0V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x116W_\x80\xFD[PZ\xF1\x15\x80\x15a\x11HW=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F8\xC3\xA6<B0\xDE[t\x1FIO\xFBT\xE3\x08q\x04\x03\x02y\xBC{\xCC\xEE\x8A\xD9\xAD1q+!\x87\x87\x87\x87`@Qa\x11\x98\x94\x93\x92\x91\x90ae\x01V[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_\x80`\x06`S\x81\x11\x15a\x11\xBFWa\x11\xBEac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a\x11\xDAWa\x11\xD9ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a\x11\xF5Wa\x11\xF4ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a\x12\x10Wa\x12\x0Fac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a\x12+Wa\x12*ac\xCEV[[`\xFF\x16`\x01\x90\x1Ba\x12<\x91\x90ad(V[a\x12F\x91\x90ad(V[a\x12P\x91\x90ad(V[a\x12Z\x91\x90ad(V[\x90P_a\x12g\x86\x83aB\xE8V[\x90Pa\x12w`\x01\x87\x87\x87\x85aCNV[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x90u1\x08\x82\x86\x89\x89\x88`@Q\x86c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x12\xCE\x95\x94\x93\x92\x91\x90ad\xB0V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x12\xE5W_\x80\xFD[PZ\xF1\x15\x80\x15a\x12\xF7W=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xEBm7\xBD'\x1A\xBE\x13\x95\xB2\x1Dmx\xF3H}e\x84\x86(r\xC2\x9F\xFD?\x90sn\xE9\x9Bs\x93\x87\x87\x87\x87`@Qa\x13G\x94\x93\x92\x91\x90ae\x01V[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_sP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x82\x02{m\x843`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x13\xA8\x92\x91\x90afMV[` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x13\xC3W=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x13\xE7\x91\x90ah-V[a\x14*W\x823`@Q\x7F\x9D\xE39,\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x14!\x92\x91\x90afMV[`@Q\x80\x91\x03\x90\xFD[_`\x08`S\x81\x11\x15a\x14?Wa\x14>ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x06`S\x81\x11\x15a\x14ZWa\x14Yac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a\x14uWa\x14tac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a\x14\x90Wa\x14\x8Fac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a\x14\xABWa\x14\xAAac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a\x14\xC6Wa\x14\xC5ac\xCEV[[`\xFF\x16`\x01\x90\x1B_`S\x81\x11\x15a\x14\xE0Wa\x14\xDFac\xCEV[[`\xFF\x16`\x01\x90\x1Ba\x14\xF1\x91\x90ad(V[a\x14\xFB\x91\x90ad(V[a\x15\x05\x91\x90ad(V[a\x15\x0F\x91\x90ad(V[a\x15\x19\x91\x90ad(V[a\x15#\x91\x90ad(V[\x90P_a\x150\x85\x83aB\xE8V[\x90P_`\x08`S\x81\x11\x15a\x15GWa\x15Fac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x06`S\x81\x11\x15a\x15bWa\x15aac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a\x15}Wa\x15|ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a\x15\x98Wa\x15\x97ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a\x15\xB3Wa\x15\xB2ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a\x15\xCEWa\x15\xCDac\xCEV[[`\xFF\x16`\x01\x90\x1Ba\x15\xDF\x91\x90ad(V[a\x15\xE9\x91\x90ad(V[a\x15\xF3\x91\x90ad(V[a\x15\xFD\x91\x90ad(V[a\x16\x07\x91\x90ad(V[\x90P_\x81\x86`S\x81\x11\x15a\x16\x1EWa\x16\x1Dac\xCEV[[`\xFF\x16`\x01\x90\x1B\x16\x03a\x16]W`@Q\x7F\xC6\xDEFj\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x84`S\x81\x11\x15a\x16pWa\x16oac\xCEV[[\x82`S\x81\x11\x15a\x16\x83Wa\x16\x82ac\xCEV[[\x03a\x16\xBAW`@Q\x7F\xB9h\x84a\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x17\x86\x86sP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]F`@Q` \x01a\x16\xE8\x95\x94\x93\x92\x91\x90ai\xABV[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x93Pa\x17\n\x84\x86aGxV[\x93Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x02\xDDbv\x86\x88\x87`@Q\x84c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x17]\x93\x92\x91\x90aj\tV[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x17tW_\x80\xFD[PZ\xF1\x15\x80\x15a\x17\x86W=_\x80>=_\xFD[PPPPsP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c>9\\\xEC\x853`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x17\xD9\x92\x91\x90afMV[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x17\xF0W_\x80\xFD[PZ\xF1\x15\x80\x15a\x18\x02W=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F1\xCC\xAEj/\x8E<\xED\x16\x92\xF7|\x8Ff\x813\xE4\xAF\xDA\xAA5\xAF\xE8D\xFFFY\xA6\xC2~b\x7F\x87\x87\x87`@Qa\x18P\x93\x92\x91\x90aj>V[`@Q\x80\x91\x03\x90\xA2PPP\x92\x91PPV[_\x80`\x06`S\x81\x11\x15a\x18wWa\x18vac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a\x18\x92Wa\x18\x91ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a\x18\xADWa\x18\xACac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a\x18\xC8Wa\x18\xC7ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a\x18\xE3Wa\x18\xE2ac\xCEV[[`\xFF\x16`\x01\x90\x1Ba\x18\xF4\x91\x90ad(V[a\x18\xFE\x91\x90ad(V[a\x19\x08\x91\x90ad(V[a\x19\x12\x91\x90ad(V[\x90P_a\x19\x1F\x86\x83aB\xE8V[\x90Pa\x19/`\x13\x87\x87\x87\x85aCNV[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xAC\xB5\xF3\x88\x82\x86\x89\x89\x88`@Q\x86c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x19\x86\x95\x94\x93\x92\x91\x90ad\xB0V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x19\x9DW_\x80\xFD[PZ\xF1\x15\x80\x15a\x19\xAFW=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xFD|\x92\x08\xF9V\xBF\x0Cj\xB7jf\x7F\x046\x12E\xAD>\n-\x0E\xFF\x92\xEB\x82z\xCF\xCC\xA6\x8E\xA9\x87\x87\x87\x87`@Qa\x19\xFF\x94\x93\x92\x91\x90ae\x01V[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[`\x01a\x1A\x1AaG\xF1V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x1A[W`@Q\x7FoOs\x1F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x02_a\x1AfaH\x15V[\x90P\x80_\x01`\x08\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x80a\x1A\xAEWP\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81_\x01_\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x10\x15[\x15a\x1A\xE5W`@Q\x7F\xF9.\xE8\xA9\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x81\x81_\x01_a\x01\0\n\x81T\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP`\x01\x81_\x01`\x08a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP_\x81_\x01`\x08a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP\x7F\xC7\xF5\x05\xB2\xF3q\xAE!u\xEEI\x13\xF4I\x9E\x1F&3\xA7\xB5\x93c!\xEE\xD1\xCD\xAE\xB6\x11Q\x81\xD2\x82`@Qa\x1Bt\x91\x90aj\x95V[`@Q\x80\x91\x03\x90\xA1PPV[_\x80a\x1B\x8AaH<V[\x90Pa\x1B\x97\x84\x84\x83aH\xB9V[\x91P3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7FR\"\xD9k\x83g'\xA1\xD6\xFE\x1E\xE9\xAE\xF2\x7F\x9B\xB5\x07\xBDAyM\xEF\xA3v\xFFld\x8A\xAF\x8F\xF1\x85\x85\x84\x86`@Qa\x1B\xE5\x94\x93\x92\x91\x90aj\xF7V[`@Q\x80\x91\x03\x90\xA2P\x92\x91PPV[a\x1B\xFCaKjV[a\x1C\x05\x82aLPV[a\x1C\x0F\x82\x82aMCV[PPV[_a\x1C\x1CaNaV[\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC_\x1B\x90P\x90V[_\x80`\x06`S\x81\x11\x15a\x1CZWa\x1CYac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a\x1CuWa\x1Ctac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a\x1C\x90Wa\x1C\x8Fac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a\x1C\xABWa\x1C\xAAac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a\x1C\xC6Wa\x1C\xC5ac\xCEV[[`\xFF\x16`\x01\x90\x1Ba\x1C\xD7\x91\x90ad(V[a\x1C\xE1\x91\x90ad(V[a\x1C\xEB\x91\x90ad(V[a\x1C\xF5\x91\x90ad(V[\x90P_a\x1D\x02\x86\x83aB\xE8V[\x90Pa\x1D\x12`\x02\x87\x87\x87\x85aCNV[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c<\x16\xFF\r\x82\x86\x89\x89\x88`@Q\x86c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x1Di\x95\x94\x93\x92\x91\x90ad\xB0V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x1D\x80W_\x80\xFD[PZ\xF1\x15\x80\x15a\x1D\x92W=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F!SF\xA4\xF9\xF9u\xE6\xD5HN)\x0B\xD4\xE5<\xA1DS\xA9\xD2\x82\xEB\xD3\xCC\xED\xB2\xA0\xF1qu=\x87\x87\x87\x87`@Qa\x1D\xE2\x94\x93\x92\x91\x90ae\x01V[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_`\x01`\xF8\x1B\x82~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x14a\x1ESW`@Q\x7FO\"NS\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x80\x1B\x83\x03a\x1E\x8EW`@Q\x7F#\xD3Y\xA3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\x06`S\x81\x11\x15a\x1E\xA3Wa\x1E\xA2ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a\x1E\xBEWa\x1E\xBDac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a\x1E\xD9Wa\x1E\xD8ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a\x1E\xF4Wa\x1E\xF3ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a\x1F\x0FWa\x1F\x0Eac\xCEV[[`\xFF\x16`\x01\x90\x1Ba\x1F \x91\x90ad(V[a\x1F*\x91\x90ad(V[a\x1F4\x91\x90ad(V[a\x1F>\x91\x90ad(V[\x90P_a\x1FK\x86\x83aB\xE8V[\x90Pa\x1F[`\x03\x87\x87\x87\x85aCNV[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c@kE\x13\x82\x86\x89\x89\x88`@Q\x86c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x1F\xB2\x95\x94\x93\x92\x91\x90ad\xB0V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x1F\xC9W_\x80\xFD[PZ\xF1\x15\x80\x15a\x1F\xDBW=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F;\xAB.\xE0\xE2\xF9\x0FF\x90\xC6\xA8{\xF6<\xF1\xA6\xB6&\x08n\x95\xF21\x86\x0B\x15)f\xE8\xDA\xBB\xF7\x87\x87\x87\x87`@Qa +\x94\x93\x92\x91\x90ae\x01V[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_\x80`\x08`S\x81\x11\x15a RWa Qac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x06`S\x81\x11\x15a mWa lac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a \x88Wa \x87ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a \xA3Wa \xA2ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a \xBEWa \xBDac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a \xD9Wa \xD8ac\xCEV[[`\xFF\x16`\x01\x90\x1B_`S\x81\x11\x15a \xF3Wa \xF2ac\xCEV[[`\xFF\x16`\x01\x90\x1Ba!\x04\x91\x90ad(V[a!\x0E\x91\x90ad(V[a!\x18\x91\x90ad(V[a!\"\x91\x90ad(V[a!,\x91\x90ad(V[a!6\x91\x90ad(V[\x90P_a!C\x86\x83aB\xE8V[\x90Pa!S`\x06\x87\x87\x87\x85aCNV[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xE8\xE3\x99\xAD\x82\x86\x89\x89\x88`@Q\x86c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a!\xAA\x95\x94\x93\x92\x91\x90ad\xB0V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a!\xC1W_\x80\xFD[PZ\xF1\x15\x80\x15a!\xD3W=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7FV\xDF'\x9B\xBF\xB0=\x9E\xD0\x97\xBB\xE2\xF2\x8DR\x0C\xA0\xC1\x16\x12\x062y&\xE9\x86d\xD7\r,$\xC4\x87\x87\x87\x87`@Qa\"#\x94\x93\x92\x91\x90ae\x01V[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_\x80`\x08`S\x81\x11\x15a\"JWa\"Iac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x06`S\x81\x11\x15a\"eWa\"dac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a\"\x80Wa\"\x7Fac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a\"\x9BWa\"\x9Aac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a\"\xB6Wa\"\xB5ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a\"\xD1Wa\"\xD0ac\xCEV[[`\xFF\x16`\x01\x90\x1Ba\"\xE2\x91\x90ad(V[a\"\xEC\x91\x90ad(V[a\"\xF6\x91\x90ad(V[a#\0\x91\x90ad(V[a#\n\x91\x90ad(V[\x90P_a#\x17\x86\x83aB\xE8V[\x90Pa#'`\n\x87\x87\x87\x85aCNV[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x14Rn\x87\x82\x86\x89\x89\x88`@Q\x86c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a#~\x95\x94\x93\x92\x91\x90ad\xB0V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a#\x95W_\x80\xFD[PZ\xF1\x15\x80\x15a#\xA7W=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xEB\x0EO\x8D\xC7@X\x19M\x06\x02B_\xE6\x02\xF9U\xC2\" \x0F\x7F\x10\xC6\xFEg\x99/{$\xC7\xE9\x87\x87\x87\x87`@Qa#\xF7\x94\x93\x92\x91\x90ae\x01V[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_\x80`\x06`S\x81\x11\x15a$\x1EWa$\x1Dac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a$9Wa$8ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a$TWa$Sac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a$oWa$nac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a$\x8AWa$\x89ac\xCEV[[`\xFF\x16`\x01\x90\x1Ba$\x9B\x91\x90ad(V[a$\xA5\x91\x90ad(V[a$\xAF\x91\x90ad(V[a$\xB9\x91\x90ad(V[\x90P_a$\xC6\x86\x83aB\xE8V[\x90Pa$\xD6`\x11\x87\x87\x87_aCNV[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x139\xC5\xEE\x82\x86\x89\x89\x88`@Q\x86c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a%-\x95\x94\x93\x92\x91\x90ad\xB0V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a%DW_\x80\xFD[PZ\xF1\x15\x80\x15a%VW=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\rH;\x10\r\x8Cs\xB2\x08\x98N\xC6\x97\xCA\xA3\t\x15!\xEEU%\xCEi\xED\xCF\x97\xD7\xE3\x95\xD3\xD0Y\x87\x87\x87\x87`@Qa%\xA6\x94\x93\x92\x91\x90ae\x01V[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_\x80`\x06`S\x81\x11\x15a%\xCDWa%\xCCac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a%\xE8Wa%\xE7ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a&\x03Wa&\x02ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a&\x1EWa&\x1Dac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a&9Wa&8ac\xCEV[[`\xFF\x16`\x01\x90\x1Ba&J\x91\x90ad(V[a&T\x91\x90ad(V[a&^\x91\x90ad(V[a&h\x91\x90ad(V[\x90P_a&u\x86\x83aB\xE8V[\x90Pa&\x85`\x10\x87\x87\x87_aCNV[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xD4\x7F=Y\x82\x86\x89\x89\x88`@Q\x86c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a&\xDC\x95\x94\x93\x92\x91\x90ad\xB0V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a&\xF3W_\x80\xFD[PZ\xF1\x15\x80\x15a'\x05W=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xDE\xF2\xE7\x04\xA0w(J\x07\xF3\xD0\xB46\xDB\x88\xF5\xD9\x81\xB6\x9FX\xAB|\x1A\xE6#%'\x18\xA6\xDE\x01\x87\x87\x87\x87`@Qa'U\x94\x93\x92\x91\x90ae\x01V[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_\x80`\x08`S\x81\x11\x15a'|Wa'{ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x07`S\x81\x11\x15a'\x97Wa'\x96ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x06`S\x81\x11\x15a'\xB2Wa'\xB1ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a'\xCDWa'\xCCac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a'\xE8Wa'\xE7ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a(\x03Wa(\x02ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a(\x1EWa(\x1Dac\xCEV[[`\xFF\x16`\x01\x90\x1B_`S\x81\x11\x15a(8Wa(7ac\xCEV[[`\xFF\x16`\x01\x90\x1Ba(I\x91\x90ad(V[a(S\x91\x90ad(V[a(]\x91\x90ad(V[a(g\x91\x90ad(V[a(q\x91\x90ad(V[a({\x91\x90ad(V[a(\x85\x91\x90ad(V[\x90P_a(\x92\x85\x83aB\xE8V[\x90Pa(\xA1`\x19\x87\x87\x87aN\xE8V[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16cNrgi\x82\x88\x88\x88\x88`@Q\x86c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a(\xF8\x95\x94\x93\x92\x91\x90ak:V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a)\x0FW_\x80\xFD[PZ\xF1\x15\x80\x15a)!W=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F`\xBE\x9Da\xAA\xD8I\xFA\xCC(\xC3\x8B\x04\x8C\xB5\xC4\xBE4 \xB8\xFA\"3\xE0\x8C\xFA\x06\xBE\x1Bm\x1C>\x87\x87\x87\x87`@Qa)q\x94\x93\x92\x91\x90ak\x8BV[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_\x90V[_\x80`\x06`S\x81\x11\x15a)\x9CWa)\x9Bac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a)\xB7Wa)\xB6ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a)\xD2Wa)\xD1ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a)\xEDWa)\xECac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a*\x08Wa*\x07ac\xCEV[[`\xFF\x16`\x01\x90\x1Ba*\x19\x91\x90ad(V[a*#\x91\x90ad(V[a*-\x91\x90ad(V[a*7\x91\x90ad(V[\x90P_a*D\x86\x83aB\xE8V[\x90Pa*T`\x0F\x87\x87\x87_aCNV[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x85\x9A\x1Bp\x82\x86\x89\x89\x88`@Q\x86c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a*\xAB\x95\x94\x93\x92\x91\x90ad\xB0V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a*\xC2W_\x80\xFD[PZ\xF1\x15\x80\x15a*\xD4W=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xC9\xFF\x8F\r\x18\xA3\xF7f\xCE]\xE3\xDE!`v\x05\x01@\xE4\xFC&R\xF5\xE0\xE7E\xF6\xFC\x83l\xDA\x8B\x87\x87\x87\x87`@Qa+$\x94\x93\x92\x91\x90ae\x01V[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_\x80`\x08`S\x81\x11\x15a+KWa+Jac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x06`S\x81\x11\x15a+fWa+eac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a+\x81Wa+\x80ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a+\x9CWa+\x9Bac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a+\xB7Wa+\xB6ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a+\xD2Wa+\xD1ac\xCEV[[`\xFF\x16`\x01\x90\x1B_`S\x81\x11\x15a+\xECWa+\xEBac\xCEV[[`\xFF\x16`\x01\x90\x1Ba+\xFD\x91\x90ad(V[a,\x07\x91\x90ad(V[a,\x11\x91\x90ad(V[a,\x1B\x91\x90ad(V[a,%\x91\x90ad(V[a,/\x91\x90ad(V[\x90P_a,<\x86\x83aB\xE8V[\x90Pa,L`\x07\x87\x87\x87\x85aCNV[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x144\xBAM\x82\x86\x89\x89\x88`@Q\x86c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a,\xA3\x95\x94\x93\x92\x91\x90ad\xB0V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a,\xBAW_\x80\xFD[PZ\xF1\x15\x80\x15a,\xCCW=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7FM2(K\xD3\x19>\xCA\xA4N\x1C\xEC\xA3/A\xC5\xD6\xC3(\x03\xA9.\x07\x96}\xD3\xEEB)r\x15\x82\x87\x87\x87\x87`@Qa-\x1C\x94\x93\x92\x91\x90ae\x01V[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_\x80`\x08`S\x81\x11\x15a-CWa-Bac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x06`S\x81\x11\x15a-^Wa-]ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a-yWa-xac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a-\x94Wa-\x93ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a-\xAFWa-\xAEac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a-\xCAWa-\xC9ac\xCEV[[`\xFF\x16`\x01\x90\x1Ba-\xDB\x91\x90ad(V[a-\xE5\x91\x90ad(V[a-\xEF\x91\x90ad(V[a-\xF9\x91\x90ad(V[a.\x03\x91\x90ad(V[\x90P_a.\x10\x86\x83aB\xE8V[\x90Pa. `\t\x87\x87\x87\x85aCNV[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x1E\xD9\x1F\xF6\x82\x86\x89\x89\x88`@Q\x86c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a.w\x95\x94\x93\x92\x91\x90ad\xB0V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a.\x8EW_\x80\xFD[PZ\xF1\x15\x80\x15a.\xA0W=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F2B \xBF\xC9\xCB\x15\x8BI)\x91\xC0<0\x9C\xD8nSE\xCA\xC4Z\xAC\xAE \x92\xDD\xAB\xE3\x1F\xA3\xD8\x87\x87\x87\x87`@Qa.\xF0\x94\x93\x92\x91\x90ae\x01V[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_\x80`\x08`S\x81\x11\x15a/\x17Wa/\x16ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x07`S\x81\x11\x15a/2Wa/1ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x06`S\x81\x11\x15a/MWa/Lac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a/hWa/gac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a/\x83Wa/\x82ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a/\x9EWa/\x9Dac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a/\xB9Wa/\xB8ac\xCEV[[`\xFF\x16`\x01\x90\x1B_`S\x81\x11\x15a/\xD3Wa/\xD2ac\xCEV[[`\xFF\x16`\x01\x90\x1Ba/\xE4\x91\x90ad(V[a/\xEE\x91\x90ad(V[a/\xF8\x91\x90ad(V[a0\x02\x91\x90ad(V[a0\x0C\x91\x90ad(V[a0\x16\x91\x90ad(V[a0 \x91\x90ad(V[\x90P_\x81\x84`S\x81\x11\x15a07Wa06ac\xCEV[[`\xFF\x16`\x01\x90\x1B\x16\x03a0vW`@Q\x7F\xC6\xDEFj\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x18\x84\x84sP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]F`@Q` \x01a0\xA4\x95\x94\x93\x92\x91\x90ak\xCEV[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x91Pa0\xC6\x82\x84aGxV[\x91Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c4\x8C1\x85\x84\x84`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a1\x17\x92\x91\x90al,V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a1.W_\x80\xFD[PZ\xF1\x15\x80\x15a1@W=_\x80>=_\xFD[PPPPsP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c>9\\\xEC\x833`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a1\x93\x92\x91\x90afMV[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a1\xAAW_\x80\xFD[PZ\xF1\x15\x80\x15a1\xBCW=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\x06<\xCD\x1B\xBAE\x15\x1D\x91\xF6\xA4\x18\x06PG\xA3\xD0H\xD0X\xA9\"SWG\xBB+WZ\x01\xD26\x85\x85\x85`@Qa2\n\x93\x92\x91\x90alSV[`@Q\x80\x91\x03\x90\xA2P\x92\x91PPV[_s6w!B\xB7Hq\xF2U\xCB\xD7\xA3\xE8\x9B@\x1D>E\x82_\x90P\x90V[`@Q\x80`@\x01`@R\x80`\x05\x81R` \x01\x7F5.0.0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81RP\x81V[_\x80`\x08`S\x81\x11\x15a2\x83Wa2\x82ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x06`S\x81\x11\x15a2\x9EWa2\x9Dac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a2\xB9Wa2\xB8ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a2\xD4Wa2\xD3ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a2\xEFWa2\xEEac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a3\nWa3\tac\xCEV[[`\xFF\x16`\x01\x90\x1Ba3\x1B\x91\x90ad(V[a3%\x91\x90ad(V[a3/\x91\x90ad(V[a39\x91\x90ad(V[a3C\x91\x90ad(V[\x90P_a3P\x86\x83aB\xE8V[\x90Pa3``\x0B\x87\x87\x87\x85aCNV[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16cf\x91\x81\xC0\x82\x86\x89\x89\x88`@Q\x86c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a3\xB7\x95\x94\x93\x92\x91\x90ad\xB0V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a3\xCEW_\x80\xFD[PZ\xF1\x15\x80\x15a3\xE0W=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xC1HgY\x05\xD0z\xD5Io\x8E\xF4\xD8\x19\\\x90u\x03\xF3\xEC\x12\xFD\x10\xED_!$\n\xBCi64\x87\x87\x87\x87`@Qa40\x94\x93\x92\x91\x90ae\x01V[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_\x80`\x08`S\x81\x11\x15a4WWa4Vac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x06`S\x81\x11\x15a4rWa4qac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a4\x8DWa4\x8Cac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a4\xA8Wa4\xA7ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a4\xC3Wa4\xC2ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a4\xDEWa4\xDDac\xCEV[[`\xFF\x16`\x01\x90\x1Ba4\xEF\x91\x90ad(V[a4\xF9\x91\x90ad(V[a5\x03\x91\x90ad(V[a5\r\x91\x90ad(V[a5\x17\x91\x90ad(V[\x90P_a5$\x86\x83aB\xE8V[\x90Pa54`\x08\x87\x87\x87\x85aCNV[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x83\xE6\xA7 \x82\x86\x89\x89\x88`@Q\x86c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a5\x8B\x95\x94\x93\x92\x91\x90ad\xB0V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a5\xA2W_\x80\xFD[PZ\xF1\x15\x80\x15a5\xB4W=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xE8B\x82\xAA\xEB\xCC\xA6\x98D>9\xA2\xA9H\xA3E\xD0\xD2\xEB\xC6T\xAF\\\xB6W\xA2\xD7\xE8\x05;\xF6\xCB\x87\x87\x87\x87`@Qa6\x04\x94\x93\x92\x91\x90ae\x01V[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_`\x01`\xF8\x1B\x82~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x14a6uW`@Q\x7FO\"NS\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x80\x1B\x83\x03a6\xB0W`@Q\x7F#\xD3Y\xA3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\x06`S\x81\x11\x15a6\xC5Wa6\xC4ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a6\xE0Wa6\xDFac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a6\xFBWa6\xFAac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a7\x16Wa7\x15ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a71Wa70ac\xCEV[[`\xFF\x16`\x01\x90\x1Ba7B\x91\x90ad(V[a7L\x91\x90ad(V[a7V\x91\x90ad(V[a7`\x91\x90ad(V[\x90P_a7m\x86\x83aB\xE8V[\x90Pa7}`\x04\x87\x87\x87\x85aCNV[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xFA\x08\xE3\x8D\x82\x86\x89\x89\x88`@Q\x86c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a7\xD4\x95\x94\x93\x92\x91\x90ad\xB0V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a7\xEBW_\x80\xFD[PZ\xF1\x15\x80\x15a7\xFDW=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\x0Ei\x1C\xD0\xBF\x8CN\x93\x08\xE4\xCE\xD1\xBB\x9C\x96A\x17\xDC\\[\xB9\xB9\xAB[\xDF\xEB\xF2\xC9\xB1:\x89|\x87\x87\x87\x87`@Qa8M\x94\x93\x92\x91\x90ae\x01V[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_\x80`\x08`S\x81\x11\x15a8tWa8sac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x06`S\x81\x11\x15a8\x8FWa8\x8Eac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a8\xAAWa8\xA9ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a8\xC5Wa8\xC4ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a8\xE0Wa8\xDFac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a8\xFBWa8\xFAac\xCEV[[`\xFF\x16`\x01\x90\x1Ba9\x0C\x91\x90ad(V[a9\x16\x91\x90ad(V[a9 \x91\x90ad(V[a9*\x91\x90ad(V[a94\x91\x90ad(V[\x90P_a9A\x84\x83aB\xE8V[\x90Pa9N`\x14\x85aS\x14V[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xA4\xC9\x8F>\x82\x86\x86`@Q\x84c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a9\xA1\x93\x92\x91\x90aj\tV[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a9\xB8W_\x80\xFD[PZ\xF1\x15\x80\x15a9\xCAW=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\x8CfM<<\xA5\x83\xFCX\x03\xB8\xA9\x1CIdK\xBD\x95P\xBF\xA8yg\xC7:\xD1\xDE\x83\x02wh\xC0\x85\x85`@Qa:\x16\x92\x91\x90al\x88V[`@Q\x80\x91\x03\x90\xA2PP\x91\x90PV[_\x80a:/aH<V[\x90Pa:;\x83\x82aT\xC4V[\x91P3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\x0C\x8A\xCA`\x17\x003&\x05\x1E\x19\x91>\xF0&1\xF2K\x80\x11%\xE1\xFA\x8A\x1D\x81.\x86\x83\x19\xFD\xA6\x84\x83\x85`@Qa:\x87\x93\x92\x91\x90al\xAFV[`@Q\x80\x91\x03\x90\xA2P\x91\x90PV[_\x80`\x08`S\x81\x11\x15a:\xABWa:\xAAac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x07`S\x81\x11\x15a:\xC6Wa:\xC5ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x06`S\x81\x11\x15a:\xE1Wa:\xE0ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a:\xFCWa:\xFBac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a;\x17Wa;\x16ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a;2Wa;1ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a;MWa;Lac\xCEV[[`\xFF\x16`\x01\x90\x1B_`S\x81\x11\x15a;gWa;fac\xCEV[[`\xFF\x16`\x01\x90\x1Ba;x\x91\x90ad(V[a;\x82\x91\x90ad(V[a;\x8C\x91\x90ad(V[a;\x96\x91\x90ad(V[a;\xA0\x91\x90ad(V[a;\xAA\x91\x90ad(V[a;\xB4\x91\x90ad(V[\x90P_a;\xC1\x86\x83aB\xE8V[\x90Pa;\xD1`\r\x87\x87\x87_aCNV[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xFA]\xEF\xDB\x82\x86\x89\x89\x88`@Q\x86c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a<(\x95\x94\x93\x92\x91\x90ad\xB0V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a<?W_\x80\xFD[PZ\xF1\x15\x80\x15a<QW=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7Fi`\xC1\xE8\x8Fa\xC3R\xDB\xA3M\x1B\xBFgS\xE3\x02yRd\xD5\xD8\xAE\x82\xF7\x98<p\x04e\x1E]\x87\x87\x87\x87`@Qa<\xA1\x94\x93\x92\x91\x90ae\x01V[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_\x80`\x08`S\x81\x11\x15a<\xC8Wa<\xC7ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x06`S\x81\x11\x15a<\xE3Wa<\xE2ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a<\xFEWa<\xFDac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a=\x19Wa=\x18ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a=4Wa=3ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a=OWa=Nac\xCEV[[`\xFF\x16`\x01\x90\x1B_`S\x81\x11\x15a=iWa=hac\xCEV[[`\xFF\x16`\x01\x90\x1Ba=z\x91\x90ad(V[a=\x84\x91\x90ad(V[a=\x8E\x91\x90ad(V[a=\x98\x91\x90ad(V[a=\xA2\x91\x90ad(V[a=\xAC\x91\x90ad(V[\x90P_a=\xB9\x86\x83aB\xE8V[\x90Pa=\xC9`\x05\x87\x87\x87\x85aCNV[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x18V\xD9\x1D\x82\x86\x89\x89\x88`@Q\x86c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a> \x95\x94\x93\x92\x91\x90ad\xB0V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a>7W_\x80\xFD[PZ\xF1\x15\x80\x15a>IW=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xE4$\x86\xB0\xCC\xDB\xEF\x81\xA2\x07\\H\xC8\xE5\x15\xC0y\xAE\xA7<\x8B\x82B\x99\x97\xC7*/\xE1\xBFO\xEF\x87\x87\x87\x87`@Qa>\x99\x94\x93\x92\x91\x90ae\x01V[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_s#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9\x90P\x90V[_\x80`\x08`S\x81\x11\x15a>\xDBWa>\xDAac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x06`S\x81\x11\x15a>\xF6Wa>\xF5ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a?\x11Wa?\x10ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a?,Wa?+ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a?GWa?Fac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a?bWa?aac\xCEV[[`\xFF\x16`\x01\x90\x1B_`S\x81\x11\x15a?|Wa?{ac\xCEV[[`\xFF\x16`\x01\x90\x1Ba?\x8D\x91\x90ad(V[a?\x97\x91\x90ad(V[a?\xA1\x91\x90ad(V[a?\xAB\x91\x90ad(V[a?\xB5\x91\x90ad(V[a?\xBF\x91\x90ad(V[\x90P_a?\xCC\x84\x83aB\xE8V[\x90Pa?\xD9`\x15\x85aS\x14V[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xFC\x06<b\x82\x86\x86`@Q\x84c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a@,\x93\x92\x91\x90aj\tV[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a@CW_\x80\xFD[PZ\xF1\x15\x80\x15a@UW=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7FU\xAF\xF4\xCCz=\x16\x0C\x83\xF1\xF1[\x81\x80\x11\xED\xE8A\xA0\xB4Y\x7F\xB1M\xCD6\x03\xDF:\x11\xE5\xE0\x85\x85`@Qa@\xA1\x92\x91\x90al\x88V[`@Q\x80\x91\x03\x90\xA2PP\x91\x90PV[_sP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]\x90P\x90V[_\x80`\x08`S\x81\x11\x15a@\xE1Wa@\xE0ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x07`S\x81\x11\x15a@\xFCWa@\xFBac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x06`S\x81\x11\x15aA\x17WaA\x16ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15aA2WaA1ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15aAMWaALac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15aAhWaAgac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15aA\x83WaA\x82ac\xCEV[[`\xFF\x16`\x01\x90\x1B_`S\x81\x11\x15aA\x9DWaA\x9Cac\xCEV[[`\xFF\x16`\x01\x90\x1BaA\xAE\x91\x90ad(V[aA\xB8\x91\x90ad(V[aA\xC2\x91\x90ad(V[aA\xCC\x91\x90ad(V[aA\xD6\x91\x90ad(V[aA\xE0\x91\x90ad(V[aA\xEA\x91\x90ad(V[\x90P_aA\xF7\x86\x83aB\xE8V[\x90PaB\x07`\x0C\x87\x87\x87_aCNV[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x94\xE7\x0EO\x82\x86\x89\x89\x88`@Q\x86c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01aB^\x95\x94\x93\x92\x91\x90ad\xB0V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15aBuW_\x80\xFD[PZ\xF1\x15\x80\x15aB\x87W=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xB3\xD5\xC6d\xEC\x86WX\x18\xE8\xD7_\xF2\\_\x86rP\xDF\x89T\x08\x85I\xC4\x1C\x84\x8C\xD1\x0Ev\xCB\x87\x87\x87\x87`@QaB\xD7\x94\x93\x92\x91\x90ae\x01V[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_aB\xF2\x83aFvV[\x90P_\x82\x82`S\x81\x11\x15aC\tWaC\x08ac\xCEV[[`\xFF\x16`\x01\x90\x1B\x16\x03aCHW`@Q\x7F\xC6\xDEFj\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x92\x91PPV[_aCX\x83aWMV[sP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x82\x02{m\x863`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01aC\xA7\x92\x91\x90afMV[` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15aC\xC2W=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90aC\xE6\x91\x90ah-V[aD)W\x843`@Q\x7F\x9D\xE39,\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aD \x92\x91\x90afMV[`@Q\x80\x91\x03\x90\xFD[_`\xF8\x1B\x83~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x03aE\x9EWsP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x82\x02{m\x853`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01aD\xA4\x92\x91\x90afMV[` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15aD\xBFW=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90aD\xE3\x91\x90ah-V[aE&W\x833`@Q\x7F\x9D\xE39,\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aE\x1D\x92\x91\x90afMV[`@Q\x80\x91\x03\x90\xFD[_aE0\x85aFvV[\x90P_aE<\x87aFvV[\x90P\x81`S\x81\x11\x15aEQWaEPac\xCEV[[\x81`S\x81\x11\x15aEdWaEcac\xCEV[[\x14aE\x9BW`@Q\x7F\x1F1X\xC7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[PP[\x85\x85\x85\x85sP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]F`@Q` \x01aE\xCD\x96\x95\x94\x93\x92\x91\x90am\x04V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x90PaE\xEF\x81\x83aGxV[\x90PsP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c>9\\\xEC\x823`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01aF@\x92\x91\x90afMV[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15aFWW_\x80\xFD[PZ\xF1\x15\x80\x15aFiW=_\x80>=_\xFD[PPPP\x95\x94PPPPPV[_\x81`\x1E` \x81\x10aF\x8BWaF\x8AamsV[[\x1A`\xF8\x1B`\xF8\x1C`\xFF\x16`S\x81\x11\x15aF\xA7WaF\xA6ac\xCEV[[\x90P\x91\x90PV[``_`\x01aF\xBC\x84aW\x91V[\x01\x90P_\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15aF\xDAWaF\xD9a_bV[[`@Q\x90\x80\x82R\x80`\x1F\x01`\x1F\x19\x16` \x01\x82\x01`@R\x80\x15aG\x0CW\x81` \x01`\x01\x82\x02\x806\x837\x80\x82\x01\x91PP\x90P[P\x90P_\x82` \x01\x82\x01\x90P[`\x01\x15aGmW\x80\x80`\x01\x90\x03\x91PP\x7F0123456789abcdef\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\n\x86\x06\x1A\x81S`\n\x85\x81aGbWaGaam\xA0V[[\x04\x94P_\x85\x03aG\x19W[\x81\x93PPPP\x91\x90PV[_\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0_\x1B\x83\x16\x90P`P`\xFF_\x1B\x90\x1B\x81\x17\x90P`\x10Fg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16_\x1B\x90\x1B\x81\x17\x90P`\x08\x82`S\x81\x11\x15aG\xD6WaG\xD5ac\xCEV[[`\xFF\x16_\x1B\x90\x1B\x81\x17\x90P_`\xFF\x16_\x1B\x81\x17\x90P\x92\x91PPV[_aG\xFAaH\x15V[_\x01_\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P\x90V[_\x7F\xF0\xC5~\x16\x84\r\xF0@\xF1P\x88\xDC/\x81\xFE9\x1C9#\xBE\xC7>#\xA9f.\xFC\x9C\"\x9Cj\0\x90P\x90V[_\x80aHFaX\xE2V[\x90P\x80_\x01TsP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]F`\x01CaHo\x91\x90am\xCDV[@B`@Q` \x01aH\x85\x95\x94\x93\x92\x91\x90an\0V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x91P\x80_\x01_\x81T\x80\x92\x91\x90aH\xB0\x90an^V[\x91\x90PUPP\x90V[_\x80`\x08`S\x81\x11\x15aH\xCFWaH\xCEac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x06`S\x81\x11\x15aH\xEAWaH\xE9ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15aI\x05WaI\x04ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15aI WaI\x1Fac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15aI;WaI:ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15aIVWaIUac\xCEV[[`\xFF\x16`\x01\x90\x1BaIg\x91\x90ad(V[aIq\x91\x90ad(V[aI{\x91\x90ad(V[aI\x85\x91\x90ad(V[aI\x8F\x91\x90ad(V[\x90P_\x81\x85`S\x81\x11\x15aI\xA6WaI\xA5ac\xCEV[[`\xFF\x16`\x01\x90\x1B\x16\x03aI\xE5W`@Q\x7F\xC6\xDEFj\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[aI\xEE\x85aY\tV[aJ$W`@Q\x7F$\xE8\xE7B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[aJ.\x85\x85aY-V[`\x1B\x85\x85\x85`@Q` \x01aJF\x94\x93\x92\x91\x90an\xC5V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x91PaJh\x82\x85aGxV[\x91Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xCC\x86g\x82\x85\x84`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01aJ\xB9\x92\x91\x90al,V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15aJ\xD0W_\x80\xFD[PZ\xF1\x15\x80\x15aJ\xE2W=_\x80>=_\xFD[PPPPsP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c>9\\\xEC\x833`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01aK5\x92\x91\x90afMV[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15aKLW_\x80\xFD[PZ\xF1\x15\x80\x15aK^W=_\x80>=_\xFD[PPPPP\x93\x92PPPV[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x160s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14\x80aL\x17WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16aK\xFEaZ}V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14\x15[\x15aLNW`@Q\x7F\xE0|\x8D\xBA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[V[sP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x8D\xA5\xCB[`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15aL\xADW=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90aL\xD1\x91\x90ao&V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14aM@W3`@Q\x7F!\xBF\xDA\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aM7\x91\x90ac_V[`@Q\x80\x91\x03\x90\xFD[PV[\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16cR\xD1\x90-`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x92PPP\x80\x15aM\xABWP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90aM\xA8\x91\x90af\"V[`\x01[aM\xECW\x81`@Q\x7FL\x9C\x8C\xE3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aM\xE3\x91\x90ac_V[`@Q\x80\x91\x03\x90\xFD[\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC_\x1B\x81\x14aNRW\x80`@Q\x7F\xAA\x1DI\xA4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aNI\x91\x90a^\xD7V[`@Q\x80\x91\x03\x90\xFD[aN\\\x83\x83aZ\xD0V[PPPV[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x160s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14aN\xE6W`@Q\x7F\xE0|\x8D\xBA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[V[_sP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x82\x02{m\x853`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01aO8\x92\x91\x90afMV[` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15aOSW=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90aOw\x91\x90ah-V[aO\xBAW\x833`@Q\x7F\x9D\xE39,\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aO\xB1\x92\x91\x90afMV[`@Q\x80\x91\x03\x90\xFD[sP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x82\x02{m\x843`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01aP\t\x92\x91\x90afMV[` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15aP$W=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90aPH\x91\x90ah-V[aP\x8BW\x823`@Q\x7F\x9D\xE39,\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aP\x82\x92\x91\x90afMV[`@Q\x80\x91\x03\x90\xFD[sP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x82\x02{m\x833`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01aP\xDA\x92\x91\x90afMV[` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15aP\xF5W=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90aQ\x19\x91\x90ah-V[aQ\\W\x813`@Q\x7F\x9D\xE39,\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aQS\x92\x91\x90afMV[`@Q\x80\x91\x03\x90\xFD[_aQf\x85aFvV[\x90P_aQr\x85aFvV[\x90P_aQ~\x85aFvV[\x90P_`S\x81\x11\x15aQ\x93WaQ\x92ac\xCEV[[\x83`S\x81\x11\x15aQ\xA6WaQ\xA5ac\xCEV[[\x14aQ\xDDW`@Q\x7F\xC6\xDEFj\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x80`S\x81\x11\x15aQ\xF0WaQ\xEFac\xCEV[[\x82`S\x81\x11\x15aR\x03WaR\x02ac\xCEV[[\x14aR:W`@Q\x7F\x1F1X\xC7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x87\x87\x87\x87sP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]F`@Q` \x01aRi\x96\x95\x94\x93\x92\x91\x90aoQV[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x93PaR\x8B\x84\x83aGxV[\x93PsP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c>9\\\xEC\x853`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01aR\xDC\x92\x91\x90afMV[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15aR\xF3W_\x80\xFD[PZ\xF1\x15\x80\x15aS\x05W=_\x80>=_\xFD[PPPPPPP\x94\x93PPPPV[_sP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x82\x02{m\x833`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01aSd\x92\x91\x90afMV[` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15aS\x7FW=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90aS\xA3\x91\x90ah-V[aS\xE6W\x813`@Q\x7F\x9D\xE39,\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aS\xDD\x92\x91\x90afMV[`@Q\x80\x91\x03\x90\xFD[\x82\x82sP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]F`@Q` \x01aT\x11\x94\x93\x92\x91\x90ao\xC0V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x90P_aT3\x83aFvV[\x90PaT?\x82\x82aGxV[\x91PsP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c>9\\\xEC\x833`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01aT\x90\x92\x91\x90afMV[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15aT\xA7W_\x80\xFD[PZ\xF1\x15\x80\x15aT\xB9W=_\x80>=_\xFD[PPPPP\x92\x91PPV[_\x80`\x08`S\x81\x11\x15aT\xDAWaT\xD9ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x06`S\x81\x11\x15aT\xF5WaT\xF4ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15aU\x10WaU\x0Fac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15aU+WaU*ac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15aUFWaUEac\xCEV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15aUaWaU`ac\xCEV[[`\xFF\x16`\x01\x90\x1B_`S\x81\x11\x15aU{WaUzac\xCEV[[`\xFF\x16`\x01\x90\x1BaU\x8C\x91\x90ad(V[aU\x96\x91\x90ad(V[aU\xA0\x91\x90ad(V[aU\xAA\x91\x90ad(V[aU\xB4\x91\x90ad(V[aU\xBE\x91\x90ad(V[\x90P_\x81\x85`S\x81\x11\x15aU\xD5WaU\xD4ac\xCEV[[`\xFF\x16`\x01\x90\x1B\x16\x03aV\x14W`@Q\x7F\xC6\xDEFj\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x1A\x84\x84`@Q` \x01aV*\x93\x92\x91\x90ap\rV[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x91PaVL\x82\x85aGxV[\x91Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\t\xB0N\x8F\x85\x84`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01aV\x9D\x92\x91\x90al,V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15aV\xB4W_\x80\xFD[PZ\xF1\x15\x80\x15aV\xC6W=_\x80>=_\xFD[PPPPsP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c>9\\\xEC\x833`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01aW\x19\x92\x91\x90afMV[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15aW0W_\x80\xFD[PZ\xF1\x15\x80\x15aWBW=_\x80>=_\xFD[PPPPP\x92\x91PPV[`\x01\x81`\xF8\x1C`\xFF\x16\x11\x15aW\x8EW`@Q\x7F\xDF{\xF3%\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[PV[_\x80_\x90Pz\x18O\x03\xE9?\xF9\xF4\xDA\xA7\x97\xEDn8\xEDd\xBFj\x1F\x01\0\0\0\0\0\0\0\0\x83\x10aW\xEDWz\x18O\x03\xE9?\xF9\xF4\xDA\xA7\x97\xEDn8\xEDd\xBFj\x1F\x01\0\0\0\0\0\0\0\0\x83\x81aW\xE3WaW\xE2am\xA0V[[\x04\x92P`@\x81\x01\x90P[m\x04\xEE-mA[\x85\xAC\xEF\x81\0\0\0\0\x83\x10aX*Wm\x04\xEE-mA[\x85\xAC\xEF\x81\0\0\0\0\x83\x81aX WaX\x1Fam\xA0V[[\x04\x92P` \x81\x01\x90P[f#\x86\xF2o\xC1\0\0\x83\x10aXYWf#\x86\xF2o\xC1\0\0\x83\x81aXOWaXNam\xA0V[[\x04\x92P`\x10\x81\x01\x90P[c\x05\xF5\xE1\0\x83\x10aX\x82Wc\x05\xF5\xE1\0\x83\x81aXxWaXwam\xA0V[[\x04\x92P`\x08\x81\x01\x90P[a'\x10\x83\x10aX\xA7Wa'\x10\x83\x81aX\x9DWaX\x9Cam\xA0V[[\x04\x92P`\x04\x81\x01\x90P[`d\x83\x10aX\xCAW`d\x83\x81aX\xC0WaX\xBFam\xA0V[[\x04\x92P`\x02\x81\x01\x90P[`\n\x83\x10aX\xD9W`\x01\x81\x01\x90P[\x80\x91PP\x91\x90PV[_\x7FF\x13\xE1w\x1Fku]$>So\xB5\xA2<[\x15\xE2\x82eu\xFE\xE9!\xE8\xFEz\"\xA7`\xC8\0\x90P\x90V[_\x80\x82\x11\x80\x15aY&WP_`\x01\x83aY\"\x91\x90am\xCDV[\x83\x16\x14[\x90P\x91\x90PV[`\x02`S\x81\x11\x15aYAWaY@ac\xCEV[[\x81`S\x81\x11\x15aYTWaYSac\xCEV[[\x03aYjWaYe\x82a\x01\0a[BV[aZyV[`\x03`S\x81\x11\x15aY~WaY}ac\xCEV[[\x81`S\x81\x11\x15aY\x91WaY\x90ac\xCEV[[\x03aY\xA8WaY\xA3\x82b\x01\0\0a[BV[aZyV[`\x04`S\x81\x11\x15aY\xBCWaY\xBBac\xCEV[[\x81`S\x81\x11\x15aY\xCFWaY\xCEac\xCEV[[\x03aY\xE8WaY\xE3\x82d\x01\0\0\0\0a[BV[aZyV[`\x05`S\x81\x11\x15aY\xFCWaY\xFBac\xCEV[[\x81`S\x81\x11\x15aZ\x0FWaZ\x0Eac\xCEV[[\x03aZ,WaZ'\x82h\x01\0\0\0\0\0\0\0\0a[BV[aZyV[`\x06`S\x81\x11\x15aZ@WaZ?ac\xCEV[[\x81`S\x81\x11\x15aZSWaZRac\xCEV[[\x03aZxWaZs\x82p\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a[BV[aZyV[[PPV[_aZ\xA9\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC_\x1Ba[\x80V[_\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P\x90V[aZ\xD9\x82a[\x89V[\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xBC|\xD7Z \xEE'\xFD\x9A\xDE\xBA\xB3 A\xF7U!M\xBCk\xFF\xA9\x0C\xC0\"[9\xDA.\\-;`@Q`@Q\x80\x91\x03\x90\xA2_\x81Q\x11\x15a[5Wa[/\x82\x82a\\RV[Pa[>V[a[=a\\\xD2V[[PPV[\x80\x82\x11\x15a[|W`@Q\x7F\xC7\xDA\xDFE\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[PPV[_\x81\x90P\x91\x90PV[_\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16;\x03a[\xE4W\x80`@Q\x7FL\x9C\x8C\xE3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a[\xDB\x91\x90ac_V[`@Q\x80\x91\x03\x90\xFD[\x80a\\\x10\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC_\x1Ba[\x80V[_\x01_a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UPPV[``_\x80\x84s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x84`@Qa\\{\x91\x90ap\x83V[_`@Q\x80\x83\x03\x81\x85Z\xF4\x91PP=\x80_\x81\x14a\\\xB3W`@Q\x91P`\x1F\x19`?=\x01\x16\x82\x01`@R=\x82R=_` \x84\x01>a\\\xB8V[``\x91P[P\x91P\x91Pa\\\xC8\x85\x83\x83a]\x0EV[\x92PPP\x92\x91PPV[_4\x11\x15a]\x0CW`@Q\x7F\xB3\x98\x97\x9F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[V[``\x82a]#Wa]\x1E\x82a]\x9BV[a]\x93V[_\x82Q\x14\x80\x15a]IWP_\x84s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16;\x14[\x15a]\x8BW\x83`@Q\x7F\x99\x96\xB3\x15\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a]\x82\x91\x90ac_V[`@Q\x80\x91\x03\x90\xFD[\x81\x90Pa]\x94V[[\x93\x92PPPV[_\x81Q\x11\x15a]\xADW\x80Q\x80\x82` \x01\xFD[`@Q\x7F\xD6\xBD\xA2u\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`@Q\x90P\x90V[_\x80\xFD[_\x80\xFD[_\x81\x90P\x91\x90PV[a^\x02\x81a]\xF0V[\x81\x14a^\x0CW_\x80\xFD[PV[_\x815\x90Pa^\x1D\x81a]\xF9V[\x92\x91PPV[_\x7F\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\x16\x90P\x91\x90PV[a^W\x81a^#V[\x81\x14a^aW_\x80\xFD[PV[_\x815\x90Pa^r\x81a^NV[\x92\x91PPV[_\x80_``\x84\x86\x03\x12\x15a^\x8FWa^\x8Ea]\xE8V[[_a^\x9C\x86\x82\x87\x01a^\x0FV[\x93PP` a^\xAD\x86\x82\x87\x01a^\x0FV[\x92PP`@a^\xBE\x86\x82\x87\x01a^dV[\x91PP\x92P\x92P\x92V[a^\xD1\x81a]\xF0V[\x82RPPV[_` \x82\x01\x90Pa^\xEA_\x83\x01\x84a^\xC8V[\x92\x91PPV[_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[_a_\x19\x82a^\xF0V[\x90P\x91\x90PV[a_)\x81a_\x0FV[\x81\x14a_3W_\x80\xFD[PV[_\x815\x90Pa_D\x81a_ V[\x92\x91PPV[_\x80\xFD[_\x80\xFD[_`\x1F\x19`\x1F\x83\x01\x16\x90P\x91\x90PV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`A`\x04R`$_\xFD[a_\x98\x82a_RV[\x81\x01\x81\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17\x15a_\xB7Wa_\xB6a_bV[[\x80`@RPPPV[_a_\xC9a]\xDFV[\x90Pa_\xD5\x82\x82a_\x8FV[\x91\x90PV[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15a_\xF4Wa_\xF3a_bV[[a_\xFD\x82a_RV[\x90P` \x81\x01\x90P\x91\x90PV[\x82\x81\x837_\x83\x83\x01RPPPV[_a`*a`%\x84a_\xDAV[a_\xC0V[\x90P\x82\x81R` \x81\x01\x84\x84\x84\x01\x11\x15a`FWa`Ea_NV[[a`Q\x84\x82\x85a`\nV[P\x93\x92PPPV[_\x82`\x1F\x83\x01\x12a`mWa`la_JV[[\x815a`}\x84\x82` \x86\x01a`\x18V[\x91PP\x92\x91PPV[`T\x81\x10a`\x92W_\x80\xFD[PV[_\x815\x90Pa`\xA3\x81a`\x86V[\x92\x91PPV[_\x80_\x80`\x80\x85\x87\x03\x12\x15a`\xC1Wa`\xC0a]\xE8V[[_a`\xCE\x87\x82\x88\x01a^\x0FV[\x94PP` a`\xDF\x87\x82\x88\x01a_6V[\x93PP`@\x85\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15aa\0Wa`\xFFa]\xECV[[aa\x0C\x87\x82\x88\x01a`YV[\x92PP``aa\x1D\x87\x82\x88\x01a`\x95V[\x91PP\x92\x95\x91\x94P\x92PV[_\x81Q\x90P\x91\x90PV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[_[\x83\x81\x10\x15aa`W\x80\x82\x01Q\x81\x84\x01R` \x81\x01\x90PaaEV[_\x84\x84\x01RPPPPV[_aau\x82aa)V[aa\x7F\x81\x85aa3V[\x93Paa\x8F\x81\x85` \x86\x01aaCV[aa\x98\x81a_RV[\x84\x01\x91PP\x92\x91PPV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Raa\xBB\x81\x84aakV[\x90P\x92\x91PPV[_\x80`@\x83\x85\x03\x12\x15aa\xD9Waa\xD8a]\xE8V[[_aa\xE6\x85\x82\x86\x01a^\x0FV[\x92PP` aa\xF7\x85\x82\x86\x01a`\x95V[\x91PP\x92P\x92\x90PV[_\x81\x90P\x91\x90PV[ab\x13\x81ab\x01V[\x81\x14ab\x1DW_\x80\xFD[PV[_\x815\x90Pab.\x81ab\nV[\x92\x91PPV[_\x80`@\x83\x85\x03\x12\x15abJWabIa]\xE8V[[_abW\x85\x82\x86\x01ab V[\x92PP` abh\x85\x82\x86\x01a`\x95V[\x91PP\x92P\x92\x90PV[_\x80`@\x83\x85\x03\x12\x15ab\x88Wab\x87a]\xE8V[[_ab\x95\x85\x82\x86\x01a_6V[\x92PP` \x83\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15ab\xB6Wab\xB5a]\xECV[[ab\xC2\x85\x82\x86\x01a`YV[\x91PP\x92P\x92\x90PV[_\x80_``\x84\x86\x03\x12\x15ab\xE3Wab\xE2a]\xE8V[[_ab\xF0\x86\x82\x87\x01a^\x0FV[\x93PP` ac\x01\x86\x82\x87\x01a^\x0FV[\x92PP`@ac\x12\x86\x82\x87\x01a^\x0FV[\x91PP\x92P\x92P\x92V[_`\xFF\x82\x16\x90P\x91\x90PV[ac1\x81ac\x1CV[\x82RPPV[_` \x82\x01\x90PacJ_\x83\x01\x84ac(V[\x92\x91PPV[acY\x81a_\x0FV[\x82RPPV[_` \x82\x01\x90Pacr_\x83\x01\x84acPV[\x92\x91PPV[_` \x82\x84\x03\x12\x15ac\x8DWac\x8Ca]\xE8V[[_ac\x9A\x84\x82\x85\x01a^\x0FV[\x91PP\x92\x91PPV[_` \x82\x84\x03\x12\x15ac\xB8Wac\xB7a]\xE8V[[_ac\xC5\x84\x82\x85\x01a`\x95V[\x91PP\x92\x91PPV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`!`\x04R`$_\xFD[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x11`\x04R`$_\xFD[_ad2\x82ab\x01V[\x91Pad=\x83ab\x01V[\x92P\x82\x82\x01\x90P\x80\x82\x11\x15adUWadTac\xFBV[[\x92\x91PPV[`T\x81\x10adlWadkac\xCEV[[PV[_\x81\x90Pad|\x82ad[V[\x91\x90PV[_ad\x8B\x82adoV[\x90P\x91\x90PV[ad\x9B\x81ad\x81V[\x82RPPV[ad\xAA\x81a^#V[\x82RPPV[_`\xA0\x82\x01\x90Pad\xC3_\x83\x01\x88ad\x92V[ad\xD0` \x83\x01\x87ad\xA1V[ad\xDD`@\x83\x01\x86a^\xC8V[ad\xEA``\x83\x01\x85a^\xC8V[ad\xF7`\x80\x83\x01\x84a^\xC8V[\x96\x95PPPPPPV[_`\x80\x82\x01\x90Pae\x14_\x83\x01\x87a^\xC8V[ae!` \x83\x01\x86a^\xC8V[ae.`@\x83\x01\x85ad\xA1V[ae;``\x83\x01\x84a^\xC8V[\x95\x94PPPPPV[aeM\x81a_\x0FV[\x82RPPV[`@\x82\x01_\x82\x01Qaeg_\x85\x01\x82aeDV[P` \x82\x01Qaez` \x85\x01\x82aeDV[PPPPV[_\x81Q\x90P\x91\x90PV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[_ae\xA4\x82ae\x80V[ae\xAE\x81\x85ae\x8AV[\x93Pae\xBE\x81\x85` \x86\x01aaCV[ae\xC7\x81a_RV[\x84\x01\x91PP\x92\x91PPV[_`\x80\x82\x01\x90Pae\xE5_\x83\x01\x86aeSV[ae\xF2`@\x83\x01\x85a^\xC8V[\x81\x81\x03``\x83\x01Raf\x04\x81\x84ae\x9AV[\x90P\x94\x93PPPPV[_\x81Q\x90Paf\x1C\x81a]\xF9V[\x92\x91PPV[_` \x82\x84\x03\x12\x15af7Waf6a]\xE8V[[_afD\x84\x82\x85\x01af\x0EV[\x91PP\x92\x91PPV[_`@\x82\x01\x90Paf`_\x83\x01\x85a^\xC8V[afm` \x83\x01\x84acPV[\x93\x92PPPV[_`\xA0\x82\x01\x90Paf\x87_\x83\x01\x88a^\xC8V[af\x94` \x83\x01\x87acPV[\x81\x81\x03`@\x83\x01Raf\xA6\x81\x86ae\x9AV[\x90Paf\xB5``\x83\x01\x85ad\x92V[af\xC2`\x80\x83\x01\x84a^\xC8V[\x96\x95PPPPPPV[_\x81\x90P\x92\x91PPV[_af\xE0\x82aa)V[af\xEA\x81\x85af\xCCV[\x93Paf\xFA\x81\x85` \x86\x01aaCV[\x80\x84\x01\x91PP\x92\x91PPV[\x7F v\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_ag:`\x02\x83af\xCCV[\x91PagE\x82ag\x06V[`\x02\x82\x01\x90P\x91\x90PV[\x7F.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_ag\x84`\x01\x83af\xCCV[\x91Pag\x8F\x82agPV[`\x01\x82\x01\x90P\x91\x90PV[_ag\xA5\x82\x87af\xD6V[\x91Pag\xB0\x82ag.V[\x91Pag\xBC\x82\x86af\xD6V[\x91Pag\xC7\x82agxV[\x91Pag\xD3\x82\x85af\xD6V[\x91Pag\xDE\x82agxV[\x91Pag\xEA\x82\x84af\xD6V[\x91P\x81\x90P\x95\x94PPPPPV[_\x81\x15\x15\x90P\x91\x90PV[ah\x0C\x81ag\xF8V[\x81\x14ah\x16W_\x80\xFD[PV[_\x81Q\x90Pah'\x81ah\x03V[\x92\x91PPV[_` \x82\x84\x03\x12\x15ahBWahAa]\xE8V[[_ahO\x84\x82\x85\x01ah\x19V[\x91PP\x92\x91PPV[`\x1C\x81\x10ahiWahhac\xCEV[[PV[_\x81\x90Pahy\x82ahXV[\x91\x90PV[_ah\x88\x82ahlV[\x90P\x91\x90PV[_\x81`\xF8\x1B\x90P\x91\x90PV[_ah\xA5\x82ah\x8FV[\x90P\x91\x90PV[ah\xBDah\xB8\x82ah~V[ah\x9BV[\x82RPPV[_\x81\x90P\x91\x90PV[ah\xDDah\xD8\x82a]\xF0V[ah\xC3V[\x82RPPV[ah\xF4ah\xEF\x82ad\x81V[ah\x9BV[\x82RPPV[_\x81\x90P\x91\x90PV[_ai\x1Dai\x18ai\x13\x84a^\xF0V[ah\xFAV[a^\xF0V[\x90P\x91\x90PV[_ai.\x82ai\x03V[\x90P\x91\x90PV[_ai?\x82ai$V[\x90P\x91\x90PV[_\x81``\x1B\x90P\x91\x90PV[_ai\\\x82aiFV[\x90P\x91\x90PV[_aim\x82aiRV[\x90P\x91\x90PV[ai\x85ai\x80\x82ai5V[aicV[\x82RPPV[_\x81\x90P\x91\x90PV[ai\xA5ai\xA0\x82ab\x01V[ai\x8BV[\x82RPPV[_ai\xB6\x82\x88ah\xACV[`\x01\x82\x01\x91Pai\xC6\x82\x87ah\xCCV[` \x82\x01\x91Pai\xD6\x82\x86ah\xE3V[`\x01\x82\x01\x91Pai\xE6\x82\x85aitV[`\x14\x82\x01\x91Pai\xF6\x82\x84ai\x94V[` \x82\x01\x91P\x81\x90P\x96\x95PPPPPPV[_``\x82\x01\x90Paj\x1C_\x83\x01\x86ad\x92V[aj)` \x83\x01\x85a^\xC8V[aj6`@\x83\x01\x84a^\xC8V[\x94\x93PPPPV[_``\x82\x01\x90PajQ_\x83\x01\x86a^\xC8V[aj^` \x83\x01\x85ad\x92V[ajk`@\x83\x01\x84a^\xC8V[\x94\x93PPPPV[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[aj\x8F\x81ajsV[\x82RPPV[_` \x82\x01\x90Paj\xA8_\x83\x01\x84aj\x86V[\x92\x91PPV[aj\xB7\x81ab\x01V[\x82RPPV[_\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\x16\x90P\x91\x90PV[aj\xF1\x81aj\xBDV[\x82RPPV[_`\x80\x82\x01\x90Pak\n_\x83\x01\x87aj\xAEV[ak\x17` \x83\x01\x86ad\x92V[ak$`@\x83\x01\x85aj\xE8V[ak1``\x83\x01\x84a^\xC8V[\x95\x94PPPPPV[_`\xA0\x82\x01\x90PakM_\x83\x01\x88ad\x92V[akZ` \x83\x01\x87a^\xC8V[akg`@\x83\x01\x86a^\xC8V[akt``\x83\x01\x85a^\xC8V[ak\x81`\x80\x83\x01\x84a^\xC8V[\x96\x95PPPPPPV[_`\x80\x82\x01\x90Pak\x9E_\x83\x01\x87a^\xC8V[ak\xAB` \x83\x01\x86a^\xC8V[ak\xB8`@\x83\x01\x85a^\xC8V[ak\xC5``\x83\x01\x84a^\xC8V[\x95\x94PPPPPV[_ak\xD9\x82\x88ah\xACV[`\x01\x82\x01\x91Pak\xE9\x82\x87ai\x94V[` \x82\x01\x91Pak\xF9\x82\x86ah\xE3V[`\x01\x82\x01\x91Pal\t\x82\x85aitV[`\x14\x82\x01\x91Pal\x19\x82\x84ai\x94V[` \x82\x01\x91P\x81\x90P\x96\x95PPPPPPV[_`@\x82\x01\x90Pal?_\x83\x01\x85ad\x92V[alL` \x83\x01\x84a^\xC8V[\x93\x92PPPV[_``\x82\x01\x90Palf_\x83\x01\x86aj\xAEV[als` \x83\x01\x85ad\x92V[al\x80`@\x83\x01\x84a^\xC8V[\x94\x93PPPPV[_`@\x82\x01\x90Pal\x9B_\x83\x01\x85a^\xC8V[al\xA8` \x83\x01\x84a^\xC8V[\x93\x92PPPV[_``\x82\x01\x90Pal\xC2_\x83\x01\x86ad\x92V[al\xCF` \x83\x01\x85aj\xE8V[al\xDC`@\x83\x01\x84a^\xC8V[\x94\x93PPPPV[_\x81\x90P\x91\x90PV[al\xFEal\xF9\x82a^#V[al\xE4V[\x82RPPV[_am\x0F\x82\x89ah\xACV[`\x01\x82\x01\x91Pam\x1F\x82\x88ah\xCCV[` \x82\x01\x91Pam/\x82\x87ah\xCCV[` \x82\x01\x91Pam?\x82\x86al\xEDV[`\x01\x82\x01\x91PamO\x82\x85aitV[`\x14\x82\x01\x91Pam_\x82\x84ai\x94V[` \x82\x01\x91P\x81\x90P\x97\x96PPPPPPPV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`2`\x04R`$_\xFD[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x12`\x04R`$_\xFD[_am\xD7\x82ab\x01V[\x91Pam\xE2\x83ab\x01V[\x92P\x82\x82\x03\x90P\x81\x81\x11\x15am\xFAWam\xF9ac\xFBV[[\x92\x91PPV[_an\x0B\x82\x88ai\x94V[` \x82\x01\x91Pan\x1B\x82\x87aitV[`\x14\x82\x01\x91Pan+\x82\x86ai\x94V[` \x82\x01\x91Pan;\x82\x85ah\xCCV[` \x82\x01\x91PanK\x82\x84ai\x94V[` \x82\x01\x91P\x81\x90P\x96\x95PPPPPPV[_anh\x82ab\x01V[\x91P\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x03an\x9AWan\x99ac\xFBV[[`\x01\x82\x01\x90P\x91\x90PV[_\x81\x90P\x91\x90PV[an\xBFan\xBA\x82aj\xBDV[an\xA5V[\x82RPPV[_an\xD0\x82\x87ah\xACV[`\x01\x82\x01\x91Pan\xE0\x82\x86ai\x94V[` \x82\x01\x91Pan\xF0\x82\x85ah\xE3V[`\x01\x82\x01\x91Pao\0\x82\x84an\xAEV[`\x10\x82\x01\x91P\x81\x90P\x95\x94PPPPPV[_\x81Q\x90Pao \x81a_ V[\x92\x91PPV[_` \x82\x84\x03\x12\x15ao;Wao:a]\xE8V[[_aoH\x84\x82\x85\x01ao\x12V[\x91PP\x92\x91PPV[_ao\\\x82\x89ah\xACV[`\x01\x82\x01\x91Paol\x82\x88ah\xCCV[` \x82\x01\x91Pao|\x82\x87ah\xCCV[` \x82\x01\x91Pao\x8C\x82\x86ah\xCCV[` \x82\x01\x91Pao\x9C\x82\x85aitV[`\x14\x82\x01\x91Pao\xAC\x82\x84ai\x94V[` \x82\x01\x91P\x81\x90P\x97\x96PPPPPPPV[_ao\xCB\x82\x87ah\xACV[`\x01\x82\x01\x91Pao\xDB\x82\x86ah\xCCV[` \x82\x01\x91Pao\xEB\x82\x85aitV[`\x14\x82\x01\x91Pao\xFB\x82\x84ai\x94V[` \x82\x01\x91P\x81\x90P\x95\x94PPPPPV[_ap\x18\x82\x86ah\xACV[`\x01\x82\x01\x91Pap(\x82\x85ah\xE3V[`\x01\x82\x01\x91Pap8\x82\x84an\xAEV[`\x10\x82\x01\x91P\x81\x90P\x94\x93PPPPV[_\x81\x90P\x92\x91PPV[_ap]\x82ae\x80V[apg\x81\x85apIV[\x93Papw\x81\x85` \x86\x01aaCV[\x80\x84\x01\x91PP\x92\x91PPV[_ap\x8E\x82\x84apSV[\x91P\x81\x90P\x92\x91PPV",
    );
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct FheType(u8);
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<FheType> for u8 {
            #[inline]
            fn stv_to_tokens(
                &self,
            ) -> <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::Token<'_> {
                alloy_sol_types::private::SolTypeValue::<
                    alloy::sol_types::sol_data::Uint<8>,
                >::stv_to_tokens(self)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::tokenize(self)
                    .0
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(self, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::abi_encoded_size(self)
            }
        }
        #[automatically_derived]
        impl FheType {
            /// The Solidity type name.
            pub const NAME: &'static str = stringify!(@ name);
            /// Convert from the underlying value type.
            #[inline]
            pub const fn from_underlying(value: u8) -> Self {
                Self(value)
            }
            /// Return the underlying value.
            #[inline]
            pub const fn into_underlying(self) -> u8 {
                self.0
            }
            /// Return the single encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode(&self.0)
            }
            /// Return the packed encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode_packed(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode_packed(&self.0)
            }
        }
        #[automatically_derived]
        impl From<u8> for FheType {
            fn from(value: u8) -> Self {
                Self::from_underlying(value)
            }
        }
        #[automatically_derived]
        impl From<FheType> for u8 {
            fn from(value: FheType) -> Self {
                value.into_underlying()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for FheType {
            type RustType = u8;
            type Token<'a> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = Self::NAME;
            const ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                Self::type_check(token).is_ok()
            }
            #[inline]
            fn type_check(token: &Self::Token<'_>) -> alloy_sol_types::Result<()> {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::type_check(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::detokenize(token)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for FheType {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::topic_preimage_length(rust)
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(rust, out)
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic(rust)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `ACLNotAllowed(bytes32,address)` and selector `0x9de3392c`.
```solidity
error ACLNotAllowed(bytes32 handle, address account);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ACLNotAllowed {
        #[allow(missing_docs)]
        pub handle: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::Address,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::Address,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ACLNotAllowed> for UnderlyingRustTuple<'_> {
            fn from(value: ACLNotAllowed) -> Self {
                (value.handle, value.account)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ACLNotAllowed {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    handle: tuple.0,
                    account: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ACLNotAllowed {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ACLNotAllowed(bytes32,address)";
            const SELECTOR: [u8; 4] = [157u8, 227u8, 57u8, 44u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.handle),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `AddressEmptyCode(address)` and selector `0x9996b315`.
```solidity
error AddressEmptyCode(address target);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AddressEmptyCode {
        #[allow(missing_docs)]
        pub target: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AddressEmptyCode> for UnderlyingRustTuple<'_> {
            fn from(value: AddressEmptyCode) -> Self {
                (value.target,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for AddressEmptyCode {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { target: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AddressEmptyCode {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AddressEmptyCode(address)";
            const SELECTOR: [u8; 4] = [153u8, 150u8, 179u8, 21u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.target,
                    ),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `DivisionByZero()` and selector `0x23d359a3`.
```solidity
error DivisionByZero();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DivisionByZero;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<DivisionByZero> for UnderlyingRustTuple<'_> {
            fn from(value: DivisionByZero) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for DivisionByZero {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for DivisionByZero {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "DivisionByZero()";
            const SELECTOR: [u8; 4] = [35u8, 211u8, 89u8, 163u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `ERC1967InvalidImplementation(address)` and selector `0x4c9c8ce3`.
```solidity
error ERC1967InvalidImplementation(address implementation);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC1967InvalidImplementation {
        #[allow(missing_docs)]
        pub implementation: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC1967InvalidImplementation>
        for UnderlyingRustTuple<'_> {
            fn from(value: ERC1967InvalidImplementation) -> Self {
                (value.implementation,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ERC1967InvalidImplementation {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { implementation: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC1967InvalidImplementation {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC1967InvalidImplementation(address)";
            const SELECTOR: [u8; 4] = [76u8, 156u8, 140u8, 227u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.implementation,
                    ),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `ERC1967NonPayable()` and selector `0xb398979f`.
```solidity
error ERC1967NonPayable();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC1967NonPayable;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC1967NonPayable> for UnderlyingRustTuple<'_> {
            fn from(value: ERC1967NonPayable) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ERC1967NonPayable {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC1967NonPayable {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC1967NonPayable()";
            const SELECTOR: [u8; 4] = [179u8, 152u8, 151u8, 159u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `FailedCall()` and selector `0xd6bda275`.
```solidity
error FailedCall();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct FailedCall;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<FailedCall> for UnderlyingRustTuple<'_> {
            fn from(value: FailedCall) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for FailedCall {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for FailedCall {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "FailedCall()";
            const SELECTOR: [u8; 4] = [214u8, 189u8, 162u8, 117u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `IncompatibleTypes()` and selector `0x1f3158c7`.
```solidity
error IncompatibleTypes();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct IncompatibleTypes;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<IncompatibleTypes> for UnderlyingRustTuple<'_> {
            fn from(value: IncompatibleTypes) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for IncompatibleTypes {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for IncompatibleTypes {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "IncompatibleTypes()";
            const SELECTOR: [u8; 4] = [31u8, 49u8, 88u8, 199u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidByteLength(uint8,uint256)` and selector `0xb30c0c57`.
```solidity
error InvalidByteLength(FheType typeOf, uint256 length);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidByteLength {
        #[allow(missing_docs)]
        pub typeOf: <FheType as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub length: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (FheType, alloy::sol_types::sol_data::Uint<256>);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            <FheType as alloy::sol_types::SolType>::RustType,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidByteLength> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidByteLength) -> Self {
                (value.typeOf, value.length)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidByteLength {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    typeOf: tuple.0,
                    length: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidByteLength {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidByteLength(uint8,uint256)";
            const SELECTOR: [u8; 4] = [179u8, 12u8, 12u8, 87u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <FheType as alloy_sol_types::SolType>::tokenize(&self.typeOf),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.length),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidInitialization()` and selector `0xf92ee8a9`.
```solidity
error InvalidInitialization();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidInitialization;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidInitialization> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidInitialization) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidInitialization {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidInitialization {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidInitialization()";
            const SELECTOR: [u8; 4] = [249u8, 46u8, 232u8, 169u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidType()` and selector `0xb9688461`.
```solidity
error InvalidType();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidType;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidType> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidType) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidType {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidType {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidType()";
            const SELECTOR: [u8; 4] = [185u8, 104u8, 132u8, 97u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `IsNotScalar()` and selector `0x4f224e53`.
```solidity
error IsNotScalar();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct IsNotScalar;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<IsNotScalar> for UnderlyingRustTuple<'_> {
            fn from(value: IsNotScalar) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for IsNotScalar {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for IsNotScalar {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "IsNotScalar()";
            const SELECTOR: [u8; 4] = [79u8, 34u8, 78u8, 83u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `NotHostOwner(address)` and selector `0x21bfda10`.
```solidity
error NotHostOwner(address sender);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NotHostOwner {
        #[allow(missing_docs)]
        pub sender: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NotHostOwner> for UnderlyingRustTuple<'_> {
            fn from(value: NotHostOwner) -> Self {
                (value.sender,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NotHostOwner {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { sender: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NotHostOwner {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NotHostOwner(address)";
            const SELECTOR: [u8; 4] = [33u8, 191u8, 218u8, 16u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sender,
                    ),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `NotInitializing()` and selector `0xd7e6bcf8`.
```solidity
error NotInitializing();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NotInitializing;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NotInitializing> for UnderlyingRustTuple<'_> {
            fn from(value: NotInitializing) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NotInitializing {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NotInitializing {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NotInitializing()";
            const SELECTOR: [u8; 4] = [215u8, 230u8, 188u8, 248u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `NotInitializingFromEmptyProxy()` and selector `0x6f4f731f`.
```solidity
error NotInitializingFromEmptyProxy();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NotInitializingFromEmptyProxy;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NotInitializingFromEmptyProxy>
        for UnderlyingRustTuple<'_> {
            fn from(value: NotInitializingFromEmptyProxy) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for NotInitializingFromEmptyProxy {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NotInitializingFromEmptyProxy {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NotInitializingFromEmptyProxy()";
            const SELECTOR: [u8; 4] = [111u8, 79u8, 115u8, 31u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `NotPowerOfTwo()` and selector `0x24e8e742`.
```solidity
error NotPowerOfTwo();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NotPowerOfTwo;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NotPowerOfTwo> for UnderlyingRustTuple<'_> {
            fn from(value: NotPowerOfTwo) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NotPowerOfTwo {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NotPowerOfTwo {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NotPowerOfTwo()";
            const SELECTOR: [u8; 4] = [36u8, 232u8, 231u8, 66u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `ScalarByteIsNotBoolean()` and selector `0xdf7bf325`.
```solidity
error ScalarByteIsNotBoolean();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ScalarByteIsNotBoolean;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ScalarByteIsNotBoolean> for UnderlyingRustTuple<'_> {
            fn from(value: ScalarByteIsNotBoolean) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ScalarByteIsNotBoolean {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ScalarByteIsNotBoolean {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ScalarByteIsNotBoolean()";
            const SELECTOR: [u8; 4] = [223u8, 123u8, 243u8, 37u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `SecondOperandIsNotScalar()` and selector `0x4dde0d98`.
```solidity
error SecondOperandIsNotScalar();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SecondOperandIsNotScalar;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<SecondOperandIsNotScalar>
        for UnderlyingRustTuple<'_> {
            fn from(value: SecondOperandIsNotScalar) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for SecondOperandIsNotScalar {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for SecondOperandIsNotScalar {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "SecondOperandIsNotScalar()";
            const SELECTOR: [u8; 4] = [77u8, 222u8, 13u8, 152u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `UUPSUnauthorizedCallContext()` and selector `0xe07c8dba`.
```solidity
error UUPSUnauthorizedCallContext();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct UUPSUnauthorizedCallContext;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UUPSUnauthorizedCallContext>
        for UnderlyingRustTuple<'_> {
            fn from(value: UUPSUnauthorizedCallContext) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for UUPSUnauthorizedCallContext {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for UUPSUnauthorizedCallContext {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "UUPSUnauthorizedCallContext()";
            const SELECTOR: [u8; 4] = [224u8, 124u8, 141u8, 186u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `UUPSUnsupportedProxiableUUID(bytes32)` and selector `0xaa1d49a4`.
```solidity
error UUPSUnsupportedProxiableUUID(bytes32 slot);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct UUPSUnsupportedProxiableUUID {
        #[allow(missing_docs)]
        pub slot: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UUPSUnsupportedProxiableUUID>
        for UnderlyingRustTuple<'_> {
            fn from(value: UUPSUnsupportedProxiableUUID) -> Self {
                (value.slot,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for UUPSUnsupportedProxiableUUID {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { slot: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for UUPSUnsupportedProxiableUUID {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "UUPSUnsupportedProxiableUUID(bytes32)";
            const SELECTOR: [u8; 4] = [170u8, 29u8, 73u8, 164u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.slot),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `UnsupportedType()` and selector `0xc6de466a`.
```solidity
error UnsupportedType();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct UnsupportedType;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnsupportedType> for UnderlyingRustTuple<'_> {
            fn from(value: UnsupportedType) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for UnsupportedType {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for UnsupportedType {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "UnsupportedType()";
            const SELECTOR: [u8; 4] = [198u8, 222u8, 70u8, 106u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `UpperBoundAboveMaxTypeValue()` and selector `0xc7dadf45`.
```solidity
error UpperBoundAboveMaxTypeValue();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct UpperBoundAboveMaxTypeValue;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UpperBoundAboveMaxTypeValue>
        for UnderlyingRustTuple<'_> {
            fn from(value: UpperBoundAboveMaxTypeValue) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for UpperBoundAboveMaxTypeValue {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for UpperBoundAboveMaxTypeValue {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "UpperBoundAboveMaxTypeValue()";
            const SELECTOR: [u8; 4] = [199u8, 218u8, 223u8, 69u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `Cast(address,bytes32,uint8,bytes32)` and selector `0x31ccae6a2f8e3ced1692f77c8f668133e4afdaaa35afe844ff4659a6c27e627f`.
```solidity
event Cast(address indexed caller, bytes32 ct, FheType toType, bytes32 result);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Cast {
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub ct: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub toType: <FheType as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Cast {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                FheType,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "Cast(address,bytes32,uint8,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                49u8, 204u8, 174u8, 106u8, 47u8, 142u8, 60u8, 237u8, 22u8, 146u8, 247u8,
                124u8, 143u8, 102u8, 129u8, 51u8, 228u8, 175u8, 218u8, 170u8, 53u8,
                175u8, 232u8, 68u8, 255u8, 70u8, 89u8, 166u8, 194u8, 126u8, 98u8, 127u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    caller: topics.1,
                    ct: data.0,
                    toType: data.1,
                    result: data.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.ct),
                    <FheType as alloy_sol_types::SolType>::tokenize(&self.toType),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.caller.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.caller,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Cast {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Cast> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Cast) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `FheAdd(address,bytes32,bytes32,bytes1,bytes32)` and selector `0xdb9050d65240431621d61d6f94b970e63f53a67a5766614ee6e5c5bbd41c8e2e`.
```solidity
event FheAdd(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct FheAdd {
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for FheAdd {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "FheAdd(address,bytes32,bytes32,bytes1,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                219u8, 144u8, 80u8, 214u8, 82u8, 64u8, 67u8, 22u8, 33u8, 214u8, 29u8,
                111u8, 148u8, 185u8, 112u8, 230u8, 63u8, 83u8, 166u8, 122u8, 87u8, 102u8,
                97u8, 78u8, 230u8, 229u8, 197u8, 187u8, 212u8, 28u8, 142u8, 46u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    caller: topics.1,
                    lhs: data.0,
                    rhs: data.1,
                    scalarByte: data.2,
                    result: data.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.caller.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.caller,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for FheAdd {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&FheAdd> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &FheAdd) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `FheBitAnd(address,bytes32,bytes32,bytes1,bytes32)` and selector `0xe42486b0ccdbef81a2075c48c8e515c079aea73c8b82429997c72a2fe1bf4fef`.
```solidity
event FheBitAnd(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct FheBitAnd {
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for FheBitAnd {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "FheBitAnd(address,bytes32,bytes32,bytes1,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                228u8, 36u8, 134u8, 176u8, 204u8, 219u8, 239u8, 129u8, 162u8, 7u8, 92u8,
                72u8, 200u8, 229u8, 21u8, 192u8, 121u8, 174u8, 167u8, 60u8, 139u8, 130u8,
                66u8, 153u8, 151u8, 199u8, 42u8, 47u8, 225u8, 191u8, 79u8, 239u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    caller: topics.1,
                    lhs: data.0,
                    rhs: data.1,
                    scalarByte: data.2,
                    result: data.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.caller.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.caller,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for FheBitAnd {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&FheBitAnd> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &FheBitAnd) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `FheBitOr(address,bytes32,bytes32,bytes1,bytes32)` and selector `0x56df279bbfb03d9ed097bbe2f28d520ca0c1161206327926e98664d70d2c24c4`.
```solidity
event FheBitOr(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct FheBitOr {
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for FheBitOr {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "FheBitOr(address,bytes32,bytes32,bytes1,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                86u8, 223u8, 39u8, 155u8, 191u8, 176u8, 61u8, 158u8, 208u8, 151u8, 187u8,
                226u8, 242u8, 141u8, 82u8, 12u8, 160u8, 193u8, 22u8, 18u8, 6u8, 50u8,
                121u8, 38u8, 233u8, 134u8, 100u8, 215u8, 13u8, 44u8, 36u8, 196u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    caller: topics.1,
                    lhs: data.0,
                    rhs: data.1,
                    scalarByte: data.2,
                    result: data.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.caller.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.caller,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for FheBitOr {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&FheBitOr> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &FheBitOr) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `FheBitXor(address,bytes32,bytes32,bytes1,bytes32)` and selector `0x4d32284bd3193ecaa44e1ceca32f41c5d6c32803a92e07967dd3ee4229721582`.
```solidity
event FheBitXor(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct FheBitXor {
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for FheBitXor {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "FheBitXor(address,bytes32,bytes32,bytes1,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                77u8, 50u8, 40u8, 75u8, 211u8, 25u8, 62u8, 202u8, 164u8, 78u8, 28u8,
                236u8, 163u8, 47u8, 65u8, 197u8, 214u8, 195u8, 40u8, 3u8, 169u8, 46u8,
                7u8, 150u8, 125u8, 211u8, 238u8, 66u8, 41u8, 114u8, 21u8, 130u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    caller: topics.1,
                    lhs: data.0,
                    rhs: data.1,
                    scalarByte: data.2,
                    result: data.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.caller.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.caller,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for FheBitXor {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&FheBitXor> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &FheBitXor) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `FheDiv(address,bytes32,bytes32,bytes1,bytes32)` and selector `0x3bab2ee0e2f90f4690c6a87bf63cf1a6b626086e95f231860b152966e8dabbf7`.
```solidity
event FheDiv(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct FheDiv {
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for FheDiv {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "FheDiv(address,bytes32,bytes32,bytes1,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                59u8, 171u8, 46u8, 224u8, 226u8, 249u8, 15u8, 70u8, 144u8, 198u8, 168u8,
                123u8, 246u8, 60u8, 241u8, 166u8, 182u8, 38u8, 8u8, 110u8, 149u8, 242u8,
                49u8, 134u8, 11u8, 21u8, 41u8, 102u8, 232u8, 218u8, 187u8, 247u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    caller: topics.1,
                    lhs: data.0,
                    rhs: data.1,
                    scalarByte: data.2,
                    result: data.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.caller.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.caller,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for FheDiv {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&FheDiv> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &FheDiv) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `FheEq(address,bytes32,bytes32,bytes1,bytes32)` and selector `0xb3d5c664ec86575818e8d75ff25c5f867250df8954088549c41c848cd10e76cb`.
```solidity
event FheEq(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct FheEq {
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for FheEq {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "FheEq(address,bytes32,bytes32,bytes1,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                179u8, 213u8, 198u8, 100u8, 236u8, 134u8, 87u8, 88u8, 24u8, 232u8, 215u8,
                95u8, 242u8, 92u8, 95u8, 134u8, 114u8, 80u8, 223u8, 137u8, 84u8, 8u8,
                133u8, 73u8, 196u8, 28u8, 132u8, 140u8, 209u8, 14u8, 118u8, 203u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    caller: topics.1,
                    lhs: data.0,
                    rhs: data.1,
                    scalarByte: data.2,
                    result: data.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.caller.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.caller,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for FheEq {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&FheEq> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &FheEq) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `FheGe(address,bytes32,bytes32,bytes1,bytes32)` and selector `0x38c3a63c4230de5b741f494ffb54e3087104030279bc7bccee8ad9ad31712b21`.
```solidity
event FheGe(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct FheGe {
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for FheGe {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "FheGe(address,bytes32,bytes32,bytes1,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                56u8, 195u8, 166u8, 60u8, 66u8, 48u8, 222u8, 91u8, 116u8, 31u8, 73u8,
                79u8, 251u8, 84u8, 227u8, 8u8, 113u8, 4u8, 3u8, 2u8, 121u8, 188u8, 123u8,
                204u8, 238u8, 138u8, 217u8, 173u8, 49u8, 113u8, 43u8, 33u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    caller: topics.1,
                    lhs: data.0,
                    rhs: data.1,
                    scalarByte: data.2,
                    result: data.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.caller.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.caller,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for FheGe {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&FheGe> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &FheGe) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `FheGt(address,bytes32,bytes32,bytes1,bytes32)` and selector `0xc9ff8f0d18a3f766ce5de3de216076050140e4fc2652f5e0e745f6fc836cda8b`.
```solidity
event FheGt(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct FheGt {
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for FheGt {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "FheGt(address,bytes32,bytes32,bytes1,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                201u8, 255u8, 143u8, 13u8, 24u8, 163u8, 247u8, 102u8, 206u8, 93u8, 227u8,
                222u8, 33u8, 96u8, 118u8, 5u8, 1u8, 64u8, 228u8, 252u8, 38u8, 82u8,
                245u8, 224u8, 231u8, 69u8, 246u8, 252u8, 131u8, 108u8, 218u8, 139u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    caller: topics.1,
                    lhs: data.0,
                    rhs: data.1,
                    scalarByte: data.2,
                    result: data.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.caller.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.caller,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for FheGt {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&FheGt> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &FheGt) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `FheIfThenElse(address,bytes32,bytes32,bytes32,bytes32)` and selector `0x60be9d61aad849facc28c38b048cb5c4be3420b8fa2233e08cfa06be1b6d1c3e`.
```solidity
event FheIfThenElse(address indexed caller, bytes32 control, bytes32 ifTrue, bytes32 ifFalse, bytes32 result);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct FheIfThenElse {
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub control: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub ifTrue: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub ifFalse: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for FheIfThenElse {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "FheIfThenElse(address,bytes32,bytes32,bytes32,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                96u8, 190u8, 157u8, 97u8, 170u8, 216u8, 73u8, 250u8, 204u8, 40u8, 195u8,
                139u8, 4u8, 140u8, 181u8, 196u8, 190u8, 52u8, 32u8, 184u8, 250u8, 34u8,
                51u8, 224u8, 140u8, 250u8, 6u8, 190u8, 27u8, 109u8, 28u8, 62u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    caller: topics.1,
                    control: data.0,
                    ifTrue: data.1,
                    ifFalse: data.2,
                    result: data.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.control),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.ifTrue),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.ifFalse),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.caller.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.caller,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for FheIfThenElse {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&FheIfThenElse> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &FheIfThenElse) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `FheLe(address,bytes32,bytes32,bytes1,bytes32)` and selector `0xdef2e704a077284a07f3d0b436db88f5d981b69f58ab7c1ae623252718a6de01`.
```solidity
event FheLe(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct FheLe {
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for FheLe {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "FheLe(address,bytes32,bytes32,bytes1,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                222u8, 242u8, 231u8, 4u8, 160u8, 119u8, 40u8, 74u8, 7u8, 243u8, 208u8,
                180u8, 54u8, 219u8, 136u8, 245u8, 217u8, 129u8, 182u8, 159u8, 88u8,
                171u8, 124u8, 26u8, 230u8, 35u8, 37u8, 39u8, 24u8, 166u8, 222u8, 1u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    caller: topics.1,
                    lhs: data.0,
                    rhs: data.1,
                    scalarByte: data.2,
                    result: data.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.caller.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.caller,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for FheLe {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&FheLe> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &FheLe) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `FheLt(address,bytes32,bytes32,bytes1,bytes32)` and selector `0x0d483b100d8c73b208984ec697caa3091521ee5525ce69edcf97d7e395d3d059`.
```solidity
event FheLt(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct FheLt {
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for FheLt {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "FheLt(address,bytes32,bytes32,bytes1,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                13u8, 72u8, 59u8, 16u8, 13u8, 140u8, 115u8, 178u8, 8u8, 152u8, 78u8,
                198u8, 151u8, 202u8, 163u8, 9u8, 21u8, 33u8, 238u8, 85u8, 37u8, 206u8,
                105u8, 237u8, 207u8, 151u8, 215u8, 227u8, 149u8, 211u8, 208u8, 89u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    caller: topics.1,
                    lhs: data.0,
                    rhs: data.1,
                    scalarByte: data.2,
                    result: data.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.caller.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.caller,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for FheLt {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&FheLt> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &FheLt) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `FheMax(address,bytes32,bytes32,bytes1,bytes32)` and selector `0xfd7c9208f956bf0c6ab76a667f04361245ad3e0a2d0eff92eb827acfcca68ea9`.
```solidity
event FheMax(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct FheMax {
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for FheMax {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "FheMax(address,bytes32,bytes32,bytes1,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                253u8, 124u8, 146u8, 8u8, 249u8, 86u8, 191u8, 12u8, 106u8, 183u8, 106u8,
                102u8, 127u8, 4u8, 54u8, 18u8, 69u8, 173u8, 62u8, 10u8, 45u8, 14u8,
                255u8, 146u8, 235u8, 130u8, 122u8, 207u8, 204u8, 166u8, 142u8, 169u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    caller: topics.1,
                    lhs: data.0,
                    rhs: data.1,
                    scalarByte: data.2,
                    result: data.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.caller.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.caller,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for FheMax {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&FheMax> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &FheMax) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `FheMin(address,bytes32,bytes32,bytes1,bytes32)` and selector `0xc11d62b13c360a83082487064be1ec0878b2f0be4f012bf59f89e128063d47ff`.
```solidity
event FheMin(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct FheMin {
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for FheMin {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "FheMin(address,bytes32,bytes32,bytes1,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                193u8, 29u8, 98u8, 177u8, 60u8, 54u8, 10u8, 131u8, 8u8, 36u8, 135u8, 6u8,
                75u8, 225u8, 236u8, 8u8, 120u8, 178u8, 240u8, 190u8, 79u8, 1u8, 43u8,
                245u8, 159u8, 137u8, 225u8, 40u8, 6u8, 61u8, 71u8, 255u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    caller: topics.1,
                    lhs: data.0,
                    rhs: data.1,
                    scalarByte: data.2,
                    result: data.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.caller.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.caller,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for FheMin {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&FheMin> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &FheMin) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `FheMul(address,bytes32,bytes32,bytes1,bytes32)` and selector `0x215346a4f9f975e6d5484e290bd4e53ca14453a9d282ebd3ccedb2a0f171753d`.
```solidity
event FheMul(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct FheMul {
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for FheMul {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "FheMul(address,bytes32,bytes32,bytes1,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                33u8, 83u8, 70u8, 164u8, 249u8, 249u8, 117u8, 230u8, 213u8, 72u8, 78u8,
                41u8, 11u8, 212u8, 229u8, 60u8, 161u8, 68u8, 83u8, 169u8, 210u8, 130u8,
                235u8, 211u8, 204u8, 237u8, 178u8, 160u8, 241u8, 113u8, 117u8, 61u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    caller: topics.1,
                    lhs: data.0,
                    rhs: data.1,
                    scalarByte: data.2,
                    result: data.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.caller.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.caller,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for FheMul {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&FheMul> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &FheMul) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `FheNe(address,bytes32,bytes32,bytes1,bytes32)` and selector `0x6960c1e88f61c352dba34d1bbf6753e302795264d5d8ae82f7983c7004651e5d`.
```solidity
event FheNe(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct FheNe {
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for FheNe {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "FheNe(address,bytes32,bytes32,bytes1,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                105u8, 96u8, 193u8, 232u8, 143u8, 97u8, 195u8, 82u8, 219u8, 163u8, 77u8,
                27u8, 191u8, 103u8, 83u8, 227u8, 2u8, 121u8, 82u8, 100u8, 213u8, 216u8,
                174u8, 130u8, 247u8, 152u8, 60u8, 112u8, 4u8, 101u8, 30u8, 93u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    caller: topics.1,
                    lhs: data.0,
                    rhs: data.1,
                    scalarByte: data.2,
                    result: data.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.caller.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.caller,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for FheNe {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&FheNe> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &FheNe) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `FheNeg(address,bytes32,bytes32)` and selector `0x8c664d3c3ca583fc5803b8a91c49644bbd9550bfa87967c73ad1de83027768c0`.
```solidity
event FheNeg(address indexed caller, bytes32 ct, bytes32 result);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct FheNeg {
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub ct: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for FheNeg {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "FheNeg(address,bytes32,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                140u8, 102u8, 77u8, 60u8, 60u8, 165u8, 131u8, 252u8, 88u8, 3u8, 184u8,
                169u8, 28u8, 73u8, 100u8, 75u8, 189u8, 149u8, 80u8, 191u8, 168u8, 121u8,
                103u8, 199u8, 58u8, 209u8, 222u8, 131u8, 2u8, 119u8, 104u8, 192u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    caller: topics.1,
                    ct: data.0,
                    result: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.ct),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.caller.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.caller,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for FheNeg {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&FheNeg> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &FheNeg) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `FheNot(address,bytes32,bytes32)` and selector `0x55aff4cc7a3d160c83f1f15b818011ede841a0b4597fb14dcd3603df3a11e5e0`.
```solidity
event FheNot(address indexed caller, bytes32 ct, bytes32 result);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct FheNot {
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub ct: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for FheNot {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "FheNot(address,bytes32,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                85u8, 175u8, 244u8, 204u8, 122u8, 61u8, 22u8, 12u8, 131u8, 241u8, 241u8,
                91u8, 129u8, 128u8, 17u8, 237u8, 232u8, 65u8, 160u8, 180u8, 89u8, 127u8,
                177u8, 77u8, 205u8, 54u8, 3u8, 223u8, 58u8, 17u8, 229u8, 224u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    caller: topics.1,
                    ct: data.0,
                    result: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.ct),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.caller.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.caller,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for FheNot {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&FheNot> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &FheNot) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `FheRand(address,uint8,bytes16,bytes32)` and selector `0x0c8aca6017003326051e19913ef02631f24b801125e1fa8a1d812e868319fda6`.
```solidity
event FheRand(address indexed caller, FheType randType, bytes16 seed, bytes32 result);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct FheRand {
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub randType: <FheType as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub seed: alloy::sol_types::private::FixedBytes<16>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for FheRand {
            type DataTuple<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<16>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "FheRand(address,uint8,bytes16,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                12u8, 138u8, 202u8, 96u8, 23u8, 0u8, 51u8, 38u8, 5u8, 30u8, 25u8, 145u8,
                62u8, 240u8, 38u8, 49u8, 242u8, 75u8, 128u8, 17u8, 37u8, 225u8, 250u8,
                138u8, 29u8, 129u8, 46u8, 134u8, 131u8, 25u8, 253u8, 166u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    caller: topics.1,
                    randType: data.0,
                    seed: data.1,
                    result: data.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <FheType as alloy_sol_types::SolType>::tokenize(&self.randType),
                    <alloy::sol_types::sol_data::FixedBytes<
                        16,
                    > as alloy_sol_types::SolType>::tokenize(&self.seed),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.caller.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.caller,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for FheRand {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&FheRand> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &FheRand) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `FheRandBounded(address,uint256,uint8,bytes16,bytes32)` and selector `0x5222d96b836727a1d6fe1ee9aef27f9bb507bd41794defa376ff6c648aaf8ff1`.
```solidity
event FheRandBounded(address indexed caller, uint256 upperBound, FheType randType, bytes16 seed, bytes32 result);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct FheRandBounded {
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub upperBound: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub randType: <FheType as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub seed: alloy::sol_types::private::FixedBytes<16>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for FheRandBounded {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                FheType,
                alloy::sol_types::sol_data::FixedBytes<16>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "FheRandBounded(address,uint256,uint8,bytes16,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                82u8, 34u8, 217u8, 107u8, 131u8, 103u8, 39u8, 161u8, 214u8, 254u8, 30u8,
                233u8, 174u8, 242u8, 127u8, 155u8, 181u8, 7u8, 189u8, 65u8, 121u8, 77u8,
                239u8, 163u8, 118u8, 255u8, 108u8, 100u8, 138u8, 175u8, 143u8, 241u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    caller: topics.1,
                    upperBound: data.0,
                    randType: data.1,
                    seed: data.2,
                    result: data.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.upperBound),
                    <FheType as alloy_sol_types::SolType>::tokenize(&self.randType),
                    <alloy::sol_types::sol_data::FixedBytes<
                        16,
                    > as alloy_sol_types::SolType>::tokenize(&self.seed),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.caller.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.caller,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for FheRandBounded {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&FheRandBounded> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &FheRandBounded) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `FheRem(address,bytes32,bytes32,bytes1,bytes32)` and selector `0x0e691cd0bf8c4e9308e4ced1bb9c964117dc5c5bb9b9ab5bdfebf2c9b13a897c`.
```solidity
event FheRem(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct FheRem {
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for FheRem {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "FheRem(address,bytes32,bytes32,bytes1,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                14u8, 105u8, 28u8, 208u8, 191u8, 140u8, 78u8, 147u8, 8u8, 228u8, 206u8,
                209u8, 187u8, 156u8, 150u8, 65u8, 23u8, 220u8, 92u8, 91u8, 185u8, 185u8,
                171u8, 91u8, 223u8, 235u8, 242u8, 201u8, 177u8, 58u8, 137u8, 124u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    caller: topics.1,
                    lhs: data.0,
                    rhs: data.1,
                    scalarByte: data.2,
                    result: data.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.caller.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.caller,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for FheRem {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&FheRem> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &FheRem) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `FheRotl(address,bytes32,bytes32,bytes1,bytes32)` and selector `0xeb0e4f8dc74058194d0602425fe602f955c222200f7f10c6fe67992f7b24c7e9`.
```solidity
event FheRotl(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct FheRotl {
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for FheRotl {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "FheRotl(address,bytes32,bytes32,bytes1,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                235u8, 14u8, 79u8, 141u8, 199u8, 64u8, 88u8, 25u8, 77u8, 6u8, 2u8, 66u8,
                95u8, 230u8, 2u8, 249u8, 85u8, 194u8, 34u8, 32u8, 15u8, 127u8, 16u8,
                198u8, 254u8, 103u8, 153u8, 47u8, 123u8, 36u8, 199u8, 233u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    caller: topics.1,
                    lhs: data.0,
                    rhs: data.1,
                    scalarByte: data.2,
                    result: data.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.caller.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.caller,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for FheRotl {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&FheRotl> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &FheRotl) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `FheRotr(address,bytes32,bytes32,bytes1,bytes32)` and selector `0xc148675905d07ad5496f8ef4d8195c907503f3ec12fd10ed5f21240abc693634`.
```solidity
event FheRotr(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct FheRotr {
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for FheRotr {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "FheRotr(address,bytes32,bytes32,bytes1,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                193u8, 72u8, 103u8, 89u8, 5u8, 208u8, 122u8, 213u8, 73u8, 111u8, 142u8,
                244u8, 216u8, 25u8, 92u8, 144u8, 117u8, 3u8, 243u8, 236u8, 18u8, 253u8,
                16u8, 237u8, 95u8, 33u8, 36u8, 10u8, 188u8, 105u8, 54u8, 52u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    caller: topics.1,
                    lhs: data.0,
                    rhs: data.1,
                    scalarByte: data.2,
                    result: data.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.caller.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.caller,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for FheRotr {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&FheRotr> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &FheRotr) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `FheShl(address,bytes32,bytes32,bytes1,bytes32)` and selector `0xe84282aaebcca698443e39a2a948a345d0d2ebc654af5cb657a2d7e8053bf6cb`.
```solidity
event FheShl(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct FheShl {
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for FheShl {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "FheShl(address,bytes32,bytes32,bytes1,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                232u8, 66u8, 130u8, 170u8, 235u8, 204u8, 166u8, 152u8, 68u8, 62u8, 57u8,
                162u8, 169u8, 72u8, 163u8, 69u8, 208u8, 210u8, 235u8, 198u8, 84u8, 175u8,
                92u8, 182u8, 87u8, 162u8, 215u8, 232u8, 5u8, 59u8, 246u8, 203u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    caller: topics.1,
                    lhs: data.0,
                    rhs: data.1,
                    scalarByte: data.2,
                    result: data.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.caller.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.caller,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for FheShl {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&FheShl> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &FheShl) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `FheShr(address,bytes32,bytes32,bytes1,bytes32)` and selector `0x324220bfc9cb158b492991c03c309cd86e5345cac45aacae2092ddabe31fa3d8`.
```solidity
event FheShr(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct FheShr {
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for FheShr {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "FheShr(address,bytes32,bytes32,bytes1,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                50u8, 66u8, 32u8, 191u8, 201u8, 203u8, 21u8, 139u8, 73u8, 41u8, 145u8,
                192u8, 60u8, 48u8, 156u8, 216u8, 110u8, 83u8, 69u8, 202u8, 196u8, 90u8,
                172u8, 174u8, 32u8, 146u8, 221u8, 171u8, 227u8, 31u8, 163u8, 216u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    caller: topics.1,
                    lhs: data.0,
                    rhs: data.1,
                    scalarByte: data.2,
                    result: data.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.caller.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.caller,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for FheShr {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&FheShr> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &FheShr) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `FheSub(address,bytes32,bytes32,bytes1,bytes32)` and selector `0xeb6d37bd271abe1395b21d6d78f3487d6584862872c29ffd3f90736ee99b7393`.
```solidity
event FheSub(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct FheSub {
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for FheSub {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "FheSub(address,bytes32,bytes32,bytes1,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                235u8, 109u8, 55u8, 189u8, 39u8, 26u8, 190u8, 19u8, 149u8, 178u8, 29u8,
                109u8, 120u8, 243u8, 72u8, 125u8, 101u8, 132u8, 134u8, 40u8, 114u8,
                194u8, 159u8, 253u8, 63u8, 144u8, 115u8, 110u8, 233u8, 155u8, 115u8,
                147u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    caller: topics.1,
                    lhs: data.0,
                    rhs: data.1,
                    scalarByte: data.2,
                    result: data.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.caller.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.caller,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for FheSub {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&FheSub> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &FheSub) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `Initialized(uint64)` and selector `0xc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d2`.
```solidity
event Initialized(uint64 version);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Initialized {
        #[allow(missing_docs)]
        pub version: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Initialized {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "Initialized(uint64)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                199u8, 245u8, 5u8, 178u8, 243u8, 113u8, 174u8, 33u8, 117u8, 238u8, 73u8,
                19u8, 244u8, 73u8, 158u8, 31u8, 38u8, 51u8, 167u8, 181u8, 147u8, 99u8,
                33u8, 238u8, 209u8, 205u8, 174u8, 182u8, 17u8, 81u8, 129u8, 210u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { version: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.version),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Initialized {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Initialized> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Initialized) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `TrivialEncrypt(address,uint256,uint8,bytes32)` and selector `0x063ccd1bba45151d91f6a418065047a3d048d058a922535747bb2b575a01d236`.
```solidity
event TrivialEncrypt(address indexed caller, uint256 pt, FheType toType, bytes32 result);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct TrivialEncrypt {
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub pt: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub toType: <FheType as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for TrivialEncrypt {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                FheType,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "TrivialEncrypt(address,uint256,uint8,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                6u8, 60u8, 205u8, 27u8, 186u8, 69u8, 21u8, 29u8, 145u8, 246u8, 164u8,
                24u8, 6u8, 80u8, 71u8, 163u8, 208u8, 72u8, 208u8, 88u8, 169u8, 34u8,
                83u8, 87u8, 71u8, 187u8, 43u8, 87u8, 90u8, 1u8, 210u8, 54u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    caller: topics.1,
                    pt: data.0,
                    toType: data.1,
                    result: data.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.pt),
                    <FheType as alloy_sol_types::SolType>::tokenize(&self.toType),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.caller.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.caller,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for TrivialEncrypt {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&TrivialEncrypt> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &TrivialEncrypt) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `Upgraded(address)` and selector `0xbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b`.
```solidity
event Upgraded(address indexed implementation);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Upgraded {
        #[allow(missing_docs)]
        pub implementation: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Upgraded {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "Upgraded(address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                188u8, 124u8, 215u8, 90u8, 32u8, 238u8, 39u8, 253u8, 154u8, 222u8, 186u8,
                179u8, 32u8, 65u8, 247u8, 85u8, 33u8, 77u8, 188u8, 107u8, 255u8, 169u8,
                12u8, 192u8, 34u8, 91u8, 57u8, 218u8, 46u8, 92u8, 45u8, 59u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { implementation: topics.1 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.implementation.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.implementation,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Upgraded {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Upgraded> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Upgraded) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `VerifyInput(address,bytes32,address,bytes,uint8,bytes32)` and selector `0xdc370db33589e73371dc3ee42c789c003d336eefcb7c3f56fe0f51ae5b1d9702`.
```solidity
event VerifyInput(address indexed caller, bytes32 inputHandle, address userAddress, bytes inputProof, FheType inputType, bytes32 result);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct VerifyInput {
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub inputHandle: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub userAddress: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub inputProof: alloy::sol_types::private::Bytes,
        #[allow(missing_docs)]
        pub inputType: <FheType as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for VerifyInput {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bytes,
                FheType,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "VerifyInput(address,bytes32,address,bytes,uint8,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                220u8, 55u8, 13u8, 179u8, 53u8, 137u8, 231u8, 51u8, 113u8, 220u8, 62u8,
                228u8, 44u8, 120u8, 156u8, 0u8, 61u8, 51u8, 110u8, 239u8, 203u8, 124u8,
                63u8, 86u8, 254u8, 15u8, 81u8, 174u8, 91u8, 29u8, 151u8, 2u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    caller: topics.1,
                    inputHandle: data.0,
                    userAddress: data.1,
                    inputProof: data.2,
                    inputType: data.3,
                    result: data.4,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.inputHandle),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.userAddress,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.inputProof,
                    ),
                    <FheType as alloy_sol_types::SolType>::tokenize(&self.inputType),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.caller.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.caller,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for VerifyInput {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&VerifyInput> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &VerifyInput) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Constructor`.
```solidity
constructor();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct constructorCall {}
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<constructorCall> for UnderlyingRustTuple<'_> {
                fn from(value: constructorCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for constructorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolConstructor for constructorCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `UPGRADE_INTERFACE_VERSION()` and selector `0xad3cb1cc`.
```solidity
function UPGRADE_INTERFACE_VERSION() external view returns (string memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct UPGRADE_INTERFACE_VERSIONCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`UPGRADE_INTERFACE_VERSION()`](UPGRADE_INTERFACE_VERSIONCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct UPGRADE_INTERFACE_VERSIONReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UPGRADE_INTERFACE_VERSIONCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: UPGRADE_INTERFACE_VERSIONCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for UPGRADE_INTERFACE_VERSIONCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UPGRADE_INTERFACE_VERSIONReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: UPGRADE_INTERFACE_VERSIONReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for UPGRADE_INTERFACE_VERSIONReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for UPGRADE_INTERFACE_VERSIONCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::String;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "UPGRADE_INTERFACE_VERSION()";
            const SELECTOR: [u8; 4] = [173u8, 60u8, 177u8, 204u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: UPGRADE_INTERFACE_VERSIONReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: UPGRADE_INTERFACE_VERSIONReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `cast(bytes32,uint8)` and selector `0x1c89ee44`.
```solidity
function cast(bytes32 ct, FheType toType) external returns (bytes32 result);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct castCall {
        #[allow(missing_docs)]
        pub ct: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub toType: <FheType as alloy::sol_types::SolType>::RustType,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`cast(bytes32,uint8)`](castCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct castReturn {
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                FheType,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                <FheType as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<castCall> for UnderlyingRustTuple<'_> {
                fn from(value: castCall) -> Self {
                    (value.ct, value.toType)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for castCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        ct: tuple.0,
                        toType: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<castReturn> for UnderlyingRustTuple<'_> {
                fn from(value: castReturn) -> Self {
                    (value.result,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for castReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { result: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for castCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>, FheType);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "cast(bytes32,uint8)";
            const SELECTOR: [u8; 4] = [28u8, 137u8, 238u8, 68u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.ct),
                    <FheType as alloy_sol_types::SolType>::tokenize(&self.toType),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: castReturn = r.into();
                        r.result
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: castReturn = r.into();
                        r.result
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `fheAdd(bytes32,bytes32,bytes1)` and selector `0x117b2f38`.
```solidity
function fheAdd(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheAddCall {
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`fheAdd(bytes32,bytes32,bytes1)`](fheAddCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheAddReturn {
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<1>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheAddCall> for UnderlyingRustTuple<'_> {
                fn from(value: fheAddCall) -> Self {
                    (value.lhs, value.rhs, value.scalarByte)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheAddCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        lhs: tuple.0,
                        rhs: tuple.1,
                        scalarByte: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheAddReturn> for UnderlyingRustTuple<'_> {
                fn from(value: fheAddReturn) -> Self {
                    (value.result,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheAddReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { result: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for fheAddCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "fheAdd(bytes32,bytes32,bytes1)";
            const SELECTOR: [u8; 4] = [17u8, 123u8, 47u8, 56u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: fheAddReturn = r.into();
                        r.result
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: fheAddReturn = r.into();
                        r.result
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `fheBitAnd(bytes32,bytes32,bytes1)` and selector `0xd99882d5`.
```solidity
function fheBitAnd(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheBitAndCall {
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`fheBitAnd(bytes32,bytes32,bytes1)`](fheBitAndCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheBitAndReturn {
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<1>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheBitAndCall> for UnderlyingRustTuple<'_> {
                fn from(value: fheBitAndCall) -> Self {
                    (value.lhs, value.rhs, value.scalarByte)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheBitAndCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        lhs: tuple.0,
                        rhs: tuple.1,
                        scalarByte: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheBitAndReturn> for UnderlyingRustTuple<'_> {
                fn from(value: fheBitAndReturn) -> Self {
                    (value.result,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheBitAndReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { result: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for fheBitAndCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "fheBitAnd(bytes32,bytes32,bytes1)";
            const SELECTOR: [u8; 4] = [217u8, 152u8, 130u8, 213u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: fheBitAndReturn = r.into();
                        r.result
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: fheBitAndReturn = r.into();
                        r.result
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `fheBitOr(bytes32,bytes32,bytes1)` and selector `0x63a2db29`.
```solidity
function fheBitOr(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheBitOrCall {
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`fheBitOr(bytes32,bytes32,bytes1)`](fheBitOrCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheBitOrReturn {
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<1>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheBitOrCall> for UnderlyingRustTuple<'_> {
                fn from(value: fheBitOrCall) -> Self {
                    (value.lhs, value.rhs, value.scalarByte)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheBitOrCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        lhs: tuple.0,
                        rhs: tuple.1,
                        scalarByte: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheBitOrReturn> for UnderlyingRustTuple<'_> {
                fn from(value: fheBitOrReturn) -> Self {
                    (value.result,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheBitOrReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { result: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for fheBitOrCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "fheBitOr(bytes32,bytes32,bytes1)";
            const SELECTOR: [u8; 4] = [99u8, 162u8, 219u8, 41u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: fheBitOrReturn = r.into();
                        r.result
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: fheBitOrReturn = r.into();
                        r.result
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `fheBitXor(bytes32,bytes32,bytes1)` and selector `0x8b49ceb4`.
```solidity
function fheBitXor(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheBitXorCall {
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`fheBitXor(bytes32,bytes32,bytes1)`](fheBitXorCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheBitXorReturn {
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<1>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheBitXorCall> for UnderlyingRustTuple<'_> {
                fn from(value: fheBitXorCall) -> Self {
                    (value.lhs, value.rhs, value.scalarByte)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheBitXorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        lhs: tuple.0,
                        rhs: tuple.1,
                        scalarByte: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheBitXorReturn> for UnderlyingRustTuple<'_> {
                fn from(value: fheBitXorReturn) -> Self {
                    (value.result,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheBitXorReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { result: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for fheBitXorCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "fheBitXor(bytes32,bytes32,bytes1)";
            const SELECTOR: [u8; 4] = [139u8, 73u8, 206u8, 180u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: fheBitXorReturn = r.into();
                        r.result
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: fheBitXorReturn = r.into();
                        r.result
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `fheDiv(bytes32,bytes32,bytes1)` and selector `0x5a53accb`.
```solidity
function fheDiv(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheDivCall {
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`fheDiv(bytes32,bytes32,bytes1)`](fheDivCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheDivReturn {
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<1>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheDivCall> for UnderlyingRustTuple<'_> {
                fn from(value: fheDivCall) -> Self {
                    (value.lhs, value.rhs, value.scalarByte)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheDivCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        lhs: tuple.0,
                        rhs: tuple.1,
                        scalarByte: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheDivReturn> for UnderlyingRustTuple<'_> {
                fn from(value: fheDivReturn) -> Self {
                    (value.result,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheDivReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { result: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for fheDivCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "fheDiv(bytes32,bytes32,bytes1)";
            const SELECTOR: [u8; 4] = [90u8, 83u8, 172u8, 203u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: fheDivReturn = r.into();
                        r.result
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: fheDivReturn = r.into();
                        r.result
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `fheEq(bytes32,bytes32,bytes1)` and selector `0xf77f3f1d`.
```solidity
function fheEq(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheEqCall {
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`fheEq(bytes32,bytes32,bytes1)`](fheEqCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheEqReturn {
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<1>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheEqCall> for UnderlyingRustTuple<'_> {
                fn from(value: fheEqCall) -> Self {
                    (value.lhs, value.rhs, value.scalarByte)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheEqCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        lhs: tuple.0,
                        rhs: tuple.1,
                        scalarByte: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheEqReturn> for UnderlyingRustTuple<'_> {
                fn from(value: fheEqReturn) -> Self {
                    (value.result,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheEqReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { result: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for fheEqCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "fheEq(bytes32,bytes32,bytes1)";
            const SELECTOR: [u8; 4] = [247u8, 127u8, 63u8, 29u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: fheEqReturn = r.into();
                        r.result
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: fheEqReturn = r.into();
                        r.result
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `fheGe(bytes32,bytes32,bytes1)` and selector `0x1391547f`.
```solidity
function fheGe(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheGeCall {
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`fheGe(bytes32,bytes32,bytes1)`](fheGeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheGeReturn {
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<1>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheGeCall> for UnderlyingRustTuple<'_> {
                fn from(value: fheGeCall) -> Self {
                    (value.lhs, value.rhs, value.scalarByte)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheGeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        lhs: tuple.0,
                        rhs: tuple.1,
                        scalarByte: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheGeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: fheGeReturn) -> Self {
                    (value.result,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheGeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { result: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for fheGeCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "fheGe(bytes32,bytes32,bytes1)";
            const SELECTOR: [u8; 4] = [19u8, 145u8, 84u8, 127u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: fheGeReturn = r.into();
                        r.result
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: fheGeReturn = r.into();
                        r.result
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `fheGt(bytes32,bytes32,bytes1)` and selector `0x85362ee7`.
```solidity
function fheGt(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheGtCall {
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`fheGt(bytes32,bytes32,bytes1)`](fheGtCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheGtReturn {
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<1>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheGtCall> for UnderlyingRustTuple<'_> {
                fn from(value: fheGtCall) -> Self {
                    (value.lhs, value.rhs, value.scalarByte)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheGtCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        lhs: tuple.0,
                        rhs: tuple.1,
                        scalarByte: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheGtReturn> for UnderlyingRustTuple<'_> {
                fn from(value: fheGtReturn) -> Self {
                    (value.result,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheGtReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { result: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for fheGtCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "fheGt(bytes32,bytes32,bytes1)";
            const SELECTOR: [u8; 4] = [133u8, 54u8, 46u8, 231u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: fheGtReturn = r.into();
                        r.result
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: fheGtReturn = r.into();
                        r.result
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `fheIfThenElse(bytes32,bytes32,bytes32)` and selector `0x7702dcff`.
```solidity
function fheIfThenElse(bytes32 control, bytes32 ifTrue, bytes32 ifFalse) external returns (bytes32 result);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheIfThenElseCall {
        #[allow(missing_docs)]
        pub control: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub ifTrue: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub ifFalse: alloy::sol_types::private::FixedBytes<32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`fheIfThenElse(bytes32,bytes32,bytes32)`](fheIfThenElseCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheIfThenElseReturn {
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheIfThenElseCall> for UnderlyingRustTuple<'_> {
                fn from(value: fheIfThenElseCall) -> Self {
                    (value.control, value.ifTrue, value.ifFalse)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheIfThenElseCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        control: tuple.0,
                        ifTrue: tuple.1,
                        ifFalse: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheIfThenElseReturn> for UnderlyingRustTuple<'_> {
                fn from(value: fheIfThenElseReturn) -> Self {
                    (value.result,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheIfThenElseReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { result: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for fheIfThenElseCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "fheIfThenElse(bytes32,bytes32,bytes32)";
            const SELECTOR: [u8; 4] = [119u8, 2u8, 220u8, 255u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.control),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.ifTrue),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.ifFalse),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: fheIfThenElseReturn = r.into();
                        r.result
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: fheIfThenElseReturn = r.into();
                        r.result
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `fheLe(bytes32,bytes32,bytes1)` and selector `0x7513a404`.
```solidity
function fheLe(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheLeCall {
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`fheLe(bytes32,bytes32,bytes1)`](fheLeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheLeReturn {
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<1>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheLeCall> for UnderlyingRustTuple<'_> {
                fn from(value: fheLeCall) -> Self {
                    (value.lhs, value.rhs, value.scalarByte)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheLeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        lhs: tuple.0,
                        rhs: tuple.1,
                        scalarByte: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheLeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: fheLeReturn) -> Self {
                    (value.result,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheLeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { result: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for fheLeCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "fheLe(bytes32,bytes32,bytes1)";
            const SELECTOR: [u8; 4] = [117u8, 19u8, 164u8, 4u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: fheLeReturn = r.into();
                        r.result
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: fheLeReturn = r.into();
                        r.result
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `fheLt(bytes32,bytes32,bytes1)` and selector `0x72107681`.
```solidity
function fheLt(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheLtCall {
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`fheLt(bytes32,bytes32,bytes1)`](fheLtCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheLtReturn {
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<1>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheLtCall> for UnderlyingRustTuple<'_> {
                fn from(value: fheLtCall) -> Self {
                    (value.lhs, value.rhs, value.scalarByte)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheLtCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        lhs: tuple.0,
                        rhs: tuple.1,
                        scalarByte: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheLtReturn> for UnderlyingRustTuple<'_> {
                fn from(value: fheLtReturn) -> Self {
                    (value.result,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheLtReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { result: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for fheLtCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "fheLt(bytes32,bytes32,bytes1)";
            const SELECTOR: [u8; 4] = [114u8, 16u8, 118u8, 129u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: fheLtReturn = r.into();
                        r.result
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: fheLtReturn = r.into();
                        r.result
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `fheMax(bytes32,bytes32,bytes1)` and selector `0x36318d64`.
```solidity
function fheMax(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheMaxCall {
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`fheMax(bytes32,bytes32,bytes1)`](fheMaxCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheMaxReturn {
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<1>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheMaxCall> for UnderlyingRustTuple<'_> {
                fn from(value: fheMaxCall) -> Self {
                    (value.lhs, value.rhs, value.scalarByte)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheMaxCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        lhs: tuple.0,
                        rhs: tuple.1,
                        scalarByte: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheMaxReturn> for UnderlyingRustTuple<'_> {
                fn from(value: fheMaxReturn) -> Self {
                    (value.result,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheMaxReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { result: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for fheMaxCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "fheMax(bytes32,bytes32,bytes1)";
            const SELECTOR: [u8; 4] = [54u8, 49u8, 141u8, 100u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: fheMaxReturn = r.into();
                        r.result
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: fheMaxReturn = r.into();
                        r.result
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `fheMin(bytes32,bytes32,bytes1)` and selector `0x04559f71`.
```solidity
function fheMin(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheMinCall {
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`fheMin(bytes32,bytes32,bytes1)`](fheMinCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheMinReturn {
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<1>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheMinCall> for UnderlyingRustTuple<'_> {
                fn from(value: fheMinCall) -> Self {
                    (value.lhs, value.rhs, value.scalarByte)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheMinCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        lhs: tuple.0,
                        rhs: tuple.1,
                        scalarByte: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheMinReturn> for UnderlyingRustTuple<'_> {
                fn from(value: fheMinReturn) -> Self {
                    (value.result,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheMinReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { result: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for fheMinCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "fheMin(bytes32,bytes32,bytes1)";
            const SELECTOR: [u8; 4] = [4u8, 85u8, 159u8, 113u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: fheMinReturn = r.into();
                        r.result
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: fheMinReturn = r.into();
                        r.result
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `fheMul(bytes32,bytes32,bytes1)` and selector `0x57f0a568`.
```solidity
function fheMul(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheMulCall {
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`fheMul(bytes32,bytes32,bytes1)`](fheMulCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheMulReturn {
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<1>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheMulCall> for UnderlyingRustTuple<'_> {
                fn from(value: fheMulCall) -> Self {
                    (value.lhs, value.rhs, value.scalarByte)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheMulCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        lhs: tuple.0,
                        rhs: tuple.1,
                        scalarByte: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheMulReturn> for UnderlyingRustTuple<'_> {
                fn from(value: fheMulReturn) -> Self {
                    (value.result,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheMulReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { result: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for fheMulCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "fheMul(bytes32,bytes32,bytes1)";
            const SELECTOR: [u8; 4] = [87u8, 240u8, 165u8, 104u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: fheMulReturn = r.into();
                        r.result
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: fheMulReturn = r.into();
                        r.result
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `fheNe(bytes32,bytes32,bytes1)` and selector `0xd8092cbc`.
```solidity
function fheNe(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheNeCall {
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`fheNe(bytes32,bytes32,bytes1)`](fheNeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheNeReturn {
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<1>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheNeCall> for UnderlyingRustTuple<'_> {
                fn from(value: fheNeCall) -> Self {
                    (value.lhs, value.rhs, value.scalarByte)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheNeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        lhs: tuple.0,
                        rhs: tuple.1,
                        scalarByte: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheNeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: fheNeReturn) -> Self {
                    (value.result,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheNeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { result: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for fheNeCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "fheNe(bytes32,bytes32,bytes1)";
            const SELECTOR: [u8; 4] = [216u8, 9u8, 44u8, 188u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: fheNeReturn = r.into();
                        r.result
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: fheNeReturn = r.into();
                        r.result
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `fheNeg(bytes32)` and selector `0xd580c063`.
```solidity
function fheNeg(bytes32 ct) external returns (bytes32 result);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheNegCall {
        #[allow(missing_docs)]
        pub ct: alloy::sol_types::private::FixedBytes<32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`fheNeg(bytes32)`](fheNegCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheNegReturn {
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheNegCall> for UnderlyingRustTuple<'_> {
                fn from(value: fheNegCall) -> Self {
                    (value.ct,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheNegCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { ct: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheNegReturn> for UnderlyingRustTuple<'_> {
                fn from(value: fheNegReturn) -> Self {
                    (value.result,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheNegReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { result: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for fheNegCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "fheNeg(bytes32)";
            const SELECTOR: [u8; 4] = [213u8, 128u8, 192u8, 99u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.ct),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: fheNegReturn = r.into();
                        r.result
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: fheNegReturn = r.into();
                        r.result
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `fheNot(bytes32)` and selector `0xf51ccfb0`.
```solidity
function fheNot(bytes32 ct) external returns (bytes32 result);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheNotCall {
        #[allow(missing_docs)]
        pub ct: alloy::sol_types::private::FixedBytes<32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`fheNot(bytes32)`](fheNotCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheNotReturn {
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheNotCall> for UnderlyingRustTuple<'_> {
                fn from(value: fheNotCall) -> Self {
                    (value.ct,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheNotCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { ct: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheNotReturn> for UnderlyingRustTuple<'_> {
                fn from(value: fheNotReturn) -> Self {
                    (value.result,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheNotReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { result: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for fheNotCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "fheNot(bytes32)";
            const SELECTOR: [u8; 4] = [245u8, 28u8, 207u8, 176u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.ct),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: fheNotReturn = r.into();
                        r.result
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: fheNotReturn = r.into();
                        r.result
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `fheRand(uint8)` and selector `0xd75d6e8a`.
```solidity
function fheRand(FheType randType) external returns (bytes32 result);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheRandCall {
        #[allow(missing_docs)]
        pub randType: <FheType as alloy::sol_types::SolType>::RustType,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`fheRand(uint8)`](fheRandCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheRandReturn {
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (FheType,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <FheType as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheRandCall> for UnderlyingRustTuple<'_> {
                fn from(value: fheRandCall) -> Self {
                    (value.randType,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheRandCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { randType: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheRandReturn> for UnderlyingRustTuple<'_> {
                fn from(value: fheRandReturn) -> Self {
                    (value.result,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheRandReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { result: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for fheRandCall {
            type Parameters<'a> = (FheType,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "fheRand(uint8)";
            const SELECTOR: [u8; 4] = [215u8, 93u8, 110u8, 138u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<FheType as alloy_sol_types::SolType>::tokenize(&self.randType),)
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: fheRandReturn = r.into();
                        r.result
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: fheRandReturn = r.into();
                        r.result
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `fheRandBounded(uint256,uint8)` and selector `0x48eef47e`.
```solidity
function fheRandBounded(uint256 upperBound, FheType randType) external returns (bytes32 result);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheRandBoundedCall {
        #[allow(missing_docs)]
        pub upperBound: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub randType: <FheType as alloy::sol_types::SolType>::RustType,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`fheRandBounded(uint256,uint8)`](fheRandBoundedCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheRandBoundedReturn {
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                FheType,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                <FheType as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheRandBoundedCall> for UnderlyingRustTuple<'_> {
                fn from(value: fheRandBoundedCall) -> Self {
                    (value.upperBound, value.randType)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheRandBoundedCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        upperBound: tuple.0,
                        randType: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheRandBoundedReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: fheRandBoundedReturn) -> Self {
                    (value.result,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for fheRandBoundedReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { result: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for fheRandBoundedCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>, FheType);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "fheRandBounded(uint256,uint8)";
            const SELECTOR: [u8; 4] = [72u8, 238u8, 244u8, 126u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.upperBound),
                    <FheType as alloy_sol_types::SolType>::tokenize(&self.randType),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: fheRandBoundedReturn = r.into();
                        r.result
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: fheRandBoundedReturn = r.into();
                        r.result
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `fheRem(bytes32,bytes32,bytes1)` and selector `0xcf4d18aa`.
```solidity
function fheRem(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheRemCall {
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`fheRem(bytes32,bytes32,bytes1)`](fheRemCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheRemReturn {
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<1>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheRemCall> for UnderlyingRustTuple<'_> {
                fn from(value: fheRemCall) -> Self {
                    (value.lhs, value.rhs, value.scalarByte)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheRemCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        lhs: tuple.0,
                        rhs: tuple.1,
                        scalarByte: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheRemReturn> for UnderlyingRustTuple<'_> {
                fn from(value: fheRemReturn) -> Self {
                    (value.result,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheRemReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { result: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for fheRemCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "fheRem(bytes32,bytes32,bytes1)";
            const SELECTOR: [u8; 4] = [207u8, 77u8, 24u8, 170u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: fheRemReturn = r.into();
                        r.result
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: fheRemReturn = r.into();
                        r.result
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `fheRotl(bytes32,bytes32,bytes1)` and selector `0x6754b360`.
```solidity
function fheRotl(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheRotlCall {
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`fheRotl(bytes32,bytes32,bytes1)`](fheRotlCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheRotlReturn {
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<1>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheRotlCall> for UnderlyingRustTuple<'_> {
                fn from(value: fheRotlCall) -> Self {
                    (value.lhs, value.rhs, value.scalarByte)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheRotlCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        lhs: tuple.0,
                        rhs: tuple.1,
                        scalarByte: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheRotlReturn> for UnderlyingRustTuple<'_> {
                fn from(value: fheRotlReturn) -> Self {
                    (value.result,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheRotlReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { result: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for fheRotlCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "fheRotl(bytes32,bytes32,bytes1)";
            const SELECTOR: [u8; 4] = [103u8, 84u8, 179u8, 96u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: fheRotlReturn = r.into();
                        r.result
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: fheRotlReturn = r.into();
                        r.result
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `fheRotr(bytes32,bytes32,bytes1)` and selector `0xc021329e`.
```solidity
function fheRotr(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheRotrCall {
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`fheRotr(bytes32,bytes32,bytes1)`](fheRotrCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheRotrReturn {
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<1>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheRotrCall> for UnderlyingRustTuple<'_> {
                fn from(value: fheRotrCall) -> Self {
                    (value.lhs, value.rhs, value.scalarByte)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheRotrCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        lhs: tuple.0,
                        rhs: tuple.1,
                        scalarByte: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheRotrReturn> for UnderlyingRustTuple<'_> {
                fn from(value: fheRotrReturn) -> Self {
                    (value.result,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheRotrReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { result: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for fheRotrCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "fheRotr(bytes32,bytes32,bytes1)";
            const SELECTOR: [u8; 4] = [192u8, 33u8, 50u8, 158u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: fheRotrReturn = r.into();
                        r.result
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: fheRotrReturn = r.into();
                        r.result
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `fheShl(bytes32,bytes32,bytes1)` and selector `0xccc480a1`.
```solidity
function fheShl(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheShlCall {
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`fheShl(bytes32,bytes32,bytes1)`](fheShlCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheShlReturn {
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<1>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheShlCall> for UnderlyingRustTuple<'_> {
                fn from(value: fheShlCall) -> Self {
                    (value.lhs, value.rhs, value.scalarByte)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheShlCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        lhs: tuple.0,
                        rhs: tuple.1,
                        scalarByte: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheShlReturn> for UnderlyingRustTuple<'_> {
                fn from(value: fheShlReturn) -> Self {
                    (value.result,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheShlReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { result: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for fheShlCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "fheShl(bytes32,bytes32,bytes1)";
            const SELECTOR: [u8; 4] = [204u8, 196u8, 128u8, 161u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: fheShlReturn = r.into();
                        r.result
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: fheShlReturn = r.into();
                        r.result
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `fheShr(bytes32,bytes32,bytes1)` and selector `0x91f98ffe`.
```solidity
function fheShr(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheShrCall {
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`fheShr(bytes32,bytes32,bytes1)`](fheShrCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheShrReturn {
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<1>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheShrCall> for UnderlyingRustTuple<'_> {
                fn from(value: fheShrCall) -> Self {
                    (value.lhs, value.rhs, value.scalarByte)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheShrCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        lhs: tuple.0,
                        rhs: tuple.1,
                        scalarByte: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheShrReturn> for UnderlyingRustTuple<'_> {
                fn from(value: fheShrReturn) -> Self {
                    (value.result,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheShrReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { result: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for fheShrCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "fheShr(bytes32,bytes32,bytes1)";
            const SELECTOR: [u8; 4] = [145u8, 249u8, 143u8, 254u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: fheShrReturn = r.into();
                        r.result
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: fheShrReturn = r.into();
                        r.result
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `fheSub(bytes32,bytes32,bytes1)` and selector `0x182b6d98`.
```solidity
function fheSub(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheSubCall {
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`fheSub(bytes32,bytes32,bytes1)`](fheSubCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheSubReturn {
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<1>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheSubCall> for UnderlyingRustTuple<'_> {
                fn from(value: fheSubCall) -> Self {
                    (value.lhs, value.rhs, value.scalarByte)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheSubCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        lhs: tuple.0,
                        rhs: tuple.1,
                        scalarByte: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheSubReturn> for UnderlyingRustTuple<'_> {
                fn from(value: fheSubReturn) -> Self {
                    (value.result,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheSubReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { result: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for fheSubCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "fheSub(bytes32,bytes32,bytes1)";
            const SELECTOR: [u8; 4] = [24u8, 43u8, 109u8, 152u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: fheSubReturn = r.into();
                        r.result
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: fheSubReturn = r.into();
                        r.result
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getACLAddress()` and selector `0xf6859bdc`.
```solidity
function getACLAddress() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getACLAddressCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getACLAddress()`](getACLAddressCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getACLAddressReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getACLAddressCall> for UnderlyingRustTuple<'_> {
                fn from(value: getACLAddressCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getACLAddressCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getACLAddressReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getACLAddressReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getACLAddressReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getACLAddressCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getACLAddress()";
            const SELECTOR: [u8; 4] = [246u8, 133u8, 155u8, 220u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getACLAddressReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getACLAddressReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getHCULimitAddress()` and selector `0xe0786972`.
```solidity
function getHCULimitAddress() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getHCULimitAddressCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getHCULimitAddress()`](getHCULimitAddressCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getHCULimitAddressReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getHCULimitAddressCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getHCULimitAddressCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getHCULimitAddressCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getHCULimitAddressReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getHCULimitAddressReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getHCULimitAddressReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getHCULimitAddressCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getHCULimitAddress()";
            const SELECTOR: [u8; 4] = [224u8, 120u8, 105u8, 114u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getHCULimitAddressReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getHCULimitAddressReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getHandleVersion()` and selector `0x7a297f4b`.
```solidity
function getHandleVersion() external pure returns (uint8);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getHandleVersionCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getHandleVersion()`](getHandleVersionCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getHandleVersionReturn {
        #[allow(missing_docs)]
        pub _0: u8,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getHandleVersionCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getHandleVersionCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getHandleVersionCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<8>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u8,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getHandleVersionReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getHandleVersionReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getHandleVersionReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getHandleVersionCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = u8;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<8>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getHandleVersion()";
            const SELECTOR: [u8; 4] = [122u8, 41u8, 127u8, 75u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getHandleVersionReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getHandleVersionReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getInputVerifierAddress()` and selector `0xa8c7c2c1`.
```solidity
function getInputVerifierAddress() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getInputVerifierAddressCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getInputVerifierAddress()`](getInputVerifierAddressCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getInputVerifierAddressReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getInputVerifierAddressCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getInputVerifierAddressCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getInputVerifierAddressCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getInputVerifierAddressReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getInputVerifierAddressReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getInputVerifierAddressReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getInputVerifierAddressCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getInputVerifierAddress()";
            const SELECTOR: [u8; 4] = [168u8, 199u8, 194u8, 193u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getInputVerifierAddressReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getInputVerifierAddressReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getVersion()` and selector `0x0d8e6e2c`.
```solidity
function getVersion() external pure returns (string memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getVersionCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getVersion()`](getVersionCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getVersionReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getVersionCall> for UnderlyingRustTuple<'_> {
                fn from(value: getVersionCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getVersionCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getVersionReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getVersionReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getVersionReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getVersionCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::String;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getVersion()";
            const SELECTOR: [u8; 4] = [13u8, 142u8, 110u8, 44u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getVersionReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getVersionReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `initializeFromEmptyProxy()` and selector `0x39f73810`.
```solidity
function initializeFromEmptyProxy() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct initializeFromEmptyProxyCall;
    ///Container type for the return parameters of the [`initializeFromEmptyProxy()`](initializeFromEmptyProxyCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct initializeFromEmptyProxyReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<initializeFromEmptyProxyCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: initializeFromEmptyProxyCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for initializeFromEmptyProxyCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<initializeFromEmptyProxyReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: initializeFromEmptyProxyReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for initializeFromEmptyProxyReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl initializeFromEmptyProxyReturn {
            fn _tokenize(
                &self,
            ) -> <initializeFromEmptyProxyCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for initializeFromEmptyProxyCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = initializeFromEmptyProxyReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "initializeFromEmptyProxy()";
            const SELECTOR: [u8; 4] = [57u8, 247u8, 56u8, 16u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                initializeFromEmptyProxyReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `proxiableUUID()` and selector `0x52d1902d`.
```solidity
function proxiableUUID() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct proxiableUUIDCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`proxiableUUID()`](proxiableUUIDCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct proxiableUUIDReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<proxiableUUIDCall> for UnderlyingRustTuple<'_> {
                fn from(value: proxiableUUIDCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for proxiableUUIDCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<proxiableUUIDReturn> for UnderlyingRustTuple<'_> {
                fn from(value: proxiableUUIDReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for proxiableUUIDReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for proxiableUUIDCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "proxiableUUID()";
            const SELECTOR: [u8; 4] = [82u8, 209u8, 144u8, 45u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: proxiableUUIDReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: proxiableUUIDReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `trivialEncrypt(uint256,uint8)` and selector `0x9cd07acb`.
```solidity
function trivialEncrypt(uint256 pt, FheType toType) external returns (bytes32 result);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct trivialEncryptCall {
        #[allow(missing_docs)]
        pub pt: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub toType: <FheType as alloy::sol_types::SolType>::RustType,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`trivialEncrypt(uint256,uint8)`](trivialEncryptCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct trivialEncryptReturn {
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                FheType,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                <FheType as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<trivialEncryptCall> for UnderlyingRustTuple<'_> {
                fn from(value: trivialEncryptCall) -> Self {
                    (value.pt, value.toType)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for trivialEncryptCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        pt: tuple.0,
                        toType: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<trivialEncryptReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: trivialEncryptReturn) -> Self {
                    (value.result,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for trivialEncryptReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { result: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for trivialEncryptCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>, FheType);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "trivialEncrypt(uint256,uint8)";
            const SELECTOR: [u8; 4] = [156u8, 208u8, 122u8, 203u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.pt),
                    <FheType as alloy_sol_types::SolType>::tokenize(&self.toType),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: trivialEncryptReturn = r.into();
                        r.result
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: trivialEncryptReturn = r.into();
                        r.result
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `upgradeToAndCall(address,bytes)` and selector `0x4f1ef286`.
```solidity
function upgradeToAndCall(address newImplementation, bytes memory data) external payable;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct upgradeToAndCallCall {
        #[allow(missing_docs)]
        pub newImplementation: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub data: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`upgradeToAndCall(address,bytes)`](upgradeToAndCallCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct upgradeToAndCallReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<upgradeToAndCallCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: upgradeToAndCallCall) -> Self {
                    (value.newImplementation, value.data)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for upgradeToAndCallCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        newImplementation: tuple.0,
                        data: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<upgradeToAndCallReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: upgradeToAndCallReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for upgradeToAndCallReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl upgradeToAndCallReturn {
            fn _tokenize(
                &self,
            ) -> <upgradeToAndCallCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for upgradeToAndCallCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = upgradeToAndCallReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "upgradeToAndCall(address,bytes)";
            const SELECTOR: [u8; 4] = [79u8, 30u8, 242u8, 134u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.newImplementation,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.data,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                upgradeToAndCallReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `verifyInput(bytes32,address,bytes,uint8)` and selector `0x08bf832a`.
```solidity
function verifyInput(bytes32 inputHandle, address userAddress, bytes memory inputProof, FheType inputType) external returns (bytes32 result);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct verifyInputCall {
        #[allow(missing_docs)]
        pub inputHandle: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub userAddress: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub inputProof: alloy::sol_types::private::Bytes,
        #[allow(missing_docs)]
        pub inputType: <FheType as alloy::sol_types::SolType>::RustType,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`verifyInput(bytes32,address,bytes,uint8)`](verifyInputCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct verifyInputReturn {
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bytes,
                FheType,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Bytes,
                <FheType as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<verifyInputCall> for UnderlyingRustTuple<'_> {
                fn from(value: verifyInputCall) -> Self {
                    (
                        value.inputHandle,
                        value.userAddress,
                        value.inputProof,
                        value.inputType,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for verifyInputCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        inputHandle: tuple.0,
                        userAddress: tuple.1,
                        inputProof: tuple.2,
                        inputType: tuple.3,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<verifyInputReturn> for UnderlyingRustTuple<'_> {
                fn from(value: verifyInputReturn) -> Self {
                    (value.result,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for verifyInputReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { result: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for verifyInputCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bytes,
                FheType,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "verifyInput(bytes32,address,bytes,uint8)";
            const SELECTOR: [u8; 4] = [8u8, 191u8, 131u8, 42u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.inputHandle),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.userAddress,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.inputProof,
                    ),
                    <FheType as alloy_sol_types::SolType>::tokenize(&self.inputType),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: verifyInputReturn = r.into();
                        r.result
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: verifyInputReturn = r.into();
                        r.result
                    })
            }
        }
    };
    ///Container for all the [`FHEVMExecutor`](self) function calls.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive()]
    pub enum FHEVMExecutorCalls {
        #[allow(missing_docs)]
        UPGRADE_INTERFACE_VERSION(UPGRADE_INTERFACE_VERSIONCall),
        #[allow(missing_docs)]
        cast(castCall),
        #[allow(missing_docs)]
        fheAdd(fheAddCall),
        #[allow(missing_docs)]
        fheBitAnd(fheBitAndCall),
        #[allow(missing_docs)]
        fheBitOr(fheBitOrCall),
        #[allow(missing_docs)]
        fheBitXor(fheBitXorCall),
        #[allow(missing_docs)]
        fheDiv(fheDivCall),
        #[allow(missing_docs)]
        fheEq(fheEqCall),
        #[allow(missing_docs)]
        fheGe(fheGeCall),
        #[allow(missing_docs)]
        fheGt(fheGtCall),
        #[allow(missing_docs)]
        fheIfThenElse(fheIfThenElseCall),
        #[allow(missing_docs)]
        fheLe(fheLeCall),
        #[allow(missing_docs)]
        fheLt(fheLtCall),
        #[allow(missing_docs)]
        fheMax(fheMaxCall),
        #[allow(missing_docs)]
        fheMin(fheMinCall),
        #[allow(missing_docs)]
        fheMul(fheMulCall),
        #[allow(missing_docs)]
        fheNe(fheNeCall),
        #[allow(missing_docs)]
        fheNeg(fheNegCall),
        #[allow(missing_docs)]
        fheNot(fheNotCall),
        #[allow(missing_docs)]
        fheRand(fheRandCall),
        #[allow(missing_docs)]
        fheRandBounded(fheRandBoundedCall),
        #[allow(missing_docs)]
        fheRem(fheRemCall),
        #[allow(missing_docs)]
        fheRotl(fheRotlCall),
        #[allow(missing_docs)]
        fheRotr(fheRotrCall),
        #[allow(missing_docs)]
        fheShl(fheShlCall),
        #[allow(missing_docs)]
        fheShr(fheShrCall),
        #[allow(missing_docs)]
        fheSub(fheSubCall),
        #[allow(missing_docs)]
        getACLAddress(getACLAddressCall),
        #[allow(missing_docs)]
        getHCULimitAddress(getHCULimitAddressCall),
        #[allow(missing_docs)]
        getHandleVersion(getHandleVersionCall),
        #[allow(missing_docs)]
        getInputVerifierAddress(getInputVerifierAddressCall),
        #[allow(missing_docs)]
        getVersion(getVersionCall),
        #[allow(missing_docs)]
        initializeFromEmptyProxy(initializeFromEmptyProxyCall),
        #[allow(missing_docs)]
        proxiableUUID(proxiableUUIDCall),
        #[allow(missing_docs)]
        trivialEncrypt(trivialEncryptCall),
        #[allow(missing_docs)]
        upgradeToAndCall(upgradeToAndCallCall),
        #[allow(missing_docs)]
        verifyInput(verifyInputCall),
    }
    #[automatically_derived]
    impl FHEVMExecutorCalls {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [4u8, 85u8, 159u8, 113u8],
            [8u8, 191u8, 131u8, 42u8],
            [13u8, 142u8, 110u8, 44u8],
            [17u8, 123u8, 47u8, 56u8],
            [19u8, 145u8, 84u8, 127u8],
            [24u8, 43u8, 109u8, 152u8],
            [28u8, 137u8, 238u8, 68u8],
            [54u8, 49u8, 141u8, 100u8],
            [57u8, 247u8, 56u8, 16u8],
            [72u8, 238u8, 244u8, 126u8],
            [79u8, 30u8, 242u8, 134u8],
            [82u8, 209u8, 144u8, 45u8],
            [87u8, 240u8, 165u8, 104u8],
            [90u8, 83u8, 172u8, 203u8],
            [99u8, 162u8, 219u8, 41u8],
            [103u8, 84u8, 179u8, 96u8],
            [114u8, 16u8, 118u8, 129u8],
            [117u8, 19u8, 164u8, 4u8],
            [119u8, 2u8, 220u8, 255u8],
            [122u8, 41u8, 127u8, 75u8],
            [133u8, 54u8, 46u8, 231u8],
            [139u8, 73u8, 206u8, 180u8],
            [145u8, 249u8, 143u8, 254u8],
            [156u8, 208u8, 122u8, 203u8],
            [168u8, 199u8, 194u8, 193u8],
            [173u8, 60u8, 177u8, 204u8],
            [192u8, 33u8, 50u8, 158u8],
            [204u8, 196u8, 128u8, 161u8],
            [207u8, 77u8, 24u8, 170u8],
            [213u8, 128u8, 192u8, 99u8],
            [215u8, 93u8, 110u8, 138u8],
            [216u8, 9u8, 44u8, 188u8],
            [217u8, 152u8, 130u8, 213u8],
            [224u8, 120u8, 105u8, 114u8],
            [245u8, 28u8, 207u8, 176u8],
            [246u8, 133u8, 155u8, 220u8],
            [247u8, 127u8, 63u8, 29u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for FHEVMExecutorCalls {
        const NAME: &'static str = "FHEVMExecutorCalls";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 37usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::UPGRADE_INTERFACE_VERSION(_) => {
                    <UPGRADE_INTERFACE_VERSIONCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::cast(_) => <castCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::fheAdd(_) => <fheAddCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::fheBitAnd(_) => {
                    <fheBitAndCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::fheBitOr(_) => <fheBitOrCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::fheBitXor(_) => {
                    <fheBitXorCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::fheDiv(_) => <fheDivCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::fheEq(_) => <fheEqCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::fheGe(_) => <fheGeCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::fheGt(_) => <fheGtCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::fheIfThenElse(_) => {
                    <fheIfThenElseCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::fheLe(_) => <fheLeCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::fheLt(_) => <fheLtCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::fheMax(_) => <fheMaxCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::fheMin(_) => <fheMinCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::fheMul(_) => <fheMulCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::fheNe(_) => <fheNeCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::fheNeg(_) => <fheNegCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::fheNot(_) => <fheNotCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::fheRand(_) => <fheRandCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::fheRandBounded(_) => {
                    <fheRandBoundedCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::fheRem(_) => <fheRemCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::fheRotl(_) => <fheRotlCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::fheRotr(_) => <fheRotrCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::fheShl(_) => <fheShlCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::fheShr(_) => <fheShrCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::fheSub(_) => <fheSubCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::getACLAddress(_) => {
                    <getACLAddressCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getHCULimitAddress(_) => {
                    <getHCULimitAddressCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getHandleVersion(_) => {
                    <getHandleVersionCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getInputVerifierAddress(_) => {
                    <getInputVerifierAddressCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getVersion(_) => {
                    <getVersionCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::initializeFromEmptyProxy(_) => {
                    <initializeFromEmptyProxyCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::proxiableUUID(_) => {
                    <proxiableUUIDCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::trivialEncrypt(_) => {
                    <trivialEncryptCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::upgradeToAndCall(_) => {
                    <upgradeToAndCallCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::verifyInput(_) => {
                    <verifyInputCall as alloy_sol_types::SolCall>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<FHEVMExecutorCalls>] = &[
                {
                    fn fheMin(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheMinCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(FHEVMExecutorCalls::fheMin)
                    }
                    fheMin
                },
                {
                    fn verifyInput(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <verifyInputCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(FHEVMExecutorCalls::verifyInput)
                    }
                    verifyInput
                },
                {
                    fn getVersion(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <getVersionCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(FHEVMExecutorCalls::getVersion)
                    }
                    getVersion
                },
                {
                    fn fheAdd(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheAddCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(FHEVMExecutorCalls::fheAdd)
                    }
                    fheAdd
                },
                {
                    fn fheGe(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheGeCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(FHEVMExecutorCalls::fheGe)
                    }
                    fheGe
                },
                {
                    fn fheSub(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheSubCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(FHEVMExecutorCalls::fheSub)
                    }
                    fheSub
                },
                {
                    fn cast(data: &[u8]) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <castCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(FHEVMExecutorCalls::cast)
                    }
                    cast
                },
                {
                    fn fheMax(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheMaxCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(FHEVMExecutorCalls::fheMax)
                    }
                    fheMax
                },
                {
                    fn initializeFromEmptyProxy(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <initializeFromEmptyProxyCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(FHEVMExecutorCalls::initializeFromEmptyProxy)
                    }
                    initializeFromEmptyProxy
                },
                {
                    fn fheRandBounded(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheRandBoundedCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(FHEVMExecutorCalls::fheRandBounded)
                    }
                    fheRandBounded
                },
                {
                    fn upgradeToAndCall(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <upgradeToAndCallCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(FHEVMExecutorCalls::upgradeToAndCall)
                    }
                    upgradeToAndCall
                },
                {
                    fn proxiableUUID(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <proxiableUUIDCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(FHEVMExecutorCalls::proxiableUUID)
                    }
                    proxiableUUID
                },
                {
                    fn fheMul(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheMulCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(FHEVMExecutorCalls::fheMul)
                    }
                    fheMul
                },
                {
                    fn fheDiv(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheDivCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(FHEVMExecutorCalls::fheDiv)
                    }
                    fheDiv
                },
                {
                    fn fheBitOr(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheBitOrCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(FHEVMExecutorCalls::fheBitOr)
                    }
                    fheBitOr
                },
                {
                    fn fheRotl(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheRotlCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(FHEVMExecutorCalls::fheRotl)
                    }
                    fheRotl
                },
                {
                    fn fheLt(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheLtCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(FHEVMExecutorCalls::fheLt)
                    }
                    fheLt
                },
                {
                    fn fheLe(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheLeCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(FHEVMExecutorCalls::fheLe)
                    }
                    fheLe
                },
                {
                    fn fheIfThenElse(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheIfThenElseCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(FHEVMExecutorCalls::fheIfThenElse)
                    }
                    fheIfThenElse
                },
                {
                    fn getHandleVersion(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <getHandleVersionCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(FHEVMExecutorCalls::getHandleVersion)
                    }
                    getHandleVersion
                },
                {
                    fn fheGt(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheGtCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(FHEVMExecutorCalls::fheGt)
                    }
                    fheGt
                },
                {
                    fn fheBitXor(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheBitXorCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(FHEVMExecutorCalls::fheBitXor)
                    }
                    fheBitXor
                },
                {
                    fn fheShr(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheShrCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(FHEVMExecutorCalls::fheShr)
                    }
                    fheShr
                },
                {
                    fn trivialEncrypt(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <trivialEncryptCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(FHEVMExecutorCalls::trivialEncrypt)
                    }
                    trivialEncrypt
                },
                {
                    fn getInputVerifierAddress(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <getInputVerifierAddressCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(FHEVMExecutorCalls::getInputVerifierAddress)
                    }
                    getInputVerifierAddress
                },
                {
                    fn UPGRADE_INTERFACE_VERSION(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <UPGRADE_INTERFACE_VERSIONCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(FHEVMExecutorCalls::UPGRADE_INTERFACE_VERSION)
                    }
                    UPGRADE_INTERFACE_VERSION
                },
                {
                    fn fheRotr(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheRotrCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(FHEVMExecutorCalls::fheRotr)
                    }
                    fheRotr
                },
                {
                    fn fheShl(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheShlCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(FHEVMExecutorCalls::fheShl)
                    }
                    fheShl
                },
                {
                    fn fheRem(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheRemCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(FHEVMExecutorCalls::fheRem)
                    }
                    fheRem
                },
                {
                    fn fheNeg(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheNegCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(FHEVMExecutorCalls::fheNeg)
                    }
                    fheNeg
                },
                {
                    fn fheRand(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheRandCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(FHEVMExecutorCalls::fheRand)
                    }
                    fheRand
                },
                {
                    fn fheNe(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheNeCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(FHEVMExecutorCalls::fheNe)
                    }
                    fheNe
                },
                {
                    fn fheBitAnd(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheBitAndCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(FHEVMExecutorCalls::fheBitAnd)
                    }
                    fheBitAnd
                },
                {
                    fn getHCULimitAddress(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <getHCULimitAddressCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(FHEVMExecutorCalls::getHCULimitAddress)
                    }
                    getHCULimitAddress
                },
                {
                    fn fheNot(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheNotCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(FHEVMExecutorCalls::fheNot)
                    }
                    fheNot
                },
                {
                    fn getACLAddress(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <getACLAddressCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(FHEVMExecutorCalls::getACLAddress)
                    }
                    getACLAddress
                },
                {
                    fn fheEq(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheEqCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(FHEVMExecutorCalls::fheEq)
                    }
                    fheEq
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data)
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw_validate(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_VALIDATE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<FHEVMExecutorCalls>] = &[
                {
                    fn fheMin(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheMinCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::fheMin)
                    }
                    fheMin
                },
                {
                    fn verifyInput(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <verifyInputCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::verifyInput)
                    }
                    verifyInput
                },
                {
                    fn getVersion(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <getVersionCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::getVersion)
                    }
                    getVersion
                },
                {
                    fn fheAdd(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheAddCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::fheAdd)
                    }
                    fheAdd
                },
                {
                    fn fheGe(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheGeCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::fheGe)
                    }
                    fheGe
                },
                {
                    fn fheSub(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheSubCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::fheSub)
                    }
                    fheSub
                },
                {
                    fn cast(data: &[u8]) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <castCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::cast)
                    }
                    cast
                },
                {
                    fn fheMax(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheMaxCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::fheMax)
                    }
                    fheMax
                },
                {
                    fn initializeFromEmptyProxy(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <initializeFromEmptyProxyCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::initializeFromEmptyProxy)
                    }
                    initializeFromEmptyProxy
                },
                {
                    fn fheRandBounded(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheRandBoundedCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::fheRandBounded)
                    }
                    fheRandBounded
                },
                {
                    fn upgradeToAndCall(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <upgradeToAndCallCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::upgradeToAndCall)
                    }
                    upgradeToAndCall
                },
                {
                    fn proxiableUUID(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <proxiableUUIDCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::proxiableUUID)
                    }
                    proxiableUUID
                },
                {
                    fn fheMul(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheMulCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::fheMul)
                    }
                    fheMul
                },
                {
                    fn fheDiv(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheDivCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::fheDiv)
                    }
                    fheDiv
                },
                {
                    fn fheBitOr(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheBitOrCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::fheBitOr)
                    }
                    fheBitOr
                },
                {
                    fn fheRotl(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheRotlCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::fheRotl)
                    }
                    fheRotl
                },
                {
                    fn fheLt(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheLtCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::fheLt)
                    }
                    fheLt
                },
                {
                    fn fheLe(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheLeCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::fheLe)
                    }
                    fheLe
                },
                {
                    fn fheIfThenElse(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheIfThenElseCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::fheIfThenElse)
                    }
                    fheIfThenElse
                },
                {
                    fn getHandleVersion(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <getHandleVersionCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::getHandleVersion)
                    }
                    getHandleVersion
                },
                {
                    fn fheGt(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheGtCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::fheGt)
                    }
                    fheGt
                },
                {
                    fn fheBitXor(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheBitXorCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::fheBitXor)
                    }
                    fheBitXor
                },
                {
                    fn fheShr(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheShrCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::fheShr)
                    }
                    fheShr
                },
                {
                    fn trivialEncrypt(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <trivialEncryptCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::trivialEncrypt)
                    }
                    trivialEncrypt
                },
                {
                    fn getInputVerifierAddress(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <getInputVerifierAddressCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::getInputVerifierAddress)
                    }
                    getInputVerifierAddress
                },
                {
                    fn UPGRADE_INTERFACE_VERSION(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <UPGRADE_INTERFACE_VERSIONCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::UPGRADE_INTERFACE_VERSION)
                    }
                    UPGRADE_INTERFACE_VERSION
                },
                {
                    fn fheRotr(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheRotrCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::fheRotr)
                    }
                    fheRotr
                },
                {
                    fn fheShl(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheShlCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::fheShl)
                    }
                    fheShl
                },
                {
                    fn fheRem(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheRemCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::fheRem)
                    }
                    fheRem
                },
                {
                    fn fheNeg(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheNegCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::fheNeg)
                    }
                    fheNeg
                },
                {
                    fn fheRand(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheRandCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::fheRand)
                    }
                    fheRand
                },
                {
                    fn fheNe(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheNeCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::fheNe)
                    }
                    fheNe
                },
                {
                    fn fheBitAnd(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheBitAndCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::fheBitAnd)
                    }
                    fheBitAnd
                },
                {
                    fn getHCULimitAddress(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <getHCULimitAddressCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::getHCULimitAddress)
                    }
                    getHCULimitAddress
                },
                {
                    fn fheNot(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheNotCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::fheNot)
                    }
                    fheNot
                },
                {
                    fn getACLAddress(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <getACLAddressCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::getACLAddress)
                    }
                    getACLAddress
                },
                {
                    fn fheEq(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheEqCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::fheEq)
                    }
                    fheEq
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_VALIDATE_SHIMS[idx](data)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::UPGRADE_INTERFACE_VERSION(inner) => {
                    <UPGRADE_INTERFACE_VERSIONCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::cast(inner) => {
                    <castCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::fheAdd(inner) => {
                    <fheAddCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::fheBitAnd(inner) => {
                    <fheBitAndCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::fheBitOr(inner) => {
                    <fheBitOrCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::fheBitXor(inner) => {
                    <fheBitXorCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::fheDiv(inner) => {
                    <fheDivCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::fheEq(inner) => {
                    <fheEqCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::fheGe(inner) => {
                    <fheGeCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::fheGt(inner) => {
                    <fheGtCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::fheIfThenElse(inner) => {
                    <fheIfThenElseCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::fheLe(inner) => {
                    <fheLeCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::fheLt(inner) => {
                    <fheLtCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::fheMax(inner) => {
                    <fheMaxCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::fheMin(inner) => {
                    <fheMinCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::fheMul(inner) => {
                    <fheMulCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::fheNe(inner) => {
                    <fheNeCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::fheNeg(inner) => {
                    <fheNegCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::fheNot(inner) => {
                    <fheNotCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::fheRand(inner) => {
                    <fheRandCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::fheRandBounded(inner) => {
                    <fheRandBoundedCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::fheRem(inner) => {
                    <fheRemCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::fheRotl(inner) => {
                    <fheRotlCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::fheRotr(inner) => {
                    <fheRotrCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::fheShl(inner) => {
                    <fheShlCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::fheShr(inner) => {
                    <fheShrCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::fheSub(inner) => {
                    <fheSubCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::getACLAddress(inner) => {
                    <getACLAddressCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getHCULimitAddress(inner) => {
                    <getHCULimitAddressCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getHandleVersion(inner) => {
                    <getHandleVersionCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getInputVerifierAddress(inner) => {
                    <getInputVerifierAddressCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getVersion(inner) => {
                    <getVersionCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::initializeFromEmptyProxy(inner) => {
                    <initializeFromEmptyProxyCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::proxiableUUID(inner) => {
                    <proxiableUUIDCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::trivialEncrypt(inner) => {
                    <trivialEncryptCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::upgradeToAndCall(inner) => {
                    <upgradeToAndCallCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::verifyInput(inner) => {
                    <verifyInputCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::UPGRADE_INTERFACE_VERSION(inner) => {
                    <UPGRADE_INTERFACE_VERSIONCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::cast(inner) => {
                    <castCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::fheAdd(inner) => {
                    <fheAddCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::fheBitAnd(inner) => {
                    <fheBitAndCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::fheBitOr(inner) => {
                    <fheBitOrCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::fheBitXor(inner) => {
                    <fheBitXorCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::fheDiv(inner) => {
                    <fheDivCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::fheEq(inner) => {
                    <fheEqCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::fheGe(inner) => {
                    <fheGeCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::fheGt(inner) => {
                    <fheGtCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::fheIfThenElse(inner) => {
                    <fheIfThenElseCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::fheLe(inner) => {
                    <fheLeCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::fheLt(inner) => {
                    <fheLtCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::fheMax(inner) => {
                    <fheMaxCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::fheMin(inner) => {
                    <fheMinCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::fheMul(inner) => {
                    <fheMulCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::fheNe(inner) => {
                    <fheNeCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::fheNeg(inner) => {
                    <fheNegCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::fheNot(inner) => {
                    <fheNotCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::fheRand(inner) => {
                    <fheRandCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::fheRandBounded(inner) => {
                    <fheRandBoundedCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::fheRem(inner) => {
                    <fheRemCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::fheRotl(inner) => {
                    <fheRotlCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::fheRotr(inner) => {
                    <fheRotrCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::fheShl(inner) => {
                    <fheShlCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::fheShr(inner) => {
                    <fheShrCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::fheSub(inner) => {
                    <fheSubCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::getACLAddress(inner) => {
                    <getACLAddressCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getHCULimitAddress(inner) => {
                    <getHCULimitAddressCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getHandleVersion(inner) => {
                    <getHandleVersionCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getInputVerifierAddress(inner) => {
                    <getInputVerifierAddressCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getVersion(inner) => {
                    <getVersionCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::initializeFromEmptyProxy(inner) => {
                    <initializeFromEmptyProxyCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::proxiableUUID(inner) => {
                    <proxiableUUIDCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::trivialEncrypt(inner) => {
                    <trivialEncryptCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::upgradeToAndCall(inner) => {
                    <upgradeToAndCallCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::verifyInput(inner) => {
                    <verifyInputCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`FHEVMExecutor`](self) custom errors.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub enum FHEVMExecutorErrors {
        #[allow(missing_docs)]
        ACLNotAllowed(ACLNotAllowed),
        #[allow(missing_docs)]
        AddressEmptyCode(AddressEmptyCode),
        #[allow(missing_docs)]
        DivisionByZero(DivisionByZero),
        #[allow(missing_docs)]
        ERC1967InvalidImplementation(ERC1967InvalidImplementation),
        #[allow(missing_docs)]
        ERC1967NonPayable(ERC1967NonPayable),
        #[allow(missing_docs)]
        FailedCall(FailedCall),
        #[allow(missing_docs)]
        IncompatibleTypes(IncompatibleTypes),
        #[allow(missing_docs)]
        InvalidByteLength(InvalidByteLength),
        #[allow(missing_docs)]
        InvalidInitialization(InvalidInitialization),
        #[allow(missing_docs)]
        InvalidType(InvalidType),
        #[allow(missing_docs)]
        IsNotScalar(IsNotScalar),
        #[allow(missing_docs)]
        NotHostOwner(NotHostOwner),
        #[allow(missing_docs)]
        NotInitializing(NotInitializing),
        #[allow(missing_docs)]
        NotInitializingFromEmptyProxy(NotInitializingFromEmptyProxy),
        #[allow(missing_docs)]
        NotPowerOfTwo(NotPowerOfTwo),
        #[allow(missing_docs)]
        ScalarByteIsNotBoolean(ScalarByteIsNotBoolean),
        #[allow(missing_docs)]
        SecondOperandIsNotScalar(SecondOperandIsNotScalar),
        #[allow(missing_docs)]
        UUPSUnauthorizedCallContext(UUPSUnauthorizedCallContext),
        #[allow(missing_docs)]
        UUPSUnsupportedProxiableUUID(UUPSUnsupportedProxiableUUID),
        #[allow(missing_docs)]
        UnsupportedType(UnsupportedType),
        #[allow(missing_docs)]
        UpperBoundAboveMaxTypeValue(UpperBoundAboveMaxTypeValue),
    }
    #[automatically_derived]
    impl FHEVMExecutorErrors {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [31u8, 49u8, 88u8, 199u8],
            [33u8, 191u8, 218u8, 16u8],
            [35u8, 211u8, 89u8, 163u8],
            [36u8, 232u8, 231u8, 66u8],
            [76u8, 156u8, 140u8, 227u8],
            [77u8, 222u8, 13u8, 152u8],
            [79u8, 34u8, 78u8, 83u8],
            [111u8, 79u8, 115u8, 31u8],
            [153u8, 150u8, 179u8, 21u8],
            [157u8, 227u8, 57u8, 44u8],
            [170u8, 29u8, 73u8, 164u8],
            [179u8, 12u8, 12u8, 87u8],
            [179u8, 152u8, 151u8, 159u8],
            [185u8, 104u8, 132u8, 97u8],
            [198u8, 222u8, 70u8, 106u8],
            [199u8, 218u8, 223u8, 69u8],
            [214u8, 189u8, 162u8, 117u8],
            [215u8, 230u8, 188u8, 248u8],
            [223u8, 123u8, 243u8, 37u8],
            [224u8, 124u8, 141u8, 186u8],
            [249u8, 46u8, 232u8, 169u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for FHEVMExecutorErrors {
        const NAME: &'static str = "FHEVMExecutorErrors";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 21usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::ACLNotAllowed(_) => {
                    <ACLNotAllowed as alloy_sol_types::SolError>::SELECTOR
                }
                Self::AddressEmptyCode(_) => {
                    <AddressEmptyCode as alloy_sol_types::SolError>::SELECTOR
                }
                Self::DivisionByZero(_) => {
                    <DivisionByZero as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC1967InvalidImplementation(_) => {
                    <ERC1967InvalidImplementation as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC1967NonPayable(_) => {
                    <ERC1967NonPayable as alloy_sol_types::SolError>::SELECTOR
                }
                Self::FailedCall(_) => {
                    <FailedCall as alloy_sol_types::SolError>::SELECTOR
                }
                Self::IncompatibleTypes(_) => {
                    <IncompatibleTypes as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidByteLength(_) => {
                    <InvalidByteLength as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidInitialization(_) => {
                    <InvalidInitialization as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidType(_) => {
                    <InvalidType as alloy_sol_types::SolError>::SELECTOR
                }
                Self::IsNotScalar(_) => {
                    <IsNotScalar as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NotHostOwner(_) => {
                    <NotHostOwner as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NotInitializing(_) => {
                    <NotInitializing as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NotInitializingFromEmptyProxy(_) => {
                    <NotInitializingFromEmptyProxy as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NotPowerOfTwo(_) => {
                    <NotPowerOfTwo as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ScalarByteIsNotBoolean(_) => {
                    <ScalarByteIsNotBoolean as alloy_sol_types::SolError>::SELECTOR
                }
                Self::SecondOperandIsNotScalar(_) => {
                    <SecondOperandIsNotScalar as alloy_sol_types::SolError>::SELECTOR
                }
                Self::UUPSUnauthorizedCallContext(_) => {
                    <UUPSUnauthorizedCallContext as alloy_sol_types::SolError>::SELECTOR
                }
                Self::UUPSUnsupportedProxiableUUID(_) => {
                    <UUPSUnsupportedProxiableUUID as alloy_sol_types::SolError>::SELECTOR
                }
                Self::UnsupportedType(_) => {
                    <UnsupportedType as alloy_sol_types::SolError>::SELECTOR
                }
                Self::UpperBoundAboveMaxTypeValue(_) => {
                    <UpperBoundAboveMaxTypeValue as alloy_sol_types::SolError>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<FHEVMExecutorErrors>] = &[
                {
                    fn IncompatibleTypes(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <IncompatibleTypes as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(FHEVMExecutorErrors::IncompatibleTypes)
                    }
                    IncompatibleTypes
                },
                {
                    fn NotHostOwner(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <NotHostOwner as alloy_sol_types::SolError>::abi_decode_raw(data)
                            .map(FHEVMExecutorErrors::NotHostOwner)
                    }
                    NotHostOwner
                },
                {
                    fn DivisionByZero(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <DivisionByZero as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(FHEVMExecutorErrors::DivisionByZero)
                    }
                    DivisionByZero
                },
                {
                    fn NotPowerOfTwo(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <NotPowerOfTwo as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(FHEVMExecutorErrors::NotPowerOfTwo)
                    }
                    NotPowerOfTwo
                },
                {
                    fn ERC1967InvalidImplementation(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <ERC1967InvalidImplementation as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(FHEVMExecutorErrors::ERC1967InvalidImplementation)
                    }
                    ERC1967InvalidImplementation
                },
                {
                    fn SecondOperandIsNotScalar(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <SecondOperandIsNotScalar as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(FHEVMExecutorErrors::SecondOperandIsNotScalar)
                    }
                    SecondOperandIsNotScalar
                },
                {
                    fn IsNotScalar(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <IsNotScalar as alloy_sol_types::SolError>::abi_decode_raw(data)
                            .map(FHEVMExecutorErrors::IsNotScalar)
                    }
                    IsNotScalar
                },
                {
                    fn NotInitializingFromEmptyProxy(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <NotInitializingFromEmptyProxy as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(FHEVMExecutorErrors::NotInitializingFromEmptyProxy)
                    }
                    NotInitializingFromEmptyProxy
                },
                {
                    fn AddressEmptyCode(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <AddressEmptyCode as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(FHEVMExecutorErrors::AddressEmptyCode)
                    }
                    AddressEmptyCode
                },
                {
                    fn ACLNotAllowed(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <ACLNotAllowed as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(FHEVMExecutorErrors::ACLNotAllowed)
                    }
                    ACLNotAllowed
                },
                {
                    fn UUPSUnsupportedProxiableUUID(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <UUPSUnsupportedProxiableUUID as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(FHEVMExecutorErrors::UUPSUnsupportedProxiableUUID)
                    }
                    UUPSUnsupportedProxiableUUID
                },
                {
                    fn InvalidByteLength(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <InvalidByteLength as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(FHEVMExecutorErrors::InvalidByteLength)
                    }
                    InvalidByteLength
                },
                {
                    fn ERC1967NonPayable(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <ERC1967NonPayable as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(FHEVMExecutorErrors::ERC1967NonPayable)
                    }
                    ERC1967NonPayable
                },
                {
                    fn InvalidType(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <InvalidType as alloy_sol_types::SolError>::abi_decode_raw(data)
                            .map(FHEVMExecutorErrors::InvalidType)
                    }
                    InvalidType
                },
                {
                    fn UnsupportedType(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <UnsupportedType as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(FHEVMExecutorErrors::UnsupportedType)
                    }
                    UnsupportedType
                },
                {
                    fn UpperBoundAboveMaxTypeValue(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <UpperBoundAboveMaxTypeValue as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(FHEVMExecutorErrors::UpperBoundAboveMaxTypeValue)
                    }
                    UpperBoundAboveMaxTypeValue
                },
                {
                    fn FailedCall(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <FailedCall as alloy_sol_types::SolError>::abi_decode_raw(data)
                            .map(FHEVMExecutorErrors::FailedCall)
                    }
                    FailedCall
                },
                {
                    fn NotInitializing(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <NotInitializing as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(FHEVMExecutorErrors::NotInitializing)
                    }
                    NotInitializing
                },
                {
                    fn ScalarByteIsNotBoolean(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <ScalarByteIsNotBoolean as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(FHEVMExecutorErrors::ScalarByteIsNotBoolean)
                    }
                    ScalarByteIsNotBoolean
                },
                {
                    fn UUPSUnauthorizedCallContext(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <UUPSUnauthorizedCallContext as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(FHEVMExecutorErrors::UUPSUnauthorizedCallContext)
                    }
                    UUPSUnauthorizedCallContext
                },
                {
                    fn InvalidInitialization(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <InvalidInitialization as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(FHEVMExecutorErrors::InvalidInitialization)
                    }
                    InvalidInitialization
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data)
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw_validate(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_VALIDATE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<FHEVMExecutorErrors>] = &[
                {
                    fn IncompatibleTypes(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <IncompatibleTypes as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorErrors::IncompatibleTypes)
                    }
                    IncompatibleTypes
                },
                {
                    fn NotHostOwner(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <NotHostOwner as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorErrors::NotHostOwner)
                    }
                    NotHostOwner
                },
                {
                    fn DivisionByZero(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <DivisionByZero as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorErrors::DivisionByZero)
                    }
                    DivisionByZero
                },
                {
                    fn NotPowerOfTwo(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <NotPowerOfTwo as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorErrors::NotPowerOfTwo)
                    }
                    NotPowerOfTwo
                },
                {
                    fn ERC1967InvalidImplementation(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <ERC1967InvalidImplementation as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorErrors::ERC1967InvalidImplementation)
                    }
                    ERC1967InvalidImplementation
                },
                {
                    fn SecondOperandIsNotScalar(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <SecondOperandIsNotScalar as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorErrors::SecondOperandIsNotScalar)
                    }
                    SecondOperandIsNotScalar
                },
                {
                    fn IsNotScalar(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <IsNotScalar as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorErrors::IsNotScalar)
                    }
                    IsNotScalar
                },
                {
                    fn NotInitializingFromEmptyProxy(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <NotInitializingFromEmptyProxy as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorErrors::NotInitializingFromEmptyProxy)
                    }
                    NotInitializingFromEmptyProxy
                },
                {
                    fn AddressEmptyCode(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <AddressEmptyCode as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorErrors::AddressEmptyCode)
                    }
                    AddressEmptyCode
                },
                {
                    fn ACLNotAllowed(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <ACLNotAllowed as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorErrors::ACLNotAllowed)
                    }
                    ACLNotAllowed
                },
                {
                    fn UUPSUnsupportedProxiableUUID(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <UUPSUnsupportedProxiableUUID as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorErrors::UUPSUnsupportedProxiableUUID)
                    }
                    UUPSUnsupportedProxiableUUID
                },
                {
                    fn InvalidByteLength(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <InvalidByteLength as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorErrors::InvalidByteLength)
                    }
                    InvalidByteLength
                },
                {
                    fn ERC1967NonPayable(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <ERC1967NonPayable as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorErrors::ERC1967NonPayable)
                    }
                    ERC1967NonPayable
                },
                {
                    fn InvalidType(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <InvalidType as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorErrors::InvalidType)
                    }
                    InvalidType
                },
                {
                    fn UnsupportedType(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <UnsupportedType as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorErrors::UnsupportedType)
                    }
                    UnsupportedType
                },
                {
                    fn UpperBoundAboveMaxTypeValue(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <UpperBoundAboveMaxTypeValue as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorErrors::UpperBoundAboveMaxTypeValue)
                    }
                    UpperBoundAboveMaxTypeValue
                },
                {
                    fn FailedCall(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <FailedCall as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorErrors::FailedCall)
                    }
                    FailedCall
                },
                {
                    fn NotInitializing(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <NotInitializing as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorErrors::NotInitializing)
                    }
                    NotInitializing
                },
                {
                    fn ScalarByteIsNotBoolean(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <ScalarByteIsNotBoolean as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorErrors::ScalarByteIsNotBoolean)
                    }
                    ScalarByteIsNotBoolean
                },
                {
                    fn UUPSUnauthorizedCallContext(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <UUPSUnauthorizedCallContext as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorErrors::UUPSUnauthorizedCallContext)
                    }
                    UUPSUnauthorizedCallContext
                },
                {
                    fn InvalidInitialization(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <InvalidInitialization as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorErrors::InvalidInitialization)
                    }
                    InvalidInitialization
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_VALIDATE_SHIMS[idx](data)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::ACLNotAllowed(inner) => {
                    <ACLNotAllowed as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::AddressEmptyCode(inner) => {
                    <AddressEmptyCode as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::DivisionByZero(inner) => {
                    <DivisionByZero as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC1967InvalidImplementation(inner) => {
                    <ERC1967InvalidImplementation as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC1967NonPayable(inner) => {
                    <ERC1967NonPayable as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::FailedCall(inner) => {
                    <FailedCall as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::IncompatibleTypes(inner) => {
                    <IncompatibleTypes as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidByteLength(inner) => {
                    <InvalidByteLength as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidInitialization(inner) => {
                    <InvalidInitialization as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidType(inner) => {
                    <InvalidType as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::IsNotScalar(inner) => {
                    <IsNotScalar as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::NotHostOwner(inner) => {
                    <NotHostOwner as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::NotInitializing(inner) => {
                    <NotInitializing as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NotInitializingFromEmptyProxy(inner) => {
                    <NotInitializingFromEmptyProxy as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NotPowerOfTwo(inner) => {
                    <NotPowerOfTwo as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::ScalarByteIsNotBoolean(inner) => {
                    <ScalarByteIsNotBoolean as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::SecondOperandIsNotScalar(inner) => {
                    <SecondOperandIsNotScalar as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::UUPSUnauthorizedCallContext(inner) => {
                    <UUPSUnauthorizedCallContext as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::UUPSUnsupportedProxiableUUID(inner) => {
                    <UUPSUnsupportedProxiableUUID as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::UnsupportedType(inner) => {
                    <UnsupportedType as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::UpperBoundAboveMaxTypeValue(inner) => {
                    <UpperBoundAboveMaxTypeValue as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::ACLNotAllowed(inner) => {
                    <ACLNotAllowed as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::AddressEmptyCode(inner) => {
                    <AddressEmptyCode as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::DivisionByZero(inner) => {
                    <DivisionByZero as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC1967InvalidImplementation(inner) => {
                    <ERC1967InvalidImplementation as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC1967NonPayable(inner) => {
                    <ERC1967NonPayable as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::FailedCall(inner) => {
                    <FailedCall as alloy_sol_types::SolError>::abi_encode_raw(inner, out)
                }
                Self::IncompatibleTypes(inner) => {
                    <IncompatibleTypes as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidByteLength(inner) => {
                    <InvalidByteLength as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidInitialization(inner) => {
                    <InvalidInitialization as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidType(inner) => {
                    <InvalidType as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::IsNotScalar(inner) => {
                    <IsNotScalar as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NotHostOwner(inner) => {
                    <NotHostOwner as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NotInitializing(inner) => {
                    <NotInitializing as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NotInitializingFromEmptyProxy(inner) => {
                    <NotInitializingFromEmptyProxy as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NotPowerOfTwo(inner) => {
                    <NotPowerOfTwo as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ScalarByteIsNotBoolean(inner) => {
                    <ScalarByteIsNotBoolean as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::SecondOperandIsNotScalar(inner) => {
                    <SecondOperandIsNotScalar as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::UUPSUnauthorizedCallContext(inner) => {
                    <UUPSUnauthorizedCallContext as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::UUPSUnsupportedProxiableUUID(inner) => {
                    <UUPSUnsupportedProxiableUUID as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::UnsupportedType(inner) => {
                    <UnsupportedType as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::UpperBoundAboveMaxTypeValue(inner) => {
                    <UpperBoundAboveMaxTypeValue as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`FHEVMExecutor`](self) events.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub enum FHEVMExecutorEvents {
        #[allow(missing_docs)]
        Cast(Cast),
        #[allow(missing_docs)]
        FheAdd(FheAdd),
        #[allow(missing_docs)]
        FheBitAnd(FheBitAnd),
        #[allow(missing_docs)]
        FheBitOr(FheBitOr),
        #[allow(missing_docs)]
        FheBitXor(FheBitXor),
        #[allow(missing_docs)]
        FheDiv(FheDiv),
        #[allow(missing_docs)]
        FheEq(FheEq),
        #[allow(missing_docs)]
        FheGe(FheGe),
        #[allow(missing_docs)]
        FheGt(FheGt),
        #[allow(missing_docs)]
        FheIfThenElse(FheIfThenElse),
        #[allow(missing_docs)]
        FheLe(FheLe),
        #[allow(missing_docs)]
        FheLt(FheLt),
        #[allow(missing_docs)]
        FheMax(FheMax),
        #[allow(missing_docs)]
        FheMin(FheMin),
        #[allow(missing_docs)]
        FheMul(FheMul),
        #[allow(missing_docs)]
        FheNe(FheNe),
        #[allow(missing_docs)]
        FheNeg(FheNeg),
        #[allow(missing_docs)]
        FheNot(FheNot),
        #[allow(missing_docs)]
        FheRand(FheRand),
        #[allow(missing_docs)]
        FheRandBounded(FheRandBounded),
        #[allow(missing_docs)]
        FheRem(FheRem),
        #[allow(missing_docs)]
        FheRotl(FheRotl),
        #[allow(missing_docs)]
        FheRotr(FheRotr),
        #[allow(missing_docs)]
        FheShl(FheShl),
        #[allow(missing_docs)]
        FheShr(FheShr),
        #[allow(missing_docs)]
        FheSub(FheSub),
        #[allow(missing_docs)]
        Initialized(Initialized),
        #[allow(missing_docs)]
        TrivialEncrypt(TrivialEncrypt),
        #[allow(missing_docs)]
        Upgraded(Upgraded),
        #[allow(missing_docs)]
        VerifyInput(VerifyInput),
    }
    #[automatically_derived]
    impl FHEVMExecutorEvents {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 32usize]] = &[
            [
                6u8, 60u8, 205u8, 27u8, 186u8, 69u8, 21u8, 29u8, 145u8, 246u8, 164u8,
                24u8, 6u8, 80u8, 71u8, 163u8, 208u8, 72u8, 208u8, 88u8, 169u8, 34u8,
                83u8, 87u8, 71u8, 187u8, 43u8, 87u8, 90u8, 1u8, 210u8, 54u8,
            ],
            [
                12u8, 138u8, 202u8, 96u8, 23u8, 0u8, 51u8, 38u8, 5u8, 30u8, 25u8, 145u8,
                62u8, 240u8, 38u8, 49u8, 242u8, 75u8, 128u8, 17u8, 37u8, 225u8, 250u8,
                138u8, 29u8, 129u8, 46u8, 134u8, 131u8, 25u8, 253u8, 166u8,
            ],
            [
                13u8, 72u8, 59u8, 16u8, 13u8, 140u8, 115u8, 178u8, 8u8, 152u8, 78u8,
                198u8, 151u8, 202u8, 163u8, 9u8, 21u8, 33u8, 238u8, 85u8, 37u8, 206u8,
                105u8, 237u8, 207u8, 151u8, 215u8, 227u8, 149u8, 211u8, 208u8, 89u8,
            ],
            [
                14u8, 105u8, 28u8, 208u8, 191u8, 140u8, 78u8, 147u8, 8u8, 228u8, 206u8,
                209u8, 187u8, 156u8, 150u8, 65u8, 23u8, 220u8, 92u8, 91u8, 185u8, 185u8,
                171u8, 91u8, 223u8, 235u8, 242u8, 201u8, 177u8, 58u8, 137u8, 124u8,
            ],
            [
                33u8, 83u8, 70u8, 164u8, 249u8, 249u8, 117u8, 230u8, 213u8, 72u8, 78u8,
                41u8, 11u8, 212u8, 229u8, 60u8, 161u8, 68u8, 83u8, 169u8, 210u8, 130u8,
                235u8, 211u8, 204u8, 237u8, 178u8, 160u8, 241u8, 113u8, 117u8, 61u8,
            ],
            [
                49u8, 204u8, 174u8, 106u8, 47u8, 142u8, 60u8, 237u8, 22u8, 146u8, 247u8,
                124u8, 143u8, 102u8, 129u8, 51u8, 228u8, 175u8, 218u8, 170u8, 53u8,
                175u8, 232u8, 68u8, 255u8, 70u8, 89u8, 166u8, 194u8, 126u8, 98u8, 127u8,
            ],
            [
                50u8, 66u8, 32u8, 191u8, 201u8, 203u8, 21u8, 139u8, 73u8, 41u8, 145u8,
                192u8, 60u8, 48u8, 156u8, 216u8, 110u8, 83u8, 69u8, 202u8, 196u8, 90u8,
                172u8, 174u8, 32u8, 146u8, 221u8, 171u8, 227u8, 31u8, 163u8, 216u8,
            ],
            [
                56u8, 195u8, 166u8, 60u8, 66u8, 48u8, 222u8, 91u8, 116u8, 31u8, 73u8,
                79u8, 251u8, 84u8, 227u8, 8u8, 113u8, 4u8, 3u8, 2u8, 121u8, 188u8, 123u8,
                204u8, 238u8, 138u8, 217u8, 173u8, 49u8, 113u8, 43u8, 33u8,
            ],
            [
                59u8, 171u8, 46u8, 224u8, 226u8, 249u8, 15u8, 70u8, 144u8, 198u8, 168u8,
                123u8, 246u8, 60u8, 241u8, 166u8, 182u8, 38u8, 8u8, 110u8, 149u8, 242u8,
                49u8, 134u8, 11u8, 21u8, 41u8, 102u8, 232u8, 218u8, 187u8, 247u8,
            ],
            [
                77u8, 50u8, 40u8, 75u8, 211u8, 25u8, 62u8, 202u8, 164u8, 78u8, 28u8,
                236u8, 163u8, 47u8, 65u8, 197u8, 214u8, 195u8, 40u8, 3u8, 169u8, 46u8,
                7u8, 150u8, 125u8, 211u8, 238u8, 66u8, 41u8, 114u8, 21u8, 130u8,
            ],
            [
                82u8, 34u8, 217u8, 107u8, 131u8, 103u8, 39u8, 161u8, 214u8, 254u8, 30u8,
                233u8, 174u8, 242u8, 127u8, 155u8, 181u8, 7u8, 189u8, 65u8, 121u8, 77u8,
                239u8, 163u8, 118u8, 255u8, 108u8, 100u8, 138u8, 175u8, 143u8, 241u8,
            ],
            [
                85u8, 175u8, 244u8, 204u8, 122u8, 61u8, 22u8, 12u8, 131u8, 241u8, 241u8,
                91u8, 129u8, 128u8, 17u8, 237u8, 232u8, 65u8, 160u8, 180u8, 89u8, 127u8,
                177u8, 77u8, 205u8, 54u8, 3u8, 223u8, 58u8, 17u8, 229u8, 224u8,
            ],
            [
                86u8, 223u8, 39u8, 155u8, 191u8, 176u8, 61u8, 158u8, 208u8, 151u8, 187u8,
                226u8, 242u8, 141u8, 82u8, 12u8, 160u8, 193u8, 22u8, 18u8, 6u8, 50u8,
                121u8, 38u8, 233u8, 134u8, 100u8, 215u8, 13u8, 44u8, 36u8, 196u8,
            ],
            [
                96u8, 190u8, 157u8, 97u8, 170u8, 216u8, 73u8, 250u8, 204u8, 40u8, 195u8,
                139u8, 4u8, 140u8, 181u8, 196u8, 190u8, 52u8, 32u8, 184u8, 250u8, 34u8,
                51u8, 224u8, 140u8, 250u8, 6u8, 190u8, 27u8, 109u8, 28u8, 62u8,
            ],
            [
                105u8, 96u8, 193u8, 232u8, 143u8, 97u8, 195u8, 82u8, 219u8, 163u8, 77u8,
                27u8, 191u8, 103u8, 83u8, 227u8, 2u8, 121u8, 82u8, 100u8, 213u8, 216u8,
                174u8, 130u8, 247u8, 152u8, 60u8, 112u8, 4u8, 101u8, 30u8, 93u8,
            ],
            [
                140u8, 102u8, 77u8, 60u8, 60u8, 165u8, 131u8, 252u8, 88u8, 3u8, 184u8,
                169u8, 28u8, 73u8, 100u8, 75u8, 189u8, 149u8, 80u8, 191u8, 168u8, 121u8,
                103u8, 199u8, 58u8, 209u8, 222u8, 131u8, 2u8, 119u8, 104u8, 192u8,
            ],
            [
                179u8, 213u8, 198u8, 100u8, 236u8, 134u8, 87u8, 88u8, 24u8, 232u8, 215u8,
                95u8, 242u8, 92u8, 95u8, 134u8, 114u8, 80u8, 223u8, 137u8, 84u8, 8u8,
                133u8, 73u8, 196u8, 28u8, 132u8, 140u8, 209u8, 14u8, 118u8, 203u8,
            ],
            [
                188u8, 124u8, 215u8, 90u8, 32u8, 238u8, 39u8, 253u8, 154u8, 222u8, 186u8,
                179u8, 32u8, 65u8, 247u8, 85u8, 33u8, 77u8, 188u8, 107u8, 255u8, 169u8,
                12u8, 192u8, 34u8, 91u8, 57u8, 218u8, 46u8, 92u8, 45u8, 59u8,
            ],
            [
                193u8, 29u8, 98u8, 177u8, 60u8, 54u8, 10u8, 131u8, 8u8, 36u8, 135u8, 6u8,
                75u8, 225u8, 236u8, 8u8, 120u8, 178u8, 240u8, 190u8, 79u8, 1u8, 43u8,
                245u8, 159u8, 137u8, 225u8, 40u8, 6u8, 61u8, 71u8, 255u8,
            ],
            [
                193u8, 72u8, 103u8, 89u8, 5u8, 208u8, 122u8, 213u8, 73u8, 111u8, 142u8,
                244u8, 216u8, 25u8, 92u8, 144u8, 117u8, 3u8, 243u8, 236u8, 18u8, 253u8,
                16u8, 237u8, 95u8, 33u8, 36u8, 10u8, 188u8, 105u8, 54u8, 52u8,
            ],
            [
                199u8, 245u8, 5u8, 178u8, 243u8, 113u8, 174u8, 33u8, 117u8, 238u8, 73u8,
                19u8, 244u8, 73u8, 158u8, 31u8, 38u8, 51u8, 167u8, 181u8, 147u8, 99u8,
                33u8, 238u8, 209u8, 205u8, 174u8, 182u8, 17u8, 81u8, 129u8, 210u8,
            ],
            [
                201u8, 255u8, 143u8, 13u8, 24u8, 163u8, 247u8, 102u8, 206u8, 93u8, 227u8,
                222u8, 33u8, 96u8, 118u8, 5u8, 1u8, 64u8, 228u8, 252u8, 38u8, 82u8,
                245u8, 224u8, 231u8, 69u8, 246u8, 252u8, 131u8, 108u8, 218u8, 139u8,
            ],
            [
                219u8, 144u8, 80u8, 214u8, 82u8, 64u8, 67u8, 22u8, 33u8, 214u8, 29u8,
                111u8, 148u8, 185u8, 112u8, 230u8, 63u8, 83u8, 166u8, 122u8, 87u8, 102u8,
                97u8, 78u8, 230u8, 229u8, 197u8, 187u8, 212u8, 28u8, 142u8, 46u8,
            ],
            [
                220u8, 55u8, 13u8, 179u8, 53u8, 137u8, 231u8, 51u8, 113u8, 220u8, 62u8,
                228u8, 44u8, 120u8, 156u8, 0u8, 61u8, 51u8, 110u8, 239u8, 203u8, 124u8,
                63u8, 86u8, 254u8, 15u8, 81u8, 174u8, 91u8, 29u8, 151u8, 2u8,
            ],
            [
                222u8, 242u8, 231u8, 4u8, 160u8, 119u8, 40u8, 74u8, 7u8, 243u8, 208u8,
                180u8, 54u8, 219u8, 136u8, 245u8, 217u8, 129u8, 182u8, 159u8, 88u8,
                171u8, 124u8, 26u8, 230u8, 35u8, 37u8, 39u8, 24u8, 166u8, 222u8, 1u8,
            ],
            [
                228u8, 36u8, 134u8, 176u8, 204u8, 219u8, 239u8, 129u8, 162u8, 7u8, 92u8,
                72u8, 200u8, 229u8, 21u8, 192u8, 121u8, 174u8, 167u8, 60u8, 139u8, 130u8,
                66u8, 153u8, 151u8, 199u8, 42u8, 47u8, 225u8, 191u8, 79u8, 239u8,
            ],
            [
                232u8, 66u8, 130u8, 170u8, 235u8, 204u8, 166u8, 152u8, 68u8, 62u8, 57u8,
                162u8, 169u8, 72u8, 163u8, 69u8, 208u8, 210u8, 235u8, 198u8, 84u8, 175u8,
                92u8, 182u8, 87u8, 162u8, 215u8, 232u8, 5u8, 59u8, 246u8, 203u8,
            ],
            [
                235u8, 14u8, 79u8, 141u8, 199u8, 64u8, 88u8, 25u8, 77u8, 6u8, 2u8, 66u8,
                95u8, 230u8, 2u8, 249u8, 85u8, 194u8, 34u8, 32u8, 15u8, 127u8, 16u8,
                198u8, 254u8, 103u8, 153u8, 47u8, 123u8, 36u8, 199u8, 233u8,
            ],
            [
                235u8, 109u8, 55u8, 189u8, 39u8, 26u8, 190u8, 19u8, 149u8, 178u8, 29u8,
                109u8, 120u8, 243u8, 72u8, 125u8, 101u8, 132u8, 134u8, 40u8, 114u8,
                194u8, 159u8, 253u8, 63u8, 144u8, 115u8, 110u8, 233u8, 155u8, 115u8,
                147u8,
            ],
            [
                253u8, 124u8, 146u8, 8u8, 249u8, 86u8, 191u8, 12u8, 106u8, 183u8, 106u8,
                102u8, 127u8, 4u8, 54u8, 18u8, 69u8, 173u8, 62u8, 10u8, 45u8, 14u8,
                255u8, 146u8, 235u8, 130u8, 122u8, 207u8, 204u8, 166u8, 142u8, 169u8,
            ],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolEventInterface for FHEVMExecutorEvents {
        const NAME: &'static str = "FHEVMExecutorEvents";
        const COUNT: usize = 30usize;
        fn decode_raw_log(
            topics: &[alloy_sol_types::Word],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            match topics.first().copied() {
                Some(<Cast as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Cast as alloy_sol_types::SolEvent>::decode_raw_log(topics, data)
                        .map(Self::Cast)
                }
                Some(<FheAdd as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <FheAdd as alloy_sol_types::SolEvent>::decode_raw_log(topics, data)
                        .map(Self::FheAdd)
                }
                Some(<FheBitAnd as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <FheBitAnd as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::FheBitAnd)
                }
                Some(<FheBitOr as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <FheBitOr as alloy_sol_types::SolEvent>::decode_raw_log(topics, data)
                        .map(Self::FheBitOr)
                }
                Some(<FheBitXor as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <FheBitXor as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::FheBitXor)
                }
                Some(<FheDiv as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <FheDiv as alloy_sol_types::SolEvent>::decode_raw_log(topics, data)
                        .map(Self::FheDiv)
                }
                Some(<FheEq as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <FheEq as alloy_sol_types::SolEvent>::decode_raw_log(topics, data)
                        .map(Self::FheEq)
                }
                Some(<FheGe as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <FheGe as alloy_sol_types::SolEvent>::decode_raw_log(topics, data)
                        .map(Self::FheGe)
                }
                Some(<FheGt as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <FheGt as alloy_sol_types::SolEvent>::decode_raw_log(topics, data)
                        .map(Self::FheGt)
                }
                Some(<FheIfThenElse as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <FheIfThenElse as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::FheIfThenElse)
                }
                Some(<FheLe as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <FheLe as alloy_sol_types::SolEvent>::decode_raw_log(topics, data)
                        .map(Self::FheLe)
                }
                Some(<FheLt as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <FheLt as alloy_sol_types::SolEvent>::decode_raw_log(topics, data)
                        .map(Self::FheLt)
                }
                Some(<FheMax as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <FheMax as alloy_sol_types::SolEvent>::decode_raw_log(topics, data)
                        .map(Self::FheMax)
                }
                Some(<FheMin as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <FheMin as alloy_sol_types::SolEvent>::decode_raw_log(topics, data)
                        .map(Self::FheMin)
                }
                Some(<FheMul as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <FheMul as alloy_sol_types::SolEvent>::decode_raw_log(topics, data)
                        .map(Self::FheMul)
                }
                Some(<FheNe as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <FheNe as alloy_sol_types::SolEvent>::decode_raw_log(topics, data)
                        .map(Self::FheNe)
                }
                Some(<FheNeg as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <FheNeg as alloy_sol_types::SolEvent>::decode_raw_log(topics, data)
                        .map(Self::FheNeg)
                }
                Some(<FheNot as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <FheNot as alloy_sol_types::SolEvent>::decode_raw_log(topics, data)
                        .map(Self::FheNot)
                }
                Some(<FheRand as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <FheRand as alloy_sol_types::SolEvent>::decode_raw_log(topics, data)
                        .map(Self::FheRand)
                }
                Some(<FheRandBounded as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <FheRandBounded as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::FheRandBounded)
                }
                Some(<FheRem as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <FheRem as alloy_sol_types::SolEvent>::decode_raw_log(topics, data)
                        .map(Self::FheRem)
                }
                Some(<FheRotl as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <FheRotl as alloy_sol_types::SolEvent>::decode_raw_log(topics, data)
                        .map(Self::FheRotl)
                }
                Some(<FheRotr as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <FheRotr as alloy_sol_types::SolEvent>::decode_raw_log(topics, data)
                        .map(Self::FheRotr)
                }
                Some(<FheShl as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <FheShl as alloy_sol_types::SolEvent>::decode_raw_log(topics, data)
                        .map(Self::FheShl)
                }
                Some(<FheShr as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <FheShr as alloy_sol_types::SolEvent>::decode_raw_log(topics, data)
                        .map(Self::FheShr)
                }
                Some(<FheSub as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <FheSub as alloy_sol_types::SolEvent>::decode_raw_log(topics, data)
                        .map(Self::FheSub)
                }
                Some(<Initialized as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Initialized as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::Initialized)
                }
                Some(<TrivialEncrypt as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <TrivialEncrypt as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::TrivialEncrypt)
                }
                Some(<Upgraded as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Upgraded as alloy_sol_types::SolEvent>::decode_raw_log(topics, data)
                        .map(Self::Upgraded)
                }
                Some(<VerifyInput as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <VerifyInput as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::VerifyInput)
                }
                _ => {
                    alloy_sol_types::private::Err(alloy_sol_types::Error::InvalidLog {
                        name: <Self as alloy_sol_types::SolEventInterface>::NAME,
                        log: alloy_sol_types::private::Box::new(
                            alloy_sol_types::private::LogData::new_unchecked(
                                topics.to_vec(),
                                data.to_vec().into(),
                            ),
                        ),
                    })
                }
            }
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::private::IntoLogData for FHEVMExecutorEvents {
        fn to_log_data(&self) -> alloy_sol_types::private::LogData {
            match self {
                Self::Cast(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::FheAdd(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::FheBitAnd(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::FheBitOr(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::FheBitXor(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::FheDiv(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::FheEq(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::FheGe(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::FheGt(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::FheIfThenElse(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::FheLe(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::FheLt(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::FheMax(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::FheMin(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::FheMul(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::FheNe(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::FheNeg(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::FheNot(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::FheRand(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::FheRandBounded(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::FheRem(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::FheRotl(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::FheRotr(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::FheShl(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::FheShr(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::FheSub(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Initialized(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::TrivialEncrypt(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Upgraded(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::VerifyInput(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
            }
        }
        fn into_log_data(self) -> alloy_sol_types::private::LogData {
            match self {
                Self::Cast(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::FheAdd(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::FheBitAnd(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::FheBitOr(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::FheBitXor(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::FheDiv(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::FheEq(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::FheGe(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::FheGt(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::FheIfThenElse(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::FheLe(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::FheLt(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::FheMax(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::FheMin(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::FheMul(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::FheNe(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::FheNeg(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::FheNot(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::FheRand(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::FheRandBounded(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::FheRem(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::FheRotl(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::FheRotr(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::FheShl(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::FheShr(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::FheSub(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Initialized(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::TrivialEncrypt(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Upgraded(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::VerifyInput(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`FHEVMExecutor`](self) contract instance.

See the [wrapper's documentation](`FHEVMExecutorInstance`) for more details.*/
    #[inline]
    pub const fn new<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> FHEVMExecutorInstance<P, N> {
        FHEVMExecutorInstance::<P, N>::new(address, provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
    ) -> impl ::core::future::Future<
        Output = alloy_contract::Result<FHEVMExecutorInstance<P, N>>,
    > {
        FHEVMExecutorInstance::<P, N>::deploy(provider)
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(provider: P) -> alloy_contract::RawCallBuilder<P, N> {
        FHEVMExecutorInstance::<P, N>::deploy_builder(provider)
    }
    /**A [`FHEVMExecutor`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`FHEVMExecutor`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct FHEVMExecutorInstance<P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network: ::core::marker::PhantomData<N>,
    }
    #[automatically_derived]
    impl<P, N> ::core::fmt::Debug for FHEVMExecutorInstance<P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("FHEVMExecutorInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > FHEVMExecutorInstance<P, N> {
        /**Creates a new wrapper around an on-chain [`FHEVMExecutor`](self) contract instance.

See the [wrapper's documentation](`FHEVMExecutorInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            provider: P,
        ) -> Self {
            Self {
                address,
                provider,
                _network: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            provider: P,
        ) -> alloy_contract::Result<FHEVMExecutorInstance<P, N>> {
            let call_builder = Self::deploy_builder(provider);
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(provider: P) -> alloy_contract::RawCallBuilder<P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                provider,
                ::core::clone::Clone::clone(&BYTECODE),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<P: ::core::clone::Clone, N> FHEVMExecutorInstance<&P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> FHEVMExecutorInstance<P, N> {
            FHEVMExecutorInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > FHEVMExecutorInstance<P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<&P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        ///Creates a new call builder for the [`UPGRADE_INTERFACE_VERSION`] function.
        pub fn UPGRADE_INTERFACE_VERSION(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, UPGRADE_INTERFACE_VERSIONCall, N> {
            self.call_builder(&UPGRADE_INTERFACE_VERSIONCall)
        }
        ///Creates a new call builder for the [`cast`] function.
        pub fn cast(
            &self,
            ct: alloy::sol_types::private::FixedBytes<32>,
            toType: <FheType as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<&P, castCall, N> {
            self.call_builder(&castCall { ct, toType })
        }
        ///Creates a new call builder for the [`fheAdd`] function.
        pub fn fheAdd(
            &self,
            lhs: alloy::sol_types::private::FixedBytes<32>,
            rhs: alloy::sol_types::private::FixedBytes<32>,
            scalarByte: alloy::sol_types::private::FixedBytes<1>,
        ) -> alloy_contract::SolCallBuilder<&P, fheAddCall, N> {
            self.call_builder(&fheAddCall { lhs, rhs, scalarByte })
        }
        ///Creates a new call builder for the [`fheBitAnd`] function.
        pub fn fheBitAnd(
            &self,
            lhs: alloy::sol_types::private::FixedBytes<32>,
            rhs: alloy::sol_types::private::FixedBytes<32>,
            scalarByte: alloy::sol_types::private::FixedBytes<1>,
        ) -> alloy_contract::SolCallBuilder<&P, fheBitAndCall, N> {
            self.call_builder(
                &fheBitAndCall {
                    lhs,
                    rhs,
                    scalarByte,
                },
            )
        }
        ///Creates a new call builder for the [`fheBitOr`] function.
        pub fn fheBitOr(
            &self,
            lhs: alloy::sol_types::private::FixedBytes<32>,
            rhs: alloy::sol_types::private::FixedBytes<32>,
            scalarByte: alloy::sol_types::private::FixedBytes<1>,
        ) -> alloy_contract::SolCallBuilder<&P, fheBitOrCall, N> {
            self.call_builder(
                &fheBitOrCall {
                    lhs,
                    rhs,
                    scalarByte,
                },
            )
        }
        ///Creates a new call builder for the [`fheBitXor`] function.
        pub fn fheBitXor(
            &self,
            lhs: alloy::sol_types::private::FixedBytes<32>,
            rhs: alloy::sol_types::private::FixedBytes<32>,
            scalarByte: alloy::sol_types::private::FixedBytes<1>,
        ) -> alloy_contract::SolCallBuilder<&P, fheBitXorCall, N> {
            self.call_builder(
                &fheBitXorCall {
                    lhs,
                    rhs,
                    scalarByte,
                },
            )
        }
        ///Creates a new call builder for the [`fheDiv`] function.
        pub fn fheDiv(
            &self,
            lhs: alloy::sol_types::private::FixedBytes<32>,
            rhs: alloy::sol_types::private::FixedBytes<32>,
            scalarByte: alloy::sol_types::private::FixedBytes<1>,
        ) -> alloy_contract::SolCallBuilder<&P, fheDivCall, N> {
            self.call_builder(&fheDivCall { lhs, rhs, scalarByte })
        }
        ///Creates a new call builder for the [`fheEq`] function.
        pub fn fheEq(
            &self,
            lhs: alloy::sol_types::private::FixedBytes<32>,
            rhs: alloy::sol_types::private::FixedBytes<32>,
            scalarByte: alloy::sol_types::private::FixedBytes<1>,
        ) -> alloy_contract::SolCallBuilder<&P, fheEqCall, N> {
            self.call_builder(&fheEqCall { lhs, rhs, scalarByte })
        }
        ///Creates a new call builder for the [`fheGe`] function.
        pub fn fheGe(
            &self,
            lhs: alloy::sol_types::private::FixedBytes<32>,
            rhs: alloy::sol_types::private::FixedBytes<32>,
            scalarByte: alloy::sol_types::private::FixedBytes<1>,
        ) -> alloy_contract::SolCallBuilder<&P, fheGeCall, N> {
            self.call_builder(&fheGeCall { lhs, rhs, scalarByte })
        }
        ///Creates a new call builder for the [`fheGt`] function.
        pub fn fheGt(
            &self,
            lhs: alloy::sol_types::private::FixedBytes<32>,
            rhs: alloy::sol_types::private::FixedBytes<32>,
            scalarByte: alloy::sol_types::private::FixedBytes<1>,
        ) -> alloy_contract::SolCallBuilder<&P, fheGtCall, N> {
            self.call_builder(&fheGtCall { lhs, rhs, scalarByte })
        }
        ///Creates a new call builder for the [`fheIfThenElse`] function.
        pub fn fheIfThenElse(
            &self,
            control: alloy::sol_types::private::FixedBytes<32>,
            ifTrue: alloy::sol_types::private::FixedBytes<32>,
            ifFalse: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<&P, fheIfThenElseCall, N> {
            self.call_builder(
                &fheIfThenElseCall {
                    control,
                    ifTrue,
                    ifFalse,
                },
            )
        }
        ///Creates a new call builder for the [`fheLe`] function.
        pub fn fheLe(
            &self,
            lhs: alloy::sol_types::private::FixedBytes<32>,
            rhs: alloy::sol_types::private::FixedBytes<32>,
            scalarByte: alloy::sol_types::private::FixedBytes<1>,
        ) -> alloy_contract::SolCallBuilder<&P, fheLeCall, N> {
            self.call_builder(&fheLeCall { lhs, rhs, scalarByte })
        }
        ///Creates a new call builder for the [`fheLt`] function.
        pub fn fheLt(
            &self,
            lhs: alloy::sol_types::private::FixedBytes<32>,
            rhs: alloy::sol_types::private::FixedBytes<32>,
            scalarByte: alloy::sol_types::private::FixedBytes<1>,
        ) -> alloy_contract::SolCallBuilder<&P, fheLtCall, N> {
            self.call_builder(&fheLtCall { lhs, rhs, scalarByte })
        }
        ///Creates a new call builder for the [`fheMax`] function.
        pub fn fheMax(
            &self,
            lhs: alloy::sol_types::private::FixedBytes<32>,
            rhs: alloy::sol_types::private::FixedBytes<32>,
            scalarByte: alloy::sol_types::private::FixedBytes<1>,
        ) -> alloy_contract::SolCallBuilder<&P, fheMaxCall, N> {
            self.call_builder(&fheMaxCall { lhs, rhs, scalarByte })
        }
        ///Creates a new call builder for the [`fheMin`] function.
        pub fn fheMin(
            &self,
            lhs: alloy::sol_types::private::FixedBytes<32>,
            rhs: alloy::sol_types::private::FixedBytes<32>,
            scalarByte: alloy::sol_types::private::FixedBytes<1>,
        ) -> alloy_contract::SolCallBuilder<&P, fheMinCall, N> {
            self.call_builder(&fheMinCall { lhs, rhs, scalarByte })
        }
        ///Creates a new call builder for the [`fheMul`] function.
        pub fn fheMul(
            &self,
            lhs: alloy::sol_types::private::FixedBytes<32>,
            rhs: alloy::sol_types::private::FixedBytes<32>,
            scalarByte: alloy::sol_types::private::FixedBytes<1>,
        ) -> alloy_contract::SolCallBuilder<&P, fheMulCall, N> {
            self.call_builder(&fheMulCall { lhs, rhs, scalarByte })
        }
        ///Creates a new call builder for the [`fheNe`] function.
        pub fn fheNe(
            &self,
            lhs: alloy::sol_types::private::FixedBytes<32>,
            rhs: alloy::sol_types::private::FixedBytes<32>,
            scalarByte: alloy::sol_types::private::FixedBytes<1>,
        ) -> alloy_contract::SolCallBuilder<&P, fheNeCall, N> {
            self.call_builder(&fheNeCall { lhs, rhs, scalarByte })
        }
        ///Creates a new call builder for the [`fheNeg`] function.
        pub fn fheNeg(
            &self,
            ct: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<&P, fheNegCall, N> {
            self.call_builder(&fheNegCall { ct })
        }
        ///Creates a new call builder for the [`fheNot`] function.
        pub fn fheNot(
            &self,
            ct: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<&P, fheNotCall, N> {
            self.call_builder(&fheNotCall { ct })
        }
        ///Creates a new call builder for the [`fheRand`] function.
        pub fn fheRand(
            &self,
            randType: <FheType as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<&P, fheRandCall, N> {
            self.call_builder(&fheRandCall { randType })
        }
        ///Creates a new call builder for the [`fheRandBounded`] function.
        pub fn fheRandBounded(
            &self,
            upperBound: alloy::sol_types::private::primitives::aliases::U256,
            randType: <FheType as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<&P, fheRandBoundedCall, N> {
            self.call_builder(
                &fheRandBoundedCall {
                    upperBound,
                    randType,
                },
            )
        }
        ///Creates a new call builder for the [`fheRem`] function.
        pub fn fheRem(
            &self,
            lhs: alloy::sol_types::private::FixedBytes<32>,
            rhs: alloy::sol_types::private::FixedBytes<32>,
            scalarByte: alloy::sol_types::private::FixedBytes<1>,
        ) -> alloy_contract::SolCallBuilder<&P, fheRemCall, N> {
            self.call_builder(&fheRemCall { lhs, rhs, scalarByte })
        }
        ///Creates a new call builder for the [`fheRotl`] function.
        pub fn fheRotl(
            &self,
            lhs: alloy::sol_types::private::FixedBytes<32>,
            rhs: alloy::sol_types::private::FixedBytes<32>,
            scalarByte: alloy::sol_types::private::FixedBytes<1>,
        ) -> alloy_contract::SolCallBuilder<&P, fheRotlCall, N> {
            self.call_builder(
                &fheRotlCall {
                    lhs,
                    rhs,
                    scalarByte,
                },
            )
        }
        ///Creates a new call builder for the [`fheRotr`] function.
        pub fn fheRotr(
            &self,
            lhs: alloy::sol_types::private::FixedBytes<32>,
            rhs: alloy::sol_types::private::FixedBytes<32>,
            scalarByte: alloy::sol_types::private::FixedBytes<1>,
        ) -> alloy_contract::SolCallBuilder<&P, fheRotrCall, N> {
            self.call_builder(
                &fheRotrCall {
                    lhs,
                    rhs,
                    scalarByte,
                },
            )
        }
        ///Creates a new call builder for the [`fheShl`] function.
        pub fn fheShl(
            &self,
            lhs: alloy::sol_types::private::FixedBytes<32>,
            rhs: alloy::sol_types::private::FixedBytes<32>,
            scalarByte: alloy::sol_types::private::FixedBytes<1>,
        ) -> alloy_contract::SolCallBuilder<&P, fheShlCall, N> {
            self.call_builder(&fheShlCall { lhs, rhs, scalarByte })
        }
        ///Creates a new call builder for the [`fheShr`] function.
        pub fn fheShr(
            &self,
            lhs: alloy::sol_types::private::FixedBytes<32>,
            rhs: alloy::sol_types::private::FixedBytes<32>,
            scalarByte: alloy::sol_types::private::FixedBytes<1>,
        ) -> alloy_contract::SolCallBuilder<&P, fheShrCall, N> {
            self.call_builder(&fheShrCall { lhs, rhs, scalarByte })
        }
        ///Creates a new call builder for the [`fheSub`] function.
        pub fn fheSub(
            &self,
            lhs: alloy::sol_types::private::FixedBytes<32>,
            rhs: alloy::sol_types::private::FixedBytes<32>,
            scalarByte: alloy::sol_types::private::FixedBytes<1>,
        ) -> alloy_contract::SolCallBuilder<&P, fheSubCall, N> {
            self.call_builder(&fheSubCall { lhs, rhs, scalarByte })
        }
        ///Creates a new call builder for the [`getACLAddress`] function.
        pub fn getACLAddress(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, getACLAddressCall, N> {
            self.call_builder(&getACLAddressCall)
        }
        ///Creates a new call builder for the [`getHCULimitAddress`] function.
        pub fn getHCULimitAddress(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, getHCULimitAddressCall, N> {
            self.call_builder(&getHCULimitAddressCall)
        }
        ///Creates a new call builder for the [`getHandleVersion`] function.
        pub fn getHandleVersion(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, getHandleVersionCall, N> {
            self.call_builder(&getHandleVersionCall)
        }
        ///Creates a new call builder for the [`getInputVerifierAddress`] function.
        pub fn getInputVerifierAddress(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, getInputVerifierAddressCall, N> {
            self.call_builder(&getInputVerifierAddressCall)
        }
        ///Creates a new call builder for the [`getVersion`] function.
        pub fn getVersion(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, getVersionCall, N> {
            self.call_builder(&getVersionCall)
        }
        ///Creates a new call builder for the [`initializeFromEmptyProxy`] function.
        pub fn initializeFromEmptyProxy(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, initializeFromEmptyProxyCall, N> {
            self.call_builder(&initializeFromEmptyProxyCall)
        }
        ///Creates a new call builder for the [`proxiableUUID`] function.
        pub fn proxiableUUID(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, proxiableUUIDCall, N> {
            self.call_builder(&proxiableUUIDCall)
        }
        ///Creates a new call builder for the [`trivialEncrypt`] function.
        pub fn trivialEncrypt(
            &self,
            pt: alloy::sol_types::private::primitives::aliases::U256,
            toType: <FheType as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<&P, trivialEncryptCall, N> {
            self.call_builder(&trivialEncryptCall { pt, toType })
        }
        ///Creates a new call builder for the [`upgradeToAndCall`] function.
        pub fn upgradeToAndCall(
            &self,
            newImplementation: alloy::sol_types::private::Address,
            data: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<&P, upgradeToAndCallCall, N> {
            self.call_builder(
                &upgradeToAndCallCall {
                    newImplementation,
                    data,
                },
            )
        }
        ///Creates a new call builder for the [`verifyInput`] function.
        pub fn verifyInput(
            &self,
            inputHandle: alloy::sol_types::private::FixedBytes<32>,
            userAddress: alloy::sol_types::private::Address,
            inputProof: alloy::sol_types::private::Bytes,
            inputType: <FheType as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<&P, verifyInputCall, N> {
            self.call_builder(
                &verifyInputCall {
                    inputHandle,
                    userAddress,
                    inputProof,
                    inputType,
                },
            )
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > FHEVMExecutorInstance<P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<&P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
        ///Creates a new event filter for the [`Cast`] event.
        pub fn Cast_filter(&self) -> alloy_contract::Event<&P, Cast, N> {
            self.event_filter::<Cast>()
        }
        ///Creates a new event filter for the [`FheAdd`] event.
        pub fn FheAdd_filter(&self) -> alloy_contract::Event<&P, FheAdd, N> {
            self.event_filter::<FheAdd>()
        }
        ///Creates a new event filter for the [`FheBitAnd`] event.
        pub fn FheBitAnd_filter(&self) -> alloy_contract::Event<&P, FheBitAnd, N> {
            self.event_filter::<FheBitAnd>()
        }
        ///Creates a new event filter for the [`FheBitOr`] event.
        pub fn FheBitOr_filter(&self) -> alloy_contract::Event<&P, FheBitOr, N> {
            self.event_filter::<FheBitOr>()
        }
        ///Creates a new event filter for the [`FheBitXor`] event.
        pub fn FheBitXor_filter(&self) -> alloy_contract::Event<&P, FheBitXor, N> {
            self.event_filter::<FheBitXor>()
        }
        ///Creates a new event filter for the [`FheDiv`] event.
        pub fn FheDiv_filter(&self) -> alloy_contract::Event<&P, FheDiv, N> {
            self.event_filter::<FheDiv>()
        }
        ///Creates a new event filter for the [`FheEq`] event.
        pub fn FheEq_filter(&self) -> alloy_contract::Event<&P, FheEq, N> {
            self.event_filter::<FheEq>()
        }
        ///Creates a new event filter for the [`FheGe`] event.
        pub fn FheGe_filter(&self) -> alloy_contract::Event<&P, FheGe, N> {
            self.event_filter::<FheGe>()
        }
        ///Creates a new event filter for the [`FheGt`] event.
        pub fn FheGt_filter(&self) -> alloy_contract::Event<&P, FheGt, N> {
            self.event_filter::<FheGt>()
        }
        ///Creates a new event filter for the [`FheIfThenElse`] event.
        pub fn FheIfThenElse_filter(
            &self,
        ) -> alloy_contract::Event<&P, FheIfThenElse, N> {
            self.event_filter::<FheIfThenElse>()
        }
        ///Creates a new event filter for the [`FheLe`] event.
        pub fn FheLe_filter(&self) -> alloy_contract::Event<&P, FheLe, N> {
            self.event_filter::<FheLe>()
        }
        ///Creates a new event filter for the [`FheLt`] event.
        pub fn FheLt_filter(&self) -> alloy_contract::Event<&P, FheLt, N> {
            self.event_filter::<FheLt>()
        }
        ///Creates a new event filter for the [`FheMax`] event.
        pub fn FheMax_filter(&self) -> alloy_contract::Event<&P, FheMax, N> {
            self.event_filter::<FheMax>()
        }
        ///Creates a new event filter for the [`FheMin`] event.
        pub fn FheMin_filter(&self) -> alloy_contract::Event<&P, FheMin, N> {
            self.event_filter::<FheMin>()
        }
        ///Creates a new event filter for the [`FheMul`] event.
        pub fn FheMul_filter(&self) -> alloy_contract::Event<&P, FheMul, N> {
            self.event_filter::<FheMul>()
        }
        ///Creates a new event filter for the [`FheNe`] event.
        pub fn FheNe_filter(&self) -> alloy_contract::Event<&P, FheNe, N> {
            self.event_filter::<FheNe>()
        }
        ///Creates a new event filter for the [`FheNeg`] event.
        pub fn FheNeg_filter(&self) -> alloy_contract::Event<&P, FheNeg, N> {
            self.event_filter::<FheNeg>()
        }
        ///Creates a new event filter for the [`FheNot`] event.
        pub fn FheNot_filter(&self) -> alloy_contract::Event<&P, FheNot, N> {
            self.event_filter::<FheNot>()
        }
        ///Creates a new event filter for the [`FheRand`] event.
        pub fn FheRand_filter(&self) -> alloy_contract::Event<&P, FheRand, N> {
            self.event_filter::<FheRand>()
        }
        ///Creates a new event filter for the [`FheRandBounded`] event.
        pub fn FheRandBounded_filter(
            &self,
        ) -> alloy_contract::Event<&P, FheRandBounded, N> {
            self.event_filter::<FheRandBounded>()
        }
        ///Creates a new event filter for the [`FheRem`] event.
        pub fn FheRem_filter(&self) -> alloy_contract::Event<&P, FheRem, N> {
            self.event_filter::<FheRem>()
        }
        ///Creates a new event filter for the [`FheRotl`] event.
        pub fn FheRotl_filter(&self) -> alloy_contract::Event<&P, FheRotl, N> {
            self.event_filter::<FheRotl>()
        }
        ///Creates a new event filter for the [`FheRotr`] event.
        pub fn FheRotr_filter(&self) -> alloy_contract::Event<&P, FheRotr, N> {
            self.event_filter::<FheRotr>()
        }
        ///Creates a new event filter for the [`FheShl`] event.
        pub fn FheShl_filter(&self) -> alloy_contract::Event<&P, FheShl, N> {
            self.event_filter::<FheShl>()
        }
        ///Creates a new event filter for the [`FheShr`] event.
        pub fn FheShr_filter(&self) -> alloy_contract::Event<&P, FheShr, N> {
            self.event_filter::<FheShr>()
        }
        ///Creates a new event filter for the [`FheSub`] event.
        pub fn FheSub_filter(&self) -> alloy_contract::Event<&P, FheSub, N> {
            self.event_filter::<FheSub>()
        }
        ///Creates a new event filter for the [`Initialized`] event.
        pub fn Initialized_filter(&self) -> alloy_contract::Event<&P, Initialized, N> {
            self.event_filter::<Initialized>()
        }
        ///Creates a new event filter for the [`TrivialEncrypt`] event.
        pub fn TrivialEncrypt_filter(
            &self,
        ) -> alloy_contract::Event<&P, TrivialEncrypt, N> {
            self.event_filter::<TrivialEncrypt>()
        }
        ///Creates a new event filter for the [`Upgraded`] event.
        pub fn Upgraded_filter(&self) -> alloy_contract::Event<&P, Upgraded, N> {
            self.event_filter::<Upgraded>()
        }
        ///Creates a new event filter for the [`VerifyInput`] event.
        pub fn VerifyInput_filter(&self) -> alloy_contract::Event<&P, VerifyInput, N> {
            self.event_filter::<VerifyInput>()
        }
    }
}
