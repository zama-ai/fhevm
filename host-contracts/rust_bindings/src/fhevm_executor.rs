/**

Generated by the following Solidity interface...
```solidity
interface FHEVMExecutor {
    type FheType is uint8;

    error ACLNotAllowed(bytes32 handle, address account);
    error AddressEmptyCode(address target);
    error DivisionByZero();
    error ERC1967InvalidImplementation(address implementation);
    error ERC1967NonPayable();
    error FailedCall();
    error IncompatibleTypes();
    error InvalidByteLength(FheType typeOf, uint256 length);
    error InvalidInitialization();
    error InvalidType();
    error IsNotScalar();
    error NotHostOwner(address sender);
    error NotInitializing();
    error NotInitializingFromEmptyProxy();
    error NotPowerOfTwo();
    error ScalarByteIsNotBoolean();
    error SecondOperandIsNotScalar();
    error UUPSUnauthorizedCallContext();
    error UUPSUnsupportedProxiableUUID(bytes32 slot);
    error UnsupportedType();
    error UpperBoundAboveMaxTypeValue();

    event Cast(address indexed caller, bytes32 ct, FheType toType, bytes32 result);
    event FheAdd(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
    event FheBitAnd(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
    event FheBitOr(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
    event FheBitXor(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
    event FheDiv(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
    event FheEq(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
    event FheGe(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
    event FheGt(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
    event FheIfThenElse(address indexed caller, bytes32 control, bytes32 ifTrue, bytes32 ifFalse, bytes32 result);
    event FheLe(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
    event FheLt(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
    event FheMax(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
    event FheMin(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
    event FheMul(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
    event FheNe(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
    event FheNeg(address indexed caller, bytes32 ct, bytes32 result);
    event FheNot(address indexed caller, bytes32 ct, bytes32 result);
    event FheRand(address indexed caller, FheType randType, bytes16 seed, bytes32 result);
    event FheRandBounded(address indexed caller, uint256 upperBound, FheType randType, bytes16 seed, bytes32 result);
    event FheRem(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
    event FheRotl(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
    event FheRotr(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
    event FheShl(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
    event FheShr(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
    event FheSub(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
    event Initialized(uint64 version);
    event TrivialEncrypt(address indexed caller, uint256 pt, FheType toType, bytes32 result);
    event Upgraded(address indexed implementation);
    event VerifyInput(address indexed caller, bytes32 inputHandle, address userAddress, bytes inputProof, FheType inputType, bytes32 result);

    constructor();

    function UPGRADE_INTERFACE_VERSION() external view returns (string memory);
    function cast(bytes32 ct, FheType toType) external returns (bytes32 result);
    function fheAdd(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
    function fheBitAnd(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
    function fheBitOr(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
    function fheBitXor(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
    function fheDiv(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
    function fheEq(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
    function fheGe(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
    function fheGt(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
    function fheIfThenElse(bytes32 control, bytes32 ifTrue, bytes32 ifFalse) external returns (bytes32 result);
    function fheLe(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
    function fheLt(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
    function fheMax(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
    function fheMin(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
    function fheMul(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
    function fheNe(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
    function fheNeg(bytes32 ct) external returns (bytes32 result);
    function fheNot(bytes32 ct) external returns (bytes32 result);
    function fheRand(FheType randType) external returns (bytes32 result);
    function fheRandBounded(uint256 upperBound, FheType randType) external returns (bytes32 result);
    function fheRem(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
    function fheRotl(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
    function fheRotr(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
    function fheShl(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
    function fheShr(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
    function fheSub(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
    function getACLAddress() external view returns (address);
    function getHCULimitAddress() external view returns (address);
    function getHandleVersion() external pure returns (uint8);
    function getInputVerifierAddress() external view returns (address);
    function getVersion() external pure returns (string memory);
    function initializeFromEmptyProxy() external;
    function proxiableUUID() external view returns (bytes32);
    function reinitializeV3() external;
    function trivialEncrypt(uint256 pt, FheType toType) external returns (bytes32 result);
    function upgradeToAndCall(address newImplementation, bytes memory data) external payable;
    function verifyInput(bytes32 inputHandle, address userAddress, bytes memory inputProof, FheType inputType) external returns (bytes32 result);
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "constructor",
    "inputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "UPGRADE_INTERFACE_VERSION",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "cast",
    "inputs": [
      {
        "name": "ct",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "toType",
        "type": "uint8",
        "internalType": "enum FheType"
      }
    ],
    "outputs": [
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "fheAdd",
    "inputs": [
      {
        "name": "lhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "internalType": "bytes1"
      }
    ],
    "outputs": [
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "fheBitAnd",
    "inputs": [
      {
        "name": "lhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "internalType": "bytes1"
      }
    ],
    "outputs": [
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "fheBitOr",
    "inputs": [
      {
        "name": "lhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "internalType": "bytes1"
      }
    ],
    "outputs": [
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "fheBitXor",
    "inputs": [
      {
        "name": "lhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "internalType": "bytes1"
      }
    ],
    "outputs": [
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "fheDiv",
    "inputs": [
      {
        "name": "lhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "internalType": "bytes1"
      }
    ],
    "outputs": [
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "fheEq",
    "inputs": [
      {
        "name": "lhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "internalType": "bytes1"
      }
    ],
    "outputs": [
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "fheGe",
    "inputs": [
      {
        "name": "lhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "internalType": "bytes1"
      }
    ],
    "outputs": [
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "fheGt",
    "inputs": [
      {
        "name": "lhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "internalType": "bytes1"
      }
    ],
    "outputs": [
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "fheIfThenElse",
    "inputs": [
      {
        "name": "control",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "ifTrue",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "ifFalse",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "fheLe",
    "inputs": [
      {
        "name": "lhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "internalType": "bytes1"
      }
    ],
    "outputs": [
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "fheLt",
    "inputs": [
      {
        "name": "lhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "internalType": "bytes1"
      }
    ],
    "outputs": [
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "fheMax",
    "inputs": [
      {
        "name": "lhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "internalType": "bytes1"
      }
    ],
    "outputs": [
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "fheMin",
    "inputs": [
      {
        "name": "lhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "internalType": "bytes1"
      }
    ],
    "outputs": [
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "fheMul",
    "inputs": [
      {
        "name": "lhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "internalType": "bytes1"
      }
    ],
    "outputs": [
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "fheNe",
    "inputs": [
      {
        "name": "lhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "internalType": "bytes1"
      }
    ],
    "outputs": [
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "fheNeg",
    "inputs": [
      {
        "name": "ct",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "fheNot",
    "inputs": [
      {
        "name": "ct",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "fheRand",
    "inputs": [
      {
        "name": "randType",
        "type": "uint8",
        "internalType": "enum FheType"
      }
    ],
    "outputs": [
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "fheRandBounded",
    "inputs": [
      {
        "name": "upperBound",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "randType",
        "type": "uint8",
        "internalType": "enum FheType"
      }
    ],
    "outputs": [
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "fheRem",
    "inputs": [
      {
        "name": "lhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "internalType": "bytes1"
      }
    ],
    "outputs": [
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "fheRotl",
    "inputs": [
      {
        "name": "lhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "internalType": "bytes1"
      }
    ],
    "outputs": [
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "fheRotr",
    "inputs": [
      {
        "name": "lhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "internalType": "bytes1"
      }
    ],
    "outputs": [
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "fheShl",
    "inputs": [
      {
        "name": "lhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "internalType": "bytes1"
      }
    ],
    "outputs": [
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "fheShr",
    "inputs": [
      {
        "name": "lhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "internalType": "bytes1"
      }
    ],
    "outputs": [
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "fheSub",
    "inputs": [
      {
        "name": "lhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "internalType": "bytes1"
      }
    ],
    "outputs": [
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "getACLAddress",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getHCULimitAddress",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getHandleVersion",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint8",
        "internalType": "uint8"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "getInputVerifierAddress",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getVersion",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "initializeFromEmptyProxy",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "proxiableUUID",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "reinitializeV3",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "trivialEncrypt",
    "inputs": [
      {
        "name": "pt",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "toType",
        "type": "uint8",
        "internalType": "enum FheType"
      }
    ],
    "outputs": [
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "upgradeToAndCall",
    "inputs": [
      {
        "name": "newImplementation",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "data",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [],
    "stateMutability": "payable"
  },
  {
    "type": "function",
    "name": "verifyInput",
    "inputs": [
      {
        "name": "inputHandle",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "userAddress",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "inputProof",
        "type": "bytes",
        "internalType": "bytes"
      },
      {
        "name": "inputType",
        "type": "uint8",
        "internalType": "enum FheType"
      }
    ],
    "outputs": [
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "event",
    "name": "Cast",
    "inputs": [
      {
        "name": "caller",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "ct",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "toType",
        "type": "uint8",
        "indexed": false,
        "internalType": "enum FheType"
      },
      {
        "name": "result",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "FheAdd",
    "inputs": [
      {
        "name": "caller",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "lhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "indexed": false,
        "internalType": "bytes1"
      },
      {
        "name": "result",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "FheBitAnd",
    "inputs": [
      {
        "name": "caller",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "lhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "indexed": false,
        "internalType": "bytes1"
      },
      {
        "name": "result",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "FheBitOr",
    "inputs": [
      {
        "name": "caller",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "lhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "indexed": false,
        "internalType": "bytes1"
      },
      {
        "name": "result",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "FheBitXor",
    "inputs": [
      {
        "name": "caller",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "lhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "indexed": false,
        "internalType": "bytes1"
      },
      {
        "name": "result",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "FheDiv",
    "inputs": [
      {
        "name": "caller",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "lhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "indexed": false,
        "internalType": "bytes1"
      },
      {
        "name": "result",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "FheEq",
    "inputs": [
      {
        "name": "caller",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "lhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "indexed": false,
        "internalType": "bytes1"
      },
      {
        "name": "result",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "FheGe",
    "inputs": [
      {
        "name": "caller",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "lhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "indexed": false,
        "internalType": "bytes1"
      },
      {
        "name": "result",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "FheGt",
    "inputs": [
      {
        "name": "caller",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "lhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "indexed": false,
        "internalType": "bytes1"
      },
      {
        "name": "result",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "FheIfThenElse",
    "inputs": [
      {
        "name": "caller",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "control",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "ifTrue",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "ifFalse",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "result",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "FheLe",
    "inputs": [
      {
        "name": "caller",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "lhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "indexed": false,
        "internalType": "bytes1"
      },
      {
        "name": "result",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "FheLt",
    "inputs": [
      {
        "name": "caller",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "lhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "indexed": false,
        "internalType": "bytes1"
      },
      {
        "name": "result",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "FheMax",
    "inputs": [
      {
        "name": "caller",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "lhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "indexed": false,
        "internalType": "bytes1"
      },
      {
        "name": "result",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "FheMin",
    "inputs": [
      {
        "name": "caller",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "lhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "indexed": false,
        "internalType": "bytes1"
      },
      {
        "name": "result",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "FheMul",
    "inputs": [
      {
        "name": "caller",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "lhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "indexed": false,
        "internalType": "bytes1"
      },
      {
        "name": "result",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "FheNe",
    "inputs": [
      {
        "name": "caller",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "lhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "indexed": false,
        "internalType": "bytes1"
      },
      {
        "name": "result",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "FheNeg",
    "inputs": [
      {
        "name": "caller",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "ct",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "result",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "FheNot",
    "inputs": [
      {
        "name": "caller",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "ct",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "result",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "FheRand",
    "inputs": [
      {
        "name": "caller",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "randType",
        "type": "uint8",
        "indexed": false,
        "internalType": "enum FheType"
      },
      {
        "name": "seed",
        "type": "bytes16",
        "indexed": false,
        "internalType": "bytes16"
      },
      {
        "name": "result",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "FheRandBounded",
    "inputs": [
      {
        "name": "caller",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "upperBound",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "randType",
        "type": "uint8",
        "indexed": false,
        "internalType": "enum FheType"
      },
      {
        "name": "seed",
        "type": "bytes16",
        "indexed": false,
        "internalType": "bytes16"
      },
      {
        "name": "result",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "FheRem",
    "inputs": [
      {
        "name": "caller",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "lhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "indexed": false,
        "internalType": "bytes1"
      },
      {
        "name": "result",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "FheRotl",
    "inputs": [
      {
        "name": "caller",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "lhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "indexed": false,
        "internalType": "bytes1"
      },
      {
        "name": "result",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "FheRotr",
    "inputs": [
      {
        "name": "caller",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "lhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "indexed": false,
        "internalType": "bytes1"
      },
      {
        "name": "result",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "FheShl",
    "inputs": [
      {
        "name": "caller",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "lhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "indexed": false,
        "internalType": "bytes1"
      },
      {
        "name": "result",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "FheShr",
    "inputs": [
      {
        "name": "caller",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "lhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "indexed": false,
        "internalType": "bytes1"
      },
      {
        "name": "result",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "FheSub",
    "inputs": [
      {
        "name": "caller",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "lhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "indexed": false,
        "internalType": "bytes1"
      },
      {
        "name": "result",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Initialized",
    "inputs": [
      {
        "name": "version",
        "type": "uint64",
        "indexed": false,
        "internalType": "uint64"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "TrivialEncrypt",
    "inputs": [
      {
        "name": "caller",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "pt",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "toType",
        "type": "uint8",
        "indexed": false,
        "internalType": "enum FheType"
      },
      {
        "name": "result",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Upgraded",
    "inputs": [
      {
        "name": "implementation",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "VerifyInput",
    "inputs": [
      {
        "name": "caller",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "inputHandle",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "userAddress",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      },
      {
        "name": "inputProof",
        "type": "bytes",
        "indexed": false,
        "internalType": "bytes"
      },
      {
        "name": "inputType",
        "type": "uint8",
        "indexed": false,
        "internalType": "enum FheType"
      },
      {
        "name": "result",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "error",
    "name": "ACLNotAllowed",
    "inputs": [
      {
        "name": "handle",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "AddressEmptyCode",
    "inputs": [
      {
        "name": "target",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "DivisionByZero",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ERC1967InvalidImplementation",
    "inputs": [
      {
        "name": "implementation",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "ERC1967NonPayable",
    "inputs": []
  },
  {
    "type": "error",
    "name": "FailedCall",
    "inputs": []
  },
  {
    "type": "error",
    "name": "IncompatibleTypes",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidByteLength",
    "inputs": [
      {
        "name": "typeOf",
        "type": "uint8",
        "internalType": "enum FheType"
      },
      {
        "name": "length",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "InvalidInitialization",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidType",
    "inputs": []
  },
  {
    "type": "error",
    "name": "IsNotScalar",
    "inputs": []
  },
  {
    "type": "error",
    "name": "NotHostOwner",
    "inputs": [
      {
        "name": "sender",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "NotInitializing",
    "inputs": []
  },
  {
    "type": "error",
    "name": "NotInitializingFromEmptyProxy",
    "inputs": []
  },
  {
    "type": "error",
    "name": "NotPowerOfTwo",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ScalarByteIsNotBoolean",
    "inputs": []
  },
  {
    "type": "error",
    "name": "SecondOperandIsNotScalar",
    "inputs": []
  },
  {
    "type": "error",
    "name": "UUPSUnauthorizedCallContext",
    "inputs": []
  },
  {
    "type": "error",
    "name": "UUPSUnsupportedProxiableUUID",
    "inputs": [
      {
        "name": "slot",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ]
  },
  {
    "type": "error",
    "name": "UnsupportedType",
    "inputs": []
  },
  {
    "type": "error",
    "name": "UpperBoundAboveMaxTypeValue",
    "inputs": []
  }
]
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod FHEVMExecutor {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x60a06040523073ffffffffffffffffffffffffffffffffffffffff1660809073ffffffffffffffffffffffffffffffffffffffff1681525034801562000043575f80fd5b50620000546200005a60201b60201c565b620001c4565b5f6200006b6200015e60201b60201c565b9050805f0160089054906101000a900460ff1615620000b6576040517ff92ee8a900000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b67ffffffffffffffff8016815f015f9054906101000a900467ffffffffffffffff1667ffffffffffffffff16146200015b5767ffffffffffffffff815f015f6101000a81548167ffffffffffffffff021916908367ffffffffffffffff1602179055507fc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d267ffffffffffffffff604051620001529190620001a9565b60405180910390a15b50565b5f7ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00905090565b5f67ffffffffffffffff82169050919050565b620001a38162000185565b82525050565b5f602082019050620001be5f83018462000198565b92915050565b60805161724d620001eb5f395f8181614ce601528181614d3b0152614fdd015261724d5ff3fe608060405260043610610224575f3560e01c80637a297f4b11610122578063ccc480a1116100aa578063d99882d51161006e578063d99882d51461091e578063e07869721461095a578063f51ccfb014610984578063f6859bdc146109c0578063f77f3f1d146109ea57610224565b8063ccc480a1146107f2578063cf4d18aa1461082e578063d580c0631461086a578063d75d6e8a146108a6578063d8092cbc146108e257610224565b80639cd07acb116100f15780639cd07acb14610710578063a8c7c2c11461074c578063ad3cb1cc14610776578063bac22bb8146107a0578063c021329e146107b657610224565b80637a297f4b1461063257806385362ee71461065c5780638b49ceb41461069857806391f98ffe146106d457610224565b806348eef47e116101b057806363a2db291161017457806363a2db29146105065780636754b36014610542578063721076811461057e5780637513a404146105ba5780637702dcff146105f657610224565b806348eef47e1461040c5780634f1ef2861461044857806352d1902d1461046457806357f0a5681461048e5780635a53accb146104ca57610224565b80631391547f116101f75780631391547f14610306578063182b6d98146103425780631c89ee441461037e57806336318d64146103ba57806339f73810146103f657610224565b806304559f711461022857806308bf832a146102645780630d8e6e2c146102a0578063117b2f38146102ca575b5f80fd5b348015610233575f80fd5b5061024e60048036038101906102499190615ff4565b610a26565b60405161025b9190616053565b60405180910390f35b34801561026f575f80fd5b5061028a60048036038101906102859190616225565b610bd7565b6040516102979190616053565b60405180910390f35b3480156102ab575f80fd5b506102b4610df4565b6040516102c1919061631f565b60405180910390f35b3480156102d5575f80fd5b506102f060048036038101906102eb9190615ff4565b610e6f565b6040516102fd9190616053565b60405180910390f35b348015610311575f80fd5b5061032c60048036038101906103279190615ff4565b61101f565b6040516103399190616053565b60405180910390f35b34801561034d575f80fd5b5061036860048036038101906103639190615ff4565b6111d0565b6040516103759190616053565b60405180910390f35b348015610389575f80fd5b506103a4600480360381019061039f919061633f565b611381565b6040516103b19190616053565b60405180910390f35b3480156103c5575f80fd5b506103e060048036038101906103db9190615ff4565b61188c565b6040516103ed9190616053565b60405180910390f35b348015610401575f80fd5b5061040a611a3d565b005b348015610417575f80fd5b50610432600480360381019061042d91906163b0565b611bad565b60405161043f9190616053565b60405180910390f35b610462600480360381019061045d91906163ee565b611c21565b005b34801561046f575f80fd5b50610478611c40565b6040516104859190616053565b60405180910390f35b348015610499575f80fd5b506104b460048036038101906104af9190615ff4565b611c71565b6040516104c19190616053565b60405180910390f35b3480156104d5575f80fd5b506104f060048036038101906104eb9190615ff4565b611e22565b6040516104fd9190616053565b60405180910390f35b348015610511575f80fd5b5061052c60048036038101906105279190615ff4565b61206d565b6040516105399190616053565b60405180910390f35b34801561054d575f80fd5b5061056860048036038101906105639190615ff4565b612267565b6040516105759190616053565b60405180910390f35b348015610589575f80fd5b506105a4600480360381019061059f9190615ff4565b61243d565b6040516105b19190616053565b60405180910390f35b3480156105c5575f80fd5b506105e060048036038101906105db9190615ff4565b6125ee565b6040516105ed9190616053565b60405180910390f35b348015610601575f80fd5b5061061c60048036038101906106179190616448565b61279f565b6040516106299190616053565b60405180910390f35b34801561063d575f80fd5b506106466129bd565b60405161065391906164b3565b60405180910390f35b348015610667575f80fd5b50610682600480360381019061067d9190615ff4565b6129c1565b60405161068f9190616053565b60405180910390f35b3480156106a3575f80fd5b506106be60048036038101906106b99190615ff4565b612b72565b6040516106cb9190616053565b60405180910390f35b3480156106df575f80fd5b506106fa60048036038101906106f59190615ff4565b612d6c565b6040516107079190616053565b60405180910390f35b34801561071b575f80fd5b50610736600480360381019061073191906163b0565b612f42565b6040516107439190616053565b60405180910390f35b348015610757575f80fd5b5061076061325c565b60405161076d91906164db565b60405180910390f35b348015610781575f80fd5b5061078a613277565b604051610797919061631f565b60405180910390f35b3480156107ab575f80fd5b506107b46132b0565b005b3480156107c1575f80fd5b506107dc60048036038101906107d79190615ff4565b6133d5565b6040516107e99190616053565b60405180910390f35b3480156107fd575f80fd5b5061081860048036038101906108139190615ff4565b6135ab565b6040516108259190616053565b60405180910390f35b348015610839575f80fd5b50610854600480360381019061084f9190615ff4565b613781565b6040516108619190616053565b60405180910390f35b348015610875575f80fd5b50610890600480360381019061088b91906164f4565b6139cc565b60405161089d9190616053565b60405180910390f35b3480156108b1575f80fd5b506108cc60048036038101906108c7919061651f565b613b95565b6040516108d99190616053565b60405180910390f35b3480156108ed575f80fd5b5061090860048036038101906109039190615ff4565b613c05565b6040516109159190616053565b60405180910390f35b348015610929575f80fd5b50610944600480360381019061093f9190615ff4565b613e24565b6040516109519190616053565b60405180910390f35b348015610965575f80fd5b5061096e61401e565b60405161097b91906164db565b60405180910390f35b34801561098f575f80fd5b506109aa60048036038101906109a591906164f4565b614039565b6040516109b79190616053565b60405180910390f35b3480156109cb575f80fd5b506109d4614226565b6040516109e191906164db565b60405180910390f35b3480156109f5575f80fd5b50610a106004803603810190610a0b9190615ff4565b614241565b604051610a1d9190616053565b60405180910390f35b5f8060066053811115610a3c57610a3b61654a565b5b60ff166001901b60056053811115610a5757610a5661654a565b5b60ff166001901b60046053811115610a7257610a7161654a565b5b60ff166001901b60036053811115610a8d57610a8c61654a565b5b60ff166001901b60026053811115610aa857610aa761654a565b5b60ff166001901b610ab991906165a4565b610ac391906165a4565b610acd91906165a4565b610ad791906165a4565b90505f610ae48683614460565b9050610af46012878787856144c6565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff166304553fb68286898988336040518763ffffffff1660e01b8152600401610b4d9695949392919061662c565b5f604051808303815f87803b158015610b64575f80fd5b505af1158015610b76573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167fc11d62b13c360a83082487064be1ec0878b2f0be4f012bf59f89e128063d47ff87878787604051610bc6949392919061668b565b60405180910390a250509392505050565b5f8060405180604001604052808673ffffffffffffffffffffffffffffffffffffffff1681526020013373ffffffffffffffffffffffffffffffffffffffff1681525090505f610c26876147ee565b9050806053811115610c3b57610c3a61654a565b5b846053811115610c4e57610c4d61654a565b5b14610c85576040517fb968846100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b7336772142b74871f255cbd7a3e89b401d3e45825f73ffffffffffffffffffffffffffffffffffffffff1663e6317df58389886040518463ffffffff1660e01b8152600401610cd69392919061675c565b6020604051808303815f875af1158015610cf2573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610d1691906167ac565b92507350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff16633e395cec84336040518363ffffffff1660e01b8152600401610d679291906167d7565b5f604051808303815f87803b158015610d7e575f80fd5b505af1158015610d90573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167fdc370db33589e73371dc3ee42c789c003d336eefcb7c3f56fe0f51ae5b1d97028888888888604051610de29594939291906167fe565b60405180910390a25050949350505050565b60606040518060400160405280600d81526020017f464845564d4578656375746f7200000000000000000000000000000000000000815250610e355f614826565b610e3f6001614826565b610e485f614826565b604051602001610e5b9493929190616924565b604051602081830303815290604052905090565b5f8060066053811115610e8557610e8461654a565b5b60ff166001901b60056053811115610ea057610e9f61654a565b5b60ff166001901b60046053811115610ebb57610eba61654a565b5b60ff166001901b60036053811115610ed657610ed561654a565b5b60ff166001901b60026053811115610ef157610ef061654a565b5b60ff166001901b610f0291906165a4565b610f0c91906165a4565b610f1691906165a4565b610f2091906165a4565b90505f610f2d8683614460565b9050610f3c5f878787856144c6565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff1663c1390c348286898988336040518763ffffffff1660e01b8152600401610f959695949392919061662c565b5f604051808303815f87803b158015610fac575f80fd5b505af1158015610fbe573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167fdb9050d65240431621d61d6f94b970e63f53a67a5766614ee6e5c5bbd41c8e2e8787878760405161100e949392919061668b565b60405180910390a250509392505050565b5f80600660538111156110355761103461654a565b5b60ff166001901b600560538111156110505761104f61654a565b5b60ff166001901b6004605381111561106b5761106a61654a565b5b60ff166001901b600360538111156110865761108561654a565b5b60ff166001901b600260538111156110a1576110a061654a565b5b60ff166001901b6110b291906165a4565b6110bc91906165a4565b6110c691906165a4565b6110d091906165a4565b90505f6110dd8683614460565b90506110ed600e8787875f6144c6565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff1663c277a9368286898988336040518763ffffffff1660e01b81526004016111469695949392919061662c565b5f604051808303815f87803b15801561115d575f80fd5b505af115801561116f573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167f38c3a63c4230de5b741f494ffb54e3087104030279bc7bccee8ad9ad31712b21878787876040516111bf949392919061668b565b60405180910390a250509392505050565b5f80600660538111156111e6576111e561654a565b5b60ff166001901b600560538111156112015761120061654a565b5b60ff166001901b6004605381111561121c5761121b61654a565b5b60ff166001901b600360538111156112375761123661654a565b5b60ff166001901b600260538111156112525761125161654a565b5b60ff166001901b61126391906165a4565b61126d91906165a4565b61127791906165a4565b61128191906165a4565b90505f61128e8683614460565b905061129e6001878787856144c6565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff1663d633c96b8286898988336040518763ffffffff1660e01b81526004016112f79695949392919061662c565b5f604051808303815f87803b15801561130e575f80fd5b505af1158015611320573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167feb6d37bd271abe1395b21d6d78f3487d6584862872c29ffd3f90736ee99b739387878787604051611370949392919061668b565b60405180910390a250509392505050565b5f7350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff166382027b6d84336040518363ffffffff1660e01b81526004016113d19291906167d7565b602060405180830381865afa1580156113ec573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061141091906169b7565b6114535782336040517f9de3392c00000000000000000000000000000000000000000000000000000000815260040161144a9291906167d7565b60405180910390fd5b5f600860538111156114685761146761654a565b5b60ff166001901b600660538111156114835761148261654a565b5b60ff166001901b6005605381111561149e5761149d61654a565b5b60ff166001901b600460538111156114b9576114b861654a565b5b60ff166001901b600360538111156114d4576114d361654a565b5b60ff166001901b600260538111156114ef576114ee61654a565b5b60ff166001901b5f60538111156115095761150861654a565b5b60ff166001901b61151a91906165a4565b61152491906165a4565b61152e91906165a4565b61153891906165a4565b61154291906165a4565b61154c91906165a4565b90505f6115598583614460565b90505f600860538111156115705761156f61654a565b5b60ff166001901b6006605381111561158b5761158a61654a565b5b60ff166001901b600560538111156115a6576115a561654a565b5b60ff166001901b600460538111156115c1576115c061654a565b5b60ff166001901b600360538111156115dc576115db61654a565b5b60ff166001901b600260538111156115f7576115f661654a565b5b60ff166001901b61160891906165a4565b61161291906165a4565b61161c91906165a4565b61162691906165a4565b61163091906165a4565b90505f818660538111156116475761164661654a565b5b60ff166001901b1603611686576040517fc6de466a00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b8460538111156116995761169861654a565b5b8260538111156116ac576116ab61654a565b5b036116e3576040517fb968846100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b601786867350157cffd6bbfa2dece204a89ec419c23ef5755d46604051602001611711959493929190616b35565b60405160208183030381529060405280519060200120935061173384866148f0565b935073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff166369931afb868887336040518563ffffffff1660e01b81526004016117889493929190616b93565b5f604051808303815f87803b15801561179f575f80fd5b505af11580156117b1573d5f803e3d5ffd5b505050507350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff16633e395cec85336040518363ffffffff1660e01b81526004016118049291906167d7565b5f604051808303815f87803b15801561181b575f80fd5b505af115801561182d573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167f31ccae6a2f8e3ced1692f77c8f668133e4afdaaa35afe844ff4659a6c27e627f87878760405161187b93929190616bd6565b60405180910390a250505092915050565b5f80600660538111156118a2576118a161654a565b5b60ff166001901b600560538111156118bd576118bc61654a565b5b60ff166001901b600460538111156118d8576118d761654a565b5b60ff166001901b600360538111156118f3576118f261654a565b5b60ff166001901b6002605381111561190e5761190d61654a565b5b60ff166001901b61191f91906165a4565b61192991906165a4565b61193391906165a4565b61193d91906165a4565b90505f61194a8683614460565b905061195a6013878787856144c6565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff1663968302d78286898988336040518763ffffffff1660e01b81526004016119b39695949392919061662c565b5f604051808303815f87803b1580156119ca575f80fd5b505af11580156119dc573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167ffd7c9208f956bf0c6ab76a667f04361245ad3e0a2d0eff92eb827acfcca68ea987878787604051611a2c949392919061668b565b60405180910390a250509392505050565b6001611a47614969565b67ffffffffffffffff1614611a88576040517f6f4f731f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60035f611a9361498d565b9050805f0160089054906101000a900460ff1680611adb57508167ffffffffffffffff16815f015f9054906101000a900467ffffffffffffffff1667ffffffffffffffff1610155b15611b12576040517ff92ee8a900000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b81815f015f6101000a81548167ffffffffffffffff021916908367ffffffffffffffff1602179055506001815f0160086101000a81548160ff0219169083151502179055505f815f0160086101000a81548160ff0219169083151502179055507fc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d282604051611ba19190616c2d565b60405180910390a15050565b5f80611bb76149b4565b9050611bc4848483614a31565b91503373ffffffffffffffffffffffffffffffffffffffff167f5222d96b836727a1d6fe1ee9aef27f9bb507bd41794defa376ff6c648aaf8ff185858486604051611c129493929190616c8f565b60405180910390a25092915050565b611c29614ce4565b611c3282614dca565b611c3c8282614ebd565b5050565b5f611c49614fdb565b7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5f1b905090565b5f8060066053811115611c8757611c8661654a565b5b60ff166001901b60056053811115611ca257611ca161654a565b5b60ff166001901b60046053811115611cbd57611cbc61654a565b5b60ff166001901b60036053811115611cd857611cd761654a565b5b60ff166001901b60026053811115611cf357611cf261654a565b5b60ff166001901b611d0491906165a4565b611d0e91906165a4565b611d1891906165a4565b611d2291906165a4565b90505f611d2f8683614460565b9050611d3f6002878787856144c6565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff1663818f4d698286898988336040518763ffffffff1660e01b8152600401611d989695949392919061662c565b5f604051808303815f87803b158015611daf575f80fd5b505af1158015611dc1573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167f215346a4f9f975e6d5484e290bd4e53ca14453a9d282ebd3ccedb2a0f171753d87878787604051611e11949392919061668b565b60405180910390a250509392505050565b5f600160f81b827effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191614611e82576040517f4f224e5300000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f801b8303611ebd576040517f23d359a300000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f60066053811115611ed257611ed161654a565b5b60ff166001901b60056053811115611eed57611eec61654a565b5b60ff166001901b60046053811115611f0857611f0761654a565b5b60ff166001901b60036053811115611f2357611f2261654a565b5b60ff166001901b60026053811115611f3e57611f3d61654a565b5b60ff166001901b611f4f91906165a4565b611f5991906165a4565b611f6391906165a4565b611f6d91906165a4565b90505f611f7a8683614460565b9050611f8a6003878787856144c6565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff16639b3f781a8286898988336040518763ffffffff1660e01b8152600401611fe39695949392919061662c565b5f604051808303815f87803b158015611ffa575f80fd5b505af115801561200c573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167f3bab2ee0e2f90f4690c6a87bf63cf1a6b626086e95f231860b152966e8dabbf78787878760405161205c949392919061668b565b60405180910390a250509392505050565b5f80600860538111156120835761208261654a565b5b60ff166001901b6006605381111561209e5761209d61654a565b5b60ff166001901b600560538111156120b9576120b861654a565b5b60ff166001901b600460538111156120d4576120d361654a565b5b60ff166001901b600360538111156120ef576120ee61654a565b5b60ff166001901b6002605381111561210a5761210961654a565b5b60ff166001901b5f60538111156121245761212361654a565b5b60ff166001901b61213591906165a4565b61213f91906165a4565b61214991906165a4565b61215391906165a4565b61215d91906165a4565b61216791906165a4565b90505f6121748683614460565b90506121846006878787856144c6565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff1663c0c5df7c8286898988336040518763ffffffff1660e01b81526004016121dd9695949392919061662c565b5f604051808303815f87803b1580156121f4575f80fd5b505af1158015612206573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167f56df279bbfb03d9ed097bbe2f28d520ca0c1161206327926e98664d70d2c24c487878787604051612256949392919061668b565b60405180910390a250509392505050565b5f806008605381111561227d5761227c61654a565b5b60ff166001901b600660538111156122985761229761654a565b5b60ff166001901b600560538111156122b3576122b261654a565b5b60ff166001901b600460538111156122ce576122cd61654a565b5b60ff166001901b600360538111156122e9576122e861654a565b5b60ff166001901b600260538111156123045761230361654a565b5b60ff166001901b61231591906165a4565b61231f91906165a4565b61232991906165a4565b61233391906165a4565b61233d91906165a4565b90505f61234a8683614460565b905061235a600a878787856144c6565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff16635f76eb308286898988336040518763ffffffff1660e01b81526004016123b39695949392919061662c565b5f604051808303815f87803b1580156123ca575f80fd5b505af11580156123dc573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167feb0e4f8dc74058194d0602425fe602f955c222200f7f10c6fe67992f7b24c7e98787878760405161242c949392919061668b565b60405180910390a250509392505050565b5f80600660538111156124535761245261654a565b5b60ff166001901b6005605381111561246e5761246d61654a565b5b60ff166001901b600460538111156124895761248861654a565b5b60ff166001901b600360538111156124a4576124a361654a565b5b60ff166001901b600260538111156124bf576124be61654a565b5b60ff166001901b6124d091906165a4565b6124da91906165a4565b6124e491906165a4565b6124ee91906165a4565b90505f6124fb8683614460565b905061250b60118787875f6144c6565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff16633bb7d5a38286898988336040518763ffffffff1660e01b81526004016125649695949392919061662c565b5f604051808303815f87803b15801561257b575f80fd5b505af115801561258d573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167f0d483b100d8c73b208984ec697caa3091521ee5525ce69edcf97d7e395d3d059878787876040516125dd949392919061668b565b60405180910390a250509392505050565b5f80600660538111156126045761260361654a565b5b60ff166001901b6005605381111561261f5761261e61654a565b5b60ff166001901b6004605381111561263a5761263961654a565b5b60ff166001901b600360538111156126555761265461654a565b5b60ff166001901b600260538111156126705761266f61654a565b5b60ff166001901b61268191906165a4565b61268b91906165a4565b61269591906165a4565b61269f91906165a4565b90505f6126ac8683614460565b90506126bc60108787875f6144c6565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff166338bd17e58286898988336040518763ffffffff1660e01b81526004016127159695949392919061662c565b5f604051808303815f87803b15801561272c575f80fd5b505af115801561273e573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167fdef2e704a077284a07f3d0b436db88f5d981b69f58ab7c1ae623252718a6de018787878760405161278e949392919061668b565b60405180910390a250509392505050565b5f80600860538111156127b5576127b461654a565b5b60ff166001901b600760538111156127d0576127cf61654a565b5b60ff166001901b600660538111156127eb576127ea61654a565b5b60ff166001901b600560538111156128065761280561654a565b5b60ff166001901b600460538111156128215761282061654a565b5b60ff166001901b6003605381111561283c5761283b61654a565b5b60ff166001901b600260538111156128575761285661654a565b5b60ff166001901b5f60538111156128715761287061654a565b5b60ff166001901b61288291906165a4565b61288c91906165a4565b61289691906165a4565b6128a091906165a4565b6128aa91906165a4565b6128b491906165a4565b6128be91906165a4565b90505f6128cb8583614460565b90506128da6019878787615062565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff16632e3c39068288888888336040518763ffffffff1660e01b815260040161293396959493929190616cd2565b5f604051808303815f87803b15801561294a575f80fd5b505af115801561295c573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167f60be9d61aad849facc28c38b048cb5c4be3420b8fa2233e08cfa06be1b6d1c3e878787876040516129ac9493929190616d31565b60405180910390a250509392505050565b5f90565b5f80600660538111156129d7576129d661654a565b5b60ff166001901b600560538111156129f2576129f161654a565b5b60ff166001901b60046053811115612a0d57612a0c61654a565b5b60ff166001901b60036053811115612a2857612a2761654a565b5b60ff166001901b60026053811115612a4357612a4261654a565b5b60ff166001901b612a5491906165a4565b612a5e91906165a4565b612a6891906165a4565b612a7291906165a4565b90505f612a7f8683614460565b9050612a8f600f8787875f6144c6565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff1663458fb2778286898988336040518763ffffffff1660e01b8152600401612ae89695949392919061662c565b5f604051808303815f87803b158015612aff575f80fd5b505af1158015612b11573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167fc9ff8f0d18a3f766ce5de3de216076050140e4fc2652f5e0e745f6fc836cda8b87878787604051612b61949392919061668b565b60405180910390a250509392505050565b5f8060086053811115612b8857612b8761654a565b5b60ff166001901b60066053811115612ba357612ba261654a565b5b60ff166001901b60056053811115612bbe57612bbd61654a565b5b60ff166001901b60046053811115612bd957612bd861654a565b5b60ff166001901b60036053811115612bf457612bf361654a565b5b60ff166001901b60026053811115612c0f57612c0e61654a565b5b60ff166001901b5f6053811115612c2957612c2861654a565b5b60ff166001901b612c3a91906165a4565b612c4491906165a4565b612c4e91906165a4565b612c5891906165a4565b612c6291906165a4565b612c6c91906165a4565b90505f612c798683614460565b9050612c896007878787856144c6565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff16639f9259bb8286898988336040518763ffffffff1660e01b8152600401612ce29695949392919061662c565b5f604051808303815f87803b158015612cf9575f80fd5b505af1158015612d0b573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167f4d32284bd3193ecaa44e1ceca32f41c5d6c32803a92e07967dd3ee422972158287878787604051612d5b949392919061668b565b60405180910390a250509392505050565b5f8060086053811115612d8257612d8161654a565b5b60ff166001901b60066053811115612d9d57612d9c61654a565b5b60ff166001901b60056053811115612db857612db761654a565b5b60ff166001901b60046053811115612dd357612dd261654a565b5b60ff166001901b60036053811115612dee57612ded61654a565b5b60ff166001901b60026053811115612e0957612e0861654a565b5b60ff166001901b612e1a91906165a4565b612e2491906165a4565b612e2e91906165a4565b612e3891906165a4565b612e4291906165a4565b90505f612e4f8683614460565b9050612e5f6009878787856144c6565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff166307ccdf618286898988336040518763ffffffff1660e01b8152600401612eb89695949392919061662c565b5f604051808303815f87803b158015612ecf575f80fd5b505af1158015612ee1573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167f324220bfc9cb158b492991c03c309cd86e5345cac45aacae2092ddabe31fa3d887878787604051612f31949392919061668b565b60405180910390a250509392505050565b5f8060086053811115612f5857612f5761654a565b5b60ff166001901b60076053811115612f7357612f7261654a565b5b60ff166001901b60066053811115612f8e57612f8d61654a565b5b60ff166001901b60056053811115612fa957612fa861654a565b5b60ff166001901b60046053811115612fc457612fc361654a565b5b60ff166001901b60036053811115612fdf57612fde61654a565b5b60ff166001901b60026053811115612ffa57612ff961654a565b5b60ff166001901b5f60538111156130145761301361654a565b5b60ff166001901b61302591906165a4565b61302f91906165a4565b61303991906165a4565b61304391906165a4565b61304d91906165a4565b61305791906165a4565b61306191906165a4565b90505f818460538111156130785761307761654a565b5b60ff166001901b16036130b7576040517fc6de466a00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b601884847350157cffd6bbfa2dece204a89ec419c23ef5755d466040516020016130e5959493929190616d74565b60405160208183030381529060405280519060200120915061310782846148f0565b915073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff1663b78bef598484336040518463ffffffff1660e01b815260040161315a93929190616dd2565b5f604051808303815f87803b158015613171575f80fd5b505af1158015613183573d5f803e3d5ffd5b505050507350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff16633e395cec83336040518363ffffffff1660e01b81526004016131d69291906167d7565b5f604051808303815f87803b1580156131ed575f80fd5b505af11580156131ff573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167f063ccd1bba45151d91f6a418065047a3d048d058a922535747bb2b575a01d23685858560405161324d93929190616e07565b60405180910390a25092915050565b5f7336772142b74871f255cbd7a3e89b401d3e45825f905090565b6040518060400160405280600581526020017f352e302e3000000000000000000000000000000000000000000000000000000081525081565b60035f6132bb61498d565b9050805f0160089054906101000a900460ff168061330357508167ffffffffffffffff16815f015f9054906101000a900467ffffffffffffffff1667ffffffffffffffff1610155b1561333a576040517ff92ee8a900000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b81815f015f6101000a81548167ffffffffffffffff021916908367ffffffffffffffff1602179055506001815f0160086101000a81548160ff0219169083151502179055505f815f0160086101000a81548160ff0219169083151502179055507fc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d2826040516133c99190616c2d565b60405180910390a15050565b5f80600860538111156133eb576133ea61654a565b5b60ff166001901b600660538111156134065761340561654a565b5b60ff166001901b600560538111156134215761342061654a565b5b60ff166001901b6004605381111561343c5761343b61654a565b5b60ff166001901b600360538111156134575761345661654a565b5b60ff166001901b600260538111156134725761347161654a565b5b60ff166001901b61348391906165a4565b61348d91906165a4565b61349791906165a4565b6134a191906165a4565b6134ab91906165a4565b90505f6134b88683614460565b90506134c8600b878787856144c6565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff16638629f5458286898988336040518763ffffffff1660e01b81526004016135219695949392919061662c565b5f604051808303815f87803b158015613538575f80fd5b505af115801561354a573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167fc148675905d07ad5496f8ef4d8195c907503f3ec12fd10ed5f21240abc6936348787878760405161359a949392919061668b565b60405180910390a250509392505050565b5f80600860538111156135c1576135c061654a565b5b60ff166001901b600660538111156135dc576135db61654a565b5b60ff166001901b600560538111156135f7576135f661654a565b5b60ff166001901b600460538111156136125761361161654a565b5b60ff166001901b6003605381111561362d5761362c61654a565b5b60ff166001901b600260538111156136485761364761654a565b5b60ff166001901b61365991906165a4565b61366391906165a4565b61366d91906165a4565b61367791906165a4565b61368191906165a4565b90505f61368e8683614460565b905061369e6008878787856144c6565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff1663f7d198f88286898988336040518763ffffffff1660e01b81526004016136f79695949392919061662c565b5f604051808303815f87803b15801561370e575f80fd5b505af1158015613720573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167fe84282aaebcca698443e39a2a948a345d0d2ebc654af5cb657a2d7e8053bf6cb87878787604051613770949392919061668b565b60405180910390a250509392505050565b5f600160f81b827effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916146137e1576040517f4f224e5300000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f801b830361381c576040517f23d359a300000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f600660538111156138315761383061654a565b5b60ff166001901b6005605381111561384c5761384b61654a565b5b60ff166001901b600460538111156138675761386661654a565b5b60ff166001901b600360538111156138825761388161654a565b5b60ff166001901b6002605381111561389d5761389c61654a565b5b60ff166001901b6138ae91906165a4565b6138b891906165a4565b6138c291906165a4565b6138cc91906165a4565b90505f6138d98683614460565b90506138e96004878787856144c6565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff16633311b1bc8286898988336040518763ffffffff1660e01b81526004016139429695949392919061662c565b5f604051808303815f87803b158015613959575f80fd5b505af115801561396b573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167f0e691cd0bf8c4e9308e4ced1bb9c964117dc5c5bb9b9ab5bdfebf2c9b13a897c878787876040516139bb949392919061668b565b60405180910390a250509392505050565b5f80600860538111156139e2576139e161654a565b5b60ff166001901b600660538111156139fd576139fc61654a565b5b60ff166001901b60056053811115613a1857613a1761654a565b5b60ff166001901b60046053811115613a3357613a3261654a565b5b60ff166001901b60036053811115613a4e57613a4d61654a565b5b60ff166001901b60026053811115613a6957613a6861654a565b5b60ff166001901b613a7a91906165a4565b613a8491906165a4565b613a8e91906165a4565b613a9891906165a4565b613aa291906165a4565b90505f613aaf8483614460565b9050613abc60148561548e565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff1663497c22c5828686336040518563ffffffff1660e01b8152600401613b119493929190616b93565b5f604051808303815f87803b158015613b28575f80fd5b505af1158015613b3a573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167f8c664d3c3ca583fc5803b8a91c49644bbd9550bfa87967c73ad1de83027768c08585604051613b86929190616e3c565b60405180910390a25050919050565b5f80613b9f6149b4565b9050613bab838261563e565b91503373ffffffffffffffffffffffffffffffffffffffff167f0c8aca6017003326051e19913ef02631f24b801125e1fa8a1d812e868319fda6848385604051613bf793929190616e63565b60405180910390a250919050565b5f8060086053811115613c1b57613c1a61654a565b5b60ff166001901b60076053811115613c3657613c3561654a565b5b60ff166001901b60066053811115613c5157613c5061654a565b5b60ff166001901b60056053811115613c6c57613c6b61654a565b5b60ff166001901b60046053811115613c8757613c8661654a565b5b60ff166001901b60036053811115613ca257613ca161654a565b5b60ff166001901b60026053811115613cbd57613cbc61654a565b5b60ff166001901b5f6053811115613cd757613cd661654a565b5b60ff166001901b613ce891906165a4565b613cf291906165a4565b613cfc91906165a4565b613d0691906165a4565b613d1091906165a4565b613d1a91906165a4565b613d2491906165a4565b90505f613d318683614460565b9050613d41600d8787875f6144c6565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff16636bad18b68286898988336040518763ffffffff1660e01b8152600401613d9a9695949392919061662c565b5f604051808303815f87803b158015613db1575f80fd5b505af1158015613dc3573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167f6960c1e88f61c352dba34d1bbf6753e302795264d5d8ae82f7983c7004651e5d87878787604051613e13949392919061668b565b60405180910390a250509392505050565b5f8060086053811115613e3a57613e3961654a565b5b60ff166001901b60066053811115613e5557613e5461654a565b5b60ff166001901b60056053811115613e7057613e6f61654a565b5b60ff166001901b60046053811115613e8b57613e8a61654a565b5b60ff166001901b60036053811115613ea657613ea561654a565b5b60ff166001901b60026053811115613ec157613ec061654a565b5b60ff166001901b5f6053811115613edb57613eda61654a565b5b60ff166001901b613eec91906165a4565b613ef691906165a4565b613f0091906165a4565b613f0a91906165a4565b613f1491906165a4565b613f1e91906165a4565b90505f613f2b8683614460565b9050613f3b6005878787856144c6565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff1663c8de43528286898988336040518763ffffffff1660e01b8152600401613f949695949392919061662c565b5f604051808303815f87803b158015613fab575f80fd5b505af1158015613fbd573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167fe42486b0ccdbef81a2075c48c8e515c079aea73c8b82429997c72a2fe1bf4fef8787878760405161400d949392919061668b565b60405180910390a250509392505050565b5f73233ff88a48c172d29f675403e6a8e302b0f032d9905090565b5f806008605381111561404f5761404e61654a565b5b60ff166001901b6006605381111561406a5761406961654a565b5b60ff166001901b600560538111156140855761408461654a565b5b60ff166001901b600460538111156140a05761409f61654a565b5b60ff166001901b600360538111156140bb576140ba61654a565b5b60ff166001901b600260538111156140d6576140d561654a565b5b60ff166001901b5f60538111156140f0576140ef61654a565b5b60ff166001901b61410191906165a4565b61410b91906165a4565b61411591906165a4565b61411f91906165a4565b61412991906165a4565b61413391906165a4565b90505f6141408483614460565b905061414d60158561548e565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff16632dcbc5d1828686336040518563ffffffff1660e01b81526004016141a29493929190616b93565b5f604051808303815f87803b1580156141b9575f80fd5b505af11580156141cb573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167f55aff4cc7a3d160c83f1f15b818011ede841a0b4597fb14dcd3603df3a11e5e08585604051614217929190616e3c565b60405180910390a25050919050565b5f7350157cffd6bbfa2dece204a89ec419c23ef5755d905090565b5f80600860538111156142575761425661654a565b5b60ff166001901b600760538111156142725761427161654a565b5b60ff166001901b6006605381111561428d5761428c61654a565b5b60ff166001901b600560538111156142a8576142a761654a565b5b60ff166001901b600460538111156142c3576142c261654a565b5b60ff166001901b600360538111156142de576142dd61654a565b5b60ff166001901b600260538111156142f9576142f861654a565b5b60ff166001901b5f60538111156143135761431261654a565b5b60ff166001901b61432491906165a4565b61432e91906165a4565b61433891906165a4565b61434291906165a4565b61434c91906165a4565b61435691906165a4565b61436091906165a4565b90505f61436d8683614460565b905061437d600c8787875f6144c6565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff166360e121898286898988336040518763ffffffff1660e01b81526004016143d69695949392919061662c565b5f604051808303815f87803b1580156143ed575f80fd5b505af11580156143ff573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167fb3d5c664ec86575818e8d75ff25c5f867250df8954088549c41c848cd10e76cb8787878760405161444f949392919061668b565b60405180910390a250509392505050565b5f61446a836147ee565b90505f828260538111156144815761448061654a565b5b60ff166001901b16036144c0576040517fc6de466a00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b92915050565b5f6144d0836158c9565b7350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff166382027b6d86336040518363ffffffff1660e01b815260040161451f9291906167d7565b602060405180830381865afa15801561453a573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061455e91906169b7565b6145a15784336040517f9de3392c0000000000000000000000000000000000000000000000000000000081526004016145989291906167d7565b60405180910390fd5b5f60f81b837effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191603614716577350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff166382027b6d85336040518363ffffffff1660e01b815260040161461c9291906167d7565b602060405180830381865afa158015614637573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061465b91906169b7565b61469e5783336040517f9de3392c0000000000000000000000000000000000000000000000000000000081526004016146959291906167d7565b60405180910390fd5b5f6146a8856147ee565b90505f6146b4876147ee565b90508160538111156146c9576146c861654a565b5b8160538111156146dc576146db61654a565b5b14614713576040517f1f3158c700000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b50505b858585857350157cffd6bbfa2dece204a89ec419c23ef5755d4660405160200161474596959493929190616eb8565b60405160208183030381529060405280519060200120905061476781836148f0565b90507350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff16633e395cec82336040518363ffffffff1660e01b81526004016147b89291906167d7565b5f604051808303815f87803b1580156147cf575f80fd5b505af11580156147e1573d5f803e3d5ffd5b5050505095945050505050565b5f81601e6020811061480357614802616f27565b5b1a60f81b60f81c60ff16605381111561481f5761481e61654a565b5b9050919050565b60605f60016148348461590d565b0190505f8167ffffffffffffffff811115614852576148516160de565b5b6040519080825280601f01601f1916602001820160405280156148845781602001600182028036833780820191505090505b5090505f82602001820190505b6001156148e5578080600190039150507f3031323334353637383961626364656600000000000000000000000000000000600a86061a8153600a85816148da576148d9616f54565b5b0494505f8503614891575b819350505050919050565b5f7fffffffffffffffffffffffffffffffffffffffffff00000000000000000000005f1b83169050605060ff5f1b901b8117905060104667ffffffffffffffff165f1b901b81179050600882605381111561494e5761494d61654a565b5b60ff165f1b901b811790505f60ff165f1b8117905092915050565b5f61497261498d565b5f015f9054906101000a900467ffffffffffffffff16905090565b5f7ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00905090565b5f806149be615a5e565b9050805f01547350157cffd6bbfa2dece204a89ec419c23ef5755d466001436149e79190616f81565b40426040516020016149fd959493929190616fb4565b604051602081830303815290604052805190602001209150805f015f815480929190614a2890617012565b91905055505090565b5f8060086053811115614a4757614a4661654a565b5b60ff166001901b60066053811115614a6257614a6161654a565b5b60ff166001901b60056053811115614a7d57614a7c61654a565b5b60ff166001901b60046053811115614a9857614a9761654a565b5b60ff166001901b60036053811115614ab357614ab261654a565b5b60ff166001901b60026053811115614ace57614acd61654a565b5b60ff166001901b614adf91906165a4565b614ae991906165a4565b614af391906165a4565b614afd91906165a4565b614b0791906165a4565b90505f81856053811115614b1e57614b1d61654a565b5b60ff166001901b1603614b5d576040517fc6de466a00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b614b6685615a85565b614b9c576040517f24e8e74200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b614ba68585615aa9565b601b858585604051602001614bbe9493929190617079565b604051602081830303815290604052805190602001209150614be082856148f0565b915073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff16636cf0bd258584336040518463ffffffff1660e01b8152600401614c3393929190616dd2565b5f604051808303815f87803b158015614c4a575f80fd5b505af1158015614c5c573d5f803e3d5ffd5b505050507350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff16633e395cec83336040518363ffffffff1660e01b8152600401614caf9291906167d7565b5f604051808303815f87803b158015614cc6575f80fd5b505af1158015614cd8573d5f803e3d5ffd5b50505050509392505050565b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff163073ffffffffffffffffffffffffffffffffffffffff161480614d9157507f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16614d78615bf9565b73ffffffffffffffffffffffffffffffffffffffff1614155b15614dc8576040517fe07c8dba00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b565b7350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff16638da5cb5b6040518163ffffffff1660e01b8152600401602060405180830381865afa158015614e27573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190614e4b91906170da565b73ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614614eba57336040517f21bfda10000000000000000000000000000000000000000000000000000000008152600401614eb191906164db565b60405180910390fd5b50565b8173ffffffffffffffffffffffffffffffffffffffff166352d1902d6040518163ffffffff1660e01b8152600401602060405180830381865afa925050508015614f2557506040513d601f19601f82011682018060405250810190614f2291906167ac565b60015b614f6657816040517f4c9c8ce3000000000000000000000000000000000000000000000000000000008152600401614f5d91906164db565b60405180910390fd5b7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5f1b8114614fcc57806040517faa1d49a4000000000000000000000000000000000000000000000000000000008152600401614fc39190616053565b60405180910390fd5b614fd68383615c4c565b505050565b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff163073ffffffffffffffffffffffffffffffffffffffff1614615060576040517fe07c8dba00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b565b5f7350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff166382027b6d85336040518363ffffffff1660e01b81526004016150b29291906167d7565b602060405180830381865afa1580156150cd573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906150f191906169b7565b6151345783336040517f9de3392c00000000000000000000000000000000000000000000000000000000815260040161512b9291906167d7565b60405180910390fd5b7350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff166382027b6d84336040518363ffffffff1660e01b81526004016151839291906167d7565b602060405180830381865afa15801561519e573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906151c291906169b7565b6152055782336040517f9de3392c0000000000000000000000000000000000000000000000000000000081526004016151fc9291906167d7565b60405180910390fd5b7350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff166382027b6d83336040518363ffffffff1660e01b81526004016152549291906167d7565b602060405180830381865afa15801561526f573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061529391906169b7565b6152d65781336040517f9de3392c0000000000000000000000000000000000000000000000000000000081526004016152cd9291906167d7565b60405180910390fd5b5f6152e0856147ee565b90505f6152ec856147ee565b90505f6152f8856147ee565b90505f605381111561530d5761530c61654a565b5b8360538111156153205761531f61654a565b5b14615357576040517fc6de466a00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b80605381111561536a5761536961654a565b5b82605381111561537d5761537c61654a565b5b146153b4576040517f1f3158c700000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b878787877350157cffd6bbfa2dece204a89ec419c23ef5755d466040516020016153e396959493929190617105565b60405160208183030381529060405280519060200120935061540584836148f0565b93507350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff16633e395cec85336040518363ffffffff1660e01b81526004016154569291906167d7565b5f604051808303815f87803b15801561546d575f80fd5b505af115801561547f573d5f803e3d5ffd5b50505050505050949350505050565b5f7350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff166382027b6d83336040518363ffffffff1660e01b81526004016154de9291906167d7565b602060405180830381865afa1580156154f9573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061551d91906169b7565b6155605781336040517f9de3392c0000000000000000000000000000000000000000000000000000000081526004016155579291906167d7565b60405180910390fd5b82827350157cffd6bbfa2dece204a89ec419c23ef5755d4660405160200161558b9493929190617174565b6040516020818303038152906040528051906020012090505f6155ad836147ee565b90506155b982826148f0565b91507350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff16633e395cec83336040518363ffffffff1660e01b815260040161560a9291906167d7565b5f604051808303815f87803b158015615621575f80fd5b505af1158015615633573d5f803e3d5ffd5b505050505092915050565b5f80600860538111156156545761565361654a565b5b60ff166001901b6006605381111561566f5761566e61654a565b5b60ff166001901b6005605381111561568a5761568961654a565b5b60ff166001901b600460538111156156a5576156a461654a565b5b60ff166001901b600360538111156156c0576156bf61654a565b5b60ff166001901b600260538111156156db576156da61654a565b5b60ff166001901b5f60538111156156f5576156f461654a565b5b60ff166001901b61570691906165a4565b61571091906165a4565b61571a91906165a4565b61572491906165a4565b61572e91906165a4565b61573891906165a4565b90505f8185605381111561574f5761574e61654a565b5b60ff166001901b160361578e576040517fc6de466a00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b601a84846040516020016157a4939291906171c1565b6040516020818303038152906040528051906020012091506157c682856148f0565b915073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff1663d5b8b8f38584336040518463ffffffff1660e01b815260040161581993929190616dd2565b5f604051808303815f87803b158015615830575f80fd5b505af1158015615842573d5f803e3d5ffd5b505050507350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff16633e395cec83336040518363ffffffff1660e01b81526004016158959291906167d7565b5f604051808303815f87803b1580156158ac575f80fd5b505af11580156158be573d5f803e3d5ffd5b505050505092915050565b60018160f81c60ff16111561590a576040517fdf7bf32500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b50565b5f805f90507a184f03e93ff9f4daa797ed6e38ed64bf6a1f0100000000000000008310615969577a184f03e93ff9f4daa797ed6e38ed64bf6a1f010000000000000000838161595f5761595e616f54565b5b0492506040810190505b6d04ee2d6d415b85acef810000000083106159a6576d04ee2d6d415b85acef8100000000838161599c5761599b616f54565b5b0492506020810190505b662386f26fc1000083106159d557662386f26fc1000083816159cb576159ca616f54565b5b0492506010810190505b6305f5e10083106159fe576305f5e10083816159f4576159f3616f54565b5b0492506008810190505b6127108310615a23576127108381615a1957615a18616f54565b5b0492506004810190505b60648310615a465760648381615a3c57615a3b616f54565b5b0492506002810190505b600a8310615a55576001810190505b80915050919050565b5f7f4613e1771f6b755d243e536fb5a23c5b15e2826575fee921e8fe7a22a760c800905090565b5f8082118015615aa257505f600183615a9e9190616f81565b8316145b9050919050565b60026053811115615abd57615abc61654a565b5b816053811115615ad057615acf61654a565b5b03615ae657615ae182610100615cbe565b615bf5565b60036053811115615afa57615af961654a565b5b816053811115615b0d57615b0c61654a565b5b03615b2457615b1f8262010000615cbe565b615bf5565b60046053811115615b3857615b3761654a565b5b816053811115615b4b57615b4a61654a565b5b03615b6457615b5f82640100000000615cbe565b615bf5565b60056053811115615b7857615b7761654a565b5b816053811115615b8b57615b8a61654a565b5b03615ba857615ba38268010000000000000000615cbe565b615bf5565b60066053811115615bbc57615bbb61654a565b5b816053811115615bcf57615bce61654a565b5b03615bf457615bef82700100000000000000000000000000000000615cbe565b615bf5565b5b5050565b5f615c257f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5f1b615cfc565b5f015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905090565b615c5582615d05565b8173ffffffffffffffffffffffffffffffffffffffff167fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b60405160405180910390a25f81511115615cb157615cab8282615dce565b50615cba565b615cb9615e4e565b5b5050565b80821115615cf8576040517fc7dadf4500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5050565b5f819050919050565b5f8173ffffffffffffffffffffffffffffffffffffffff163b03615d6057806040517f4c9c8ce3000000000000000000000000000000000000000000000000000000008152600401615d5791906164db565b60405180910390fd5b80615d8c7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5f1b615cfc565b5f015f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555050565b60605f808473ffffffffffffffffffffffffffffffffffffffff1684604051615df79190617237565b5f60405180830381855af49150503d805f8114615e2f576040519150601f19603f3d011682016040523d82523d5f602084013e615e34565b606091505b5091509150615e44858383615e8a565b9250505092915050565b5f341115615e88576040517fb398979f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b565b606082615e9f57615e9a82615f17565b615f0f565b5f8251148015615ec557505f8473ffffffffffffffffffffffffffffffffffffffff163b145b15615f0757836040517f9996b315000000000000000000000000000000000000000000000000000000008152600401615efe91906164db565b60405180910390fd5b819050615f10565b5b9392505050565b5f81511115615f295780518082602001fd5b6040517fd6bda27500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f604051905090565b5f80fd5b5f80fd5b5f819050919050565b615f7e81615f6c565b8114615f88575f80fd5b50565b5f81359050615f9981615f75565b92915050565b5f7fff0000000000000000000000000000000000000000000000000000000000000082169050919050565b615fd381615f9f565b8114615fdd575f80fd5b50565b5f81359050615fee81615fca565b92915050565b5f805f6060848603121561600b5761600a615f64565b5b5f61601886828701615f8b565b935050602061602986828701615f8b565b925050604061603a86828701615fe0565b9150509250925092565b61604d81615f6c565b82525050565b5f6020820190506160665f830184616044565b92915050565b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f6160958261606c565b9050919050565b6160a58161608b565b81146160af575f80fd5b50565b5f813590506160c08161609c565b92915050565b5f80fd5b5f80fd5b5f601f19601f8301169050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b616114826160ce565b810181811067ffffffffffffffff82111715616133576161326160de565b5b80604052505050565b5f616145615f5b565b9050616151828261610b565b919050565b5f67ffffffffffffffff8211156161705761616f6160de565b5b616179826160ce565b9050602081019050919050565b828183375f83830152505050565b5f6161a66161a184616156565b61613c565b9050828152602081018484840111156161c2576161c16160ca565b5b6161cd848285616186565b509392505050565b5f82601f8301126161e9576161e86160c6565b5b81356161f9848260208601616194565b91505092915050565b6054811061620e575f80fd5b50565b5f8135905061621f81616202565b92915050565b5f805f806080858703121561623d5761623c615f64565b5b5f61624a87828801615f8b565b945050602061625b878288016160b2565b935050604085013567ffffffffffffffff81111561627c5761627b615f68565b5b616288878288016161d5565b925050606061629987828801616211565b91505092959194509250565b5f81519050919050565b5f82825260208201905092915050565b5f5b838110156162dc5780820151818401526020810190506162c1565b5f8484015250505050565b5f6162f1826162a5565b6162fb81856162af565b935061630b8185602086016162bf565b616314816160ce565b840191505092915050565b5f6020820190508181035f83015261633781846162e7565b905092915050565b5f806040838503121561635557616354615f64565b5b5f61636285828601615f8b565b925050602061637385828601616211565b9150509250929050565b5f819050919050565b61638f8161637d565b8114616399575f80fd5b50565b5f813590506163aa81616386565b92915050565b5f80604083850312156163c6576163c5615f64565b5b5f6163d38582860161639c565b92505060206163e485828601616211565b9150509250929050565b5f806040838503121561640457616403615f64565b5b5f616411858286016160b2565b925050602083013567ffffffffffffffff81111561643257616431615f68565b5b61643e858286016161d5565b9150509250929050565b5f805f6060848603121561645f5761645e615f64565b5b5f61646c86828701615f8b565b935050602061647d86828701615f8b565b925050604061648e86828701615f8b565b9150509250925092565b5f60ff82169050919050565b6164ad81616498565b82525050565b5f6020820190506164c65f8301846164a4565b92915050565b6164d58161608b565b82525050565b5f6020820190506164ee5f8301846164cc565b92915050565b5f6020828403121561650957616508615f64565b5b5f61651684828501615f8b565b91505092915050565b5f6020828403121561653457616533615f64565b5b5f61654184828501616211565b91505092915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52602160045260245ffd5b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5f6165ae8261637d565b91506165b98361637d565b92508282019050808211156165d1576165d0616577565b5b92915050565b605481106165e8576165e761654a565b5b50565b5f8190506165f8826165d7565b919050565b5f616607826165eb565b9050919050565b616617816165fd565b82525050565b61662681615f9f565b82525050565b5f60c08201905061663f5f83018961660e565b61664c602083018861661d565b6166596040830187616044565b6166666060830186616044565b6166736080830185616044565b61668060a08301846164cc565b979650505050505050565b5f60808201905061669e5f830187616044565b6166ab6020830186616044565b6166b8604083018561661d565b6166c56060830184616044565b95945050505050565b6166d78161608b565b82525050565b604082015f8201516166f15f8501826166ce565b50602082015161670460208501826166ce565b50505050565b5f81519050919050565b5f82825260208201905092915050565b5f61672e8261670a565b6167388185616714565b93506167488185602086016162bf565b616751816160ce565b840191505092915050565b5f60808201905061676f5f8301866166dd565b61677c6040830185616044565b818103606083015261678e8184616724565b9050949350505050565b5f815190506167a681615f75565b92915050565b5f602082840312156167c1576167c0615f64565b5b5f6167ce84828501616798565b91505092915050565b5f6040820190506167ea5f830185616044565b6167f760208301846164cc565b9392505050565b5f60a0820190506168115f830188616044565b61681e60208301876164cc565b81810360408301526168308186616724565b905061683f606083018561660e565b61684c6080830184616044565b9695505050505050565b5f81905092915050565b5f61686a826162a5565b6168748185616856565b93506168848185602086016162bf565b80840191505092915050565b7f20760000000000000000000000000000000000000000000000000000000000005f82015250565b5f6168c4600283616856565b91506168cf82616890565b600282019050919050565b7f2e000000000000000000000000000000000000000000000000000000000000005f82015250565b5f61690e600183616856565b9150616919826168da565b600182019050919050565b5f61692f8287616860565b915061693a826168b8565b91506169468286616860565b915061695182616902565b915061695d8285616860565b915061696882616902565b91506169748284616860565b915081905095945050505050565b5f8115159050919050565b61699681616982565b81146169a0575f80fd5b50565b5f815190506169b18161698d565b92915050565b5f602082840312156169cc576169cb615f64565b5b5f6169d9848285016169a3565b91505092915050565b601c81106169f3576169f261654a565b5b50565b5f819050616a03826169e2565b919050565b5f616a12826169f6565b9050919050565b5f8160f81b9050919050565b5f616a2f82616a19565b9050919050565b616a47616a4282616a08565b616a25565b82525050565b5f819050919050565b616a67616a6282615f6c565b616a4d565b82525050565b616a7e616a79826165fd565b616a25565b82525050565b5f819050919050565b5f616aa7616aa2616a9d8461606c565b616a84565b61606c565b9050919050565b5f616ab882616a8d565b9050919050565b5f616ac982616aae565b9050919050565b5f8160601b9050919050565b5f616ae682616ad0565b9050919050565b5f616af782616adc565b9050919050565b616b0f616b0a82616abf565b616aed565b82525050565b5f819050919050565b616b2f616b2a8261637d565b616b15565b82525050565b5f616b408288616a36565b600182019150616b508287616a56565b602082019150616b608286616a6d565b600182019150616b708285616afe565b601482019150616b808284616b1e565b6020820191508190509695505050505050565b5f608082019050616ba65f83018761660e565b616bb36020830186616044565b616bc06040830185616044565b616bcd60608301846164cc565b95945050505050565b5f606082019050616be95f830186616044565b616bf6602083018561660e565b616c036040830184616044565b949350505050565b5f67ffffffffffffffff82169050919050565b616c2781616c0b565b82525050565b5f602082019050616c405f830184616c1e565b92915050565b616c4f8161637d565b82525050565b5f7fffffffffffffffffffffffffffffffff0000000000000000000000000000000082169050919050565b616c8981616c55565b82525050565b5f608082019050616ca25f830187616c46565b616caf602083018661660e565b616cbc6040830185616c80565b616cc96060830184616044565b95945050505050565b5f60c082019050616ce55f83018961660e565b616cf26020830188616044565b616cff6040830187616044565b616d0c6060830186616044565b616d196080830185616044565b616d2660a08301846164cc565b979650505050505050565b5f608082019050616d445f830187616044565b616d516020830186616044565b616d5e6040830185616044565b616d6b6060830184616044565b95945050505050565b5f616d7f8288616a36565b600182019150616d8f8287616b1e565b602082019150616d9f8286616a6d565b600182019150616daf8285616afe565b601482019150616dbf8284616b1e565b6020820191508190509695505050505050565b5f606082019050616de55f83018661660e565b616df26020830185616044565b616dff60408301846164cc565b949350505050565b5f606082019050616e1a5f830186616c46565b616e27602083018561660e565b616e346040830184616044565b949350505050565b5f604082019050616e4f5f830185616044565b616e5c6020830184616044565b9392505050565b5f606082019050616e765f83018661660e565b616e836020830185616c80565b616e906040830184616044565b949350505050565b5f819050919050565b616eb2616ead82615f9f565b616e98565b82525050565b5f616ec38289616a36565b600182019150616ed38288616a56565b602082019150616ee38287616a56565b602082019150616ef38286616ea1565b600182019150616f038285616afe565b601482019150616f138284616b1e565b602082019150819050979650505050505050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603260045260245ffd5b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601260045260245ffd5b5f616f8b8261637d565b9150616f968361637d565b9250828203905081811115616fae57616fad616577565b5b92915050565b5f616fbf8288616b1e565b602082019150616fcf8287616afe565b601482019150616fdf8286616b1e565b602082019150616fef8285616a56565b602082019150616fff8284616b1e565b6020820191508190509695505050505050565b5f61701c8261637d565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff820361704e5761704d616577565b5b600182019050919050565b5f819050919050565b61707361706e82616c55565b617059565b82525050565b5f6170848287616a36565b6001820191506170948286616b1e565b6020820191506170a48285616a6d565b6001820191506170b48284617062565b60108201915081905095945050505050565b5f815190506170d48161609c565b92915050565b5f602082840312156170ef576170ee615f64565b5b5f6170fc848285016170c6565b91505092915050565b5f6171108289616a36565b6001820191506171208288616a56565b6020820191506171308287616a56565b6020820191506171408286616a56565b6020820191506171508285616afe565b6014820191506171608284616b1e565b602082019150819050979650505050505050565b5f61717f8287616a36565b60018201915061718f8286616a56565b60208201915061719f8285616afe565b6014820191506171af8284616b1e565b60208201915081905095945050505050565b5f6171cc8286616a36565b6001820191506171dc8285616a6d565b6001820191506171ec8284617062565b601082019150819050949350505050565b5f81905092915050565b5f6172118261670a565b61721b81856171fd565b935061722b8185602086016162bf565b80840191505092915050565b5f6172428284617207565b91508190509291505056
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\xA0`@R0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`\x80\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81RP4\x80\x15b\0\0CW_\x80\xFD[Pb\0\0Tb\0\0Z` \x1B` \x1CV[b\0\x01\xC4V[_b\0\0kb\0\x01^` \x1B` \x1CV[\x90P\x80_\x01`\x08\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x15b\0\0\xB6W`@Q\x7F\xF9.\xE8\xA9\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\x16\x81_\x01_\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14b\0\x01[Wg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81_\x01_a\x01\0\n\x81T\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP\x7F\xC7\xF5\x05\xB2\xF3q\xAE!u\xEEI\x13\xF4I\x9E\x1F&3\xA7\xB5\x93c!\xEE\xD1\xCD\xAE\xB6\x11Q\x81\xD2g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@Qb\0\x01R\x91\x90b\0\x01\xA9V[`@Q\x80\x91\x03\x90\xA1[PV[_\x7F\xF0\xC5~\x16\x84\r\xF0@\xF1P\x88\xDC/\x81\xFE9\x1C9#\xBE\xC7>#\xA9f.\xFC\x9C\"\x9Cj\0\x90P\x90V[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[b\0\x01\xA3\x81b\0\x01\x85V[\x82RPPV[_` \x82\x01\x90Pb\0\x01\xBE_\x83\x01\x84b\0\x01\x98V[\x92\x91PPV[`\x80QarMb\0\x01\xEB_9_\x81\x81aL\xE6\x01R\x81\x81aM;\x01RaO\xDD\x01RarM_\xF3\xFE`\x80`@R`\x046\x10a\x02$W_5`\xE0\x1C\x80cz)\x7FK\x11a\x01\"W\x80c\xCC\xC4\x80\xA1\x11a\0\xAAW\x80c\xD9\x98\x82\xD5\x11a\0nW\x80c\xD9\x98\x82\xD5\x14a\t\x1EW\x80c\xE0xir\x14a\tZW\x80c\xF5\x1C\xCF\xB0\x14a\t\x84W\x80c\xF6\x85\x9B\xDC\x14a\t\xC0W\x80c\xF7\x7F?\x1D\x14a\t\xEAWa\x02$V[\x80c\xCC\xC4\x80\xA1\x14a\x07\xF2W\x80c\xCFM\x18\xAA\x14a\x08.W\x80c\xD5\x80\xC0c\x14a\x08jW\x80c\xD7]n\x8A\x14a\x08\xA6W\x80c\xD8\t,\xBC\x14a\x08\xE2Wa\x02$V[\x80c\x9C\xD0z\xCB\x11a\0\xF1W\x80c\x9C\xD0z\xCB\x14a\x07\x10W\x80c\xA8\xC7\xC2\xC1\x14a\x07LW\x80c\xAD<\xB1\xCC\x14a\x07vW\x80c\xBA\xC2+\xB8\x14a\x07\xA0W\x80c\xC0!2\x9E\x14a\x07\xB6Wa\x02$V[\x80cz)\x7FK\x14a\x062W\x80c\x856.\xE7\x14a\x06\\W\x80c\x8BI\xCE\xB4\x14a\x06\x98W\x80c\x91\xF9\x8F\xFE\x14a\x06\xD4Wa\x02$V[\x80cH\xEE\xF4~\x11a\x01\xB0W\x80cc\xA2\xDB)\x11a\x01tW\x80cc\xA2\xDB)\x14a\x05\x06W\x80cgT\xB3`\x14a\x05BW\x80cr\x10v\x81\x14a\x05~W\x80cu\x13\xA4\x04\x14a\x05\xBAW\x80cw\x02\xDC\xFF\x14a\x05\xF6Wa\x02$V[\x80cH\xEE\xF4~\x14a\x04\x0CW\x80cO\x1E\xF2\x86\x14a\x04HW\x80cR\xD1\x90-\x14a\x04dW\x80cW\xF0\xA5h\x14a\x04\x8EW\x80cZS\xAC\xCB\x14a\x04\xCAWa\x02$V[\x80c\x13\x91T\x7F\x11a\x01\xF7W\x80c\x13\x91T\x7F\x14a\x03\x06W\x80c\x18+m\x98\x14a\x03BW\x80c\x1C\x89\xEED\x14a\x03~W\x80c61\x8Dd\x14a\x03\xBAW\x80c9\xF78\x10\x14a\x03\xF6Wa\x02$V[\x80c\x04U\x9Fq\x14a\x02(W\x80c\x08\xBF\x83*\x14a\x02dW\x80c\r\x8En,\x14a\x02\xA0W\x80c\x11{/8\x14a\x02\xCAW[_\x80\xFD[4\x80\x15a\x023W_\x80\xFD[Pa\x02N`\x04\x806\x03\x81\x01\x90a\x02I\x91\x90a_\xF4V[a\n&V[`@Qa\x02[\x91\x90a`SV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x02oW_\x80\xFD[Pa\x02\x8A`\x04\x806\x03\x81\x01\x90a\x02\x85\x91\x90ab%V[a\x0B\xD7V[`@Qa\x02\x97\x91\x90a`SV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x02\xABW_\x80\xFD[Pa\x02\xB4a\r\xF4V[`@Qa\x02\xC1\x91\x90ac\x1FV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x02\xD5W_\x80\xFD[Pa\x02\xF0`\x04\x806\x03\x81\x01\x90a\x02\xEB\x91\x90a_\xF4V[a\x0EoV[`@Qa\x02\xFD\x91\x90a`SV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x03\x11W_\x80\xFD[Pa\x03,`\x04\x806\x03\x81\x01\x90a\x03'\x91\x90a_\xF4V[a\x10\x1FV[`@Qa\x039\x91\x90a`SV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x03MW_\x80\xFD[Pa\x03h`\x04\x806\x03\x81\x01\x90a\x03c\x91\x90a_\xF4V[a\x11\xD0V[`@Qa\x03u\x91\x90a`SV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x03\x89W_\x80\xFD[Pa\x03\xA4`\x04\x806\x03\x81\x01\x90a\x03\x9F\x91\x90ac?V[a\x13\x81V[`@Qa\x03\xB1\x91\x90a`SV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x03\xC5W_\x80\xFD[Pa\x03\xE0`\x04\x806\x03\x81\x01\x90a\x03\xDB\x91\x90a_\xF4V[a\x18\x8CV[`@Qa\x03\xED\x91\x90a`SV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x04\x01W_\x80\xFD[Pa\x04\na\x1A=V[\0[4\x80\x15a\x04\x17W_\x80\xFD[Pa\x042`\x04\x806\x03\x81\x01\x90a\x04-\x91\x90ac\xB0V[a\x1B\xADV[`@Qa\x04?\x91\x90a`SV[`@Q\x80\x91\x03\x90\xF3[a\x04b`\x04\x806\x03\x81\x01\x90a\x04]\x91\x90ac\xEEV[a\x1C!V[\0[4\x80\x15a\x04oW_\x80\xFD[Pa\x04xa\x1C@V[`@Qa\x04\x85\x91\x90a`SV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x04\x99W_\x80\xFD[Pa\x04\xB4`\x04\x806\x03\x81\x01\x90a\x04\xAF\x91\x90a_\xF4V[a\x1CqV[`@Qa\x04\xC1\x91\x90a`SV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x04\xD5W_\x80\xFD[Pa\x04\xF0`\x04\x806\x03\x81\x01\x90a\x04\xEB\x91\x90a_\xF4V[a\x1E\"V[`@Qa\x04\xFD\x91\x90a`SV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x05\x11W_\x80\xFD[Pa\x05,`\x04\x806\x03\x81\x01\x90a\x05'\x91\x90a_\xF4V[a mV[`@Qa\x059\x91\x90a`SV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x05MW_\x80\xFD[Pa\x05h`\x04\x806\x03\x81\x01\x90a\x05c\x91\x90a_\xF4V[a\"gV[`@Qa\x05u\x91\x90a`SV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x05\x89W_\x80\xFD[Pa\x05\xA4`\x04\x806\x03\x81\x01\x90a\x05\x9F\x91\x90a_\xF4V[a$=V[`@Qa\x05\xB1\x91\x90a`SV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x05\xC5W_\x80\xFD[Pa\x05\xE0`\x04\x806\x03\x81\x01\x90a\x05\xDB\x91\x90a_\xF4V[a%\xEEV[`@Qa\x05\xED\x91\x90a`SV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x06\x01W_\x80\xFD[Pa\x06\x1C`\x04\x806\x03\x81\x01\x90a\x06\x17\x91\x90adHV[a'\x9FV[`@Qa\x06)\x91\x90a`SV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x06=W_\x80\xFD[Pa\x06Fa)\xBDV[`@Qa\x06S\x91\x90ad\xB3V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x06gW_\x80\xFD[Pa\x06\x82`\x04\x806\x03\x81\x01\x90a\x06}\x91\x90a_\xF4V[a)\xC1V[`@Qa\x06\x8F\x91\x90a`SV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x06\xA3W_\x80\xFD[Pa\x06\xBE`\x04\x806\x03\x81\x01\x90a\x06\xB9\x91\x90a_\xF4V[a+rV[`@Qa\x06\xCB\x91\x90a`SV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x06\xDFW_\x80\xFD[Pa\x06\xFA`\x04\x806\x03\x81\x01\x90a\x06\xF5\x91\x90a_\xF4V[a-lV[`@Qa\x07\x07\x91\x90a`SV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x07\x1BW_\x80\xFD[Pa\x076`\x04\x806\x03\x81\x01\x90a\x071\x91\x90ac\xB0V[a/BV[`@Qa\x07C\x91\x90a`SV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x07WW_\x80\xFD[Pa\x07`a2\\V[`@Qa\x07m\x91\x90ad\xDBV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x07\x81W_\x80\xFD[Pa\x07\x8Aa2wV[`@Qa\x07\x97\x91\x90ac\x1FV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x07\xABW_\x80\xFD[Pa\x07\xB4a2\xB0V[\0[4\x80\x15a\x07\xC1W_\x80\xFD[Pa\x07\xDC`\x04\x806\x03\x81\x01\x90a\x07\xD7\x91\x90a_\xF4V[a3\xD5V[`@Qa\x07\xE9\x91\x90a`SV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x07\xFDW_\x80\xFD[Pa\x08\x18`\x04\x806\x03\x81\x01\x90a\x08\x13\x91\x90a_\xF4V[a5\xABV[`@Qa\x08%\x91\x90a`SV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x089W_\x80\xFD[Pa\x08T`\x04\x806\x03\x81\x01\x90a\x08O\x91\x90a_\xF4V[a7\x81V[`@Qa\x08a\x91\x90a`SV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x08uW_\x80\xFD[Pa\x08\x90`\x04\x806\x03\x81\x01\x90a\x08\x8B\x91\x90ad\xF4V[a9\xCCV[`@Qa\x08\x9D\x91\x90a`SV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x08\xB1W_\x80\xFD[Pa\x08\xCC`\x04\x806\x03\x81\x01\x90a\x08\xC7\x91\x90ae\x1FV[a;\x95V[`@Qa\x08\xD9\x91\x90a`SV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x08\xEDW_\x80\xFD[Pa\t\x08`\x04\x806\x03\x81\x01\x90a\t\x03\x91\x90a_\xF4V[a<\x05V[`@Qa\t\x15\x91\x90a`SV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\t)W_\x80\xFD[Pa\tD`\x04\x806\x03\x81\x01\x90a\t?\x91\x90a_\xF4V[a>$V[`@Qa\tQ\x91\x90a`SV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\teW_\x80\xFD[Pa\tna@\x1EV[`@Qa\t{\x91\x90ad\xDBV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\t\x8FW_\x80\xFD[Pa\t\xAA`\x04\x806\x03\x81\x01\x90a\t\xA5\x91\x90ad\xF4V[a@9V[`@Qa\t\xB7\x91\x90a`SV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\t\xCBW_\x80\xFD[Pa\t\xD4aB&V[`@Qa\t\xE1\x91\x90ad\xDBV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\t\xF5W_\x80\xFD[Pa\n\x10`\x04\x806\x03\x81\x01\x90a\n\x0B\x91\x90a_\xF4V[aBAV[`@Qa\n\x1D\x91\x90a`SV[`@Q\x80\x91\x03\x90\xF3[_\x80`\x06`S\x81\x11\x15a\n<Wa\n;aeJV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a\nWWa\nVaeJV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a\nrWa\nqaeJV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a\n\x8DWa\n\x8CaeJV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a\n\xA8Wa\n\xA7aeJV[[`\xFF\x16`\x01\x90\x1Ba\n\xB9\x91\x90ae\xA4V[a\n\xC3\x91\x90ae\xA4V[a\n\xCD\x91\x90ae\xA4V[a\n\xD7\x91\x90ae\xA4V[\x90P_a\n\xE4\x86\x83aD`V[\x90Pa\n\xF4`\x12\x87\x87\x87\x85aD\xC6V[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x04U?\xB6\x82\x86\x89\x89\x883`@Q\x87c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x0BM\x96\x95\x94\x93\x92\x91\x90af,V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x0BdW_\x80\xFD[PZ\xF1\x15\x80\x15a\x0BvW=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xC1\x1Db\xB1<6\n\x83\x08$\x87\x06K\xE1\xEC\x08x\xB2\xF0\xBEO\x01+\xF5\x9F\x89\xE1(\x06=G\xFF\x87\x87\x87\x87`@Qa\x0B\xC6\x94\x93\x92\x91\x90af\x8BV[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_\x80`@Q\x80`@\x01`@R\x80\x86s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x013s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81RP\x90P_a\x0C&\x87aG\xEEV[\x90P\x80`S\x81\x11\x15a\x0C;Wa\x0C:aeJV[[\x84`S\x81\x11\x15a\x0CNWa\x0CMaeJV[[\x14a\x0C\x85W`@Q\x7F\xB9h\x84a\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[s6w!B\xB7Hq\xF2U\xCB\xD7\xA3\xE8\x9B@\x1D>E\x82_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xE61}\xF5\x83\x89\x88`@Q\x84c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x0C\xD6\x93\x92\x91\x90ag\\V[` `@Q\x80\x83\x03\x81_\x87Z\xF1\x15\x80\x15a\x0C\xF2W=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\r\x16\x91\x90ag\xACV[\x92PsP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c>9\\\xEC\x843`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\rg\x92\x91\x90ag\xD7V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\r~W_\x80\xFD[PZ\xF1\x15\x80\x15a\r\x90W=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xDC7\r\xB35\x89\xE73q\xDC>\xE4,x\x9C\0=3n\xEF\xCB|?V\xFE\x0FQ\xAE[\x1D\x97\x02\x88\x88\x88\x88\x88`@Qa\r\xE2\x95\x94\x93\x92\x91\x90ag\xFEV[`@Q\x80\x91\x03\x90\xA2PP\x94\x93PPPPV[```@Q\x80`@\x01`@R\x80`\r\x81R` \x01\x7FFHEVMExecutor\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81RPa\x0E5_aH&V[a\x0E?`\x01aH&V[a\x0EH_aH&V[`@Q` \x01a\x0E[\x94\x93\x92\x91\x90ai$V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x90P\x90V[_\x80`\x06`S\x81\x11\x15a\x0E\x85Wa\x0E\x84aeJV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a\x0E\xA0Wa\x0E\x9FaeJV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a\x0E\xBBWa\x0E\xBAaeJV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a\x0E\xD6Wa\x0E\xD5aeJV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a\x0E\xF1Wa\x0E\xF0aeJV[[`\xFF\x16`\x01\x90\x1Ba\x0F\x02\x91\x90ae\xA4V[a\x0F\x0C\x91\x90ae\xA4V[a\x0F\x16\x91\x90ae\xA4V[a\x0F \x91\x90ae\xA4V[\x90P_a\x0F-\x86\x83aD`V[\x90Pa\x0F<_\x87\x87\x87\x85aD\xC6V[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xC19\x0C4\x82\x86\x89\x89\x883`@Q\x87c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x0F\x95\x96\x95\x94\x93\x92\x91\x90af,V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x0F\xACW_\x80\xFD[PZ\xF1\x15\x80\x15a\x0F\xBEW=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xDB\x90P\xD6R@C\x16!\xD6\x1Do\x94\xB9p\xE6?S\xA6zWfaN\xE6\xE5\xC5\xBB\xD4\x1C\x8E.\x87\x87\x87\x87`@Qa\x10\x0E\x94\x93\x92\x91\x90af\x8BV[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_\x80`\x06`S\x81\x11\x15a\x105Wa\x104aeJV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a\x10PWa\x10OaeJV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a\x10kWa\x10jaeJV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a\x10\x86Wa\x10\x85aeJV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a\x10\xA1Wa\x10\xA0aeJV[[`\xFF\x16`\x01\x90\x1Ba\x10\xB2\x91\x90ae\xA4V[a\x10\xBC\x91\x90ae\xA4V[a\x10\xC6\x91\x90ae\xA4V[a\x10\xD0\x91\x90ae\xA4V[\x90P_a\x10\xDD\x86\x83aD`V[\x90Pa\x10\xED`\x0E\x87\x87\x87_aD\xC6V[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xC2w\xA96\x82\x86\x89\x89\x883`@Q\x87c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x11F\x96\x95\x94\x93\x92\x91\x90af,V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x11]W_\x80\xFD[PZ\xF1\x15\x80\x15a\x11oW=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F8\xC3\xA6<B0\xDE[t\x1FIO\xFBT\xE3\x08q\x04\x03\x02y\xBC{\xCC\xEE\x8A\xD9\xAD1q+!\x87\x87\x87\x87`@Qa\x11\xBF\x94\x93\x92\x91\x90af\x8BV[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_\x80`\x06`S\x81\x11\x15a\x11\xE6Wa\x11\xE5aeJV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a\x12\x01Wa\x12\0aeJV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a\x12\x1CWa\x12\x1BaeJV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a\x127Wa\x126aeJV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a\x12RWa\x12QaeJV[[`\xFF\x16`\x01\x90\x1Ba\x12c\x91\x90ae\xA4V[a\x12m\x91\x90ae\xA4V[a\x12w\x91\x90ae\xA4V[a\x12\x81\x91\x90ae\xA4V[\x90P_a\x12\x8E\x86\x83aD`V[\x90Pa\x12\x9E`\x01\x87\x87\x87\x85aD\xC6V[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xD63\xC9k\x82\x86\x89\x89\x883`@Q\x87c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x12\xF7\x96\x95\x94\x93\x92\x91\x90af,V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x13\x0EW_\x80\xFD[PZ\xF1\x15\x80\x15a\x13 W=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xEBm7\xBD'\x1A\xBE\x13\x95\xB2\x1Dmx\xF3H}e\x84\x86(r\xC2\x9F\xFD?\x90sn\xE9\x9Bs\x93\x87\x87\x87\x87`@Qa\x13p\x94\x93\x92\x91\x90af\x8BV[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_sP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x82\x02{m\x843`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x13\xD1\x92\x91\x90ag\xD7V[` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x13\xECW=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x14\x10\x91\x90ai\xB7V[a\x14SW\x823`@Q\x7F\x9D\xE39,\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x14J\x92\x91\x90ag\xD7V[`@Q\x80\x91\x03\x90\xFD[_`\x08`S\x81\x11\x15a\x14hWa\x14gaeJV[[`\xFF\x16`\x01\x90\x1B`\x06`S\x81\x11\x15a\x14\x83Wa\x14\x82aeJV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a\x14\x9EWa\x14\x9DaeJV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a\x14\xB9Wa\x14\xB8aeJV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a\x14\xD4Wa\x14\xD3aeJV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a\x14\xEFWa\x14\xEEaeJV[[`\xFF\x16`\x01\x90\x1B_`S\x81\x11\x15a\x15\tWa\x15\x08aeJV[[`\xFF\x16`\x01\x90\x1Ba\x15\x1A\x91\x90ae\xA4V[a\x15$\x91\x90ae\xA4V[a\x15.\x91\x90ae\xA4V[a\x158\x91\x90ae\xA4V[a\x15B\x91\x90ae\xA4V[a\x15L\x91\x90ae\xA4V[\x90P_a\x15Y\x85\x83aD`V[\x90P_`\x08`S\x81\x11\x15a\x15pWa\x15oaeJV[[`\xFF\x16`\x01\x90\x1B`\x06`S\x81\x11\x15a\x15\x8BWa\x15\x8AaeJV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a\x15\xA6Wa\x15\xA5aeJV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a\x15\xC1Wa\x15\xC0aeJV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a\x15\xDCWa\x15\xDBaeJV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a\x15\xF7Wa\x15\xF6aeJV[[`\xFF\x16`\x01\x90\x1Ba\x16\x08\x91\x90ae\xA4V[a\x16\x12\x91\x90ae\xA4V[a\x16\x1C\x91\x90ae\xA4V[a\x16&\x91\x90ae\xA4V[a\x160\x91\x90ae\xA4V[\x90P_\x81\x86`S\x81\x11\x15a\x16GWa\x16FaeJV[[`\xFF\x16`\x01\x90\x1B\x16\x03a\x16\x86W`@Q\x7F\xC6\xDEFj\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x84`S\x81\x11\x15a\x16\x99Wa\x16\x98aeJV[[\x82`S\x81\x11\x15a\x16\xACWa\x16\xABaeJV[[\x03a\x16\xE3W`@Q\x7F\xB9h\x84a\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x17\x86\x86sP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]F`@Q` \x01a\x17\x11\x95\x94\x93\x92\x91\x90ak5V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x93Pa\x173\x84\x86aH\xF0V[\x93Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16ci\x93\x1A\xFB\x86\x88\x873`@Q\x85c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x17\x88\x94\x93\x92\x91\x90ak\x93V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x17\x9FW_\x80\xFD[PZ\xF1\x15\x80\x15a\x17\xB1W=_\x80>=_\xFD[PPPPsP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c>9\\\xEC\x853`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x18\x04\x92\x91\x90ag\xD7V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x18\x1BW_\x80\xFD[PZ\xF1\x15\x80\x15a\x18-W=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F1\xCC\xAEj/\x8E<\xED\x16\x92\xF7|\x8Ff\x813\xE4\xAF\xDA\xAA5\xAF\xE8D\xFFFY\xA6\xC2~b\x7F\x87\x87\x87`@Qa\x18{\x93\x92\x91\x90ak\xD6V[`@Q\x80\x91\x03\x90\xA2PPP\x92\x91PPV[_\x80`\x06`S\x81\x11\x15a\x18\xA2Wa\x18\xA1aeJV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a\x18\xBDWa\x18\xBCaeJV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a\x18\xD8Wa\x18\xD7aeJV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a\x18\xF3Wa\x18\xF2aeJV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a\x19\x0EWa\x19\raeJV[[`\xFF\x16`\x01\x90\x1Ba\x19\x1F\x91\x90ae\xA4V[a\x19)\x91\x90ae\xA4V[a\x193\x91\x90ae\xA4V[a\x19=\x91\x90ae\xA4V[\x90P_a\x19J\x86\x83aD`V[\x90Pa\x19Z`\x13\x87\x87\x87\x85aD\xC6V[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x96\x83\x02\xD7\x82\x86\x89\x89\x883`@Q\x87c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x19\xB3\x96\x95\x94\x93\x92\x91\x90af,V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x19\xCAW_\x80\xFD[PZ\xF1\x15\x80\x15a\x19\xDCW=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xFD|\x92\x08\xF9V\xBF\x0Cj\xB7jf\x7F\x046\x12E\xAD>\n-\x0E\xFF\x92\xEB\x82z\xCF\xCC\xA6\x8E\xA9\x87\x87\x87\x87`@Qa\x1A,\x94\x93\x92\x91\x90af\x8BV[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[`\x01a\x1AGaIiV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x1A\x88W`@Q\x7FoOs\x1F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x03_a\x1A\x93aI\x8DV[\x90P\x80_\x01`\x08\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x80a\x1A\xDBWP\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81_\x01_\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x10\x15[\x15a\x1B\x12W`@Q\x7F\xF9.\xE8\xA9\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x81\x81_\x01_a\x01\0\n\x81T\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP`\x01\x81_\x01`\x08a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP_\x81_\x01`\x08a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP\x7F\xC7\xF5\x05\xB2\xF3q\xAE!u\xEEI\x13\xF4I\x9E\x1F&3\xA7\xB5\x93c!\xEE\xD1\xCD\xAE\xB6\x11Q\x81\xD2\x82`@Qa\x1B\xA1\x91\x90al-V[`@Q\x80\x91\x03\x90\xA1PPV[_\x80a\x1B\xB7aI\xB4V[\x90Pa\x1B\xC4\x84\x84\x83aJ1V[\x91P3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7FR\"\xD9k\x83g'\xA1\xD6\xFE\x1E\xE9\xAE\xF2\x7F\x9B\xB5\x07\xBDAyM\xEF\xA3v\xFFld\x8A\xAF\x8F\xF1\x85\x85\x84\x86`@Qa\x1C\x12\x94\x93\x92\x91\x90al\x8FV[`@Q\x80\x91\x03\x90\xA2P\x92\x91PPV[a\x1C)aL\xE4V[a\x1C2\x82aM\xCAV[a\x1C<\x82\x82aN\xBDV[PPV[_a\x1CIaO\xDBV[\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC_\x1B\x90P\x90V[_\x80`\x06`S\x81\x11\x15a\x1C\x87Wa\x1C\x86aeJV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a\x1C\xA2Wa\x1C\xA1aeJV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a\x1C\xBDWa\x1C\xBCaeJV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a\x1C\xD8Wa\x1C\xD7aeJV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a\x1C\xF3Wa\x1C\xF2aeJV[[`\xFF\x16`\x01\x90\x1Ba\x1D\x04\x91\x90ae\xA4V[a\x1D\x0E\x91\x90ae\xA4V[a\x1D\x18\x91\x90ae\xA4V[a\x1D\"\x91\x90ae\xA4V[\x90P_a\x1D/\x86\x83aD`V[\x90Pa\x1D?`\x02\x87\x87\x87\x85aD\xC6V[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x81\x8FMi\x82\x86\x89\x89\x883`@Q\x87c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x1D\x98\x96\x95\x94\x93\x92\x91\x90af,V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x1D\xAFW_\x80\xFD[PZ\xF1\x15\x80\x15a\x1D\xC1W=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F!SF\xA4\xF9\xF9u\xE6\xD5HN)\x0B\xD4\xE5<\xA1DS\xA9\xD2\x82\xEB\xD3\xCC\xED\xB2\xA0\xF1qu=\x87\x87\x87\x87`@Qa\x1E\x11\x94\x93\x92\x91\x90af\x8BV[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_`\x01`\xF8\x1B\x82~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x14a\x1E\x82W`@Q\x7FO\"NS\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x80\x1B\x83\x03a\x1E\xBDW`@Q\x7F#\xD3Y\xA3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\x06`S\x81\x11\x15a\x1E\xD2Wa\x1E\xD1aeJV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a\x1E\xEDWa\x1E\xECaeJV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a\x1F\x08Wa\x1F\x07aeJV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a\x1F#Wa\x1F\"aeJV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a\x1F>Wa\x1F=aeJV[[`\xFF\x16`\x01\x90\x1Ba\x1FO\x91\x90ae\xA4V[a\x1FY\x91\x90ae\xA4V[a\x1Fc\x91\x90ae\xA4V[a\x1Fm\x91\x90ae\xA4V[\x90P_a\x1Fz\x86\x83aD`V[\x90Pa\x1F\x8A`\x03\x87\x87\x87\x85aD\xC6V[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x9B?x\x1A\x82\x86\x89\x89\x883`@Q\x87c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x1F\xE3\x96\x95\x94\x93\x92\x91\x90af,V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x1F\xFAW_\x80\xFD[PZ\xF1\x15\x80\x15a \x0CW=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F;\xAB.\xE0\xE2\xF9\x0FF\x90\xC6\xA8{\xF6<\xF1\xA6\xB6&\x08n\x95\xF21\x86\x0B\x15)f\xE8\xDA\xBB\xF7\x87\x87\x87\x87`@Qa \\\x94\x93\x92\x91\x90af\x8BV[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_\x80`\x08`S\x81\x11\x15a \x83Wa \x82aeJV[[`\xFF\x16`\x01\x90\x1B`\x06`S\x81\x11\x15a \x9EWa \x9DaeJV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a \xB9Wa \xB8aeJV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a \xD4Wa \xD3aeJV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a \xEFWa \xEEaeJV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a!\nWa!\taeJV[[`\xFF\x16`\x01\x90\x1B_`S\x81\x11\x15a!$Wa!#aeJV[[`\xFF\x16`\x01\x90\x1Ba!5\x91\x90ae\xA4V[a!?\x91\x90ae\xA4V[a!I\x91\x90ae\xA4V[a!S\x91\x90ae\xA4V[a!]\x91\x90ae\xA4V[a!g\x91\x90ae\xA4V[\x90P_a!t\x86\x83aD`V[\x90Pa!\x84`\x06\x87\x87\x87\x85aD\xC6V[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xC0\xC5\xDF|\x82\x86\x89\x89\x883`@Q\x87c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a!\xDD\x96\x95\x94\x93\x92\x91\x90af,V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a!\xF4W_\x80\xFD[PZ\xF1\x15\x80\x15a\"\x06W=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7FV\xDF'\x9B\xBF\xB0=\x9E\xD0\x97\xBB\xE2\xF2\x8DR\x0C\xA0\xC1\x16\x12\x062y&\xE9\x86d\xD7\r,$\xC4\x87\x87\x87\x87`@Qa\"V\x94\x93\x92\x91\x90af\x8BV[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_\x80`\x08`S\x81\x11\x15a\"}Wa\"|aeJV[[`\xFF\x16`\x01\x90\x1B`\x06`S\x81\x11\x15a\"\x98Wa\"\x97aeJV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a\"\xB3Wa\"\xB2aeJV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a\"\xCEWa\"\xCDaeJV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a\"\xE9Wa\"\xE8aeJV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a#\x04Wa#\x03aeJV[[`\xFF\x16`\x01\x90\x1Ba#\x15\x91\x90ae\xA4V[a#\x1F\x91\x90ae\xA4V[a#)\x91\x90ae\xA4V[a#3\x91\x90ae\xA4V[a#=\x91\x90ae\xA4V[\x90P_a#J\x86\x83aD`V[\x90Pa#Z`\n\x87\x87\x87\x85aD\xC6V[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c_v\xEB0\x82\x86\x89\x89\x883`@Q\x87c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a#\xB3\x96\x95\x94\x93\x92\x91\x90af,V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a#\xCAW_\x80\xFD[PZ\xF1\x15\x80\x15a#\xDCW=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xEB\x0EO\x8D\xC7@X\x19M\x06\x02B_\xE6\x02\xF9U\xC2\" \x0F\x7F\x10\xC6\xFEg\x99/{$\xC7\xE9\x87\x87\x87\x87`@Qa$,\x94\x93\x92\x91\x90af\x8BV[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_\x80`\x06`S\x81\x11\x15a$SWa$RaeJV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a$nWa$maeJV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a$\x89Wa$\x88aeJV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a$\xA4Wa$\xA3aeJV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a$\xBFWa$\xBEaeJV[[`\xFF\x16`\x01\x90\x1Ba$\xD0\x91\x90ae\xA4V[a$\xDA\x91\x90ae\xA4V[a$\xE4\x91\x90ae\xA4V[a$\xEE\x91\x90ae\xA4V[\x90P_a$\xFB\x86\x83aD`V[\x90Pa%\x0B`\x11\x87\x87\x87_aD\xC6V[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c;\xB7\xD5\xA3\x82\x86\x89\x89\x883`@Q\x87c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a%d\x96\x95\x94\x93\x92\x91\x90af,V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a%{W_\x80\xFD[PZ\xF1\x15\x80\x15a%\x8DW=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\rH;\x10\r\x8Cs\xB2\x08\x98N\xC6\x97\xCA\xA3\t\x15!\xEEU%\xCEi\xED\xCF\x97\xD7\xE3\x95\xD3\xD0Y\x87\x87\x87\x87`@Qa%\xDD\x94\x93\x92\x91\x90af\x8BV[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_\x80`\x06`S\x81\x11\x15a&\x04Wa&\x03aeJV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a&\x1FWa&\x1EaeJV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a&:Wa&9aeJV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a&UWa&TaeJV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a&pWa&oaeJV[[`\xFF\x16`\x01\x90\x1Ba&\x81\x91\x90ae\xA4V[a&\x8B\x91\x90ae\xA4V[a&\x95\x91\x90ae\xA4V[a&\x9F\x91\x90ae\xA4V[\x90P_a&\xAC\x86\x83aD`V[\x90Pa&\xBC`\x10\x87\x87\x87_aD\xC6V[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c8\xBD\x17\xE5\x82\x86\x89\x89\x883`@Q\x87c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a'\x15\x96\x95\x94\x93\x92\x91\x90af,V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a',W_\x80\xFD[PZ\xF1\x15\x80\x15a'>W=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xDE\xF2\xE7\x04\xA0w(J\x07\xF3\xD0\xB46\xDB\x88\xF5\xD9\x81\xB6\x9FX\xAB|\x1A\xE6#%'\x18\xA6\xDE\x01\x87\x87\x87\x87`@Qa'\x8E\x94\x93\x92\x91\x90af\x8BV[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_\x80`\x08`S\x81\x11\x15a'\xB5Wa'\xB4aeJV[[`\xFF\x16`\x01\x90\x1B`\x07`S\x81\x11\x15a'\xD0Wa'\xCFaeJV[[`\xFF\x16`\x01\x90\x1B`\x06`S\x81\x11\x15a'\xEBWa'\xEAaeJV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a(\x06Wa(\x05aeJV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a(!Wa( aeJV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a(<Wa(;aeJV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a(WWa(VaeJV[[`\xFF\x16`\x01\x90\x1B_`S\x81\x11\x15a(qWa(paeJV[[`\xFF\x16`\x01\x90\x1Ba(\x82\x91\x90ae\xA4V[a(\x8C\x91\x90ae\xA4V[a(\x96\x91\x90ae\xA4V[a(\xA0\x91\x90ae\xA4V[a(\xAA\x91\x90ae\xA4V[a(\xB4\x91\x90ae\xA4V[a(\xBE\x91\x90ae\xA4V[\x90P_a(\xCB\x85\x83aD`V[\x90Pa(\xDA`\x19\x87\x87\x87aPbV[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c.<9\x06\x82\x88\x88\x88\x883`@Q\x87c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a)3\x96\x95\x94\x93\x92\x91\x90al\xD2V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a)JW_\x80\xFD[PZ\xF1\x15\x80\x15a)\\W=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F`\xBE\x9Da\xAA\xD8I\xFA\xCC(\xC3\x8B\x04\x8C\xB5\xC4\xBE4 \xB8\xFA\"3\xE0\x8C\xFA\x06\xBE\x1Bm\x1C>\x87\x87\x87\x87`@Qa)\xAC\x94\x93\x92\x91\x90am1V[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_\x90V[_\x80`\x06`S\x81\x11\x15a)\xD7Wa)\xD6aeJV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a)\xF2Wa)\xF1aeJV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a*\rWa*\x0CaeJV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a*(Wa*'aeJV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a*CWa*BaeJV[[`\xFF\x16`\x01\x90\x1Ba*T\x91\x90ae\xA4V[a*^\x91\x90ae\xA4V[a*h\x91\x90ae\xA4V[a*r\x91\x90ae\xA4V[\x90P_a*\x7F\x86\x83aD`V[\x90Pa*\x8F`\x0F\x87\x87\x87_aD\xC6V[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16cE\x8F\xB2w\x82\x86\x89\x89\x883`@Q\x87c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a*\xE8\x96\x95\x94\x93\x92\x91\x90af,V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a*\xFFW_\x80\xFD[PZ\xF1\x15\x80\x15a+\x11W=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xC9\xFF\x8F\r\x18\xA3\xF7f\xCE]\xE3\xDE!`v\x05\x01@\xE4\xFC&R\xF5\xE0\xE7E\xF6\xFC\x83l\xDA\x8B\x87\x87\x87\x87`@Qa+a\x94\x93\x92\x91\x90af\x8BV[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_\x80`\x08`S\x81\x11\x15a+\x88Wa+\x87aeJV[[`\xFF\x16`\x01\x90\x1B`\x06`S\x81\x11\x15a+\xA3Wa+\xA2aeJV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a+\xBEWa+\xBDaeJV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a+\xD9Wa+\xD8aeJV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a+\xF4Wa+\xF3aeJV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a,\x0FWa,\x0EaeJV[[`\xFF\x16`\x01\x90\x1B_`S\x81\x11\x15a,)Wa,(aeJV[[`\xFF\x16`\x01\x90\x1Ba,:\x91\x90ae\xA4V[a,D\x91\x90ae\xA4V[a,N\x91\x90ae\xA4V[a,X\x91\x90ae\xA4V[a,b\x91\x90ae\xA4V[a,l\x91\x90ae\xA4V[\x90P_a,y\x86\x83aD`V[\x90Pa,\x89`\x07\x87\x87\x87\x85aD\xC6V[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x9F\x92Y\xBB\x82\x86\x89\x89\x883`@Q\x87c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a,\xE2\x96\x95\x94\x93\x92\x91\x90af,V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a,\xF9W_\x80\xFD[PZ\xF1\x15\x80\x15a-\x0BW=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7FM2(K\xD3\x19>\xCA\xA4N\x1C\xEC\xA3/A\xC5\xD6\xC3(\x03\xA9.\x07\x96}\xD3\xEEB)r\x15\x82\x87\x87\x87\x87`@Qa-[\x94\x93\x92\x91\x90af\x8BV[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_\x80`\x08`S\x81\x11\x15a-\x82Wa-\x81aeJV[[`\xFF\x16`\x01\x90\x1B`\x06`S\x81\x11\x15a-\x9DWa-\x9CaeJV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a-\xB8Wa-\xB7aeJV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a-\xD3Wa-\xD2aeJV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a-\xEEWa-\xEDaeJV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a.\tWa.\x08aeJV[[`\xFF\x16`\x01\x90\x1Ba.\x1A\x91\x90ae\xA4V[a.$\x91\x90ae\xA4V[a..\x91\x90ae\xA4V[a.8\x91\x90ae\xA4V[a.B\x91\x90ae\xA4V[\x90P_a.O\x86\x83aD`V[\x90Pa._`\t\x87\x87\x87\x85aD\xC6V[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x07\xCC\xDFa\x82\x86\x89\x89\x883`@Q\x87c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a.\xB8\x96\x95\x94\x93\x92\x91\x90af,V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a.\xCFW_\x80\xFD[PZ\xF1\x15\x80\x15a.\xE1W=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F2B \xBF\xC9\xCB\x15\x8BI)\x91\xC0<0\x9C\xD8nSE\xCA\xC4Z\xAC\xAE \x92\xDD\xAB\xE3\x1F\xA3\xD8\x87\x87\x87\x87`@Qa/1\x94\x93\x92\x91\x90af\x8BV[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_\x80`\x08`S\x81\x11\x15a/XWa/WaeJV[[`\xFF\x16`\x01\x90\x1B`\x07`S\x81\x11\x15a/sWa/raeJV[[`\xFF\x16`\x01\x90\x1B`\x06`S\x81\x11\x15a/\x8EWa/\x8DaeJV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a/\xA9Wa/\xA8aeJV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a/\xC4Wa/\xC3aeJV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a/\xDFWa/\xDEaeJV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a/\xFAWa/\xF9aeJV[[`\xFF\x16`\x01\x90\x1B_`S\x81\x11\x15a0\x14Wa0\x13aeJV[[`\xFF\x16`\x01\x90\x1Ba0%\x91\x90ae\xA4V[a0/\x91\x90ae\xA4V[a09\x91\x90ae\xA4V[a0C\x91\x90ae\xA4V[a0M\x91\x90ae\xA4V[a0W\x91\x90ae\xA4V[a0a\x91\x90ae\xA4V[\x90P_\x81\x84`S\x81\x11\x15a0xWa0waeJV[[`\xFF\x16`\x01\x90\x1B\x16\x03a0\xB7W`@Q\x7F\xC6\xDEFj\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x18\x84\x84sP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]F`@Q` \x01a0\xE5\x95\x94\x93\x92\x91\x90amtV[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x91Pa1\x07\x82\x84aH\xF0V[\x91Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xB7\x8B\xEFY\x84\x843`@Q\x84c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a1Z\x93\x92\x91\x90am\xD2V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a1qW_\x80\xFD[PZ\xF1\x15\x80\x15a1\x83W=_\x80>=_\xFD[PPPPsP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c>9\\\xEC\x833`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a1\xD6\x92\x91\x90ag\xD7V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a1\xEDW_\x80\xFD[PZ\xF1\x15\x80\x15a1\xFFW=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\x06<\xCD\x1B\xBAE\x15\x1D\x91\xF6\xA4\x18\x06PG\xA3\xD0H\xD0X\xA9\"SWG\xBB+WZ\x01\xD26\x85\x85\x85`@Qa2M\x93\x92\x91\x90an\x07V[`@Q\x80\x91\x03\x90\xA2P\x92\x91PPV[_s6w!B\xB7Hq\xF2U\xCB\xD7\xA3\xE8\x9B@\x1D>E\x82_\x90P\x90V[`@Q\x80`@\x01`@R\x80`\x05\x81R` \x01\x7F5.0.0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81RP\x81V[`\x03_a2\xBBaI\x8DV[\x90P\x80_\x01`\x08\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x80a3\x03WP\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81_\x01_\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x10\x15[\x15a3:W`@Q\x7F\xF9.\xE8\xA9\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x81\x81_\x01_a\x01\0\n\x81T\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP`\x01\x81_\x01`\x08a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP_\x81_\x01`\x08a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP\x7F\xC7\xF5\x05\xB2\xF3q\xAE!u\xEEI\x13\xF4I\x9E\x1F&3\xA7\xB5\x93c!\xEE\xD1\xCD\xAE\xB6\x11Q\x81\xD2\x82`@Qa3\xC9\x91\x90al-V[`@Q\x80\x91\x03\x90\xA1PPV[_\x80`\x08`S\x81\x11\x15a3\xEBWa3\xEAaeJV[[`\xFF\x16`\x01\x90\x1B`\x06`S\x81\x11\x15a4\x06Wa4\x05aeJV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a4!Wa4 aeJV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a4<Wa4;aeJV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a4WWa4VaeJV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a4rWa4qaeJV[[`\xFF\x16`\x01\x90\x1Ba4\x83\x91\x90ae\xA4V[a4\x8D\x91\x90ae\xA4V[a4\x97\x91\x90ae\xA4V[a4\xA1\x91\x90ae\xA4V[a4\xAB\x91\x90ae\xA4V[\x90P_a4\xB8\x86\x83aD`V[\x90Pa4\xC8`\x0B\x87\x87\x87\x85aD\xC6V[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x86)\xF5E\x82\x86\x89\x89\x883`@Q\x87c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a5!\x96\x95\x94\x93\x92\x91\x90af,V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a58W_\x80\xFD[PZ\xF1\x15\x80\x15a5JW=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xC1HgY\x05\xD0z\xD5Io\x8E\xF4\xD8\x19\\\x90u\x03\xF3\xEC\x12\xFD\x10\xED_!$\n\xBCi64\x87\x87\x87\x87`@Qa5\x9A\x94\x93\x92\x91\x90af\x8BV[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_\x80`\x08`S\x81\x11\x15a5\xC1Wa5\xC0aeJV[[`\xFF\x16`\x01\x90\x1B`\x06`S\x81\x11\x15a5\xDCWa5\xDBaeJV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a5\xF7Wa5\xF6aeJV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a6\x12Wa6\x11aeJV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a6-Wa6,aeJV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a6HWa6GaeJV[[`\xFF\x16`\x01\x90\x1Ba6Y\x91\x90ae\xA4V[a6c\x91\x90ae\xA4V[a6m\x91\x90ae\xA4V[a6w\x91\x90ae\xA4V[a6\x81\x91\x90ae\xA4V[\x90P_a6\x8E\x86\x83aD`V[\x90Pa6\x9E`\x08\x87\x87\x87\x85aD\xC6V[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xF7\xD1\x98\xF8\x82\x86\x89\x89\x883`@Q\x87c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a6\xF7\x96\x95\x94\x93\x92\x91\x90af,V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a7\x0EW_\x80\xFD[PZ\xF1\x15\x80\x15a7 W=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xE8B\x82\xAA\xEB\xCC\xA6\x98D>9\xA2\xA9H\xA3E\xD0\xD2\xEB\xC6T\xAF\\\xB6W\xA2\xD7\xE8\x05;\xF6\xCB\x87\x87\x87\x87`@Qa7p\x94\x93\x92\x91\x90af\x8BV[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_`\x01`\xF8\x1B\x82~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x14a7\xE1W`@Q\x7FO\"NS\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x80\x1B\x83\x03a8\x1CW`@Q\x7F#\xD3Y\xA3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\x06`S\x81\x11\x15a81Wa80aeJV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a8LWa8KaeJV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a8gWa8faeJV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a8\x82Wa8\x81aeJV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a8\x9DWa8\x9CaeJV[[`\xFF\x16`\x01\x90\x1Ba8\xAE\x91\x90ae\xA4V[a8\xB8\x91\x90ae\xA4V[a8\xC2\x91\x90ae\xA4V[a8\xCC\x91\x90ae\xA4V[\x90P_a8\xD9\x86\x83aD`V[\x90Pa8\xE9`\x04\x87\x87\x87\x85aD\xC6V[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c3\x11\xB1\xBC\x82\x86\x89\x89\x883`@Q\x87c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a9B\x96\x95\x94\x93\x92\x91\x90af,V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a9YW_\x80\xFD[PZ\xF1\x15\x80\x15a9kW=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\x0Ei\x1C\xD0\xBF\x8CN\x93\x08\xE4\xCE\xD1\xBB\x9C\x96A\x17\xDC\\[\xB9\xB9\xAB[\xDF\xEB\xF2\xC9\xB1:\x89|\x87\x87\x87\x87`@Qa9\xBB\x94\x93\x92\x91\x90af\x8BV[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_\x80`\x08`S\x81\x11\x15a9\xE2Wa9\xE1aeJV[[`\xFF\x16`\x01\x90\x1B`\x06`S\x81\x11\x15a9\xFDWa9\xFCaeJV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a:\x18Wa:\x17aeJV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a:3Wa:2aeJV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a:NWa:MaeJV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a:iWa:haeJV[[`\xFF\x16`\x01\x90\x1Ba:z\x91\x90ae\xA4V[a:\x84\x91\x90ae\xA4V[a:\x8E\x91\x90ae\xA4V[a:\x98\x91\x90ae\xA4V[a:\xA2\x91\x90ae\xA4V[\x90P_a:\xAF\x84\x83aD`V[\x90Pa:\xBC`\x14\x85aT\x8EV[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16cI|\"\xC5\x82\x86\x863`@Q\x85c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a;\x11\x94\x93\x92\x91\x90ak\x93V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a;(W_\x80\xFD[PZ\xF1\x15\x80\x15a;:W=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\x8CfM<<\xA5\x83\xFCX\x03\xB8\xA9\x1CIdK\xBD\x95P\xBF\xA8yg\xC7:\xD1\xDE\x83\x02wh\xC0\x85\x85`@Qa;\x86\x92\x91\x90an<V[`@Q\x80\x91\x03\x90\xA2PP\x91\x90PV[_\x80a;\x9FaI\xB4V[\x90Pa;\xAB\x83\x82aV>V[\x91P3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\x0C\x8A\xCA`\x17\x003&\x05\x1E\x19\x91>\xF0&1\xF2K\x80\x11%\xE1\xFA\x8A\x1D\x81.\x86\x83\x19\xFD\xA6\x84\x83\x85`@Qa;\xF7\x93\x92\x91\x90ancV[`@Q\x80\x91\x03\x90\xA2P\x91\x90PV[_\x80`\x08`S\x81\x11\x15a<\x1BWa<\x1AaeJV[[`\xFF\x16`\x01\x90\x1B`\x07`S\x81\x11\x15a<6Wa<5aeJV[[`\xFF\x16`\x01\x90\x1B`\x06`S\x81\x11\x15a<QWa<PaeJV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a<lWa<kaeJV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a<\x87Wa<\x86aeJV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a<\xA2Wa<\xA1aeJV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a<\xBDWa<\xBCaeJV[[`\xFF\x16`\x01\x90\x1B_`S\x81\x11\x15a<\xD7Wa<\xD6aeJV[[`\xFF\x16`\x01\x90\x1Ba<\xE8\x91\x90ae\xA4V[a<\xF2\x91\x90ae\xA4V[a<\xFC\x91\x90ae\xA4V[a=\x06\x91\x90ae\xA4V[a=\x10\x91\x90ae\xA4V[a=\x1A\x91\x90ae\xA4V[a=$\x91\x90ae\xA4V[\x90P_a=1\x86\x83aD`V[\x90Pa=A`\r\x87\x87\x87_aD\xC6V[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16ck\xAD\x18\xB6\x82\x86\x89\x89\x883`@Q\x87c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a=\x9A\x96\x95\x94\x93\x92\x91\x90af,V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a=\xB1W_\x80\xFD[PZ\xF1\x15\x80\x15a=\xC3W=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7Fi`\xC1\xE8\x8Fa\xC3R\xDB\xA3M\x1B\xBFgS\xE3\x02yRd\xD5\xD8\xAE\x82\xF7\x98<p\x04e\x1E]\x87\x87\x87\x87`@Qa>\x13\x94\x93\x92\x91\x90af\x8BV[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_\x80`\x08`S\x81\x11\x15a>:Wa>9aeJV[[`\xFF\x16`\x01\x90\x1B`\x06`S\x81\x11\x15a>UWa>TaeJV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a>pWa>oaeJV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a>\x8BWa>\x8AaeJV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a>\xA6Wa>\xA5aeJV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a>\xC1Wa>\xC0aeJV[[`\xFF\x16`\x01\x90\x1B_`S\x81\x11\x15a>\xDBWa>\xDAaeJV[[`\xFF\x16`\x01\x90\x1Ba>\xEC\x91\x90ae\xA4V[a>\xF6\x91\x90ae\xA4V[a?\0\x91\x90ae\xA4V[a?\n\x91\x90ae\xA4V[a?\x14\x91\x90ae\xA4V[a?\x1E\x91\x90ae\xA4V[\x90P_a?+\x86\x83aD`V[\x90Pa?;`\x05\x87\x87\x87\x85aD\xC6V[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xC8\xDECR\x82\x86\x89\x89\x883`@Q\x87c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a?\x94\x96\x95\x94\x93\x92\x91\x90af,V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a?\xABW_\x80\xFD[PZ\xF1\x15\x80\x15a?\xBDW=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xE4$\x86\xB0\xCC\xDB\xEF\x81\xA2\x07\\H\xC8\xE5\x15\xC0y\xAE\xA7<\x8B\x82B\x99\x97\xC7*/\xE1\xBFO\xEF\x87\x87\x87\x87`@Qa@\r\x94\x93\x92\x91\x90af\x8BV[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_s#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9\x90P\x90V[_\x80`\x08`S\x81\x11\x15a@OWa@NaeJV[[`\xFF\x16`\x01\x90\x1B`\x06`S\x81\x11\x15a@jWa@iaeJV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a@\x85Wa@\x84aeJV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a@\xA0Wa@\x9FaeJV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a@\xBBWa@\xBAaeJV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a@\xD6Wa@\xD5aeJV[[`\xFF\x16`\x01\x90\x1B_`S\x81\x11\x15a@\xF0Wa@\xEFaeJV[[`\xFF\x16`\x01\x90\x1BaA\x01\x91\x90ae\xA4V[aA\x0B\x91\x90ae\xA4V[aA\x15\x91\x90ae\xA4V[aA\x1F\x91\x90ae\xA4V[aA)\x91\x90ae\xA4V[aA3\x91\x90ae\xA4V[\x90P_aA@\x84\x83aD`V[\x90PaAM`\x15\x85aT\x8EV[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c-\xCB\xC5\xD1\x82\x86\x863`@Q\x85c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01aA\xA2\x94\x93\x92\x91\x90ak\x93V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15aA\xB9W_\x80\xFD[PZ\xF1\x15\x80\x15aA\xCBW=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7FU\xAF\xF4\xCCz=\x16\x0C\x83\xF1\xF1[\x81\x80\x11\xED\xE8A\xA0\xB4Y\x7F\xB1M\xCD6\x03\xDF:\x11\xE5\xE0\x85\x85`@QaB\x17\x92\x91\x90an<V[`@Q\x80\x91\x03\x90\xA2PP\x91\x90PV[_sP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]\x90P\x90V[_\x80`\x08`S\x81\x11\x15aBWWaBVaeJV[[`\xFF\x16`\x01\x90\x1B`\x07`S\x81\x11\x15aBrWaBqaeJV[[`\xFF\x16`\x01\x90\x1B`\x06`S\x81\x11\x15aB\x8DWaB\x8CaeJV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15aB\xA8WaB\xA7aeJV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15aB\xC3WaB\xC2aeJV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15aB\xDEWaB\xDDaeJV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15aB\xF9WaB\xF8aeJV[[`\xFF\x16`\x01\x90\x1B_`S\x81\x11\x15aC\x13WaC\x12aeJV[[`\xFF\x16`\x01\x90\x1BaC$\x91\x90ae\xA4V[aC.\x91\x90ae\xA4V[aC8\x91\x90ae\xA4V[aCB\x91\x90ae\xA4V[aCL\x91\x90ae\xA4V[aCV\x91\x90ae\xA4V[aC`\x91\x90ae\xA4V[\x90P_aCm\x86\x83aD`V[\x90PaC}`\x0C\x87\x87\x87_aD\xC6V[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c`\xE1!\x89\x82\x86\x89\x89\x883`@Q\x87c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01aC\xD6\x96\x95\x94\x93\x92\x91\x90af,V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15aC\xEDW_\x80\xFD[PZ\xF1\x15\x80\x15aC\xFFW=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xB3\xD5\xC6d\xEC\x86WX\x18\xE8\xD7_\xF2\\_\x86rP\xDF\x89T\x08\x85I\xC4\x1C\x84\x8C\xD1\x0Ev\xCB\x87\x87\x87\x87`@QaDO\x94\x93\x92\x91\x90af\x8BV[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_aDj\x83aG\xEEV[\x90P_\x82\x82`S\x81\x11\x15aD\x81WaD\x80aeJV[[`\xFF\x16`\x01\x90\x1B\x16\x03aD\xC0W`@Q\x7F\xC6\xDEFj\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x92\x91PPV[_aD\xD0\x83aX\xC9V[sP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x82\x02{m\x863`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01aE\x1F\x92\x91\x90ag\xD7V[` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15aE:W=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90aE^\x91\x90ai\xB7V[aE\xA1W\x843`@Q\x7F\x9D\xE39,\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aE\x98\x92\x91\x90ag\xD7V[`@Q\x80\x91\x03\x90\xFD[_`\xF8\x1B\x83~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x03aG\x16WsP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x82\x02{m\x853`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01aF\x1C\x92\x91\x90ag\xD7V[` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15aF7W=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90aF[\x91\x90ai\xB7V[aF\x9EW\x833`@Q\x7F\x9D\xE39,\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aF\x95\x92\x91\x90ag\xD7V[`@Q\x80\x91\x03\x90\xFD[_aF\xA8\x85aG\xEEV[\x90P_aF\xB4\x87aG\xEEV[\x90P\x81`S\x81\x11\x15aF\xC9WaF\xC8aeJV[[\x81`S\x81\x11\x15aF\xDCWaF\xDBaeJV[[\x14aG\x13W`@Q\x7F\x1F1X\xC7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[PP[\x85\x85\x85\x85sP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]F`@Q` \x01aGE\x96\x95\x94\x93\x92\x91\x90an\xB8V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x90PaGg\x81\x83aH\xF0V[\x90PsP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c>9\\\xEC\x823`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01aG\xB8\x92\x91\x90ag\xD7V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15aG\xCFW_\x80\xFD[PZ\xF1\x15\x80\x15aG\xE1W=_\x80>=_\xFD[PPPP\x95\x94PPPPPV[_\x81`\x1E` \x81\x10aH\x03WaH\x02ao'V[[\x1A`\xF8\x1B`\xF8\x1C`\xFF\x16`S\x81\x11\x15aH\x1FWaH\x1EaeJV[[\x90P\x91\x90PV[``_`\x01aH4\x84aY\rV[\x01\x90P_\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15aHRWaHQa`\xDEV[[`@Q\x90\x80\x82R\x80`\x1F\x01`\x1F\x19\x16` \x01\x82\x01`@R\x80\x15aH\x84W\x81` \x01`\x01\x82\x02\x806\x837\x80\x82\x01\x91PP\x90P[P\x90P_\x82` \x01\x82\x01\x90P[`\x01\x15aH\xE5W\x80\x80`\x01\x90\x03\x91PP\x7F0123456789abcdef\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\n\x86\x06\x1A\x81S`\n\x85\x81aH\xDAWaH\xD9aoTV[[\x04\x94P_\x85\x03aH\x91W[\x81\x93PPPP\x91\x90PV[_\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0_\x1B\x83\x16\x90P`P`\xFF_\x1B\x90\x1B\x81\x17\x90P`\x10Fg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16_\x1B\x90\x1B\x81\x17\x90P`\x08\x82`S\x81\x11\x15aINWaIMaeJV[[`\xFF\x16_\x1B\x90\x1B\x81\x17\x90P_`\xFF\x16_\x1B\x81\x17\x90P\x92\x91PPV[_aIraI\x8DV[_\x01_\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P\x90V[_\x7F\xF0\xC5~\x16\x84\r\xF0@\xF1P\x88\xDC/\x81\xFE9\x1C9#\xBE\xC7>#\xA9f.\xFC\x9C\"\x9Cj\0\x90P\x90V[_\x80aI\xBEaZ^V[\x90P\x80_\x01TsP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]F`\x01CaI\xE7\x91\x90ao\x81V[@B`@Q` \x01aI\xFD\x95\x94\x93\x92\x91\x90ao\xB4V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x91P\x80_\x01_\x81T\x80\x92\x91\x90aJ(\x90ap\x12V[\x91\x90PUPP\x90V[_\x80`\x08`S\x81\x11\x15aJGWaJFaeJV[[`\xFF\x16`\x01\x90\x1B`\x06`S\x81\x11\x15aJbWaJaaeJV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15aJ}WaJ|aeJV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15aJ\x98WaJ\x97aeJV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15aJ\xB3WaJ\xB2aeJV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15aJ\xCEWaJ\xCDaeJV[[`\xFF\x16`\x01\x90\x1BaJ\xDF\x91\x90ae\xA4V[aJ\xE9\x91\x90ae\xA4V[aJ\xF3\x91\x90ae\xA4V[aJ\xFD\x91\x90ae\xA4V[aK\x07\x91\x90ae\xA4V[\x90P_\x81\x85`S\x81\x11\x15aK\x1EWaK\x1DaeJV[[`\xFF\x16`\x01\x90\x1B\x16\x03aK]W`@Q\x7F\xC6\xDEFj\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[aKf\x85aZ\x85V[aK\x9CW`@Q\x7F$\xE8\xE7B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[aK\xA6\x85\x85aZ\xA9V[`\x1B\x85\x85\x85`@Q` \x01aK\xBE\x94\x93\x92\x91\x90apyV[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x91PaK\xE0\x82\x85aH\xF0V[\x91Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16cl\xF0\xBD%\x85\x843`@Q\x84c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01aL3\x93\x92\x91\x90am\xD2V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15aLJW_\x80\xFD[PZ\xF1\x15\x80\x15aL\\W=_\x80>=_\xFD[PPPPsP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c>9\\\xEC\x833`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01aL\xAF\x92\x91\x90ag\xD7V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15aL\xC6W_\x80\xFD[PZ\xF1\x15\x80\x15aL\xD8W=_\x80>=_\xFD[PPPPP\x93\x92PPPV[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x160s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14\x80aM\x91WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16aMxa[\xF9V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14\x15[\x15aM\xC8W`@Q\x7F\xE0|\x8D\xBA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[V[sP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x8D\xA5\xCB[`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15aN'W=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90aNK\x91\x90ap\xDAV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14aN\xBAW3`@Q\x7F!\xBF\xDA\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aN\xB1\x91\x90ad\xDBV[`@Q\x80\x91\x03\x90\xFD[PV[\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16cR\xD1\x90-`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x92PPP\x80\x15aO%WP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90aO\"\x91\x90ag\xACV[`\x01[aOfW\x81`@Q\x7FL\x9C\x8C\xE3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aO]\x91\x90ad\xDBV[`@Q\x80\x91\x03\x90\xFD[\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC_\x1B\x81\x14aO\xCCW\x80`@Q\x7F\xAA\x1DI\xA4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aO\xC3\x91\x90a`SV[`@Q\x80\x91\x03\x90\xFD[aO\xD6\x83\x83a\\LV[PPPV[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x160s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14aP`W`@Q\x7F\xE0|\x8D\xBA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[V[_sP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x82\x02{m\x853`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01aP\xB2\x92\x91\x90ag\xD7V[` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15aP\xCDW=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90aP\xF1\x91\x90ai\xB7V[aQ4W\x833`@Q\x7F\x9D\xE39,\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aQ+\x92\x91\x90ag\xD7V[`@Q\x80\x91\x03\x90\xFD[sP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x82\x02{m\x843`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01aQ\x83\x92\x91\x90ag\xD7V[` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15aQ\x9EW=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90aQ\xC2\x91\x90ai\xB7V[aR\x05W\x823`@Q\x7F\x9D\xE39,\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aQ\xFC\x92\x91\x90ag\xD7V[`@Q\x80\x91\x03\x90\xFD[sP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x82\x02{m\x833`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01aRT\x92\x91\x90ag\xD7V[` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15aRoW=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90aR\x93\x91\x90ai\xB7V[aR\xD6W\x813`@Q\x7F\x9D\xE39,\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aR\xCD\x92\x91\x90ag\xD7V[`@Q\x80\x91\x03\x90\xFD[_aR\xE0\x85aG\xEEV[\x90P_aR\xEC\x85aG\xEEV[\x90P_aR\xF8\x85aG\xEEV[\x90P_`S\x81\x11\x15aS\rWaS\x0CaeJV[[\x83`S\x81\x11\x15aS WaS\x1FaeJV[[\x14aSWW`@Q\x7F\xC6\xDEFj\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x80`S\x81\x11\x15aSjWaSiaeJV[[\x82`S\x81\x11\x15aS}WaS|aeJV[[\x14aS\xB4W`@Q\x7F\x1F1X\xC7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x87\x87\x87\x87sP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]F`@Q` \x01aS\xE3\x96\x95\x94\x93\x92\x91\x90aq\x05V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x93PaT\x05\x84\x83aH\xF0V[\x93PsP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c>9\\\xEC\x853`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01aTV\x92\x91\x90ag\xD7V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15aTmW_\x80\xFD[PZ\xF1\x15\x80\x15aT\x7FW=_\x80>=_\xFD[PPPPPPP\x94\x93PPPPV[_sP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x82\x02{m\x833`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01aT\xDE\x92\x91\x90ag\xD7V[` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15aT\xF9W=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90aU\x1D\x91\x90ai\xB7V[aU`W\x813`@Q\x7F\x9D\xE39,\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aUW\x92\x91\x90ag\xD7V[`@Q\x80\x91\x03\x90\xFD[\x82\x82sP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]F`@Q` \x01aU\x8B\x94\x93\x92\x91\x90aqtV[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x90P_aU\xAD\x83aG\xEEV[\x90PaU\xB9\x82\x82aH\xF0V[\x91PsP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c>9\\\xEC\x833`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01aV\n\x92\x91\x90ag\xD7V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15aV!W_\x80\xFD[PZ\xF1\x15\x80\x15aV3W=_\x80>=_\xFD[PPPPP\x92\x91PPV[_\x80`\x08`S\x81\x11\x15aVTWaVSaeJV[[`\xFF\x16`\x01\x90\x1B`\x06`S\x81\x11\x15aVoWaVnaeJV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15aV\x8AWaV\x89aeJV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15aV\xA5WaV\xA4aeJV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15aV\xC0WaV\xBFaeJV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15aV\xDBWaV\xDAaeJV[[`\xFF\x16`\x01\x90\x1B_`S\x81\x11\x15aV\xF5WaV\xF4aeJV[[`\xFF\x16`\x01\x90\x1BaW\x06\x91\x90ae\xA4V[aW\x10\x91\x90ae\xA4V[aW\x1A\x91\x90ae\xA4V[aW$\x91\x90ae\xA4V[aW.\x91\x90ae\xA4V[aW8\x91\x90ae\xA4V[\x90P_\x81\x85`S\x81\x11\x15aWOWaWNaeJV[[`\xFF\x16`\x01\x90\x1B\x16\x03aW\x8EW`@Q\x7F\xC6\xDEFj\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x1A\x84\x84`@Q` \x01aW\xA4\x93\x92\x91\x90aq\xC1V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x91PaW\xC6\x82\x85aH\xF0V[\x91Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xD5\xB8\xB8\xF3\x85\x843`@Q\x84c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01aX\x19\x93\x92\x91\x90am\xD2V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15aX0W_\x80\xFD[PZ\xF1\x15\x80\x15aXBW=_\x80>=_\xFD[PPPPsP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c>9\\\xEC\x833`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01aX\x95\x92\x91\x90ag\xD7V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15aX\xACW_\x80\xFD[PZ\xF1\x15\x80\x15aX\xBEW=_\x80>=_\xFD[PPPPP\x92\x91PPV[`\x01\x81`\xF8\x1C`\xFF\x16\x11\x15aY\nW`@Q\x7F\xDF{\xF3%\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[PV[_\x80_\x90Pz\x18O\x03\xE9?\xF9\xF4\xDA\xA7\x97\xEDn8\xEDd\xBFj\x1F\x01\0\0\0\0\0\0\0\0\x83\x10aYiWz\x18O\x03\xE9?\xF9\xF4\xDA\xA7\x97\xEDn8\xEDd\xBFj\x1F\x01\0\0\0\0\0\0\0\0\x83\x81aY_WaY^aoTV[[\x04\x92P`@\x81\x01\x90P[m\x04\xEE-mA[\x85\xAC\xEF\x81\0\0\0\0\x83\x10aY\xA6Wm\x04\xEE-mA[\x85\xAC\xEF\x81\0\0\0\0\x83\x81aY\x9CWaY\x9BaoTV[[\x04\x92P` \x81\x01\x90P[f#\x86\xF2o\xC1\0\0\x83\x10aY\xD5Wf#\x86\xF2o\xC1\0\0\x83\x81aY\xCBWaY\xCAaoTV[[\x04\x92P`\x10\x81\x01\x90P[c\x05\xF5\xE1\0\x83\x10aY\xFEWc\x05\xF5\xE1\0\x83\x81aY\xF4WaY\xF3aoTV[[\x04\x92P`\x08\x81\x01\x90P[a'\x10\x83\x10aZ#Wa'\x10\x83\x81aZ\x19WaZ\x18aoTV[[\x04\x92P`\x04\x81\x01\x90P[`d\x83\x10aZFW`d\x83\x81aZ<WaZ;aoTV[[\x04\x92P`\x02\x81\x01\x90P[`\n\x83\x10aZUW`\x01\x81\x01\x90P[\x80\x91PP\x91\x90PV[_\x7FF\x13\xE1w\x1Fku]$>So\xB5\xA2<[\x15\xE2\x82eu\xFE\xE9!\xE8\xFEz\"\xA7`\xC8\0\x90P\x90V[_\x80\x82\x11\x80\x15aZ\xA2WP_`\x01\x83aZ\x9E\x91\x90ao\x81V[\x83\x16\x14[\x90P\x91\x90PV[`\x02`S\x81\x11\x15aZ\xBDWaZ\xBCaeJV[[\x81`S\x81\x11\x15aZ\xD0WaZ\xCFaeJV[[\x03aZ\xE6WaZ\xE1\x82a\x01\0a\\\xBEV[a[\xF5V[`\x03`S\x81\x11\x15aZ\xFAWaZ\xF9aeJV[[\x81`S\x81\x11\x15a[\rWa[\x0CaeJV[[\x03a[$Wa[\x1F\x82b\x01\0\0a\\\xBEV[a[\xF5V[`\x04`S\x81\x11\x15a[8Wa[7aeJV[[\x81`S\x81\x11\x15a[KWa[JaeJV[[\x03a[dWa[_\x82d\x01\0\0\0\0a\\\xBEV[a[\xF5V[`\x05`S\x81\x11\x15a[xWa[waeJV[[\x81`S\x81\x11\x15a[\x8BWa[\x8AaeJV[[\x03a[\xA8Wa[\xA3\x82h\x01\0\0\0\0\0\0\0\0a\\\xBEV[a[\xF5V[`\x06`S\x81\x11\x15a[\xBCWa[\xBBaeJV[[\x81`S\x81\x11\x15a[\xCFWa[\xCEaeJV[[\x03a[\xF4Wa[\xEF\x82p\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\\\xBEV[a[\xF5V[[PPV[_a\\%\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC_\x1Ba\\\xFCV[_\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P\x90V[a\\U\x82a]\x05V[\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xBC|\xD7Z \xEE'\xFD\x9A\xDE\xBA\xB3 A\xF7U!M\xBCk\xFF\xA9\x0C\xC0\"[9\xDA.\\-;`@Q`@Q\x80\x91\x03\x90\xA2_\x81Q\x11\x15a\\\xB1Wa\\\xAB\x82\x82a]\xCEV[Pa\\\xBAV[a\\\xB9a^NV[[PPV[\x80\x82\x11\x15a\\\xF8W`@Q\x7F\xC7\xDA\xDFE\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[PPV[_\x81\x90P\x91\x90PV[_\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16;\x03a]`W\x80`@Q\x7FL\x9C\x8C\xE3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a]W\x91\x90ad\xDBV[`@Q\x80\x91\x03\x90\xFD[\x80a]\x8C\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC_\x1Ba\\\xFCV[_\x01_a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UPPV[``_\x80\x84s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x84`@Qa]\xF7\x91\x90ar7V[_`@Q\x80\x83\x03\x81\x85Z\xF4\x91PP=\x80_\x81\x14a^/W`@Q\x91P`\x1F\x19`?=\x01\x16\x82\x01`@R=\x82R=_` \x84\x01>a^4V[``\x91P[P\x91P\x91Pa^D\x85\x83\x83a^\x8AV[\x92PPP\x92\x91PPV[_4\x11\x15a^\x88W`@Q\x7F\xB3\x98\x97\x9F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[V[``\x82a^\x9FWa^\x9A\x82a_\x17V[a_\x0FV[_\x82Q\x14\x80\x15a^\xC5WP_\x84s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16;\x14[\x15a_\x07W\x83`@Q\x7F\x99\x96\xB3\x15\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a^\xFE\x91\x90ad\xDBV[`@Q\x80\x91\x03\x90\xFD[\x81\x90Pa_\x10V[[\x93\x92PPPV[_\x81Q\x11\x15a_)W\x80Q\x80\x82` \x01\xFD[`@Q\x7F\xD6\xBD\xA2u\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`@Q\x90P\x90V[_\x80\xFD[_\x80\xFD[_\x81\x90P\x91\x90PV[a_~\x81a_lV[\x81\x14a_\x88W_\x80\xFD[PV[_\x815\x90Pa_\x99\x81a_uV[\x92\x91PPV[_\x7F\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\x16\x90P\x91\x90PV[a_\xD3\x81a_\x9FV[\x81\x14a_\xDDW_\x80\xFD[PV[_\x815\x90Pa_\xEE\x81a_\xCAV[\x92\x91PPV[_\x80_``\x84\x86\x03\x12\x15a`\x0BWa`\na_dV[[_a`\x18\x86\x82\x87\x01a_\x8BV[\x93PP` a`)\x86\x82\x87\x01a_\x8BV[\x92PP`@a`:\x86\x82\x87\x01a_\xE0V[\x91PP\x92P\x92P\x92V[a`M\x81a_lV[\x82RPPV[_` \x82\x01\x90Pa`f_\x83\x01\x84a`DV[\x92\x91PPV[_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[_a`\x95\x82a`lV[\x90P\x91\x90PV[a`\xA5\x81a`\x8BV[\x81\x14a`\xAFW_\x80\xFD[PV[_\x815\x90Pa`\xC0\x81a`\x9CV[\x92\x91PPV[_\x80\xFD[_\x80\xFD[_`\x1F\x19`\x1F\x83\x01\x16\x90P\x91\x90PV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`A`\x04R`$_\xFD[aa\x14\x82a`\xCEV[\x81\x01\x81\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17\x15aa3Waa2a`\xDEV[[\x80`@RPPPV[_aaEa_[V[\x90PaaQ\x82\x82aa\x0BV[\x91\x90PV[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15aapWaaoa`\xDEV[[aay\x82a`\xCEV[\x90P` \x81\x01\x90P\x91\x90PV[\x82\x81\x837_\x83\x83\x01RPPPV[_aa\xA6aa\xA1\x84aaVV[aa<V[\x90P\x82\x81R` \x81\x01\x84\x84\x84\x01\x11\x15aa\xC2Waa\xC1a`\xCAV[[aa\xCD\x84\x82\x85aa\x86V[P\x93\x92PPPV[_\x82`\x1F\x83\x01\x12aa\xE9Waa\xE8a`\xC6V[[\x815aa\xF9\x84\x82` \x86\x01aa\x94V[\x91PP\x92\x91PPV[`T\x81\x10ab\x0EW_\x80\xFD[PV[_\x815\x90Pab\x1F\x81ab\x02V[\x92\x91PPV[_\x80_\x80`\x80\x85\x87\x03\x12\x15ab=Wab<a_dV[[_abJ\x87\x82\x88\x01a_\x8BV[\x94PP` ab[\x87\x82\x88\x01a`\xB2V[\x93PP`@\x85\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15ab|Wab{a_hV[[ab\x88\x87\x82\x88\x01aa\xD5V[\x92PP``ab\x99\x87\x82\x88\x01ab\x11V[\x91PP\x92\x95\x91\x94P\x92PV[_\x81Q\x90P\x91\x90PV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[_[\x83\x81\x10\x15ab\xDCW\x80\x82\x01Q\x81\x84\x01R` \x81\x01\x90Pab\xC1V[_\x84\x84\x01RPPPPV[_ab\xF1\x82ab\xA5V[ab\xFB\x81\x85ab\xAFV[\x93Pac\x0B\x81\x85` \x86\x01ab\xBFV[ac\x14\x81a`\xCEV[\x84\x01\x91PP\x92\x91PPV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Rac7\x81\x84ab\xE7V[\x90P\x92\x91PPV[_\x80`@\x83\x85\x03\x12\x15acUWacTa_dV[[_acb\x85\x82\x86\x01a_\x8BV[\x92PP` acs\x85\x82\x86\x01ab\x11V[\x91PP\x92P\x92\x90PV[_\x81\x90P\x91\x90PV[ac\x8F\x81ac}V[\x81\x14ac\x99W_\x80\xFD[PV[_\x815\x90Pac\xAA\x81ac\x86V[\x92\x91PPV[_\x80`@\x83\x85\x03\x12\x15ac\xC6Wac\xC5a_dV[[_ac\xD3\x85\x82\x86\x01ac\x9CV[\x92PP` ac\xE4\x85\x82\x86\x01ab\x11V[\x91PP\x92P\x92\x90PV[_\x80`@\x83\x85\x03\x12\x15ad\x04Wad\x03a_dV[[_ad\x11\x85\x82\x86\x01a`\xB2V[\x92PP` \x83\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15ad2Wad1a_hV[[ad>\x85\x82\x86\x01aa\xD5V[\x91PP\x92P\x92\x90PV[_\x80_``\x84\x86\x03\x12\x15ad_Wad^a_dV[[_adl\x86\x82\x87\x01a_\x8BV[\x93PP` ad}\x86\x82\x87\x01a_\x8BV[\x92PP`@ad\x8E\x86\x82\x87\x01a_\x8BV[\x91PP\x92P\x92P\x92V[_`\xFF\x82\x16\x90P\x91\x90PV[ad\xAD\x81ad\x98V[\x82RPPV[_` \x82\x01\x90Pad\xC6_\x83\x01\x84ad\xA4V[\x92\x91PPV[ad\xD5\x81a`\x8BV[\x82RPPV[_` \x82\x01\x90Pad\xEE_\x83\x01\x84ad\xCCV[\x92\x91PPV[_` \x82\x84\x03\x12\x15ae\tWae\x08a_dV[[_ae\x16\x84\x82\x85\x01a_\x8BV[\x91PP\x92\x91PPV[_` \x82\x84\x03\x12\x15ae4Wae3a_dV[[_aeA\x84\x82\x85\x01ab\x11V[\x91PP\x92\x91PPV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`!`\x04R`$_\xFD[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x11`\x04R`$_\xFD[_ae\xAE\x82ac}V[\x91Pae\xB9\x83ac}V[\x92P\x82\x82\x01\x90P\x80\x82\x11\x15ae\xD1Wae\xD0aewV[[\x92\x91PPV[`T\x81\x10ae\xE8Wae\xE7aeJV[[PV[_\x81\x90Pae\xF8\x82ae\xD7V[\x91\x90PV[_af\x07\x82ae\xEBV[\x90P\x91\x90PV[af\x17\x81ae\xFDV[\x82RPPV[af&\x81a_\x9FV[\x82RPPV[_`\xC0\x82\x01\x90Paf?_\x83\x01\x89af\x0EV[afL` \x83\x01\x88af\x1DV[afY`@\x83\x01\x87a`DV[aff``\x83\x01\x86a`DV[afs`\x80\x83\x01\x85a`DV[af\x80`\xA0\x83\x01\x84ad\xCCV[\x97\x96PPPPPPPV[_`\x80\x82\x01\x90Paf\x9E_\x83\x01\x87a`DV[af\xAB` \x83\x01\x86a`DV[af\xB8`@\x83\x01\x85af\x1DV[af\xC5``\x83\x01\x84a`DV[\x95\x94PPPPPV[af\xD7\x81a`\x8BV[\x82RPPV[`@\x82\x01_\x82\x01Qaf\xF1_\x85\x01\x82af\xCEV[P` \x82\x01Qag\x04` \x85\x01\x82af\xCEV[PPPPV[_\x81Q\x90P\x91\x90PV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[_ag.\x82ag\nV[ag8\x81\x85ag\x14V[\x93PagH\x81\x85` \x86\x01ab\xBFV[agQ\x81a`\xCEV[\x84\x01\x91PP\x92\x91PPV[_`\x80\x82\x01\x90Pago_\x83\x01\x86af\xDDV[ag|`@\x83\x01\x85a`DV[\x81\x81\x03``\x83\x01Rag\x8E\x81\x84ag$V[\x90P\x94\x93PPPPV[_\x81Q\x90Pag\xA6\x81a_uV[\x92\x91PPV[_` \x82\x84\x03\x12\x15ag\xC1Wag\xC0a_dV[[_ag\xCE\x84\x82\x85\x01ag\x98V[\x91PP\x92\x91PPV[_`@\x82\x01\x90Pag\xEA_\x83\x01\x85a`DV[ag\xF7` \x83\x01\x84ad\xCCV[\x93\x92PPPV[_`\xA0\x82\x01\x90Pah\x11_\x83\x01\x88a`DV[ah\x1E` \x83\x01\x87ad\xCCV[\x81\x81\x03`@\x83\x01Rah0\x81\x86ag$V[\x90Pah?``\x83\x01\x85af\x0EV[ahL`\x80\x83\x01\x84a`DV[\x96\x95PPPPPPV[_\x81\x90P\x92\x91PPV[_ahj\x82ab\xA5V[aht\x81\x85ahVV[\x93Pah\x84\x81\x85` \x86\x01ab\xBFV[\x80\x84\x01\x91PP\x92\x91PPV[\x7F v\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_ah\xC4`\x02\x83ahVV[\x91Pah\xCF\x82ah\x90V[`\x02\x82\x01\x90P\x91\x90PV[\x7F.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_ai\x0E`\x01\x83ahVV[\x91Pai\x19\x82ah\xDAV[`\x01\x82\x01\x90P\x91\x90PV[_ai/\x82\x87ah`V[\x91Pai:\x82ah\xB8V[\x91PaiF\x82\x86ah`V[\x91PaiQ\x82ai\x02V[\x91Pai]\x82\x85ah`V[\x91Paih\x82ai\x02V[\x91Pait\x82\x84ah`V[\x91P\x81\x90P\x95\x94PPPPPV[_\x81\x15\x15\x90P\x91\x90PV[ai\x96\x81ai\x82V[\x81\x14ai\xA0W_\x80\xFD[PV[_\x81Q\x90Pai\xB1\x81ai\x8DV[\x92\x91PPV[_` \x82\x84\x03\x12\x15ai\xCCWai\xCBa_dV[[_ai\xD9\x84\x82\x85\x01ai\xA3V[\x91PP\x92\x91PPV[`\x1C\x81\x10ai\xF3Wai\xF2aeJV[[PV[_\x81\x90Paj\x03\x82ai\xE2V[\x91\x90PV[_aj\x12\x82ai\xF6V[\x90P\x91\x90PV[_\x81`\xF8\x1B\x90P\x91\x90PV[_aj/\x82aj\x19V[\x90P\x91\x90PV[ajGajB\x82aj\x08V[aj%V[\x82RPPV[_\x81\x90P\x91\x90PV[ajgajb\x82a_lV[ajMV[\x82RPPV[aj~ajy\x82ae\xFDV[aj%V[\x82RPPV[_\x81\x90P\x91\x90PV[_aj\xA7aj\xA2aj\x9D\x84a`lV[aj\x84V[a`lV[\x90P\x91\x90PV[_aj\xB8\x82aj\x8DV[\x90P\x91\x90PV[_aj\xC9\x82aj\xAEV[\x90P\x91\x90PV[_\x81``\x1B\x90P\x91\x90PV[_aj\xE6\x82aj\xD0V[\x90P\x91\x90PV[_aj\xF7\x82aj\xDCV[\x90P\x91\x90PV[ak\x0Fak\n\x82aj\xBFV[aj\xEDV[\x82RPPV[_\x81\x90P\x91\x90PV[ak/ak*\x82ac}V[ak\x15V[\x82RPPV[_ak@\x82\x88aj6V[`\x01\x82\x01\x91PakP\x82\x87ajVV[` \x82\x01\x91Pak`\x82\x86ajmV[`\x01\x82\x01\x91Pakp\x82\x85aj\xFEV[`\x14\x82\x01\x91Pak\x80\x82\x84ak\x1EV[` \x82\x01\x91P\x81\x90P\x96\x95PPPPPPV[_`\x80\x82\x01\x90Pak\xA6_\x83\x01\x87af\x0EV[ak\xB3` \x83\x01\x86a`DV[ak\xC0`@\x83\x01\x85a`DV[ak\xCD``\x83\x01\x84ad\xCCV[\x95\x94PPPPPV[_``\x82\x01\x90Pak\xE9_\x83\x01\x86a`DV[ak\xF6` \x83\x01\x85af\x0EV[al\x03`@\x83\x01\x84a`DV[\x94\x93PPPPV[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[al'\x81al\x0BV[\x82RPPV[_` \x82\x01\x90Pal@_\x83\x01\x84al\x1EV[\x92\x91PPV[alO\x81ac}V[\x82RPPV[_\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\x16\x90P\x91\x90PV[al\x89\x81alUV[\x82RPPV[_`\x80\x82\x01\x90Pal\xA2_\x83\x01\x87alFV[al\xAF` \x83\x01\x86af\x0EV[al\xBC`@\x83\x01\x85al\x80V[al\xC9``\x83\x01\x84a`DV[\x95\x94PPPPPV[_`\xC0\x82\x01\x90Pal\xE5_\x83\x01\x89af\x0EV[al\xF2` \x83\x01\x88a`DV[al\xFF`@\x83\x01\x87a`DV[am\x0C``\x83\x01\x86a`DV[am\x19`\x80\x83\x01\x85a`DV[am&`\xA0\x83\x01\x84ad\xCCV[\x97\x96PPPPPPPV[_`\x80\x82\x01\x90PamD_\x83\x01\x87a`DV[amQ` \x83\x01\x86a`DV[am^`@\x83\x01\x85a`DV[amk``\x83\x01\x84a`DV[\x95\x94PPPPPV[_am\x7F\x82\x88aj6V[`\x01\x82\x01\x91Pam\x8F\x82\x87ak\x1EV[` \x82\x01\x91Pam\x9F\x82\x86ajmV[`\x01\x82\x01\x91Pam\xAF\x82\x85aj\xFEV[`\x14\x82\x01\x91Pam\xBF\x82\x84ak\x1EV[` \x82\x01\x91P\x81\x90P\x96\x95PPPPPPV[_``\x82\x01\x90Pam\xE5_\x83\x01\x86af\x0EV[am\xF2` \x83\x01\x85a`DV[am\xFF`@\x83\x01\x84ad\xCCV[\x94\x93PPPPV[_``\x82\x01\x90Pan\x1A_\x83\x01\x86alFV[an'` \x83\x01\x85af\x0EV[an4`@\x83\x01\x84a`DV[\x94\x93PPPPV[_`@\x82\x01\x90PanO_\x83\x01\x85a`DV[an\\` \x83\x01\x84a`DV[\x93\x92PPPV[_``\x82\x01\x90Panv_\x83\x01\x86af\x0EV[an\x83` \x83\x01\x85al\x80V[an\x90`@\x83\x01\x84a`DV[\x94\x93PPPPV[_\x81\x90P\x91\x90PV[an\xB2an\xAD\x82a_\x9FV[an\x98V[\x82RPPV[_an\xC3\x82\x89aj6V[`\x01\x82\x01\x91Pan\xD3\x82\x88ajVV[` \x82\x01\x91Pan\xE3\x82\x87ajVV[` \x82\x01\x91Pan\xF3\x82\x86an\xA1V[`\x01\x82\x01\x91Pao\x03\x82\x85aj\xFEV[`\x14\x82\x01\x91Pao\x13\x82\x84ak\x1EV[` \x82\x01\x91P\x81\x90P\x97\x96PPPPPPPV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`2`\x04R`$_\xFD[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x12`\x04R`$_\xFD[_ao\x8B\x82ac}V[\x91Pao\x96\x83ac}V[\x92P\x82\x82\x03\x90P\x81\x81\x11\x15ao\xAEWao\xADaewV[[\x92\x91PPV[_ao\xBF\x82\x88ak\x1EV[` \x82\x01\x91Pao\xCF\x82\x87aj\xFEV[`\x14\x82\x01\x91Pao\xDF\x82\x86ak\x1EV[` \x82\x01\x91Pao\xEF\x82\x85ajVV[` \x82\x01\x91Pao\xFF\x82\x84ak\x1EV[` \x82\x01\x91P\x81\x90P\x96\x95PPPPPPV[_ap\x1C\x82ac}V[\x91P\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x03apNWapMaewV[[`\x01\x82\x01\x90P\x91\x90PV[_\x81\x90P\x91\x90PV[apsapn\x82alUV[apYV[\x82RPPV[_ap\x84\x82\x87aj6V[`\x01\x82\x01\x91Pap\x94\x82\x86ak\x1EV[` \x82\x01\x91Pap\xA4\x82\x85ajmV[`\x01\x82\x01\x91Pap\xB4\x82\x84apbV[`\x10\x82\x01\x91P\x81\x90P\x95\x94PPPPPV[_\x81Q\x90Pap\xD4\x81a`\x9CV[\x92\x91PPV[_` \x82\x84\x03\x12\x15ap\xEFWap\xEEa_dV[[_ap\xFC\x84\x82\x85\x01ap\xC6V[\x91PP\x92\x91PPV[_aq\x10\x82\x89aj6V[`\x01\x82\x01\x91Paq \x82\x88ajVV[` \x82\x01\x91Paq0\x82\x87ajVV[` \x82\x01\x91Paq@\x82\x86ajVV[` \x82\x01\x91PaqP\x82\x85aj\xFEV[`\x14\x82\x01\x91Paq`\x82\x84ak\x1EV[` \x82\x01\x91P\x81\x90P\x97\x96PPPPPPPV[_aq\x7F\x82\x87aj6V[`\x01\x82\x01\x91Paq\x8F\x82\x86ajVV[` \x82\x01\x91Paq\x9F\x82\x85aj\xFEV[`\x14\x82\x01\x91Paq\xAF\x82\x84ak\x1EV[` \x82\x01\x91P\x81\x90P\x95\x94PPPPPV[_aq\xCC\x82\x86aj6V[`\x01\x82\x01\x91Paq\xDC\x82\x85ajmV[`\x01\x82\x01\x91Paq\xEC\x82\x84apbV[`\x10\x82\x01\x91P\x81\x90P\x94\x93PPPPV[_\x81\x90P\x92\x91PPV[_ar\x11\x82ag\nV[ar\x1B\x81\x85aq\xFDV[\x93Par+\x81\x85` \x86\x01ab\xBFV[\x80\x84\x01\x91PP\x92\x91PPV[_arB\x82\x84ar\x07V[\x91P\x81\x90P\x92\x91PPV",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x608060405260043610610224575f3560e01c80637a297f4b11610122578063ccc480a1116100aa578063d99882d51161006e578063d99882d51461091e578063e07869721461095a578063f51ccfb014610984578063f6859bdc146109c0578063f77f3f1d146109ea57610224565b8063ccc480a1146107f2578063cf4d18aa1461082e578063d580c0631461086a578063d75d6e8a146108a6578063d8092cbc146108e257610224565b80639cd07acb116100f15780639cd07acb14610710578063a8c7c2c11461074c578063ad3cb1cc14610776578063bac22bb8146107a0578063c021329e146107b657610224565b80637a297f4b1461063257806385362ee71461065c5780638b49ceb41461069857806391f98ffe146106d457610224565b806348eef47e116101b057806363a2db291161017457806363a2db29146105065780636754b36014610542578063721076811461057e5780637513a404146105ba5780637702dcff146105f657610224565b806348eef47e1461040c5780634f1ef2861461044857806352d1902d1461046457806357f0a5681461048e5780635a53accb146104ca57610224565b80631391547f116101f75780631391547f14610306578063182b6d98146103425780631c89ee441461037e57806336318d64146103ba57806339f73810146103f657610224565b806304559f711461022857806308bf832a146102645780630d8e6e2c146102a0578063117b2f38146102ca575b5f80fd5b348015610233575f80fd5b5061024e60048036038101906102499190615ff4565b610a26565b60405161025b9190616053565b60405180910390f35b34801561026f575f80fd5b5061028a60048036038101906102859190616225565b610bd7565b6040516102979190616053565b60405180910390f35b3480156102ab575f80fd5b506102b4610df4565b6040516102c1919061631f565b60405180910390f35b3480156102d5575f80fd5b506102f060048036038101906102eb9190615ff4565b610e6f565b6040516102fd9190616053565b60405180910390f35b348015610311575f80fd5b5061032c60048036038101906103279190615ff4565b61101f565b6040516103399190616053565b60405180910390f35b34801561034d575f80fd5b5061036860048036038101906103639190615ff4565b6111d0565b6040516103759190616053565b60405180910390f35b348015610389575f80fd5b506103a4600480360381019061039f919061633f565b611381565b6040516103b19190616053565b60405180910390f35b3480156103c5575f80fd5b506103e060048036038101906103db9190615ff4565b61188c565b6040516103ed9190616053565b60405180910390f35b348015610401575f80fd5b5061040a611a3d565b005b348015610417575f80fd5b50610432600480360381019061042d91906163b0565b611bad565b60405161043f9190616053565b60405180910390f35b610462600480360381019061045d91906163ee565b611c21565b005b34801561046f575f80fd5b50610478611c40565b6040516104859190616053565b60405180910390f35b348015610499575f80fd5b506104b460048036038101906104af9190615ff4565b611c71565b6040516104c19190616053565b60405180910390f35b3480156104d5575f80fd5b506104f060048036038101906104eb9190615ff4565b611e22565b6040516104fd9190616053565b60405180910390f35b348015610511575f80fd5b5061052c60048036038101906105279190615ff4565b61206d565b6040516105399190616053565b60405180910390f35b34801561054d575f80fd5b5061056860048036038101906105639190615ff4565b612267565b6040516105759190616053565b60405180910390f35b348015610589575f80fd5b506105a4600480360381019061059f9190615ff4565b61243d565b6040516105b19190616053565b60405180910390f35b3480156105c5575f80fd5b506105e060048036038101906105db9190615ff4565b6125ee565b6040516105ed9190616053565b60405180910390f35b348015610601575f80fd5b5061061c60048036038101906106179190616448565b61279f565b6040516106299190616053565b60405180910390f35b34801561063d575f80fd5b506106466129bd565b60405161065391906164b3565b60405180910390f35b348015610667575f80fd5b50610682600480360381019061067d9190615ff4565b6129c1565b60405161068f9190616053565b60405180910390f35b3480156106a3575f80fd5b506106be60048036038101906106b99190615ff4565b612b72565b6040516106cb9190616053565b60405180910390f35b3480156106df575f80fd5b506106fa60048036038101906106f59190615ff4565b612d6c565b6040516107079190616053565b60405180910390f35b34801561071b575f80fd5b50610736600480360381019061073191906163b0565b612f42565b6040516107439190616053565b60405180910390f35b348015610757575f80fd5b5061076061325c565b60405161076d91906164db565b60405180910390f35b348015610781575f80fd5b5061078a613277565b604051610797919061631f565b60405180910390f35b3480156107ab575f80fd5b506107b46132b0565b005b3480156107c1575f80fd5b506107dc60048036038101906107d79190615ff4565b6133d5565b6040516107e99190616053565b60405180910390f35b3480156107fd575f80fd5b5061081860048036038101906108139190615ff4565b6135ab565b6040516108259190616053565b60405180910390f35b348015610839575f80fd5b50610854600480360381019061084f9190615ff4565b613781565b6040516108619190616053565b60405180910390f35b348015610875575f80fd5b50610890600480360381019061088b91906164f4565b6139cc565b60405161089d9190616053565b60405180910390f35b3480156108b1575f80fd5b506108cc60048036038101906108c7919061651f565b613b95565b6040516108d99190616053565b60405180910390f35b3480156108ed575f80fd5b5061090860048036038101906109039190615ff4565b613c05565b6040516109159190616053565b60405180910390f35b348015610929575f80fd5b50610944600480360381019061093f9190615ff4565b613e24565b6040516109519190616053565b60405180910390f35b348015610965575f80fd5b5061096e61401e565b60405161097b91906164db565b60405180910390f35b34801561098f575f80fd5b506109aa60048036038101906109a591906164f4565b614039565b6040516109b79190616053565b60405180910390f35b3480156109cb575f80fd5b506109d4614226565b6040516109e191906164db565b60405180910390f35b3480156109f5575f80fd5b50610a106004803603810190610a0b9190615ff4565b614241565b604051610a1d9190616053565b60405180910390f35b5f8060066053811115610a3c57610a3b61654a565b5b60ff166001901b60056053811115610a5757610a5661654a565b5b60ff166001901b60046053811115610a7257610a7161654a565b5b60ff166001901b60036053811115610a8d57610a8c61654a565b5b60ff166001901b60026053811115610aa857610aa761654a565b5b60ff166001901b610ab991906165a4565b610ac391906165a4565b610acd91906165a4565b610ad791906165a4565b90505f610ae48683614460565b9050610af46012878787856144c6565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff166304553fb68286898988336040518763ffffffff1660e01b8152600401610b4d9695949392919061662c565b5f604051808303815f87803b158015610b64575f80fd5b505af1158015610b76573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167fc11d62b13c360a83082487064be1ec0878b2f0be4f012bf59f89e128063d47ff87878787604051610bc6949392919061668b565b60405180910390a250509392505050565b5f8060405180604001604052808673ffffffffffffffffffffffffffffffffffffffff1681526020013373ffffffffffffffffffffffffffffffffffffffff1681525090505f610c26876147ee565b9050806053811115610c3b57610c3a61654a565b5b846053811115610c4e57610c4d61654a565b5b14610c85576040517fb968846100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b7336772142b74871f255cbd7a3e89b401d3e45825f73ffffffffffffffffffffffffffffffffffffffff1663e6317df58389886040518463ffffffff1660e01b8152600401610cd69392919061675c565b6020604051808303815f875af1158015610cf2573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610d1691906167ac565b92507350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff16633e395cec84336040518363ffffffff1660e01b8152600401610d679291906167d7565b5f604051808303815f87803b158015610d7e575f80fd5b505af1158015610d90573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167fdc370db33589e73371dc3ee42c789c003d336eefcb7c3f56fe0f51ae5b1d97028888888888604051610de29594939291906167fe565b60405180910390a25050949350505050565b60606040518060400160405280600d81526020017f464845564d4578656375746f7200000000000000000000000000000000000000815250610e355f614826565b610e3f6001614826565b610e485f614826565b604051602001610e5b9493929190616924565b604051602081830303815290604052905090565b5f8060066053811115610e8557610e8461654a565b5b60ff166001901b60056053811115610ea057610e9f61654a565b5b60ff166001901b60046053811115610ebb57610eba61654a565b5b60ff166001901b60036053811115610ed657610ed561654a565b5b60ff166001901b60026053811115610ef157610ef061654a565b5b60ff166001901b610f0291906165a4565b610f0c91906165a4565b610f1691906165a4565b610f2091906165a4565b90505f610f2d8683614460565b9050610f3c5f878787856144c6565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff1663c1390c348286898988336040518763ffffffff1660e01b8152600401610f959695949392919061662c565b5f604051808303815f87803b158015610fac575f80fd5b505af1158015610fbe573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167fdb9050d65240431621d61d6f94b970e63f53a67a5766614ee6e5c5bbd41c8e2e8787878760405161100e949392919061668b565b60405180910390a250509392505050565b5f80600660538111156110355761103461654a565b5b60ff166001901b600560538111156110505761104f61654a565b5b60ff166001901b6004605381111561106b5761106a61654a565b5b60ff166001901b600360538111156110865761108561654a565b5b60ff166001901b600260538111156110a1576110a061654a565b5b60ff166001901b6110b291906165a4565b6110bc91906165a4565b6110c691906165a4565b6110d091906165a4565b90505f6110dd8683614460565b90506110ed600e8787875f6144c6565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff1663c277a9368286898988336040518763ffffffff1660e01b81526004016111469695949392919061662c565b5f604051808303815f87803b15801561115d575f80fd5b505af115801561116f573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167f38c3a63c4230de5b741f494ffb54e3087104030279bc7bccee8ad9ad31712b21878787876040516111bf949392919061668b565b60405180910390a250509392505050565b5f80600660538111156111e6576111e561654a565b5b60ff166001901b600560538111156112015761120061654a565b5b60ff166001901b6004605381111561121c5761121b61654a565b5b60ff166001901b600360538111156112375761123661654a565b5b60ff166001901b600260538111156112525761125161654a565b5b60ff166001901b61126391906165a4565b61126d91906165a4565b61127791906165a4565b61128191906165a4565b90505f61128e8683614460565b905061129e6001878787856144c6565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff1663d633c96b8286898988336040518763ffffffff1660e01b81526004016112f79695949392919061662c565b5f604051808303815f87803b15801561130e575f80fd5b505af1158015611320573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167feb6d37bd271abe1395b21d6d78f3487d6584862872c29ffd3f90736ee99b739387878787604051611370949392919061668b565b60405180910390a250509392505050565b5f7350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff166382027b6d84336040518363ffffffff1660e01b81526004016113d19291906167d7565b602060405180830381865afa1580156113ec573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061141091906169b7565b6114535782336040517f9de3392c00000000000000000000000000000000000000000000000000000000815260040161144a9291906167d7565b60405180910390fd5b5f600860538111156114685761146761654a565b5b60ff166001901b600660538111156114835761148261654a565b5b60ff166001901b6005605381111561149e5761149d61654a565b5b60ff166001901b600460538111156114b9576114b861654a565b5b60ff166001901b600360538111156114d4576114d361654a565b5b60ff166001901b600260538111156114ef576114ee61654a565b5b60ff166001901b5f60538111156115095761150861654a565b5b60ff166001901b61151a91906165a4565b61152491906165a4565b61152e91906165a4565b61153891906165a4565b61154291906165a4565b61154c91906165a4565b90505f6115598583614460565b90505f600860538111156115705761156f61654a565b5b60ff166001901b6006605381111561158b5761158a61654a565b5b60ff166001901b600560538111156115a6576115a561654a565b5b60ff166001901b600460538111156115c1576115c061654a565b5b60ff166001901b600360538111156115dc576115db61654a565b5b60ff166001901b600260538111156115f7576115f661654a565b5b60ff166001901b61160891906165a4565b61161291906165a4565b61161c91906165a4565b61162691906165a4565b61163091906165a4565b90505f818660538111156116475761164661654a565b5b60ff166001901b1603611686576040517fc6de466a00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b8460538111156116995761169861654a565b5b8260538111156116ac576116ab61654a565b5b036116e3576040517fb968846100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b601786867350157cffd6bbfa2dece204a89ec419c23ef5755d46604051602001611711959493929190616b35565b60405160208183030381529060405280519060200120935061173384866148f0565b935073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff166369931afb868887336040518563ffffffff1660e01b81526004016117889493929190616b93565b5f604051808303815f87803b15801561179f575f80fd5b505af11580156117b1573d5f803e3d5ffd5b505050507350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff16633e395cec85336040518363ffffffff1660e01b81526004016118049291906167d7565b5f604051808303815f87803b15801561181b575f80fd5b505af115801561182d573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167f31ccae6a2f8e3ced1692f77c8f668133e4afdaaa35afe844ff4659a6c27e627f87878760405161187b93929190616bd6565b60405180910390a250505092915050565b5f80600660538111156118a2576118a161654a565b5b60ff166001901b600560538111156118bd576118bc61654a565b5b60ff166001901b600460538111156118d8576118d761654a565b5b60ff166001901b600360538111156118f3576118f261654a565b5b60ff166001901b6002605381111561190e5761190d61654a565b5b60ff166001901b61191f91906165a4565b61192991906165a4565b61193391906165a4565b61193d91906165a4565b90505f61194a8683614460565b905061195a6013878787856144c6565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff1663968302d78286898988336040518763ffffffff1660e01b81526004016119b39695949392919061662c565b5f604051808303815f87803b1580156119ca575f80fd5b505af11580156119dc573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167ffd7c9208f956bf0c6ab76a667f04361245ad3e0a2d0eff92eb827acfcca68ea987878787604051611a2c949392919061668b565b60405180910390a250509392505050565b6001611a47614969565b67ffffffffffffffff1614611a88576040517f6f4f731f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60035f611a9361498d565b9050805f0160089054906101000a900460ff1680611adb57508167ffffffffffffffff16815f015f9054906101000a900467ffffffffffffffff1667ffffffffffffffff1610155b15611b12576040517ff92ee8a900000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b81815f015f6101000a81548167ffffffffffffffff021916908367ffffffffffffffff1602179055506001815f0160086101000a81548160ff0219169083151502179055505f815f0160086101000a81548160ff0219169083151502179055507fc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d282604051611ba19190616c2d565b60405180910390a15050565b5f80611bb76149b4565b9050611bc4848483614a31565b91503373ffffffffffffffffffffffffffffffffffffffff167f5222d96b836727a1d6fe1ee9aef27f9bb507bd41794defa376ff6c648aaf8ff185858486604051611c129493929190616c8f565b60405180910390a25092915050565b611c29614ce4565b611c3282614dca565b611c3c8282614ebd565b5050565b5f611c49614fdb565b7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5f1b905090565b5f8060066053811115611c8757611c8661654a565b5b60ff166001901b60056053811115611ca257611ca161654a565b5b60ff166001901b60046053811115611cbd57611cbc61654a565b5b60ff166001901b60036053811115611cd857611cd761654a565b5b60ff166001901b60026053811115611cf357611cf261654a565b5b60ff166001901b611d0491906165a4565b611d0e91906165a4565b611d1891906165a4565b611d2291906165a4565b90505f611d2f8683614460565b9050611d3f6002878787856144c6565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff1663818f4d698286898988336040518763ffffffff1660e01b8152600401611d989695949392919061662c565b5f604051808303815f87803b158015611daf575f80fd5b505af1158015611dc1573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167f215346a4f9f975e6d5484e290bd4e53ca14453a9d282ebd3ccedb2a0f171753d87878787604051611e11949392919061668b565b60405180910390a250509392505050565b5f600160f81b827effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191614611e82576040517f4f224e5300000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f801b8303611ebd576040517f23d359a300000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f60066053811115611ed257611ed161654a565b5b60ff166001901b60056053811115611eed57611eec61654a565b5b60ff166001901b60046053811115611f0857611f0761654a565b5b60ff166001901b60036053811115611f2357611f2261654a565b5b60ff166001901b60026053811115611f3e57611f3d61654a565b5b60ff166001901b611f4f91906165a4565b611f5991906165a4565b611f6391906165a4565b611f6d91906165a4565b90505f611f7a8683614460565b9050611f8a6003878787856144c6565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff16639b3f781a8286898988336040518763ffffffff1660e01b8152600401611fe39695949392919061662c565b5f604051808303815f87803b158015611ffa575f80fd5b505af115801561200c573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167f3bab2ee0e2f90f4690c6a87bf63cf1a6b626086e95f231860b152966e8dabbf78787878760405161205c949392919061668b565b60405180910390a250509392505050565b5f80600860538111156120835761208261654a565b5b60ff166001901b6006605381111561209e5761209d61654a565b5b60ff166001901b600560538111156120b9576120b861654a565b5b60ff166001901b600460538111156120d4576120d361654a565b5b60ff166001901b600360538111156120ef576120ee61654a565b5b60ff166001901b6002605381111561210a5761210961654a565b5b60ff166001901b5f60538111156121245761212361654a565b5b60ff166001901b61213591906165a4565b61213f91906165a4565b61214991906165a4565b61215391906165a4565b61215d91906165a4565b61216791906165a4565b90505f6121748683614460565b90506121846006878787856144c6565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff1663c0c5df7c8286898988336040518763ffffffff1660e01b81526004016121dd9695949392919061662c565b5f604051808303815f87803b1580156121f4575f80fd5b505af1158015612206573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167f56df279bbfb03d9ed097bbe2f28d520ca0c1161206327926e98664d70d2c24c487878787604051612256949392919061668b565b60405180910390a250509392505050565b5f806008605381111561227d5761227c61654a565b5b60ff166001901b600660538111156122985761229761654a565b5b60ff166001901b600560538111156122b3576122b261654a565b5b60ff166001901b600460538111156122ce576122cd61654a565b5b60ff166001901b600360538111156122e9576122e861654a565b5b60ff166001901b600260538111156123045761230361654a565b5b60ff166001901b61231591906165a4565b61231f91906165a4565b61232991906165a4565b61233391906165a4565b61233d91906165a4565b90505f61234a8683614460565b905061235a600a878787856144c6565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff16635f76eb308286898988336040518763ffffffff1660e01b81526004016123b39695949392919061662c565b5f604051808303815f87803b1580156123ca575f80fd5b505af11580156123dc573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167feb0e4f8dc74058194d0602425fe602f955c222200f7f10c6fe67992f7b24c7e98787878760405161242c949392919061668b565b60405180910390a250509392505050565b5f80600660538111156124535761245261654a565b5b60ff166001901b6005605381111561246e5761246d61654a565b5b60ff166001901b600460538111156124895761248861654a565b5b60ff166001901b600360538111156124a4576124a361654a565b5b60ff166001901b600260538111156124bf576124be61654a565b5b60ff166001901b6124d091906165a4565b6124da91906165a4565b6124e491906165a4565b6124ee91906165a4565b90505f6124fb8683614460565b905061250b60118787875f6144c6565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff16633bb7d5a38286898988336040518763ffffffff1660e01b81526004016125649695949392919061662c565b5f604051808303815f87803b15801561257b575f80fd5b505af115801561258d573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167f0d483b100d8c73b208984ec697caa3091521ee5525ce69edcf97d7e395d3d059878787876040516125dd949392919061668b565b60405180910390a250509392505050565b5f80600660538111156126045761260361654a565b5b60ff166001901b6005605381111561261f5761261e61654a565b5b60ff166001901b6004605381111561263a5761263961654a565b5b60ff166001901b600360538111156126555761265461654a565b5b60ff166001901b600260538111156126705761266f61654a565b5b60ff166001901b61268191906165a4565b61268b91906165a4565b61269591906165a4565b61269f91906165a4565b90505f6126ac8683614460565b90506126bc60108787875f6144c6565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff166338bd17e58286898988336040518763ffffffff1660e01b81526004016127159695949392919061662c565b5f604051808303815f87803b15801561272c575f80fd5b505af115801561273e573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167fdef2e704a077284a07f3d0b436db88f5d981b69f58ab7c1ae623252718a6de018787878760405161278e949392919061668b565b60405180910390a250509392505050565b5f80600860538111156127b5576127b461654a565b5b60ff166001901b600760538111156127d0576127cf61654a565b5b60ff166001901b600660538111156127eb576127ea61654a565b5b60ff166001901b600560538111156128065761280561654a565b5b60ff166001901b600460538111156128215761282061654a565b5b60ff166001901b6003605381111561283c5761283b61654a565b5b60ff166001901b600260538111156128575761285661654a565b5b60ff166001901b5f60538111156128715761287061654a565b5b60ff166001901b61288291906165a4565b61288c91906165a4565b61289691906165a4565b6128a091906165a4565b6128aa91906165a4565b6128b491906165a4565b6128be91906165a4565b90505f6128cb8583614460565b90506128da6019878787615062565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff16632e3c39068288888888336040518763ffffffff1660e01b815260040161293396959493929190616cd2565b5f604051808303815f87803b15801561294a575f80fd5b505af115801561295c573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167f60be9d61aad849facc28c38b048cb5c4be3420b8fa2233e08cfa06be1b6d1c3e878787876040516129ac9493929190616d31565b60405180910390a250509392505050565b5f90565b5f80600660538111156129d7576129d661654a565b5b60ff166001901b600560538111156129f2576129f161654a565b5b60ff166001901b60046053811115612a0d57612a0c61654a565b5b60ff166001901b60036053811115612a2857612a2761654a565b5b60ff166001901b60026053811115612a4357612a4261654a565b5b60ff166001901b612a5491906165a4565b612a5e91906165a4565b612a6891906165a4565b612a7291906165a4565b90505f612a7f8683614460565b9050612a8f600f8787875f6144c6565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff1663458fb2778286898988336040518763ffffffff1660e01b8152600401612ae89695949392919061662c565b5f604051808303815f87803b158015612aff575f80fd5b505af1158015612b11573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167fc9ff8f0d18a3f766ce5de3de216076050140e4fc2652f5e0e745f6fc836cda8b87878787604051612b61949392919061668b565b60405180910390a250509392505050565b5f8060086053811115612b8857612b8761654a565b5b60ff166001901b60066053811115612ba357612ba261654a565b5b60ff166001901b60056053811115612bbe57612bbd61654a565b5b60ff166001901b60046053811115612bd957612bd861654a565b5b60ff166001901b60036053811115612bf457612bf361654a565b5b60ff166001901b60026053811115612c0f57612c0e61654a565b5b60ff166001901b5f6053811115612c2957612c2861654a565b5b60ff166001901b612c3a91906165a4565b612c4491906165a4565b612c4e91906165a4565b612c5891906165a4565b612c6291906165a4565b612c6c91906165a4565b90505f612c798683614460565b9050612c896007878787856144c6565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff16639f9259bb8286898988336040518763ffffffff1660e01b8152600401612ce29695949392919061662c565b5f604051808303815f87803b158015612cf9575f80fd5b505af1158015612d0b573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167f4d32284bd3193ecaa44e1ceca32f41c5d6c32803a92e07967dd3ee422972158287878787604051612d5b949392919061668b565b60405180910390a250509392505050565b5f8060086053811115612d8257612d8161654a565b5b60ff166001901b60066053811115612d9d57612d9c61654a565b5b60ff166001901b60056053811115612db857612db761654a565b5b60ff166001901b60046053811115612dd357612dd261654a565b5b60ff166001901b60036053811115612dee57612ded61654a565b5b60ff166001901b60026053811115612e0957612e0861654a565b5b60ff166001901b612e1a91906165a4565b612e2491906165a4565b612e2e91906165a4565b612e3891906165a4565b612e4291906165a4565b90505f612e4f8683614460565b9050612e5f6009878787856144c6565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff166307ccdf618286898988336040518763ffffffff1660e01b8152600401612eb89695949392919061662c565b5f604051808303815f87803b158015612ecf575f80fd5b505af1158015612ee1573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167f324220bfc9cb158b492991c03c309cd86e5345cac45aacae2092ddabe31fa3d887878787604051612f31949392919061668b565b60405180910390a250509392505050565b5f8060086053811115612f5857612f5761654a565b5b60ff166001901b60076053811115612f7357612f7261654a565b5b60ff166001901b60066053811115612f8e57612f8d61654a565b5b60ff166001901b60056053811115612fa957612fa861654a565b5b60ff166001901b60046053811115612fc457612fc361654a565b5b60ff166001901b60036053811115612fdf57612fde61654a565b5b60ff166001901b60026053811115612ffa57612ff961654a565b5b60ff166001901b5f60538111156130145761301361654a565b5b60ff166001901b61302591906165a4565b61302f91906165a4565b61303991906165a4565b61304391906165a4565b61304d91906165a4565b61305791906165a4565b61306191906165a4565b90505f818460538111156130785761307761654a565b5b60ff166001901b16036130b7576040517fc6de466a00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b601884847350157cffd6bbfa2dece204a89ec419c23ef5755d466040516020016130e5959493929190616d74565b60405160208183030381529060405280519060200120915061310782846148f0565b915073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff1663b78bef598484336040518463ffffffff1660e01b815260040161315a93929190616dd2565b5f604051808303815f87803b158015613171575f80fd5b505af1158015613183573d5f803e3d5ffd5b505050507350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff16633e395cec83336040518363ffffffff1660e01b81526004016131d69291906167d7565b5f604051808303815f87803b1580156131ed575f80fd5b505af11580156131ff573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167f063ccd1bba45151d91f6a418065047a3d048d058a922535747bb2b575a01d23685858560405161324d93929190616e07565b60405180910390a25092915050565b5f7336772142b74871f255cbd7a3e89b401d3e45825f905090565b6040518060400160405280600581526020017f352e302e3000000000000000000000000000000000000000000000000000000081525081565b60035f6132bb61498d565b9050805f0160089054906101000a900460ff168061330357508167ffffffffffffffff16815f015f9054906101000a900467ffffffffffffffff1667ffffffffffffffff1610155b1561333a576040517ff92ee8a900000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b81815f015f6101000a81548167ffffffffffffffff021916908367ffffffffffffffff1602179055506001815f0160086101000a81548160ff0219169083151502179055505f815f0160086101000a81548160ff0219169083151502179055507fc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d2826040516133c99190616c2d565b60405180910390a15050565b5f80600860538111156133eb576133ea61654a565b5b60ff166001901b600660538111156134065761340561654a565b5b60ff166001901b600560538111156134215761342061654a565b5b60ff166001901b6004605381111561343c5761343b61654a565b5b60ff166001901b600360538111156134575761345661654a565b5b60ff166001901b600260538111156134725761347161654a565b5b60ff166001901b61348391906165a4565b61348d91906165a4565b61349791906165a4565b6134a191906165a4565b6134ab91906165a4565b90505f6134b88683614460565b90506134c8600b878787856144c6565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff16638629f5458286898988336040518763ffffffff1660e01b81526004016135219695949392919061662c565b5f604051808303815f87803b158015613538575f80fd5b505af115801561354a573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167fc148675905d07ad5496f8ef4d8195c907503f3ec12fd10ed5f21240abc6936348787878760405161359a949392919061668b565b60405180910390a250509392505050565b5f80600860538111156135c1576135c061654a565b5b60ff166001901b600660538111156135dc576135db61654a565b5b60ff166001901b600560538111156135f7576135f661654a565b5b60ff166001901b600460538111156136125761361161654a565b5b60ff166001901b6003605381111561362d5761362c61654a565b5b60ff166001901b600260538111156136485761364761654a565b5b60ff166001901b61365991906165a4565b61366391906165a4565b61366d91906165a4565b61367791906165a4565b61368191906165a4565b90505f61368e8683614460565b905061369e6008878787856144c6565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff1663f7d198f88286898988336040518763ffffffff1660e01b81526004016136f79695949392919061662c565b5f604051808303815f87803b15801561370e575f80fd5b505af1158015613720573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167fe84282aaebcca698443e39a2a948a345d0d2ebc654af5cb657a2d7e8053bf6cb87878787604051613770949392919061668b565b60405180910390a250509392505050565b5f600160f81b827effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916146137e1576040517f4f224e5300000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f801b830361381c576040517f23d359a300000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f600660538111156138315761383061654a565b5b60ff166001901b6005605381111561384c5761384b61654a565b5b60ff166001901b600460538111156138675761386661654a565b5b60ff166001901b600360538111156138825761388161654a565b5b60ff166001901b6002605381111561389d5761389c61654a565b5b60ff166001901b6138ae91906165a4565b6138b891906165a4565b6138c291906165a4565b6138cc91906165a4565b90505f6138d98683614460565b90506138e96004878787856144c6565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff16633311b1bc8286898988336040518763ffffffff1660e01b81526004016139429695949392919061662c565b5f604051808303815f87803b158015613959575f80fd5b505af115801561396b573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167f0e691cd0bf8c4e9308e4ced1bb9c964117dc5c5bb9b9ab5bdfebf2c9b13a897c878787876040516139bb949392919061668b565b60405180910390a250509392505050565b5f80600860538111156139e2576139e161654a565b5b60ff166001901b600660538111156139fd576139fc61654a565b5b60ff166001901b60056053811115613a1857613a1761654a565b5b60ff166001901b60046053811115613a3357613a3261654a565b5b60ff166001901b60036053811115613a4e57613a4d61654a565b5b60ff166001901b60026053811115613a6957613a6861654a565b5b60ff166001901b613a7a91906165a4565b613a8491906165a4565b613a8e91906165a4565b613a9891906165a4565b613aa291906165a4565b90505f613aaf8483614460565b9050613abc60148561548e565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff1663497c22c5828686336040518563ffffffff1660e01b8152600401613b119493929190616b93565b5f604051808303815f87803b158015613b28575f80fd5b505af1158015613b3a573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167f8c664d3c3ca583fc5803b8a91c49644bbd9550bfa87967c73ad1de83027768c08585604051613b86929190616e3c565b60405180910390a25050919050565b5f80613b9f6149b4565b9050613bab838261563e565b91503373ffffffffffffffffffffffffffffffffffffffff167f0c8aca6017003326051e19913ef02631f24b801125e1fa8a1d812e868319fda6848385604051613bf793929190616e63565b60405180910390a250919050565b5f8060086053811115613c1b57613c1a61654a565b5b60ff166001901b60076053811115613c3657613c3561654a565b5b60ff166001901b60066053811115613c5157613c5061654a565b5b60ff166001901b60056053811115613c6c57613c6b61654a565b5b60ff166001901b60046053811115613c8757613c8661654a565b5b60ff166001901b60036053811115613ca257613ca161654a565b5b60ff166001901b60026053811115613cbd57613cbc61654a565b5b60ff166001901b5f6053811115613cd757613cd661654a565b5b60ff166001901b613ce891906165a4565b613cf291906165a4565b613cfc91906165a4565b613d0691906165a4565b613d1091906165a4565b613d1a91906165a4565b613d2491906165a4565b90505f613d318683614460565b9050613d41600d8787875f6144c6565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff16636bad18b68286898988336040518763ffffffff1660e01b8152600401613d9a9695949392919061662c565b5f604051808303815f87803b158015613db1575f80fd5b505af1158015613dc3573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167f6960c1e88f61c352dba34d1bbf6753e302795264d5d8ae82f7983c7004651e5d87878787604051613e13949392919061668b565b60405180910390a250509392505050565b5f8060086053811115613e3a57613e3961654a565b5b60ff166001901b60066053811115613e5557613e5461654a565b5b60ff166001901b60056053811115613e7057613e6f61654a565b5b60ff166001901b60046053811115613e8b57613e8a61654a565b5b60ff166001901b60036053811115613ea657613ea561654a565b5b60ff166001901b60026053811115613ec157613ec061654a565b5b60ff166001901b5f6053811115613edb57613eda61654a565b5b60ff166001901b613eec91906165a4565b613ef691906165a4565b613f0091906165a4565b613f0a91906165a4565b613f1491906165a4565b613f1e91906165a4565b90505f613f2b8683614460565b9050613f3b6005878787856144c6565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff1663c8de43528286898988336040518763ffffffff1660e01b8152600401613f949695949392919061662c565b5f604051808303815f87803b158015613fab575f80fd5b505af1158015613fbd573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167fe42486b0ccdbef81a2075c48c8e515c079aea73c8b82429997c72a2fe1bf4fef8787878760405161400d949392919061668b565b60405180910390a250509392505050565b5f73233ff88a48c172d29f675403e6a8e302b0f032d9905090565b5f806008605381111561404f5761404e61654a565b5b60ff166001901b6006605381111561406a5761406961654a565b5b60ff166001901b600560538111156140855761408461654a565b5b60ff166001901b600460538111156140a05761409f61654a565b5b60ff166001901b600360538111156140bb576140ba61654a565b5b60ff166001901b600260538111156140d6576140d561654a565b5b60ff166001901b5f60538111156140f0576140ef61654a565b5b60ff166001901b61410191906165a4565b61410b91906165a4565b61411591906165a4565b61411f91906165a4565b61412991906165a4565b61413391906165a4565b90505f6141408483614460565b905061414d60158561548e565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff16632dcbc5d1828686336040518563ffffffff1660e01b81526004016141a29493929190616b93565b5f604051808303815f87803b1580156141b9575f80fd5b505af11580156141cb573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167f55aff4cc7a3d160c83f1f15b818011ede841a0b4597fb14dcd3603df3a11e5e08585604051614217929190616e3c565b60405180910390a25050919050565b5f7350157cffd6bbfa2dece204a89ec419c23ef5755d905090565b5f80600860538111156142575761425661654a565b5b60ff166001901b600760538111156142725761427161654a565b5b60ff166001901b6006605381111561428d5761428c61654a565b5b60ff166001901b600560538111156142a8576142a761654a565b5b60ff166001901b600460538111156142c3576142c261654a565b5b60ff166001901b600360538111156142de576142dd61654a565b5b60ff166001901b600260538111156142f9576142f861654a565b5b60ff166001901b5f60538111156143135761431261654a565b5b60ff166001901b61432491906165a4565b61432e91906165a4565b61433891906165a4565b61434291906165a4565b61434c91906165a4565b61435691906165a4565b61436091906165a4565b90505f61436d8683614460565b905061437d600c8787875f6144c6565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff166360e121898286898988336040518763ffffffff1660e01b81526004016143d69695949392919061662c565b5f604051808303815f87803b1580156143ed575f80fd5b505af11580156143ff573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167fb3d5c664ec86575818e8d75ff25c5f867250df8954088549c41c848cd10e76cb8787878760405161444f949392919061668b565b60405180910390a250509392505050565b5f61446a836147ee565b90505f828260538111156144815761448061654a565b5b60ff166001901b16036144c0576040517fc6de466a00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b92915050565b5f6144d0836158c9565b7350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff166382027b6d86336040518363ffffffff1660e01b815260040161451f9291906167d7565b602060405180830381865afa15801561453a573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061455e91906169b7565b6145a15784336040517f9de3392c0000000000000000000000000000000000000000000000000000000081526004016145989291906167d7565b60405180910390fd5b5f60f81b837effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191603614716577350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff166382027b6d85336040518363ffffffff1660e01b815260040161461c9291906167d7565b602060405180830381865afa158015614637573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061465b91906169b7565b61469e5783336040517f9de3392c0000000000000000000000000000000000000000000000000000000081526004016146959291906167d7565b60405180910390fd5b5f6146a8856147ee565b90505f6146b4876147ee565b90508160538111156146c9576146c861654a565b5b8160538111156146dc576146db61654a565b5b14614713576040517f1f3158c700000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b50505b858585857350157cffd6bbfa2dece204a89ec419c23ef5755d4660405160200161474596959493929190616eb8565b60405160208183030381529060405280519060200120905061476781836148f0565b90507350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff16633e395cec82336040518363ffffffff1660e01b81526004016147b89291906167d7565b5f604051808303815f87803b1580156147cf575f80fd5b505af11580156147e1573d5f803e3d5ffd5b5050505095945050505050565b5f81601e6020811061480357614802616f27565b5b1a60f81b60f81c60ff16605381111561481f5761481e61654a565b5b9050919050565b60605f60016148348461590d565b0190505f8167ffffffffffffffff811115614852576148516160de565b5b6040519080825280601f01601f1916602001820160405280156148845781602001600182028036833780820191505090505b5090505f82602001820190505b6001156148e5578080600190039150507f3031323334353637383961626364656600000000000000000000000000000000600a86061a8153600a85816148da576148d9616f54565b5b0494505f8503614891575b819350505050919050565b5f7fffffffffffffffffffffffffffffffffffffffffff00000000000000000000005f1b83169050605060ff5f1b901b8117905060104667ffffffffffffffff165f1b901b81179050600882605381111561494e5761494d61654a565b5b60ff165f1b901b811790505f60ff165f1b8117905092915050565b5f61497261498d565b5f015f9054906101000a900467ffffffffffffffff16905090565b5f7ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00905090565b5f806149be615a5e565b9050805f01547350157cffd6bbfa2dece204a89ec419c23ef5755d466001436149e79190616f81565b40426040516020016149fd959493929190616fb4565b604051602081830303815290604052805190602001209150805f015f815480929190614a2890617012565b91905055505090565b5f8060086053811115614a4757614a4661654a565b5b60ff166001901b60066053811115614a6257614a6161654a565b5b60ff166001901b60056053811115614a7d57614a7c61654a565b5b60ff166001901b60046053811115614a9857614a9761654a565b5b60ff166001901b60036053811115614ab357614ab261654a565b5b60ff166001901b60026053811115614ace57614acd61654a565b5b60ff166001901b614adf91906165a4565b614ae991906165a4565b614af391906165a4565b614afd91906165a4565b614b0791906165a4565b90505f81856053811115614b1e57614b1d61654a565b5b60ff166001901b1603614b5d576040517fc6de466a00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b614b6685615a85565b614b9c576040517f24e8e74200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b614ba68585615aa9565b601b858585604051602001614bbe9493929190617079565b604051602081830303815290604052805190602001209150614be082856148f0565b915073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff16636cf0bd258584336040518463ffffffff1660e01b8152600401614c3393929190616dd2565b5f604051808303815f87803b158015614c4a575f80fd5b505af1158015614c5c573d5f803e3d5ffd5b505050507350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff16633e395cec83336040518363ffffffff1660e01b8152600401614caf9291906167d7565b5f604051808303815f87803b158015614cc6575f80fd5b505af1158015614cd8573d5f803e3d5ffd5b50505050509392505050565b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff163073ffffffffffffffffffffffffffffffffffffffff161480614d9157507f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16614d78615bf9565b73ffffffffffffffffffffffffffffffffffffffff1614155b15614dc8576040517fe07c8dba00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b565b7350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff16638da5cb5b6040518163ffffffff1660e01b8152600401602060405180830381865afa158015614e27573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190614e4b91906170da565b73ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614614eba57336040517f21bfda10000000000000000000000000000000000000000000000000000000008152600401614eb191906164db565b60405180910390fd5b50565b8173ffffffffffffffffffffffffffffffffffffffff166352d1902d6040518163ffffffff1660e01b8152600401602060405180830381865afa925050508015614f2557506040513d601f19601f82011682018060405250810190614f2291906167ac565b60015b614f6657816040517f4c9c8ce3000000000000000000000000000000000000000000000000000000008152600401614f5d91906164db565b60405180910390fd5b7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5f1b8114614fcc57806040517faa1d49a4000000000000000000000000000000000000000000000000000000008152600401614fc39190616053565b60405180910390fd5b614fd68383615c4c565b505050565b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff163073ffffffffffffffffffffffffffffffffffffffff1614615060576040517fe07c8dba00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b565b5f7350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff166382027b6d85336040518363ffffffff1660e01b81526004016150b29291906167d7565b602060405180830381865afa1580156150cd573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906150f191906169b7565b6151345783336040517f9de3392c00000000000000000000000000000000000000000000000000000000815260040161512b9291906167d7565b60405180910390fd5b7350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff166382027b6d84336040518363ffffffff1660e01b81526004016151839291906167d7565b602060405180830381865afa15801561519e573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906151c291906169b7565b6152055782336040517f9de3392c0000000000000000000000000000000000000000000000000000000081526004016151fc9291906167d7565b60405180910390fd5b7350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff166382027b6d83336040518363ffffffff1660e01b81526004016152549291906167d7565b602060405180830381865afa15801561526f573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061529391906169b7565b6152d65781336040517f9de3392c0000000000000000000000000000000000000000000000000000000081526004016152cd9291906167d7565b60405180910390fd5b5f6152e0856147ee565b90505f6152ec856147ee565b90505f6152f8856147ee565b90505f605381111561530d5761530c61654a565b5b8360538111156153205761531f61654a565b5b14615357576040517fc6de466a00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b80605381111561536a5761536961654a565b5b82605381111561537d5761537c61654a565b5b146153b4576040517f1f3158c700000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b878787877350157cffd6bbfa2dece204a89ec419c23ef5755d466040516020016153e396959493929190617105565b60405160208183030381529060405280519060200120935061540584836148f0565b93507350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff16633e395cec85336040518363ffffffff1660e01b81526004016154569291906167d7565b5f604051808303815f87803b15801561546d575f80fd5b505af115801561547f573d5f803e3d5ffd5b50505050505050949350505050565b5f7350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff166382027b6d83336040518363ffffffff1660e01b81526004016154de9291906167d7565b602060405180830381865afa1580156154f9573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061551d91906169b7565b6155605781336040517f9de3392c0000000000000000000000000000000000000000000000000000000081526004016155579291906167d7565b60405180910390fd5b82827350157cffd6bbfa2dece204a89ec419c23ef5755d4660405160200161558b9493929190617174565b6040516020818303038152906040528051906020012090505f6155ad836147ee565b90506155b982826148f0565b91507350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff16633e395cec83336040518363ffffffff1660e01b815260040161560a9291906167d7565b5f604051808303815f87803b158015615621575f80fd5b505af1158015615633573d5f803e3d5ffd5b505050505092915050565b5f80600860538111156156545761565361654a565b5b60ff166001901b6006605381111561566f5761566e61654a565b5b60ff166001901b6005605381111561568a5761568961654a565b5b60ff166001901b600460538111156156a5576156a461654a565b5b60ff166001901b600360538111156156c0576156bf61654a565b5b60ff166001901b600260538111156156db576156da61654a565b5b60ff166001901b5f60538111156156f5576156f461654a565b5b60ff166001901b61570691906165a4565b61571091906165a4565b61571a91906165a4565b61572491906165a4565b61572e91906165a4565b61573891906165a4565b90505f8185605381111561574f5761574e61654a565b5b60ff166001901b160361578e576040517fc6de466a00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b601a84846040516020016157a4939291906171c1565b6040516020818303038152906040528051906020012091506157c682856148f0565b915073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff1663d5b8b8f38584336040518463ffffffff1660e01b815260040161581993929190616dd2565b5f604051808303815f87803b158015615830575f80fd5b505af1158015615842573d5f803e3d5ffd5b505050507350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff16633e395cec83336040518363ffffffff1660e01b81526004016158959291906167d7565b5f604051808303815f87803b1580156158ac575f80fd5b505af11580156158be573d5f803e3d5ffd5b505050505092915050565b60018160f81c60ff16111561590a576040517fdf7bf32500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b50565b5f805f90507a184f03e93ff9f4daa797ed6e38ed64bf6a1f0100000000000000008310615969577a184f03e93ff9f4daa797ed6e38ed64bf6a1f010000000000000000838161595f5761595e616f54565b5b0492506040810190505b6d04ee2d6d415b85acef810000000083106159a6576d04ee2d6d415b85acef8100000000838161599c5761599b616f54565b5b0492506020810190505b662386f26fc1000083106159d557662386f26fc1000083816159cb576159ca616f54565b5b0492506010810190505b6305f5e10083106159fe576305f5e10083816159f4576159f3616f54565b5b0492506008810190505b6127108310615a23576127108381615a1957615a18616f54565b5b0492506004810190505b60648310615a465760648381615a3c57615a3b616f54565b5b0492506002810190505b600a8310615a55576001810190505b80915050919050565b5f7f4613e1771f6b755d243e536fb5a23c5b15e2826575fee921e8fe7a22a760c800905090565b5f8082118015615aa257505f600183615a9e9190616f81565b8316145b9050919050565b60026053811115615abd57615abc61654a565b5b816053811115615ad057615acf61654a565b5b03615ae657615ae182610100615cbe565b615bf5565b60036053811115615afa57615af961654a565b5b816053811115615b0d57615b0c61654a565b5b03615b2457615b1f8262010000615cbe565b615bf5565b60046053811115615b3857615b3761654a565b5b816053811115615b4b57615b4a61654a565b5b03615b6457615b5f82640100000000615cbe565b615bf5565b60056053811115615b7857615b7761654a565b5b816053811115615b8b57615b8a61654a565b5b03615ba857615ba38268010000000000000000615cbe565b615bf5565b60066053811115615bbc57615bbb61654a565b5b816053811115615bcf57615bce61654a565b5b03615bf457615bef82700100000000000000000000000000000000615cbe565b615bf5565b5b5050565b5f615c257f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5f1b615cfc565b5f015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905090565b615c5582615d05565b8173ffffffffffffffffffffffffffffffffffffffff167fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b60405160405180910390a25f81511115615cb157615cab8282615dce565b50615cba565b615cb9615e4e565b5b5050565b80821115615cf8576040517fc7dadf4500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5050565b5f819050919050565b5f8173ffffffffffffffffffffffffffffffffffffffff163b03615d6057806040517f4c9c8ce3000000000000000000000000000000000000000000000000000000008152600401615d5791906164db565b60405180910390fd5b80615d8c7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5f1b615cfc565b5f015f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555050565b60605f808473ffffffffffffffffffffffffffffffffffffffff1684604051615df79190617237565b5f60405180830381855af49150503d805f8114615e2f576040519150601f19603f3d011682016040523d82523d5f602084013e615e34565b606091505b5091509150615e44858383615e8a565b9250505092915050565b5f341115615e88576040517fb398979f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b565b606082615e9f57615e9a82615f17565b615f0f565b5f8251148015615ec557505f8473ffffffffffffffffffffffffffffffffffffffff163b145b15615f0757836040517f9996b315000000000000000000000000000000000000000000000000000000008152600401615efe91906164db565b60405180910390fd5b819050615f10565b5b9392505050565b5f81511115615f295780518082602001fd5b6040517fd6bda27500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f604051905090565b5f80fd5b5f80fd5b5f819050919050565b615f7e81615f6c565b8114615f88575f80fd5b50565b5f81359050615f9981615f75565b92915050565b5f7fff0000000000000000000000000000000000000000000000000000000000000082169050919050565b615fd381615f9f565b8114615fdd575f80fd5b50565b5f81359050615fee81615fca565b92915050565b5f805f6060848603121561600b5761600a615f64565b5b5f61601886828701615f8b565b935050602061602986828701615f8b565b925050604061603a86828701615fe0565b9150509250925092565b61604d81615f6c565b82525050565b5f6020820190506160665f830184616044565b92915050565b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f6160958261606c565b9050919050565b6160a58161608b565b81146160af575f80fd5b50565b5f813590506160c08161609c565b92915050565b5f80fd5b5f80fd5b5f601f19601f8301169050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b616114826160ce565b810181811067ffffffffffffffff82111715616133576161326160de565b5b80604052505050565b5f616145615f5b565b9050616151828261610b565b919050565b5f67ffffffffffffffff8211156161705761616f6160de565b5b616179826160ce565b9050602081019050919050565b828183375f83830152505050565b5f6161a66161a184616156565b61613c565b9050828152602081018484840111156161c2576161c16160ca565b5b6161cd848285616186565b509392505050565b5f82601f8301126161e9576161e86160c6565b5b81356161f9848260208601616194565b91505092915050565b6054811061620e575f80fd5b50565b5f8135905061621f81616202565b92915050565b5f805f806080858703121561623d5761623c615f64565b5b5f61624a87828801615f8b565b945050602061625b878288016160b2565b935050604085013567ffffffffffffffff81111561627c5761627b615f68565b5b616288878288016161d5565b925050606061629987828801616211565b91505092959194509250565b5f81519050919050565b5f82825260208201905092915050565b5f5b838110156162dc5780820151818401526020810190506162c1565b5f8484015250505050565b5f6162f1826162a5565b6162fb81856162af565b935061630b8185602086016162bf565b616314816160ce565b840191505092915050565b5f6020820190508181035f83015261633781846162e7565b905092915050565b5f806040838503121561635557616354615f64565b5b5f61636285828601615f8b565b925050602061637385828601616211565b9150509250929050565b5f819050919050565b61638f8161637d565b8114616399575f80fd5b50565b5f813590506163aa81616386565b92915050565b5f80604083850312156163c6576163c5615f64565b5b5f6163d38582860161639c565b92505060206163e485828601616211565b9150509250929050565b5f806040838503121561640457616403615f64565b5b5f616411858286016160b2565b925050602083013567ffffffffffffffff81111561643257616431615f68565b5b61643e858286016161d5565b9150509250929050565b5f805f6060848603121561645f5761645e615f64565b5b5f61646c86828701615f8b565b935050602061647d86828701615f8b565b925050604061648e86828701615f8b565b9150509250925092565b5f60ff82169050919050565b6164ad81616498565b82525050565b5f6020820190506164c65f8301846164a4565b92915050565b6164d58161608b565b82525050565b5f6020820190506164ee5f8301846164cc565b92915050565b5f6020828403121561650957616508615f64565b5b5f61651684828501615f8b565b91505092915050565b5f6020828403121561653457616533615f64565b5b5f61654184828501616211565b91505092915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52602160045260245ffd5b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5f6165ae8261637d565b91506165b98361637d565b92508282019050808211156165d1576165d0616577565b5b92915050565b605481106165e8576165e761654a565b5b50565b5f8190506165f8826165d7565b919050565b5f616607826165eb565b9050919050565b616617816165fd565b82525050565b61662681615f9f565b82525050565b5f60c08201905061663f5f83018961660e565b61664c602083018861661d565b6166596040830187616044565b6166666060830186616044565b6166736080830185616044565b61668060a08301846164cc565b979650505050505050565b5f60808201905061669e5f830187616044565b6166ab6020830186616044565b6166b8604083018561661d565b6166c56060830184616044565b95945050505050565b6166d78161608b565b82525050565b604082015f8201516166f15f8501826166ce565b50602082015161670460208501826166ce565b50505050565b5f81519050919050565b5f82825260208201905092915050565b5f61672e8261670a565b6167388185616714565b93506167488185602086016162bf565b616751816160ce565b840191505092915050565b5f60808201905061676f5f8301866166dd565b61677c6040830185616044565b818103606083015261678e8184616724565b9050949350505050565b5f815190506167a681615f75565b92915050565b5f602082840312156167c1576167c0615f64565b5b5f6167ce84828501616798565b91505092915050565b5f6040820190506167ea5f830185616044565b6167f760208301846164cc565b9392505050565b5f60a0820190506168115f830188616044565b61681e60208301876164cc565b81810360408301526168308186616724565b905061683f606083018561660e565b61684c6080830184616044565b9695505050505050565b5f81905092915050565b5f61686a826162a5565b6168748185616856565b93506168848185602086016162bf565b80840191505092915050565b7f20760000000000000000000000000000000000000000000000000000000000005f82015250565b5f6168c4600283616856565b91506168cf82616890565b600282019050919050565b7f2e000000000000000000000000000000000000000000000000000000000000005f82015250565b5f61690e600183616856565b9150616919826168da565b600182019050919050565b5f61692f8287616860565b915061693a826168b8565b91506169468286616860565b915061695182616902565b915061695d8285616860565b915061696882616902565b91506169748284616860565b915081905095945050505050565b5f8115159050919050565b61699681616982565b81146169a0575f80fd5b50565b5f815190506169b18161698d565b92915050565b5f602082840312156169cc576169cb615f64565b5b5f6169d9848285016169a3565b91505092915050565b601c81106169f3576169f261654a565b5b50565b5f819050616a03826169e2565b919050565b5f616a12826169f6565b9050919050565b5f8160f81b9050919050565b5f616a2f82616a19565b9050919050565b616a47616a4282616a08565b616a25565b82525050565b5f819050919050565b616a67616a6282615f6c565b616a4d565b82525050565b616a7e616a79826165fd565b616a25565b82525050565b5f819050919050565b5f616aa7616aa2616a9d8461606c565b616a84565b61606c565b9050919050565b5f616ab882616a8d565b9050919050565b5f616ac982616aae565b9050919050565b5f8160601b9050919050565b5f616ae682616ad0565b9050919050565b5f616af782616adc565b9050919050565b616b0f616b0a82616abf565b616aed565b82525050565b5f819050919050565b616b2f616b2a8261637d565b616b15565b82525050565b5f616b408288616a36565b600182019150616b508287616a56565b602082019150616b608286616a6d565b600182019150616b708285616afe565b601482019150616b808284616b1e565b6020820191508190509695505050505050565b5f608082019050616ba65f83018761660e565b616bb36020830186616044565b616bc06040830185616044565b616bcd60608301846164cc565b95945050505050565b5f606082019050616be95f830186616044565b616bf6602083018561660e565b616c036040830184616044565b949350505050565b5f67ffffffffffffffff82169050919050565b616c2781616c0b565b82525050565b5f602082019050616c405f830184616c1e565b92915050565b616c4f8161637d565b82525050565b5f7fffffffffffffffffffffffffffffffff0000000000000000000000000000000082169050919050565b616c8981616c55565b82525050565b5f608082019050616ca25f830187616c46565b616caf602083018661660e565b616cbc6040830185616c80565b616cc96060830184616044565b95945050505050565b5f60c082019050616ce55f83018961660e565b616cf26020830188616044565b616cff6040830187616044565b616d0c6060830186616044565b616d196080830185616044565b616d2660a08301846164cc565b979650505050505050565b5f608082019050616d445f830187616044565b616d516020830186616044565b616d5e6040830185616044565b616d6b6060830184616044565b95945050505050565b5f616d7f8288616a36565b600182019150616d8f8287616b1e565b602082019150616d9f8286616a6d565b600182019150616daf8285616afe565b601482019150616dbf8284616b1e565b6020820191508190509695505050505050565b5f606082019050616de55f83018661660e565b616df26020830185616044565b616dff60408301846164cc565b949350505050565b5f606082019050616e1a5f830186616c46565b616e27602083018561660e565b616e346040830184616044565b949350505050565b5f604082019050616e4f5f830185616044565b616e5c6020830184616044565b9392505050565b5f606082019050616e765f83018661660e565b616e836020830185616c80565b616e906040830184616044565b949350505050565b5f819050919050565b616eb2616ead82615f9f565b616e98565b82525050565b5f616ec38289616a36565b600182019150616ed38288616a56565b602082019150616ee38287616a56565b602082019150616ef38286616ea1565b600182019150616f038285616afe565b601482019150616f138284616b1e565b602082019150819050979650505050505050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603260045260245ffd5b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601260045260245ffd5b5f616f8b8261637d565b9150616f968361637d565b9250828203905081811115616fae57616fad616577565b5b92915050565b5f616fbf8288616b1e565b602082019150616fcf8287616afe565b601482019150616fdf8286616b1e565b602082019150616fef8285616a56565b602082019150616fff8284616b1e565b6020820191508190509695505050505050565b5f61701c8261637d565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff820361704e5761704d616577565b5b600182019050919050565b5f819050919050565b61707361706e82616c55565b617059565b82525050565b5f6170848287616a36565b6001820191506170948286616b1e565b6020820191506170a48285616a6d565b6001820191506170b48284617062565b60108201915081905095945050505050565b5f815190506170d48161609c565b92915050565b5f602082840312156170ef576170ee615f64565b5b5f6170fc848285016170c6565b91505092915050565b5f6171108289616a36565b6001820191506171208288616a56565b6020820191506171308287616a56565b6020820191506171408286616a56565b6020820191506171508285616afe565b6014820191506171608284616b1e565b602082019150819050979650505050505050565b5f61717f8287616a36565b60018201915061718f8286616a56565b60208201915061719f8285616afe565b6014820191506171af8284616b1e565b60208201915081905095945050505050565b5f6171cc8286616a36565b6001820191506171dc8285616a6d565b6001820191506171ec8284617062565b601082019150819050949350505050565b5f81905092915050565b5f6172118261670a565b61721b81856171fd565b935061722b8185602086016162bf565b80840191505092915050565b5f6172428284617207565b91508190509291505056
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R`\x046\x10a\x02$W_5`\xE0\x1C\x80cz)\x7FK\x11a\x01\"W\x80c\xCC\xC4\x80\xA1\x11a\0\xAAW\x80c\xD9\x98\x82\xD5\x11a\0nW\x80c\xD9\x98\x82\xD5\x14a\t\x1EW\x80c\xE0xir\x14a\tZW\x80c\xF5\x1C\xCF\xB0\x14a\t\x84W\x80c\xF6\x85\x9B\xDC\x14a\t\xC0W\x80c\xF7\x7F?\x1D\x14a\t\xEAWa\x02$V[\x80c\xCC\xC4\x80\xA1\x14a\x07\xF2W\x80c\xCFM\x18\xAA\x14a\x08.W\x80c\xD5\x80\xC0c\x14a\x08jW\x80c\xD7]n\x8A\x14a\x08\xA6W\x80c\xD8\t,\xBC\x14a\x08\xE2Wa\x02$V[\x80c\x9C\xD0z\xCB\x11a\0\xF1W\x80c\x9C\xD0z\xCB\x14a\x07\x10W\x80c\xA8\xC7\xC2\xC1\x14a\x07LW\x80c\xAD<\xB1\xCC\x14a\x07vW\x80c\xBA\xC2+\xB8\x14a\x07\xA0W\x80c\xC0!2\x9E\x14a\x07\xB6Wa\x02$V[\x80cz)\x7FK\x14a\x062W\x80c\x856.\xE7\x14a\x06\\W\x80c\x8BI\xCE\xB4\x14a\x06\x98W\x80c\x91\xF9\x8F\xFE\x14a\x06\xD4Wa\x02$V[\x80cH\xEE\xF4~\x11a\x01\xB0W\x80cc\xA2\xDB)\x11a\x01tW\x80cc\xA2\xDB)\x14a\x05\x06W\x80cgT\xB3`\x14a\x05BW\x80cr\x10v\x81\x14a\x05~W\x80cu\x13\xA4\x04\x14a\x05\xBAW\x80cw\x02\xDC\xFF\x14a\x05\xF6Wa\x02$V[\x80cH\xEE\xF4~\x14a\x04\x0CW\x80cO\x1E\xF2\x86\x14a\x04HW\x80cR\xD1\x90-\x14a\x04dW\x80cW\xF0\xA5h\x14a\x04\x8EW\x80cZS\xAC\xCB\x14a\x04\xCAWa\x02$V[\x80c\x13\x91T\x7F\x11a\x01\xF7W\x80c\x13\x91T\x7F\x14a\x03\x06W\x80c\x18+m\x98\x14a\x03BW\x80c\x1C\x89\xEED\x14a\x03~W\x80c61\x8Dd\x14a\x03\xBAW\x80c9\xF78\x10\x14a\x03\xF6Wa\x02$V[\x80c\x04U\x9Fq\x14a\x02(W\x80c\x08\xBF\x83*\x14a\x02dW\x80c\r\x8En,\x14a\x02\xA0W\x80c\x11{/8\x14a\x02\xCAW[_\x80\xFD[4\x80\x15a\x023W_\x80\xFD[Pa\x02N`\x04\x806\x03\x81\x01\x90a\x02I\x91\x90a_\xF4V[a\n&V[`@Qa\x02[\x91\x90a`SV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x02oW_\x80\xFD[Pa\x02\x8A`\x04\x806\x03\x81\x01\x90a\x02\x85\x91\x90ab%V[a\x0B\xD7V[`@Qa\x02\x97\x91\x90a`SV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x02\xABW_\x80\xFD[Pa\x02\xB4a\r\xF4V[`@Qa\x02\xC1\x91\x90ac\x1FV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x02\xD5W_\x80\xFD[Pa\x02\xF0`\x04\x806\x03\x81\x01\x90a\x02\xEB\x91\x90a_\xF4V[a\x0EoV[`@Qa\x02\xFD\x91\x90a`SV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x03\x11W_\x80\xFD[Pa\x03,`\x04\x806\x03\x81\x01\x90a\x03'\x91\x90a_\xF4V[a\x10\x1FV[`@Qa\x039\x91\x90a`SV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x03MW_\x80\xFD[Pa\x03h`\x04\x806\x03\x81\x01\x90a\x03c\x91\x90a_\xF4V[a\x11\xD0V[`@Qa\x03u\x91\x90a`SV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x03\x89W_\x80\xFD[Pa\x03\xA4`\x04\x806\x03\x81\x01\x90a\x03\x9F\x91\x90ac?V[a\x13\x81V[`@Qa\x03\xB1\x91\x90a`SV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x03\xC5W_\x80\xFD[Pa\x03\xE0`\x04\x806\x03\x81\x01\x90a\x03\xDB\x91\x90a_\xF4V[a\x18\x8CV[`@Qa\x03\xED\x91\x90a`SV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x04\x01W_\x80\xFD[Pa\x04\na\x1A=V[\0[4\x80\x15a\x04\x17W_\x80\xFD[Pa\x042`\x04\x806\x03\x81\x01\x90a\x04-\x91\x90ac\xB0V[a\x1B\xADV[`@Qa\x04?\x91\x90a`SV[`@Q\x80\x91\x03\x90\xF3[a\x04b`\x04\x806\x03\x81\x01\x90a\x04]\x91\x90ac\xEEV[a\x1C!V[\0[4\x80\x15a\x04oW_\x80\xFD[Pa\x04xa\x1C@V[`@Qa\x04\x85\x91\x90a`SV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x04\x99W_\x80\xFD[Pa\x04\xB4`\x04\x806\x03\x81\x01\x90a\x04\xAF\x91\x90a_\xF4V[a\x1CqV[`@Qa\x04\xC1\x91\x90a`SV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x04\xD5W_\x80\xFD[Pa\x04\xF0`\x04\x806\x03\x81\x01\x90a\x04\xEB\x91\x90a_\xF4V[a\x1E\"V[`@Qa\x04\xFD\x91\x90a`SV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x05\x11W_\x80\xFD[Pa\x05,`\x04\x806\x03\x81\x01\x90a\x05'\x91\x90a_\xF4V[a mV[`@Qa\x059\x91\x90a`SV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x05MW_\x80\xFD[Pa\x05h`\x04\x806\x03\x81\x01\x90a\x05c\x91\x90a_\xF4V[a\"gV[`@Qa\x05u\x91\x90a`SV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x05\x89W_\x80\xFD[Pa\x05\xA4`\x04\x806\x03\x81\x01\x90a\x05\x9F\x91\x90a_\xF4V[a$=V[`@Qa\x05\xB1\x91\x90a`SV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x05\xC5W_\x80\xFD[Pa\x05\xE0`\x04\x806\x03\x81\x01\x90a\x05\xDB\x91\x90a_\xF4V[a%\xEEV[`@Qa\x05\xED\x91\x90a`SV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x06\x01W_\x80\xFD[Pa\x06\x1C`\x04\x806\x03\x81\x01\x90a\x06\x17\x91\x90adHV[a'\x9FV[`@Qa\x06)\x91\x90a`SV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x06=W_\x80\xFD[Pa\x06Fa)\xBDV[`@Qa\x06S\x91\x90ad\xB3V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x06gW_\x80\xFD[Pa\x06\x82`\x04\x806\x03\x81\x01\x90a\x06}\x91\x90a_\xF4V[a)\xC1V[`@Qa\x06\x8F\x91\x90a`SV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x06\xA3W_\x80\xFD[Pa\x06\xBE`\x04\x806\x03\x81\x01\x90a\x06\xB9\x91\x90a_\xF4V[a+rV[`@Qa\x06\xCB\x91\x90a`SV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x06\xDFW_\x80\xFD[Pa\x06\xFA`\x04\x806\x03\x81\x01\x90a\x06\xF5\x91\x90a_\xF4V[a-lV[`@Qa\x07\x07\x91\x90a`SV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x07\x1BW_\x80\xFD[Pa\x076`\x04\x806\x03\x81\x01\x90a\x071\x91\x90ac\xB0V[a/BV[`@Qa\x07C\x91\x90a`SV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x07WW_\x80\xFD[Pa\x07`a2\\V[`@Qa\x07m\x91\x90ad\xDBV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x07\x81W_\x80\xFD[Pa\x07\x8Aa2wV[`@Qa\x07\x97\x91\x90ac\x1FV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x07\xABW_\x80\xFD[Pa\x07\xB4a2\xB0V[\0[4\x80\x15a\x07\xC1W_\x80\xFD[Pa\x07\xDC`\x04\x806\x03\x81\x01\x90a\x07\xD7\x91\x90a_\xF4V[a3\xD5V[`@Qa\x07\xE9\x91\x90a`SV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x07\xFDW_\x80\xFD[Pa\x08\x18`\x04\x806\x03\x81\x01\x90a\x08\x13\x91\x90a_\xF4V[a5\xABV[`@Qa\x08%\x91\x90a`SV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x089W_\x80\xFD[Pa\x08T`\x04\x806\x03\x81\x01\x90a\x08O\x91\x90a_\xF4V[a7\x81V[`@Qa\x08a\x91\x90a`SV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x08uW_\x80\xFD[Pa\x08\x90`\x04\x806\x03\x81\x01\x90a\x08\x8B\x91\x90ad\xF4V[a9\xCCV[`@Qa\x08\x9D\x91\x90a`SV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x08\xB1W_\x80\xFD[Pa\x08\xCC`\x04\x806\x03\x81\x01\x90a\x08\xC7\x91\x90ae\x1FV[a;\x95V[`@Qa\x08\xD9\x91\x90a`SV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x08\xEDW_\x80\xFD[Pa\t\x08`\x04\x806\x03\x81\x01\x90a\t\x03\x91\x90a_\xF4V[a<\x05V[`@Qa\t\x15\x91\x90a`SV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\t)W_\x80\xFD[Pa\tD`\x04\x806\x03\x81\x01\x90a\t?\x91\x90a_\xF4V[a>$V[`@Qa\tQ\x91\x90a`SV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\teW_\x80\xFD[Pa\tna@\x1EV[`@Qa\t{\x91\x90ad\xDBV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\t\x8FW_\x80\xFD[Pa\t\xAA`\x04\x806\x03\x81\x01\x90a\t\xA5\x91\x90ad\xF4V[a@9V[`@Qa\t\xB7\x91\x90a`SV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\t\xCBW_\x80\xFD[Pa\t\xD4aB&V[`@Qa\t\xE1\x91\x90ad\xDBV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\t\xF5W_\x80\xFD[Pa\n\x10`\x04\x806\x03\x81\x01\x90a\n\x0B\x91\x90a_\xF4V[aBAV[`@Qa\n\x1D\x91\x90a`SV[`@Q\x80\x91\x03\x90\xF3[_\x80`\x06`S\x81\x11\x15a\n<Wa\n;aeJV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a\nWWa\nVaeJV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a\nrWa\nqaeJV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a\n\x8DWa\n\x8CaeJV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a\n\xA8Wa\n\xA7aeJV[[`\xFF\x16`\x01\x90\x1Ba\n\xB9\x91\x90ae\xA4V[a\n\xC3\x91\x90ae\xA4V[a\n\xCD\x91\x90ae\xA4V[a\n\xD7\x91\x90ae\xA4V[\x90P_a\n\xE4\x86\x83aD`V[\x90Pa\n\xF4`\x12\x87\x87\x87\x85aD\xC6V[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x04U?\xB6\x82\x86\x89\x89\x883`@Q\x87c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x0BM\x96\x95\x94\x93\x92\x91\x90af,V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x0BdW_\x80\xFD[PZ\xF1\x15\x80\x15a\x0BvW=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xC1\x1Db\xB1<6\n\x83\x08$\x87\x06K\xE1\xEC\x08x\xB2\xF0\xBEO\x01+\xF5\x9F\x89\xE1(\x06=G\xFF\x87\x87\x87\x87`@Qa\x0B\xC6\x94\x93\x92\x91\x90af\x8BV[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_\x80`@Q\x80`@\x01`@R\x80\x86s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x013s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81RP\x90P_a\x0C&\x87aG\xEEV[\x90P\x80`S\x81\x11\x15a\x0C;Wa\x0C:aeJV[[\x84`S\x81\x11\x15a\x0CNWa\x0CMaeJV[[\x14a\x0C\x85W`@Q\x7F\xB9h\x84a\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[s6w!B\xB7Hq\xF2U\xCB\xD7\xA3\xE8\x9B@\x1D>E\x82_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xE61}\xF5\x83\x89\x88`@Q\x84c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x0C\xD6\x93\x92\x91\x90ag\\V[` `@Q\x80\x83\x03\x81_\x87Z\xF1\x15\x80\x15a\x0C\xF2W=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\r\x16\x91\x90ag\xACV[\x92PsP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c>9\\\xEC\x843`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\rg\x92\x91\x90ag\xD7V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\r~W_\x80\xFD[PZ\xF1\x15\x80\x15a\r\x90W=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xDC7\r\xB35\x89\xE73q\xDC>\xE4,x\x9C\0=3n\xEF\xCB|?V\xFE\x0FQ\xAE[\x1D\x97\x02\x88\x88\x88\x88\x88`@Qa\r\xE2\x95\x94\x93\x92\x91\x90ag\xFEV[`@Q\x80\x91\x03\x90\xA2PP\x94\x93PPPPV[```@Q\x80`@\x01`@R\x80`\r\x81R` \x01\x7FFHEVMExecutor\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81RPa\x0E5_aH&V[a\x0E?`\x01aH&V[a\x0EH_aH&V[`@Q` \x01a\x0E[\x94\x93\x92\x91\x90ai$V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x90P\x90V[_\x80`\x06`S\x81\x11\x15a\x0E\x85Wa\x0E\x84aeJV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a\x0E\xA0Wa\x0E\x9FaeJV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a\x0E\xBBWa\x0E\xBAaeJV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a\x0E\xD6Wa\x0E\xD5aeJV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a\x0E\xF1Wa\x0E\xF0aeJV[[`\xFF\x16`\x01\x90\x1Ba\x0F\x02\x91\x90ae\xA4V[a\x0F\x0C\x91\x90ae\xA4V[a\x0F\x16\x91\x90ae\xA4V[a\x0F \x91\x90ae\xA4V[\x90P_a\x0F-\x86\x83aD`V[\x90Pa\x0F<_\x87\x87\x87\x85aD\xC6V[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xC19\x0C4\x82\x86\x89\x89\x883`@Q\x87c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x0F\x95\x96\x95\x94\x93\x92\x91\x90af,V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x0F\xACW_\x80\xFD[PZ\xF1\x15\x80\x15a\x0F\xBEW=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xDB\x90P\xD6R@C\x16!\xD6\x1Do\x94\xB9p\xE6?S\xA6zWfaN\xE6\xE5\xC5\xBB\xD4\x1C\x8E.\x87\x87\x87\x87`@Qa\x10\x0E\x94\x93\x92\x91\x90af\x8BV[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_\x80`\x06`S\x81\x11\x15a\x105Wa\x104aeJV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a\x10PWa\x10OaeJV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a\x10kWa\x10jaeJV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a\x10\x86Wa\x10\x85aeJV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a\x10\xA1Wa\x10\xA0aeJV[[`\xFF\x16`\x01\x90\x1Ba\x10\xB2\x91\x90ae\xA4V[a\x10\xBC\x91\x90ae\xA4V[a\x10\xC6\x91\x90ae\xA4V[a\x10\xD0\x91\x90ae\xA4V[\x90P_a\x10\xDD\x86\x83aD`V[\x90Pa\x10\xED`\x0E\x87\x87\x87_aD\xC6V[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xC2w\xA96\x82\x86\x89\x89\x883`@Q\x87c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x11F\x96\x95\x94\x93\x92\x91\x90af,V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x11]W_\x80\xFD[PZ\xF1\x15\x80\x15a\x11oW=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F8\xC3\xA6<B0\xDE[t\x1FIO\xFBT\xE3\x08q\x04\x03\x02y\xBC{\xCC\xEE\x8A\xD9\xAD1q+!\x87\x87\x87\x87`@Qa\x11\xBF\x94\x93\x92\x91\x90af\x8BV[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_\x80`\x06`S\x81\x11\x15a\x11\xE6Wa\x11\xE5aeJV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a\x12\x01Wa\x12\0aeJV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a\x12\x1CWa\x12\x1BaeJV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a\x127Wa\x126aeJV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a\x12RWa\x12QaeJV[[`\xFF\x16`\x01\x90\x1Ba\x12c\x91\x90ae\xA4V[a\x12m\x91\x90ae\xA4V[a\x12w\x91\x90ae\xA4V[a\x12\x81\x91\x90ae\xA4V[\x90P_a\x12\x8E\x86\x83aD`V[\x90Pa\x12\x9E`\x01\x87\x87\x87\x85aD\xC6V[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xD63\xC9k\x82\x86\x89\x89\x883`@Q\x87c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x12\xF7\x96\x95\x94\x93\x92\x91\x90af,V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x13\x0EW_\x80\xFD[PZ\xF1\x15\x80\x15a\x13 W=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xEBm7\xBD'\x1A\xBE\x13\x95\xB2\x1Dmx\xF3H}e\x84\x86(r\xC2\x9F\xFD?\x90sn\xE9\x9Bs\x93\x87\x87\x87\x87`@Qa\x13p\x94\x93\x92\x91\x90af\x8BV[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_sP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x82\x02{m\x843`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x13\xD1\x92\x91\x90ag\xD7V[` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x13\xECW=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x14\x10\x91\x90ai\xB7V[a\x14SW\x823`@Q\x7F\x9D\xE39,\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x14J\x92\x91\x90ag\xD7V[`@Q\x80\x91\x03\x90\xFD[_`\x08`S\x81\x11\x15a\x14hWa\x14gaeJV[[`\xFF\x16`\x01\x90\x1B`\x06`S\x81\x11\x15a\x14\x83Wa\x14\x82aeJV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a\x14\x9EWa\x14\x9DaeJV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a\x14\xB9Wa\x14\xB8aeJV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a\x14\xD4Wa\x14\xD3aeJV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a\x14\xEFWa\x14\xEEaeJV[[`\xFF\x16`\x01\x90\x1B_`S\x81\x11\x15a\x15\tWa\x15\x08aeJV[[`\xFF\x16`\x01\x90\x1Ba\x15\x1A\x91\x90ae\xA4V[a\x15$\x91\x90ae\xA4V[a\x15.\x91\x90ae\xA4V[a\x158\x91\x90ae\xA4V[a\x15B\x91\x90ae\xA4V[a\x15L\x91\x90ae\xA4V[\x90P_a\x15Y\x85\x83aD`V[\x90P_`\x08`S\x81\x11\x15a\x15pWa\x15oaeJV[[`\xFF\x16`\x01\x90\x1B`\x06`S\x81\x11\x15a\x15\x8BWa\x15\x8AaeJV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a\x15\xA6Wa\x15\xA5aeJV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a\x15\xC1Wa\x15\xC0aeJV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a\x15\xDCWa\x15\xDBaeJV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a\x15\xF7Wa\x15\xF6aeJV[[`\xFF\x16`\x01\x90\x1Ba\x16\x08\x91\x90ae\xA4V[a\x16\x12\x91\x90ae\xA4V[a\x16\x1C\x91\x90ae\xA4V[a\x16&\x91\x90ae\xA4V[a\x160\x91\x90ae\xA4V[\x90P_\x81\x86`S\x81\x11\x15a\x16GWa\x16FaeJV[[`\xFF\x16`\x01\x90\x1B\x16\x03a\x16\x86W`@Q\x7F\xC6\xDEFj\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x84`S\x81\x11\x15a\x16\x99Wa\x16\x98aeJV[[\x82`S\x81\x11\x15a\x16\xACWa\x16\xABaeJV[[\x03a\x16\xE3W`@Q\x7F\xB9h\x84a\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x17\x86\x86sP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]F`@Q` \x01a\x17\x11\x95\x94\x93\x92\x91\x90ak5V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x93Pa\x173\x84\x86aH\xF0V[\x93Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16ci\x93\x1A\xFB\x86\x88\x873`@Q\x85c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x17\x88\x94\x93\x92\x91\x90ak\x93V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x17\x9FW_\x80\xFD[PZ\xF1\x15\x80\x15a\x17\xB1W=_\x80>=_\xFD[PPPPsP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c>9\\\xEC\x853`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x18\x04\x92\x91\x90ag\xD7V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x18\x1BW_\x80\xFD[PZ\xF1\x15\x80\x15a\x18-W=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F1\xCC\xAEj/\x8E<\xED\x16\x92\xF7|\x8Ff\x813\xE4\xAF\xDA\xAA5\xAF\xE8D\xFFFY\xA6\xC2~b\x7F\x87\x87\x87`@Qa\x18{\x93\x92\x91\x90ak\xD6V[`@Q\x80\x91\x03\x90\xA2PPP\x92\x91PPV[_\x80`\x06`S\x81\x11\x15a\x18\xA2Wa\x18\xA1aeJV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a\x18\xBDWa\x18\xBCaeJV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a\x18\xD8Wa\x18\xD7aeJV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a\x18\xF3Wa\x18\xF2aeJV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a\x19\x0EWa\x19\raeJV[[`\xFF\x16`\x01\x90\x1Ba\x19\x1F\x91\x90ae\xA4V[a\x19)\x91\x90ae\xA4V[a\x193\x91\x90ae\xA4V[a\x19=\x91\x90ae\xA4V[\x90P_a\x19J\x86\x83aD`V[\x90Pa\x19Z`\x13\x87\x87\x87\x85aD\xC6V[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x96\x83\x02\xD7\x82\x86\x89\x89\x883`@Q\x87c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x19\xB3\x96\x95\x94\x93\x92\x91\x90af,V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x19\xCAW_\x80\xFD[PZ\xF1\x15\x80\x15a\x19\xDCW=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xFD|\x92\x08\xF9V\xBF\x0Cj\xB7jf\x7F\x046\x12E\xAD>\n-\x0E\xFF\x92\xEB\x82z\xCF\xCC\xA6\x8E\xA9\x87\x87\x87\x87`@Qa\x1A,\x94\x93\x92\x91\x90af\x8BV[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[`\x01a\x1AGaIiV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x1A\x88W`@Q\x7FoOs\x1F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x03_a\x1A\x93aI\x8DV[\x90P\x80_\x01`\x08\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x80a\x1A\xDBWP\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81_\x01_\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x10\x15[\x15a\x1B\x12W`@Q\x7F\xF9.\xE8\xA9\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x81\x81_\x01_a\x01\0\n\x81T\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP`\x01\x81_\x01`\x08a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP_\x81_\x01`\x08a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP\x7F\xC7\xF5\x05\xB2\xF3q\xAE!u\xEEI\x13\xF4I\x9E\x1F&3\xA7\xB5\x93c!\xEE\xD1\xCD\xAE\xB6\x11Q\x81\xD2\x82`@Qa\x1B\xA1\x91\x90al-V[`@Q\x80\x91\x03\x90\xA1PPV[_\x80a\x1B\xB7aI\xB4V[\x90Pa\x1B\xC4\x84\x84\x83aJ1V[\x91P3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7FR\"\xD9k\x83g'\xA1\xD6\xFE\x1E\xE9\xAE\xF2\x7F\x9B\xB5\x07\xBDAyM\xEF\xA3v\xFFld\x8A\xAF\x8F\xF1\x85\x85\x84\x86`@Qa\x1C\x12\x94\x93\x92\x91\x90al\x8FV[`@Q\x80\x91\x03\x90\xA2P\x92\x91PPV[a\x1C)aL\xE4V[a\x1C2\x82aM\xCAV[a\x1C<\x82\x82aN\xBDV[PPV[_a\x1CIaO\xDBV[\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC_\x1B\x90P\x90V[_\x80`\x06`S\x81\x11\x15a\x1C\x87Wa\x1C\x86aeJV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a\x1C\xA2Wa\x1C\xA1aeJV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a\x1C\xBDWa\x1C\xBCaeJV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a\x1C\xD8Wa\x1C\xD7aeJV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a\x1C\xF3Wa\x1C\xF2aeJV[[`\xFF\x16`\x01\x90\x1Ba\x1D\x04\x91\x90ae\xA4V[a\x1D\x0E\x91\x90ae\xA4V[a\x1D\x18\x91\x90ae\xA4V[a\x1D\"\x91\x90ae\xA4V[\x90P_a\x1D/\x86\x83aD`V[\x90Pa\x1D?`\x02\x87\x87\x87\x85aD\xC6V[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x81\x8FMi\x82\x86\x89\x89\x883`@Q\x87c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x1D\x98\x96\x95\x94\x93\x92\x91\x90af,V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x1D\xAFW_\x80\xFD[PZ\xF1\x15\x80\x15a\x1D\xC1W=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F!SF\xA4\xF9\xF9u\xE6\xD5HN)\x0B\xD4\xE5<\xA1DS\xA9\xD2\x82\xEB\xD3\xCC\xED\xB2\xA0\xF1qu=\x87\x87\x87\x87`@Qa\x1E\x11\x94\x93\x92\x91\x90af\x8BV[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_`\x01`\xF8\x1B\x82~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x14a\x1E\x82W`@Q\x7FO\"NS\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x80\x1B\x83\x03a\x1E\xBDW`@Q\x7F#\xD3Y\xA3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\x06`S\x81\x11\x15a\x1E\xD2Wa\x1E\xD1aeJV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a\x1E\xEDWa\x1E\xECaeJV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a\x1F\x08Wa\x1F\x07aeJV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a\x1F#Wa\x1F\"aeJV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a\x1F>Wa\x1F=aeJV[[`\xFF\x16`\x01\x90\x1Ba\x1FO\x91\x90ae\xA4V[a\x1FY\x91\x90ae\xA4V[a\x1Fc\x91\x90ae\xA4V[a\x1Fm\x91\x90ae\xA4V[\x90P_a\x1Fz\x86\x83aD`V[\x90Pa\x1F\x8A`\x03\x87\x87\x87\x85aD\xC6V[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x9B?x\x1A\x82\x86\x89\x89\x883`@Q\x87c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x1F\xE3\x96\x95\x94\x93\x92\x91\x90af,V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x1F\xFAW_\x80\xFD[PZ\xF1\x15\x80\x15a \x0CW=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F;\xAB.\xE0\xE2\xF9\x0FF\x90\xC6\xA8{\xF6<\xF1\xA6\xB6&\x08n\x95\xF21\x86\x0B\x15)f\xE8\xDA\xBB\xF7\x87\x87\x87\x87`@Qa \\\x94\x93\x92\x91\x90af\x8BV[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_\x80`\x08`S\x81\x11\x15a \x83Wa \x82aeJV[[`\xFF\x16`\x01\x90\x1B`\x06`S\x81\x11\x15a \x9EWa \x9DaeJV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a \xB9Wa \xB8aeJV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a \xD4Wa \xD3aeJV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a \xEFWa \xEEaeJV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a!\nWa!\taeJV[[`\xFF\x16`\x01\x90\x1B_`S\x81\x11\x15a!$Wa!#aeJV[[`\xFF\x16`\x01\x90\x1Ba!5\x91\x90ae\xA4V[a!?\x91\x90ae\xA4V[a!I\x91\x90ae\xA4V[a!S\x91\x90ae\xA4V[a!]\x91\x90ae\xA4V[a!g\x91\x90ae\xA4V[\x90P_a!t\x86\x83aD`V[\x90Pa!\x84`\x06\x87\x87\x87\x85aD\xC6V[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xC0\xC5\xDF|\x82\x86\x89\x89\x883`@Q\x87c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a!\xDD\x96\x95\x94\x93\x92\x91\x90af,V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a!\xF4W_\x80\xFD[PZ\xF1\x15\x80\x15a\"\x06W=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7FV\xDF'\x9B\xBF\xB0=\x9E\xD0\x97\xBB\xE2\xF2\x8DR\x0C\xA0\xC1\x16\x12\x062y&\xE9\x86d\xD7\r,$\xC4\x87\x87\x87\x87`@Qa\"V\x94\x93\x92\x91\x90af\x8BV[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_\x80`\x08`S\x81\x11\x15a\"}Wa\"|aeJV[[`\xFF\x16`\x01\x90\x1B`\x06`S\x81\x11\x15a\"\x98Wa\"\x97aeJV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a\"\xB3Wa\"\xB2aeJV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a\"\xCEWa\"\xCDaeJV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a\"\xE9Wa\"\xE8aeJV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a#\x04Wa#\x03aeJV[[`\xFF\x16`\x01\x90\x1Ba#\x15\x91\x90ae\xA4V[a#\x1F\x91\x90ae\xA4V[a#)\x91\x90ae\xA4V[a#3\x91\x90ae\xA4V[a#=\x91\x90ae\xA4V[\x90P_a#J\x86\x83aD`V[\x90Pa#Z`\n\x87\x87\x87\x85aD\xC6V[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c_v\xEB0\x82\x86\x89\x89\x883`@Q\x87c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a#\xB3\x96\x95\x94\x93\x92\x91\x90af,V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a#\xCAW_\x80\xFD[PZ\xF1\x15\x80\x15a#\xDCW=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xEB\x0EO\x8D\xC7@X\x19M\x06\x02B_\xE6\x02\xF9U\xC2\" \x0F\x7F\x10\xC6\xFEg\x99/{$\xC7\xE9\x87\x87\x87\x87`@Qa$,\x94\x93\x92\x91\x90af\x8BV[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_\x80`\x06`S\x81\x11\x15a$SWa$RaeJV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a$nWa$maeJV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a$\x89Wa$\x88aeJV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a$\xA4Wa$\xA3aeJV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a$\xBFWa$\xBEaeJV[[`\xFF\x16`\x01\x90\x1Ba$\xD0\x91\x90ae\xA4V[a$\xDA\x91\x90ae\xA4V[a$\xE4\x91\x90ae\xA4V[a$\xEE\x91\x90ae\xA4V[\x90P_a$\xFB\x86\x83aD`V[\x90Pa%\x0B`\x11\x87\x87\x87_aD\xC6V[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c;\xB7\xD5\xA3\x82\x86\x89\x89\x883`@Q\x87c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a%d\x96\x95\x94\x93\x92\x91\x90af,V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a%{W_\x80\xFD[PZ\xF1\x15\x80\x15a%\x8DW=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\rH;\x10\r\x8Cs\xB2\x08\x98N\xC6\x97\xCA\xA3\t\x15!\xEEU%\xCEi\xED\xCF\x97\xD7\xE3\x95\xD3\xD0Y\x87\x87\x87\x87`@Qa%\xDD\x94\x93\x92\x91\x90af\x8BV[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_\x80`\x06`S\x81\x11\x15a&\x04Wa&\x03aeJV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a&\x1FWa&\x1EaeJV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a&:Wa&9aeJV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a&UWa&TaeJV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a&pWa&oaeJV[[`\xFF\x16`\x01\x90\x1Ba&\x81\x91\x90ae\xA4V[a&\x8B\x91\x90ae\xA4V[a&\x95\x91\x90ae\xA4V[a&\x9F\x91\x90ae\xA4V[\x90P_a&\xAC\x86\x83aD`V[\x90Pa&\xBC`\x10\x87\x87\x87_aD\xC6V[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c8\xBD\x17\xE5\x82\x86\x89\x89\x883`@Q\x87c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a'\x15\x96\x95\x94\x93\x92\x91\x90af,V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a',W_\x80\xFD[PZ\xF1\x15\x80\x15a'>W=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xDE\xF2\xE7\x04\xA0w(J\x07\xF3\xD0\xB46\xDB\x88\xF5\xD9\x81\xB6\x9FX\xAB|\x1A\xE6#%'\x18\xA6\xDE\x01\x87\x87\x87\x87`@Qa'\x8E\x94\x93\x92\x91\x90af\x8BV[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_\x80`\x08`S\x81\x11\x15a'\xB5Wa'\xB4aeJV[[`\xFF\x16`\x01\x90\x1B`\x07`S\x81\x11\x15a'\xD0Wa'\xCFaeJV[[`\xFF\x16`\x01\x90\x1B`\x06`S\x81\x11\x15a'\xEBWa'\xEAaeJV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a(\x06Wa(\x05aeJV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a(!Wa( aeJV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a(<Wa(;aeJV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a(WWa(VaeJV[[`\xFF\x16`\x01\x90\x1B_`S\x81\x11\x15a(qWa(paeJV[[`\xFF\x16`\x01\x90\x1Ba(\x82\x91\x90ae\xA4V[a(\x8C\x91\x90ae\xA4V[a(\x96\x91\x90ae\xA4V[a(\xA0\x91\x90ae\xA4V[a(\xAA\x91\x90ae\xA4V[a(\xB4\x91\x90ae\xA4V[a(\xBE\x91\x90ae\xA4V[\x90P_a(\xCB\x85\x83aD`V[\x90Pa(\xDA`\x19\x87\x87\x87aPbV[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c.<9\x06\x82\x88\x88\x88\x883`@Q\x87c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a)3\x96\x95\x94\x93\x92\x91\x90al\xD2V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a)JW_\x80\xFD[PZ\xF1\x15\x80\x15a)\\W=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F`\xBE\x9Da\xAA\xD8I\xFA\xCC(\xC3\x8B\x04\x8C\xB5\xC4\xBE4 \xB8\xFA\"3\xE0\x8C\xFA\x06\xBE\x1Bm\x1C>\x87\x87\x87\x87`@Qa)\xAC\x94\x93\x92\x91\x90am1V[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_\x90V[_\x80`\x06`S\x81\x11\x15a)\xD7Wa)\xD6aeJV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a)\xF2Wa)\xF1aeJV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a*\rWa*\x0CaeJV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a*(Wa*'aeJV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a*CWa*BaeJV[[`\xFF\x16`\x01\x90\x1Ba*T\x91\x90ae\xA4V[a*^\x91\x90ae\xA4V[a*h\x91\x90ae\xA4V[a*r\x91\x90ae\xA4V[\x90P_a*\x7F\x86\x83aD`V[\x90Pa*\x8F`\x0F\x87\x87\x87_aD\xC6V[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16cE\x8F\xB2w\x82\x86\x89\x89\x883`@Q\x87c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a*\xE8\x96\x95\x94\x93\x92\x91\x90af,V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a*\xFFW_\x80\xFD[PZ\xF1\x15\x80\x15a+\x11W=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xC9\xFF\x8F\r\x18\xA3\xF7f\xCE]\xE3\xDE!`v\x05\x01@\xE4\xFC&R\xF5\xE0\xE7E\xF6\xFC\x83l\xDA\x8B\x87\x87\x87\x87`@Qa+a\x94\x93\x92\x91\x90af\x8BV[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_\x80`\x08`S\x81\x11\x15a+\x88Wa+\x87aeJV[[`\xFF\x16`\x01\x90\x1B`\x06`S\x81\x11\x15a+\xA3Wa+\xA2aeJV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a+\xBEWa+\xBDaeJV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a+\xD9Wa+\xD8aeJV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a+\xF4Wa+\xF3aeJV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a,\x0FWa,\x0EaeJV[[`\xFF\x16`\x01\x90\x1B_`S\x81\x11\x15a,)Wa,(aeJV[[`\xFF\x16`\x01\x90\x1Ba,:\x91\x90ae\xA4V[a,D\x91\x90ae\xA4V[a,N\x91\x90ae\xA4V[a,X\x91\x90ae\xA4V[a,b\x91\x90ae\xA4V[a,l\x91\x90ae\xA4V[\x90P_a,y\x86\x83aD`V[\x90Pa,\x89`\x07\x87\x87\x87\x85aD\xC6V[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x9F\x92Y\xBB\x82\x86\x89\x89\x883`@Q\x87c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a,\xE2\x96\x95\x94\x93\x92\x91\x90af,V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a,\xF9W_\x80\xFD[PZ\xF1\x15\x80\x15a-\x0BW=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7FM2(K\xD3\x19>\xCA\xA4N\x1C\xEC\xA3/A\xC5\xD6\xC3(\x03\xA9.\x07\x96}\xD3\xEEB)r\x15\x82\x87\x87\x87\x87`@Qa-[\x94\x93\x92\x91\x90af\x8BV[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_\x80`\x08`S\x81\x11\x15a-\x82Wa-\x81aeJV[[`\xFF\x16`\x01\x90\x1B`\x06`S\x81\x11\x15a-\x9DWa-\x9CaeJV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a-\xB8Wa-\xB7aeJV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a-\xD3Wa-\xD2aeJV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a-\xEEWa-\xEDaeJV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a.\tWa.\x08aeJV[[`\xFF\x16`\x01\x90\x1Ba.\x1A\x91\x90ae\xA4V[a.$\x91\x90ae\xA4V[a..\x91\x90ae\xA4V[a.8\x91\x90ae\xA4V[a.B\x91\x90ae\xA4V[\x90P_a.O\x86\x83aD`V[\x90Pa._`\t\x87\x87\x87\x85aD\xC6V[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x07\xCC\xDFa\x82\x86\x89\x89\x883`@Q\x87c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a.\xB8\x96\x95\x94\x93\x92\x91\x90af,V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a.\xCFW_\x80\xFD[PZ\xF1\x15\x80\x15a.\xE1W=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F2B \xBF\xC9\xCB\x15\x8BI)\x91\xC0<0\x9C\xD8nSE\xCA\xC4Z\xAC\xAE \x92\xDD\xAB\xE3\x1F\xA3\xD8\x87\x87\x87\x87`@Qa/1\x94\x93\x92\x91\x90af\x8BV[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_\x80`\x08`S\x81\x11\x15a/XWa/WaeJV[[`\xFF\x16`\x01\x90\x1B`\x07`S\x81\x11\x15a/sWa/raeJV[[`\xFF\x16`\x01\x90\x1B`\x06`S\x81\x11\x15a/\x8EWa/\x8DaeJV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a/\xA9Wa/\xA8aeJV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a/\xC4Wa/\xC3aeJV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a/\xDFWa/\xDEaeJV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a/\xFAWa/\xF9aeJV[[`\xFF\x16`\x01\x90\x1B_`S\x81\x11\x15a0\x14Wa0\x13aeJV[[`\xFF\x16`\x01\x90\x1Ba0%\x91\x90ae\xA4V[a0/\x91\x90ae\xA4V[a09\x91\x90ae\xA4V[a0C\x91\x90ae\xA4V[a0M\x91\x90ae\xA4V[a0W\x91\x90ae\xA4V[a0a\x91\x90ae\xA4V[\x90P_\x81\x84`S\x81\x11\x15a0xWa0waeJV[[`\xFF\x16`\x01\x90\x1B\x16\x03a0\xB7W`@Q\x7F\xC6\xDEFj\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x18\x84\x84sP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]F`@Q` \x01a0\xE5\x95\x94\x93\x92\x91\x90amtV[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x91Pa1\x07\x82\x84aH\xF0V[\x91Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xB7\x8B\xEFY\x84\x843`@Q\x84c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a1Z\x93\x92\x91\x90am\xD2V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a1qW_\x80\xFD[PZ\xF1\x15\x80\x15a1\x83W=_\x80>=_\xFD[PPPPsP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c>9\\\xEC\x833`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a1\xD6\x92\x91\x90ag\xD7V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a1\xEDW_\x80\xFD[PZ\xF1\x15\x80\x15a1\xFFW=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\x06<\xCD\x1B\xBAE\x15\x1D\x91\xF6\xA4\x18\x06PG\xA3\xD0H\xD0X\xA9\"SWG\xBB+WZ\x01\xD26\x85\x85\x85`@Qa2M\x93\x92\x91\x90an\x07V[`@Q\x80\x91\x03\x90\xA2P\x92\x91PPV[_s6w!B\xB7Hq\xF2U\xCB\xD7\xA3\xE8\x9B@\x1D>E\x82_\x90P\x90V[`@Q\x80`@\x01`@R\x80`\x05\x81R` \x01\x7F5.0.0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81RP\x81V[`\x03_a2\xBBaI\x8DV[\x90P\x80_\x01`\x08\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x80a3\x03WP\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81_\x01_\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x10\x15[\x15a3:W`@Q\x7F\xF9.\xE8\xA9\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x81\x81_\x01_a\x01\0\n\x81T\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP`\x01\x81_\x01`\x08a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP_\x81_\x01`\x08a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP\x7F\xC7\xF5\x05\xB2\xF3q\xAE!u\xEEI\x13\xF4I\x9E\x1F&3\xA7\xB5\x93c!\xEE\xD1\xCD\xAE\xB6\x11Q\x81\xD2\x82`@Qa3\xC9\x91\x90al-V[`@Q\x80\x91\x03\x90\xA1PPV[_\x80`\x08`S\x81\x11\x15a3\xEBWa3\xEAaeJV[[`\xFF\x16`\x01\x90\x1B`\x06`S\x81\x11\x15a4\x06Wa4\x05aeJV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a4!Wa4 aeJV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a4<Wa4;aeJV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a4WWa4VaeJV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a4rWa4qaeJV[[`\xFF\x16`\x01\x90\x1Ba4\x83\x91\x90ae\xA4V[a4\x8D\x91\x90ae\xA4V[a4\x97\x91\x90ae\xA4V[a4\xA1\x91\x90ae\xA4V[a4\xAB\x91\x90ae\xA4V[\x90P_a4\xB8\x86\x83aD`V[\x90Pa4\xC8`\x0B\x87\x87\x87\x85aD\xC6V[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x86)\xF5E\x82\x86\x89\x89\x883`@Q\x87c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a5!\x96\x95\x94\x93\x92\x91\x90af,V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a58W_\x80\xFD[PZ\xF1\x15\x80\x15a5JW=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xC1HgY\x05\xD0z\xD5Io\x8E\xF4\xD8\x19\\\x90u\x03\xF3\xEC\x12\xFD\x10\xED_!$\n\xBCi64\x87\x87\x87\x87`@Qa5\x9A\x94\x93\x92\x91\x90af\x8BV[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_\x80`\x08`S\x81\x11\x15a5\xC1Wa5\xC0aeJV[[`\xFF\x16`\x01\x90\x1B`\x06`S\x81\x11\x15a5\xDCWa5\xDBaeJV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a5\xF7Wa5\xF6aeJV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a6\x12Wa6\x11aeJV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a6-Wa6,aeJV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a6HWa6GaeJV[[`\xFF\x16`\x01\x90\x1Ba6Y\x91\x90ae\xA4V[a6c\x91\x90ae\xA4V[a6m\x91\x90ae\xA4V[a6w\x91\x90ae\xA4V[a6\x81\x91\x90ae\xA4V[\x90P_a6\x8E\x86\x83aD`V[\x90Pa6\x9E`\x08\x87\x87\x87\x85aD\xC6V[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xF7\xD1\x98\xF8\x82\x86\x89\x89\x883`@Q\x87c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a6\xF7\x96\x95\x94\x93\x92\x91\x90af,V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a7\x0EW_\x80\xFD[PZ\xF1\x15\x80\x15a7 W=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xE8B\x82\xAA\xEB\xCC\xA6\x98D>9\xA2\xA9H\xA3E\xD0\xD2\xEB\xC6T\xAF\\\xB6W\xA2\xD7\xE8\x05;\xF6\xCB\x87\x87\x87\x87`@Qa7p\x94\x93\x92\x91\x90af\x8BV[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_`\x01`\xF8\x1B\x82~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x14a7\xE1W`@Q\x7FO\"NS\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x80\x1B\x83\x03a8\x1CW`@Q\x7F#\xD3Y\xA3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\x06`S\x81\x11\x15a81Wa80aeJV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a8LWa8KaeJV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a8gWa8faeJV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a8\x82Wa8\x81aeJV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a8\x9DWa8\x9CaeJV[[`\xFF\x16`\x01\x90\x1Ba8\xAE\x91\x90ae\xA4V[a8\xB8\x91\x90ae\xA4V[a8\xC2\x91\x90ae\xA4V[a8\xCC\x91\x90ae\xA4V[\x90P_a8\xD9\x86\x83aD`V[\x90Pa8\xE9`\x04\x87\x87\x87\x85aD\xC6V[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c3\x11\xB1\xBC\x82\x86\x89\x89\x883`@Q\x87c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a9B\x96\x95\x94\x93\x92\x91\x90af,V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a9YW_\x80\xFD[PZ\xF1\x15\x80\x15a9kW=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\x0Ei\x1C\xD0\xBF\x8CN\x93\x08\xE4\xCE\xD1\xBB\x9C\x96A\x17\xDC\\[\xB9\xB9\xAB[\xDF\xEB\xF2\xC9\xB1:\x89|\x87\x87\x87\x87`@Qa9\xBB\x94\x93\x92\x91\x90af\x8BV[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_\x80`\x08`S\x81\x11\x15a9\xE2Wa9\xE1aeJV[[`\xFF\x16`\x01\x90\x1B`\x06`S\x81\x11\x15a9\xFDWa9\xFCaeJV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a:\x18Wa:\x17aeJV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a:3Wa:2aeJV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a:NWa:MaeJV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a:iWa:haeJV[[`\xFF\x16`\x01\x90\x1Ba:z\x91\x90ae\xA4V[a:\x84\x91\x90ae\xA4V[a:\x8E\x91\x90ae\xA4V[a:\x98\x91\x90ae\xA4V[a:\xA2\x91\x90ae\xA4V[\x90P_a:\xAF\x84\x83aD`V[\x90Pa:\xBC`\x14\x85aT\x8EV[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16cI|\"\xC5\x82\x86\x863`@Q\x85c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a;\x11\x94\x93\x92\x91\x90ak\x93V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a;(W_\x80\xFD[PZ\xF1\x15\x80\x15a;:W=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\x8CfM<<\xA5\x83\xFCX\x03\xB8\xA9\x1CIdK\xBD\x95P\xBF\xA8yg\xC7:\xD1\xDE\x83\x02wh\xC0\x85\x85`@Qa;\x86\x92\x91\x90an<V[`@Q\x80\x91\x03\x90\xA2PP\x91\x90PV[_\x80a;\x9FaI\xB4V[\x90Pa;\xAB\x83\x82aV>V[\x91P3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\x0C\x8A\xCA`\x17\x003&\x05\x1E\x19\x91>\xF0&1\xF2K\x80\x11%\xE1\xFA\x8A\x1D\x81.\x86\x83\x19\xFD\xA6\x84\x83\x85`@Qa;\xF7\x93\x92\x91\x90ancV[`@Q\x80\x91\x03\x90\xA2P\x91\x90PV[_\x80`\x08`S\x81\x11\x15a<\x1BWa<\x1AaeJV[[`\xFF\x16`\x01\x90\x1B`\x07`S\x81\x11\x15a<6Wa<5aeJV[[`\xFF\x16`\x01\x90\x1B`\x06`S\x81\x11\x15a<QWa<PaeJV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a<lWa<kaeJV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a<\x87Wa<\x86aeJV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a<\xA2Wa<\xA1aeJV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a<\xBDWa<\xBCaeJV[[`\xFF\x16`\x01\x90\x1B_`S\x81\x11\x15a<\xD7Wa<\xD6aeJV[[`\xFF\x16`\x01\x90\x1Ba<\xE8\x91\x90ae\xA4V[a<\xF2\x91\x90ae\xA4V[a<\xFC\x91\x90ae\xA4V[a=\x06\x91\x90ae\xA4V[a=\x10\x91\x90ae\xA4V[a=\x1A\x91\x90ae\xA4V[a=$\x91\x90ae\xA4V[\x90P_a=1\x86\x83aD`V[\x90Pa=A`\r\x87\x87\x87_aD\xC6V[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16ck\xAD\x18\xB6\x82\x86\x89\x89\x883`@Q\x87c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a=\x9A\x96\x95\x94\x93\x92\x91\x90af,V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a=\xB1W_\x80\xFD[PZ\xF1\x15\x80\x15a=\xC3W=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7Fi`\xC1\xE8\x8Fa\xC3R\xDB\xA3M\x1B\xBFgS\xE3\x02yRd\xD5\xD8\xAE\x82\xF7\x98<p\x04e\x1E]\x87\x87\x87\x87`@Qa>\x13\x94\x93\x92\x91\x90af\x8BV[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_\x80`\x08`S\x81\x11\x15a>:Wa>9aeJV[[`\xFF\x16`\x01\x90\x1B`\x06`S\x81\x11\x15a>UWa>TaeJV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a>pWa>oaeJV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a>\x8BWa>\x8AaeJV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a>\xA6Wa>\xA5aeJV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a>\xC1Wa>\xC0aeJV[[`\xFF\x16`\x01\x90\x1B_`S\x81\x11\x15a>\xDBWa>\xDAaeJV[[`\xFF\x16`\x01\x90\x1Ba>\xEC\x91\x90ae\xA4V[a>\xF6\x91\x90ae\xA4V[a?\0\x91\x90ae\xA4V[a?\n\x91\x90ae\xA4V[a?\x14\x91\x90ae\xA4V[a?\x1E\x91\x90ae\xA4V[\x90P_a?+\x86\x83aD`V[\x90Pa?;`\x05\x87\x87\x87\x85aD\xC6V[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xC8\xDECR\x82\x86\x89\x89\x883`@Q\x87c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a?\x94\x96\x95\x94\x93\x92\x91\x90af,V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a?\xABW_\x80\xFD[PZ\xF1\x15\x80\x15a?\xBDW=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xE4$\x86\xB0\xCC\xDB\xEF\x81\xA2\x07\\H\xC8\xE5\x15\xC0y\xAE\xA7<\x8B\x82B\x99\x97\xC7*/\xE1\xBFO\xEF\x87\x87\x87\x87`@Qa@\r\x94\x93\x92\x91\x90af\x8BV[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_s#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9\x90P\x90V[_\x80`\x08`S\x81\x11\x15a@OWa@NaeJV[[`\xFF\x16`\x01\x90\x1B`\x06`S\x81\x11\x15a@jWa@iaeJV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a@\x85Wa@\x84aeJV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a@\xA0Wa@\x9FaeJV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a@\xBBWa@\xBAaeJV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a@\xD6Wa@\xD5aeJV[[`\xFF\x16`\x01\x90\x1B_`S\x81\x11\x15a@\xF0Wa@\xEFaeJV[[`\xFF\x16`\x01\x90\x1BaA\x01\x91\x90ae\xA4V[aA\x0B\x91\x90ae\xA4V[aA\x15\x91\x90ae\xA4V[aA\x1F\x91\x90ae\xA4V[aA)\x91\x90ae\xA4V[aA3\x91\x90ae\xA4V[\x90P_aA@\x84\x83aD`V[\x90PaAM`\x15\x85aT\x8EV[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c-\xCB\xC5\xD1\x82\x86\x863`@Q\x85c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01aA\xA2\x94\x93\x92\x91\x90ak\x93V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15aA\xB9W_\x80\xFD[PZ\xF1\x15\x80\x15aA\xCBW=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7FU\xAF\xF4\xCCz=\x16\x0C\x83\xF1\xF1[\x81\x80\x11\xED\xE8A\xA0\xB4Y\x7F\xB1M\xCD6\x03\xDF:\x11\xE5\xE0\x85\x85`@QaB\x17\x92\x91\x90an<V[`@Q\x80\x91\x03\x90\xA2PP\x91\x90PV[_sP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]\x90P\x90V[_\x80`\x08`S\x81\x11\x15aBWWaBVaeJV[[`\xFF\x16`\x01\x90\x1B`\x07`S\x81\x11\x15aBrWaBqaeJV[[`\xFF\x16`\x01\x90\x1B`\x06`S\x81\x11\x15aB\x8DWaB\x8CaeJV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15aB\xA8WaB\xA7aeJV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15aB\xC3WaB\xC2aeJV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15aB\xDEWaB\xDDaeJV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15aB\xF9WaB\xF8aeJV[[`\xFF\x16`\x01\x90\x1B_`S\x81\x11\x15aC\x13WaC\x12aeJV[[`\xFF\x16`\x01\x90\x1BaC$\x91\x90ae\xA4V[aC.\x91\x90ae\xA4V[aC8\x91\x90ae\xA4V[aCB\x91\x90ae\xA4V[aCL\x91\x90ae\xA4V[aCV\x91\x90ae\xA4V[aC`\x91\x90ae\xA4V[\x90P_aCm\x86\x83aD`V[\x90PaC}`\x0C\x87\x87\x87_aD\xC6V[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c`\xE1!\x89\x82\x86\x89\x89\x883`@Q\x87c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01aC\xD6\x96\x95\x94\x93\x92\x91\x90af,V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15aC\xEDW_\x80\xFD[PZ\xF1\x15\x80\x15aC\xFFW=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xB3\xD5\xC6d\xEC\x86WX\x18\xE8\xD7_\xF2\\_\x86rP\xDF\x89T\x08\x85I\xC4\x1C\x84\x8C\xD1\x0Ev\xCB\x87\x87\x87\x87`@QaDO\x94\x93\x92\x91\x90af\x8BV[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_aDj\x83aG\xEEV[\x90P_\x82\x82`S\x81\x11\x15aD\x81WaD\x80aeJV[[`\xFF\x16`\x01\x90\x1B\x16\x03aD\xC0W`@Q\x7F\xC6\xDEFj\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x92\x91PPV[_aD\xD0\x83aX\xC9V[sP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x82\x02{m\x863`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01aE\x1F\x92\x91\x90ag\xD7V[` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15aE:W=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90aE^\x91\x90ai\xB7V[aE\xA1W\x843`@Q\x7F\x9D\xE39,\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aE\x98\x92\x91\x90ag\xD7V[`@Q\x80\x91\x03\x90\xFD[_`\xF8\x1B\x83~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x03aG\x16WsP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x82\x02{m\x853`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01aF\x1C\x92\x91\x90ag\xD7V[` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15aF7W=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90aF[\x91\x90ai\xB7V[aF\x9EW\x833`@Q\x7F\x9D\xE39,\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aF\x95\x92\x91\x90ag\xD7V[`@Q\x80\x91\x03\x90\xFD[_aF\xA8\x85aG\xEEV[\x90P_aF\xB4\x87aG\xEEV[\x90P\x81`S\x81\x11\x15aF\xC9WaF\xC8aeJV[[\x81`S\x81\x11\x15aF\xDCWaF\xDBaeJV[[\x14aG\x13W`@Q\x7F\x1F1X\xC7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[PP[\x85\x85\x85\x85sP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]F`@Q` \x01aGE\x96\x95\x94\x93\x92\x91\x90an\xB8V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x90PaGg\x81\x83aH\xF0V[\x90PsP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c>9\\\xEC\x823`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01aG\xB8\x92\x91\x90ag\xD7V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15aG\xCFW_\x80\xFD[PZ\xF1\x15\x80\x15aG\xE1W=_\x80>=_\xFD[PPPP\x95\x94PPPPPV[_\x81`\x1E` \x81\x10aH\x03WaH\x02ao'V[[\x1A`\xF8\x1B`\xF8\x1C`\xFF\x16`S\x81\x11\x15aH\x1FWaH\x1EaeJV[[\x90P\x91\x90PV[``_`\x01aH4\x84aY\rV[\x01\x90P_\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15aHRWaHQa`\xDEV[[`@Q\x90\x80\x82R\x80`\x1F\x01`\x1F\x19\x16` \x01\x82\x01`@R\x80\x15aH\x84W\x81` \x01`\x01\x82\x02\x806\x837\x80\x82\x01\x91PP\x90P[P\x90P_\x82` \x01\x82\x01\x90P[`\x01\x15aH\xE5W\x80\x80`\x01\x90\x03\x91PP\x7F0123456789abcdef\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\n\x86\x06\x1A\x81S`\n\x85\x81aH\xDAWaH\xD9aoTV[[\x04\x94P_\x85\x03aH\x91W[\x81\x93PPPP\x91\x90PV[_\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0_\x1B\x83\x16\x90P`P`\xFF_\x1B\x90\x1B\x81\x17\x90P`\x10Fg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16_\x1B\x90\x1B\x81\x17\x90P`\x08\x82`S\x81\x11\x15aINWaIMaeJV[[`\xFF\x16_\x1B\x90\x1B\x81\x17\x90P_`\xFF\x16_\x1B\x81\x17\x90P\x92\x91PPV[_aIraI\x8DV[_\x01_\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P\x90V[_\x7F\xF0\xC5~\x16\x84\r\xF0@\xF1P\x88\xDC/\x81\xFE9\x1C9#\xBE\xC7>#\xA9f.\xFC\x9C\"\x9Cj\0\x90P\x90V[_\x80aI\xBEaZ^V[\x90P\x80_\x01TsP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]F`\x01CaI\xE7\x91\x90ao\x81V[@B`@Q` \x01aI\xFD\x95\x94\x93\x92\x91\x90ao\xB4V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x91P\x80_\x01_\x81T\x80\x92\x91\x90aJ(\x90ap\x12V[\x91\x90PUPP\x90V[_\x80`\x08`S\x81\x11\x15aJGWaJFaeJV[[`\xFF\x16`\x01\x90\x1B`\x06`S\x81\x11\x15aJbWaJaaeJV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15aJ}WaJ|aeJV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15aJ\x98WaJ\x97aeJV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15aJ\xB3WaJ\xB2aeJV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15aJ\xCEWaJ\xCDaeJV[[`\xFF\x16`\x01\x90\x1BaJ\xDF\x91\x90ae\xA4V[aJ\xE9\x91\x90ae\xA4V[aJ\xF3\x91\x90ae\xA4V[aJ\xFD\x91\x90ae\xA4V[aK\x07\x91\x90ae\xA4V[\x90P_\x81\x85`S\x81\x11\x15aK\x1EWaK\x1DaeJV[[`\xFF\x16`\x01\x90\x1B\x16\x03aK]W`@Q\x7F\xC6\xDEFj\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[aKf\x85aZ\x85V[aK\x9CW`@Q\x7F$\xE8\xE7B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[aK\xA6\x85\x85aZ\xA9V[`\x1B\x85\x85\x85`@Q` \x01aK\xBE\x94\x93\x92\x91\x90apyV[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x91PaK\xE0\x82\x85aH\xF0V[\x91Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16cl\xF0\xBD%\x85\x843`@Q\x84c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01aL3\x93\x92\x91\x90am\xD2V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15aLJW_\x80\xFD[PZ\xF1\x15\x80\x15aL\\W=_\x80>=_\xFD[PPPPsP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c>9\\\xEC\x833`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01aL\xAF\x92\x91\x90ag\xD7V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15aL\xC6W_\x80\xFD[PZ\xF1\x15\x80\x15aL\xD8W=_\x80>=_\xFD[PPPPP\x93\x92PPPV[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x160s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14\x80aM\x91WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16aMxa[\xF9V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14\x15[\x15aM\xC8W`@Q\x7F\xE0|\x8D\xBA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[V[sP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x8D\xA5\xCB[`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15aN'W=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90aNK\x91\x90ap\xDAV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14aN\xBAW3`@Q\x7F!\xBF\xDA\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aN\xB1\x91\x90ad\xDBV[`@Q\x80\x91\x03\x90\xFD[PV[\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16cR\xD1\x90-`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x92PPP\x80\x15aO%WP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90aO\"\x91\x90ag\xACV[`\x01[aOfW\x81`@Q\x7FL\x9C\x8C\xE3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aO]\x91\x90ad\xDBV[`@Q\x80\x91\x03\x90\xFD[\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC_\x1B\x81\x14aO\xCCW\x80`@Q\x7F\xAA\x1DI\xA4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aO\xC3\x91\x90a`SV[`@Q\x80\x91\x03\x90\xFD[aO\xD6\x83\x83a\\LV[PPPV[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x160s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14aP`W`@Q\x7F\xE0|\x8D\xBA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[V[_sP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x82\x02{m\x853`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01aP\xB2\x92\x91\x90ag\xD7V[` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15aP\xCDW=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90aP\xF1\x91\x90ai\xB7V[aQ4W\x833`@Q\x7F\x9D\xE39,\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aQ+\x92\x91\x90ag\xD7V[`@Q\x80\x91\x03\x90\xFD[sP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x82\x02{m\x843`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01aQ\x83\x92\x91\x90ag\xD7V[` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15aQ\x9EW=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90aQ\xC2\x91\x90ai\xB7V[aR\x05W\x823`@Q\x7F\x9D\xE39,\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aQ\xFC\x92\x91\x90ag\xD7V[`@Q\x80\x91\x03\x90\xFD[sP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x82\x02{m\x833`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01aRT\x92\x91\x90ag\xD7V[` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15aRoW=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90aR\x93\x91\x90ai\xB7V[aR\xD6W\x813`@Q\x7F\x9D\xE39,\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aR\xCD\x92\x91\x90ag\xD7V[`@Q\x80\x91\x03\x90\xFD[_aR\xE0\x85aG\xEEV[\x90P_aR\xEC\x85aG\xEEV[\x90P_aR\xF8\x85aG\xEEV[\x90P_`S\x81\x11\x15aS\rWaS\x0CaeJV[[\x83`S\x81\x11\x15aS WaS\x1FaeJV[[\x14aSWW`@Q\x7F\xC6\xDEFj\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x80`S\x81\x11\x15aSjWaSiaeJV[[\x82`S\x81\x11\x15aS}WaS|aeJV[[\x14aS\xB4W`@Q\x7F\x1F1X\xC7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x87\x87\x87\x87sP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]F`@Q` \x01aS\xE3\x96\x95\x94\x93\x92\x91\x90aq\x05V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x93PaT\x05\x84\x83aH\xF0V[\x93PsP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c>9\\\xEC\x853`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01aTV\x92\x91\x90ag\xD7V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15aTmW_\x80\xFD[PZ\xF1\x15\x80\x15aT\x7FW=_\x80>=_\xFD[PPPPPPP\x94\x93PPPPV[_sP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x82\x02{m\x833`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01aT\xDE\x92\x91\x90ag\xD7V[` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15aT\xF9W=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90aU\x1D\x91\x90ai\xB7V[aU`W\x813`@Q\x7F\x9D\xE39,\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aUW\x92\x91\x90ag\xD7V[`@Q\x80\x91\x03\x90\xFD[\x82\x82sP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]F`@Q` \x01aU\x8B\x94\x93\x92\x91\x90aqtV[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x90P_aU\xAD\x83aG\xEEV[\x90PaU\xB9\x82\x82aH\xF0V[\x91PsP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c>9\\\xEC\x833`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01aV\n\x92\x91\x90ag\xD7V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15aV!W_\x80\xFD[PZ\xF1\x15\x80\x15aV3W=_\x80>=_\xFD[PPPPP\x92\x91PPV[_\x80`\x08`S\x81\x11\x15aVTWaVSaeJV[[`\xFF\x16`\x01\x90\x1B`\x06`S\x81\x11\x15aVoWaVnaeJV[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15aV\x8AWaV\x89aeJV[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15aV\xA5WaV\xA4aeJV[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15aV\xC0WaV\xBFaeJV[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15aV\xDBWaV\xDAaeJV[[`\xFF\x16`\x01\x90\x1B_`S\x81\x11\x15aV\xF5WaV\xF4aeJV[[`\xFF\x16`\x01\x90\x1BaW\x06\x91\x90ae\xA4V[aW\x10\x91\x90ae\xA4V[aW\x1A\x91\x90ae\xA4V[aW$\x91\x90ae\xA4V[aW.\x91\x90ae\xA4V[aW8\x91\x90ae\xA4V[\x90P_\x81\x85`S\x81\x11\x15aWOWaWNaeJV[[`\xFF\x16`\x01\x90\x1B\x16\x03aW\x8EW`@Q\x7F\xC6\xDEFj\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x1A\x84\x84`@Q` \x01aW\xA4\x93\x92\x91\x90aq\xC1V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x91PaW\xC6\x82\x85aH\xF0V[\x91Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xD5\xB8\xB8\xF3\x85\x843`@Q\x84c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01aX\x19\x93\x92\x91\x90am\xD2V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15aX0W_\x80\xFD[PZ\xF1\x15\x80\x15aXBW=_\x80>=_\xFD[PPPPsP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c>9\\\xEC\x833`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01aX\x95\x92\x91\x90ag\xD7V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15aX\xACW_\x80\xFD[PZ\xF1\x15\x80\x15aX\xBEW=_\x80>=_\xFD[PPPPP\x92\x91PPV[`\x01\x81`\xF8\x1C`\xFF\x16\x11\x15aY\nW`@Q\x7F\xDF{\xF3%\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[PV[_\x80_\x90Pz\x18O\x03\xE9?\xF9\xF4\xDA\xA7\x97\xEDn8\xEDd\xBFj\x1F\x01\0\0\0\0\0\0\0\0\x83\x10aYiWz\x18O\x03\xE9?\xF9\xF4\xDA\xA7\x97\xEDn8\xEDd\xBFj\x1F\x01\0\0\0\0\0\0\0\0\x83\x81aY_WaY^aoTV[[\x04\x92P`@\x81\x01\x90P[m\x04\xEE-mA[\x85\xAC\xEF\x81\0\0\0\0\x83\x10aY\xA6Wm\x04\xEE-mA[\x85\xAC\xEF\x81\0\0\0\0\x83\x81aY\x9CWaY\x9BaoTV[[\x04\x92P` \x81\x01\x90P[f#\x86\xF2o\xC1\0\0\x83\x10aY\xD5Wf#\x86\xF2o\xC1\0\0\x83\x81aY\xCBWaY\xCAaoTV[[\x04\x92P`\x10\x81\x01\x90P[c\x05\xF5\xE1\0\x83\x10aY\xFEWc\x05\xF5\xE1\0\x83\x81aY\xF4WaY\xF3aoTV[[\x04\x92P`\x08\x81\x01\x90P[a'\x10\x83\x10aZ#Wa'\x10\x83\x81aZ\x19WaZ\x18aoTV[[\x04\x92P`\x04\x81\x01\x90P[`d\x83\x10aZFW`d\x83\x81aZ<WaZ;aoTV[[\x04\x92P`\x02\x81\x01\x90P[`\n\x83\x10aZUW`\x01\x81\x01\x90P[\x80\x91PP\x91\x90PV[_\x7FF\x13\xE1w\x1Fku]$>So\xB5\xA2<[\x15\xE2\x82eu\xFE\xE9!\xE8\xFEz\"\xA7`\xC8\0\x90P\x90V[_\x80\x82\x11\x80\x15aZ\xA2WP_`\x01\x83aZ\x9E\x91\x90ao\x81V[\x83\x16\x14[\x90P\x91\x90PV[`\x02`S\x81\x11\x15aZ\xBDWaZ\xBCaeJV[[\x81`S\x81\x11\x15aZ\xD0WaZ\xCFaeJV[[\x03aZ\xE6WaZ\xE1\x82a\x01\0a\\\xBEV[a[\xF5V[`\x03`S\x81\x11\x15aZ\xFAWaZ\xF9aeJV[[\x81`S\x81\x11\x15a[\rWa[\x0CaeJV[[\x03a[$Wa[\x1F\x82b\x01\0\0a\\\xBEV[a[\xF5V[`\x04`S\x81\x11\x15a[8Wa[7aeJV[[\x81`S\x81\x11\x15a[KWa[JaeJV[[\x03a[dWa[_\x82d\x01\0\0\0\0a\\\xBEV[a[\xF5V[`\x05`S\x81\x11\x15a[xWa[waeJV[[\x81`S\x81\x11\x15a[\x8BWa[\x8AaeJV[[\x03a[\xA8Wa[\xA3\x82h\x01\0\0\0\0\0\0\0\0a\\\xBEV[a[\xF5V[`\x06`S\x81\x11\x15a[\xBCWa[\xBBaeJV[[\x81`S\x81\x11\x15a[\xCFWa[\xCEaeJV[[\x03a[\xF4Wa[\xEF\x82p\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\\\xBEV[a[\xF5V[[PPV[_a\\%\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC_\x1Ba\\\xFCV[_\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P\x90V[a\\U\x82a]\x05V[\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xBC|\xD7Z \xEE'\xFD\x9A\xDE\xBA\xB3 A\xF7U!M\xBCk\xFF\xA9\x0C\xC0\"[9\xDA.\\-;`@Q`@Q\x80\x91\x03\x90\xA2_\x81Q\x11\x15a\\\xB1Wa\\\xAB\x82\x82a]\xCEV[Pa\\\xBAV[a\\\xB9a^NV[[PPV[\x80\x82\x11\x15a\\\xF8W`@Q\x7F\xC7\xDA\xDFE\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[PPV[_\x81\x90P\x91\x90PV[_\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16;\x03a]`W\x80`@Q\x7FL\x9C\x8C\xE3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a]W\x91\x90ad\xDBV[`@Q\x80\x91\x03\x90\xFD[\x80a]\x8C\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC_\x1Ba\\\xFCV[_\x01_a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UPPV[``_\x80\x84s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x84`@Qa]\xF7\x91\x90ar7V[_`@Q\x80\x83\x03\x81\x85Z\xF4\x91PP=\x80_\x81\x14a^/W`@Q\x91P`\x1F\x19`?=\x01\x16\x82\x01`@R=\x82R=_` \x84\x01>a^4V[``\x91P[P\x91P\x91Pa^D\x85\x83\x83a^\x8AV[\x92PPP\x92\x91PPV[_4\x11\x15a^\x88W`@Q\x7F\xB3\x98\x97\x9F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[V[``\x82a^\x9FWa^\x9A\x82a_\x17V[a_\x0FV[_\x82Q\x14\x80\x15a^\xC5WP_\x84s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16;\x14[\x15a_\x07W\x83`@Q\x7F\x99\x96\xB3\x15\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a^\xFE\x91\x90ad\xDBV[`@Q\x80\x91\x03\x90\xFD[\x81\x90Pa_\x10V[[\x93\x92PPPV[_\x81Q\x11\x15a_)W\x80Q\x80\x82` \x01\xFD[`@Q\x7F\xD6\xBD\xA2u\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`@Q\x90P\x90V[_\x80\xFD[_\x80\xFD[_\x81\x90P\x91\x90PV[a_~\x81a_lV[\x81\x14a_\x88W_\x80\xFD[PV[_\x815\x90Pa_\x99\x81a_uV[\x92\x91PPV[_\x7F\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\x16\x90P\x91\x90PV[a_\xD3\x81a_\x9FV[\x81\x14a_\xDDW_\x80\xFD[PV[_\x815\x90Pa_\xEE\x81a_\xCAV[\x92\x91PPV[_\x80_``\x84\x86\x03\x12\x15a`\x0BWa`\na_dV[[_a`\x18\x86\x82\x87\x01a_\x8BV[\x93PP` a`)\x86\x82\x87\x01a_\x8BV[\x92PP`@a`:\x86\x82\x87\x01a_\xE0V[\x91PP\x92P\x92P\x92V[a`M\x81a_lV[\x82RPPV[_` \x82\x01\x90Pa`f_\x83\x01\x84a`DV[\x92\x91PPV[_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[_a`\x95\x82a`lV[\x90P\x91\x90PV[a`\xA5\x81a`\x8BV[\x81\x14a`\xAFW_\x80\xFD[PV[_\x815\x90Pa`\xC0\x81a`\x9CV[\x92\x91PPV[_\x80\xFD[_\x80\xFD[_`\x1F\x19`\x1F\x83\x01\x16\x90P\x91\x90PV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`A`\x04R`$_\xFD[aa\x14\x82a`\xCEV[\x81\x01\x81\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17\x15aa3Waa2a`\xDEV[[\x80`@RPPPV[_aaEa_[V[\x90PaaQ\x82\x82aa\x0BV[\x91\x90PV[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15aapWaaoa`\xDEV[[aay\x82a`\xCEV[\x90P` \x81\x01\x90P\x91\x90PV[\x82\x81\x837_\x83\x83\x01RPPPV[_aa\xA6aa\xA1\x84aaVV[aa<V[\x90P\x82\x81R` \x81\x01\x84\x84\x84\x01\x11\x15aa\xC2Waa\xC1a`\xCAV[[aa\xCD\x84\x82\x85aa\x86V[P\x93\x92PPPV[_\x82`\x1F\x83\x01\x12aa\xE9Waa\xE8a`\xC6V[[\x815aa\xF9\x84\x82` \x86\x01aa\x94V[\x91PP\x92\x91PPV[`T\x81\x10ab\x0EW_\x80\xFD[PV[_\x815\x90Pab\x1F\x81ab\x02V[\x92\x91PPV[_\x80_\x80`\x80\x85\x87\x03\x12\x15ab=Wab<a_dV[[_abJ\x87\x82\x88\x01a_\x8BV[\x94PP` ab[\x87\x82\x88\x01a`\xB2V[\x93PP`@\x85\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15ab|Wab{a_hV[[ab\x88\x87\x82\x88\x01aa\xD5V[\x92PP``ab\x99\x87\x82\x88\x01ab\x11V[\x91PP\x92\x95\x91\x94P\x92PV[_\x81Q\x90P\x91\x90PV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[_[\x83\x81\x10\x15ab\xDCW\x80\x82\x01Q\x81\x84\x01R` \x81\x01\x90Pab\xC1V[_\x84\x84\x01RPPPPV[_ab\xF1\x82ab\xA5V[ab\xFB\x81\x85ab\xAFV[\x93Pac\x0B\x81\x85` \x86\x01ab\xBFV[ac\x14\x81a`\xCEV[\x84\x01\x91PP\x92\x91PPV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Rac7\x81\x84ab\xE7V[\x90P\x92\x91PPV[_\x80`@\x83\x85\x03\x12\x15acUWacTa_dV[[_acb\x85\x82\x86\x01a_\x8BV[\x92PP` acs\x85\x82\x86\x01ab\x11V[\x91PP\x92P\x92\x90PV[_\x81\x90P\x91\x90PV[ac\x8F\x81ac}V[\x81\x14ac\x99W_\x80\xFD[PV[_\x815\x90Pac\xAA\x81ac\x86V[\x92\x91PPV[_\x80`@\x83\x85\x03\x12\x15ac\xC6Wac\xC5a_dV[[_ac\xD3\x85\x82\x86\x01ac\x9CV[\x92PP` ac\xE4\x85\x82\x86\x01ab\x11V[\x91PP\x92P\x92\x90PV[_\x80`@\x83\x85\x03\x12\x15ad\x04Wad\x03a_dV[[_ad\x11\x85\x82\x86\x01a`\xB2V[\x92PP` \x83\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15ad2Wad1a_hV[[ad>\x85\x82\x86\x01aa\xD5V[\x91PP\x92P\x92\x90PV[_\x80_``\x84\x86\x03\x12\x15ad_Wad^a_dV[[_adl\x86\x82\x87\x01a_\x8BV[\x93PP` ad}\x86\x82\x87\x01a_\x8BV[\x92PP`@ad\x8E\x86\x82\x87\x01a_\x8BV[\x91PP\x92P\x92P\x92V[_`\xFF\x82\x16\x90P\x91\x90PV[ad\xAD\x81ad\x98V[\x82RPPV[_` \x82\x01\x90Pad\xC6_\x83\x01\x84ad\xA4V[\x92\x91PPV[ad\xD5\x81a`\x8BV[\x82RPPV[_` \x82\x01\x90Pad\xEE_\x83\x01\x84ad\xCCV[\x92\x91PPV[_` \x82\x84\x03\x12\x15ae\tWae\x08a_dV[[_ae\x16\x84\x82\x85\x01a_\x8BV[\x91PP\x92\x91PPV[_` \x82\x84\x03\x12\x15ae4Wae3a_dV[[_aeA\x84\x82\x85\x01ab\x11V[\x91PP\x92\x91PPV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`!`\x04R`$_\xFD[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x11`\x04R`$_\xFD[_ae\xAE\x82ac}V[\x91Pae\xB9\x83ac}V[\x92P\x82\x82\x01\x90P\x80\x82\x11\x15ae\xD1Wae\xD0aewV[[\x92\x91PPV[`T\x81\x10ae\xE8Wae\xE7aeJV[[PV[_\x81\x90Pae\xF8\x82ae\xD7V[\x91\x90PV[_af\x07\x82ae\xEBV[\x90P\x91\x90PV[af\x17\x81ae\xFDV[\x82RPPV[af&\x81a_\x9FV[\x82RPPV[_`\xC0\x82\x01\x90Paf?_\x83\x01\x89af\x0EV[afL` \x83\x01\x88af\x1DV[afY`@\x83\x01\x87a`DV[aff``\x83\x01\x86a`DV[afs`\x80\x83\x01\x85a`DV[af\x80`\xA0\x83\x01\x84ad\xCCV[\x97\x96PPPPPPPV[_`\x80\x82\x01\x90Paf\x9E_\x83\x01\x87a`DV[af\xAB` \x83\x01\x86a`DV[af\xB8`@\x83\x01\x85af\x1DV[af\xC5``\x83\x01\x84a`DV[\x95\x94PPPPPV[af\xD7\x81a`\x8BV[\x82RPPV[`@\x82\x01_\x82\x01Qaf\xF1_\x85\x01\x82af\xCEV[P` \x82\x01Qag\x04` \x85\x01\x82af\xCEV[PPPPV[_\x81Q\x90P\x91\x90PV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[_ag.\x82ag\nV[ag8\x81\x85ag\x14V[\x93PagH\x81\x85` \x86\x01ab\xBFV[agQ\x81a`\xCEV[\x84\x01\x91PP\x92\x91PPV[_`\x80\x82\x01\x90Pago_\x83\x01\x86af\xDDV[ag|`@\x83\x01\x85a`DV[\x81\x81\x03``\x83\x01Rag\x8E\x81\x84ag$V[\x90P\x94\x93PPPPV[_\x81Q\x90Pag\xA6\x81a_uV[\x92\x91PPV[_` \x82\x84\x03\x12\x15ag\xC1Wag\xC0a_dV[[_ag\xCE\x84\x82\x85\x01ag\x98V[\x91PP\x92\x91PPV[_`@\x82\x01\x90Pag\xEA_\x83\x01\x85a`DV[ag\xF7` \x83\x01\x84ad\xCCV[\x93\x92PPPV[_`\xA0\x82\x01\x90Pah\x11_\x83\x01\x88a`DV[ah\x1E` \x83\x01\x87ad\xCCV[\x81\x81\x03`@\x83\x01Rah0\x81\x86ag$V[\x90Pah?``\x83\x01\x85af\x0EV[ahL`\x80\x83\x01\x84a`DV[\x96\x95PPPPPPV[_\x81\x90P\x92\x91PPV[_ahj\x82ab\xA5V[aht\x81\x85ahVV[\x93Pah\x84\x81\x85` \x86\x01ab\xBFV[\x80\x84\x01\x91PP\x92\x91PPV[\x7F v\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_ah\xC4`\x02\x83ahVV[\x91Pah\xCF\x82ah\x90V[`\x02\x82\x01\x90P\x91\x90PV[\x7F.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_ai\x0E`\x01\x83ahVV[\x91Pai\x19\x82ah\xDAV[`\x01\x82\x01\x90P\x91\x90PV[_ai/\x82\x87ah`V[\x91Pai:\x82ah\xB8V[\x91PaiF\x82\x86ah`V[\x91PaiQ\x82ai\x02V[\x91Pai]\x82\x85ah`V[\x91Paih\x82ai\x02V[\x91Pait\x82\x84ah`V[\x91P\x81\x90P\x95\x94PPPPPV[_\x81\x15\x15\x90P\x91\x90PV[ai\x96\x81ai\x82V[\x81\x14ai\xA0W_\x80\xFD[PV[_\x81Q\x90Pai\xB1\x81ai\x8DV[\x92\x91PPV[_` \x82\x84\x03\x12\x15ai\xCCWai\xCBa_dV[[_ai\xD9\x84\x82\x85\x01ai\xA3V[\x91PP\x92\x91PPV[`\x1C\x81\x10ai\xF3Wai\xF2aeJV[[PV[_\x81\x90Paj\x03\x82ai\xE2V[\x91\x90PV[_aj\x12\x82ai\xF6V[\x90P\x91\x90PV[_\x81`\xF8\x1B\x90P\x91\x90PV[_aj/\x82aj\x19V[\x90P\x91\x90PV[ajGajB\x82aj\x08V[aj%V[\x82RPPV[_\x81\x90P\x91\x90PV[ajgajb\x82a_lV[ajMV[\x82RPPV[aj~ajy\x82ae\xFDV[aj%V[\x82RPPV[_\x81\x90P\x91\x90PV[_aj\xA7aj\xA2aj\x9D\x84a`lV[aj\x84V[a`lV[\x90P\x91\x90PV[_aj\xB8\x82aj\x8DV[\x90P\x91\x90PV[_aj\xC9\x82aj\xAEV[\x90P\x91\x90PV[_\x81``\x1B\x90P\x91\x90PV[_aj\xE6\x82aj\xD0V[\x90P\x91\x90PV[_aj\xF7\x82aj\xDCV[\x90P\x91\x90PV[ak\x0Fak\n\x82aj\xBFV[aj\xEDV[\x82RPPV[_\x81\x90P\x91\x90PV[ak/ak*\x82ac}V[ak\x15V[\x82RPPV[_ak@\x82\x88aj6V[`\x01\x82\x01\x91PakP\x82\x87ajVV[` \x82\x01\x91Pak`\x82\x86ajmV[`\x01\x82\x01\x91Pakp\x82\x85aj\xFEV[`\x14\x82\x01\x91Pak\x80\x82\x84ak\x1EV[` \x82\x01\x91P\x81\x90P\x96\x95PPPPPPV[_`\x80\x82\x01\x90Pak\xA6_\x83\x01\x87af\x0EV[ak\xB3` \x83\x01\x86a`DV[ak\xC0`@\x83\x01\x85a`DV[ak\xCD``\x83\x01\x84ad\xCCV[\x95\x94PPPPPV[_``\x82\x01\x90Pak\xE9_\x83\x01\x86a`DV[ak\xF6` \x83\x01\x85af\x0EV[al\x03`@\x83\x01\x84a`DV[\x94\x93PPPPV[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[al'\x81al\x0BV[\x82RPPV[_` \x82\x01\x90Pal@_\x83\x01\x84al\x1EV[\x92\x91PPV[alO\x81ac}V[\x82RPPV[_\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\x16\x90P\x91\x90PV[al\x89\x81alUV[\x82RPPV[_`\x80\x82\x01\x90Pal\xA2_\x83\x01\x87alFV[al\xAF` \x83\x01\x86af\x0EV[al\xBC`@\x83\x01\x85al\x80V[al\xC9``\x83\x01\x84a`DV[\x95\x94PPPPPV[_`\xC0\x82\x01\x90Pal\xE5_\x83\x01\x89af\x0EV[al\xF2` \x83\x01\x88a`DV[al\xFF`@\x83\x01\x87a`DV[am\x0C``\x83\x01\x86a`DV[am\x19`\x80\x83\x01\x85a`DV[am&`\xA0\x83\x01\x84ad\xCCV[\x97\x96PPPPPPPV[_`\x80\x82\x01\x90PamD_\x83\x01\x87a`DV[amQ` \x83\x01\x86a`DV[am^`@\x83\x01\x85a`DV[amk``\x83\x01\x84a`DV[\x95\x94PPPPPV[_am\x7F\x82\x88aj6V[`\x01\x82\x01\x91Pam\x8F\x82\x87ak\x1EV[` \x82\x01\x91Pam\x9F\x82\x86ajmV[`\x01\x82\x01\x91Pam\xAF\x82\x85aj\xFEV[`\x14\x82\x01\x91Pam\xBF\x82\x84ak\x1EV[` \x82\x01\x91P\x81\x90P\x96\x95PPPPPPV[_``\x82\x01\x90Pam\xE5_\x83\x01\x86af\x0EV[am\xF2` \x83\x01\x85a`DV[am\xFF`@\x83\x01\x84ad\xCCV[\x94\x93PPPPV[_``\x82\x01\x90Pan\x1A_\x83\x01\x86alFV[an'` \x83\x01\x85af\x0EV[an4`@\x83\x01\x84a`DV[\x94\x93PPPPV[_`@\x82\x01\x90PanO_\x83\x01\x85a`DV[an\\` \x83\x01\x84a`DV[\x93\x92PPPV[_``\x82\x01\x90Panv_\x83\x01\x86af\x0EV[an\x83` \x83\x01\x85al\x80V[an\x90`@\x83\x01\x84a`DV[\x94\x93PPPPV[_\x81\x90P\x91\x90PV[an\xB2an\xAD\x82a_\x9FV[an\x98V[\x82RPPV[_an\xC3\x82\x89aj6V[`\x01\x82\x01\x91Pan\xD3\x82\x88ajVV[` \x82\x01\x91Pan\xE3\x82\x87ajVV[` \x82\x01\x91Pan\xF3\x82\x86an\xA1V[`\x01\x82\x01\x91Pao\x03\x82\x85aj\xFEV[`\x14\x82\x01\x91Pao\x13\x82\x84ak\x1EV[` \x82\x01\x91P\x81\x90P\x97\x96PPPPPPPV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`2`\x04R`$_\xFD[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x12`\x04R`$_\xFD[_ao\x8B\x82ac}V[\x91Pao\x96\x83ac}V[\x92P\x82\x82\x03\x90P\x81\x81\x11\x15ao\xAEWao\xADaewV[[\x92\x91PPV[_ao\xBF\x82\x88ak\x1EV[` \x82\x01\x91Pao\xCF\x82\x87aj\xFEV[`\x14\x82\x01\x91Pao\xDF\x82\x86ak\x1EV[` \x82\x01\x91Pao\xEF\x82\x85ajVV[` \x82\x01\x91Pao\xFF\x82\x84ak\x1EV[` \x82\x01\x91P\x81\x90P\x96\x95PPPPPPV[_ap\x1C\x82ac}V[\x91P\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x03apNWapMaewV[[`\x01\x82\x01\x90P\x91\x90PV[_\x81\x90P\x91\x90PV[apsapn\x82alUV[apYV[\x82RPPV[_ap\x84\x82\x87aj6V[`\x01\x82\x01\x91Pap\x94\x82\x86ak\x1EV[` \x82\x01\x91Pap\xA4\x82\x85ajmV[`\x01\x82\x01\x91Pap\xB4\x82\x84apbV[`\x10\x82\x01\x91P\x81\x90P\x95\x94PPPPPV[_\x81Q\x90Pap\xD4\x81a`\x9CV[\x92\x91PPV[_` \x82\x84\x03\x12\x15ap\xEFWap\xEEa_dV[[_ap\xFC\x84\x82\x85\x01ap\xC6V[\x91PP\x92\x91PPV[_aq\x10\x82\x89aj6V[`\x01\x82\x01\x91Paq \x82\x88ajVV[` \x82\x01\x91Paq0\x82\x87ajVV[` \x82\x01\x91Paq@\x82\x86ajVV[` \x82\x01\x91PaqP\x82\x85aj\xFEV[`\x14\x82\x01\x91Paq`\x82\x84ak\x1EV[` \x82\x01\x91P\x81\x90P\x97\x96PPPPPPPV[_aq\x7F\x82\x87aj6V[`\x01\x82\x01\x91Paq\x8F\x82\x86ajVV[` \x82\x01\x91Paq\x9F\x82\x85aj\xFEV[`\x14\x82\x01\x91Paq\xAF\x82\x84ak\x1EV[` \x82\x01\x91P\x81\x90P\x95\x94PPPPPV[_aq\xCC\x82\x86aj6V[`\x01\x82\x01\x91Paq\xDC\x82\x85ajmV[`\x01\x82\x01\x91Paq\xEC\x82\x84apbV[`\x10\x82\x01\x91P\x81\x90P\x94\x93PPPPV[_\x81\x90P\x92\x91PPV[_ar\x11\x82ag\nV[ar\x1B\x81\x85aq\xFDV[\x93Par+\x81\x85` \x86\x01ab\xBFV[\x80\x84\x01\x91PP\x92\x91PPV[_arB\x82\x84ar\x07V[\x91P\x81\x90P\x92\x91PPV",
    );
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct FheType(u8);
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<FheType> for u8 {
            #[inline]
            fn stv_to_tokens(
                &self,
            ) -> <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::Token<'_> {
                alloy_sol_types::private::SolTypeValue::<
                    alloy::sol_types::sol_data::Uint<8>,
                >::stv_to_tokens(self)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::tokenize(self)
                    .0
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(self, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::abi_encoded_size(self)
            }
        }
        #[automatically_derived]
        impl FheType {
            /// The Solidity type name.
            pub const NAME: &'static str = stringify!(@ name);
            /// Convert from the underlying value type.
            #[inline]
            pub const fn from_underlying(value: u8) -> Self {
                Self(value)
            }
            /// Return the underlying value.
            #[inline]
            pub const fn into_underlying(self) -> u8 {
                self.0
            }
            /// Return the single encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode(&self.0)
            }
            /// Return the packed encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode_packed(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode_packed(&self.0)
            }
        }
        #[automatically_derived]
        impl From<u8> for FheType {
            fn from(value: u8) -> Self {
                Self::from_underlying(value)
            }
        }
        #[automatically_derived]
        impl From<FheType> for u8 {
            fn from(value: FheType) -> Self {
                value.into_underlying()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for FheType {
            type RustType = u8;
            type Token<'a> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = Self::NAME;
            const ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                Self::type_check(token).is_ok()
            }
            #[inline]
            fn type_check(token: &Self::Token<'_>) -> alloy_sol_types::Result<()> {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::type_check(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::detokenize(token)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for FheType {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::topic_preimage_length(rust)
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(rust, out)
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic(rust)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `ACLNotAllowed(bytes32,address)` and selector `0x9de3392c`.
```solidity
error ACLNotAllowed(bytes32 handle, address account);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ACLNotAllowed {
        #[allow(missing_docs)]
        pub handle: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::Address,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::Address,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ACLNotAllowed> for UnderlyingRustTuple<'_> {
            fn from(value: ACLNotAllowed) -> Self {
                (value.handle, value.account)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ACLNotAllowed {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    handle: tuple.0,
                    account: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ACLNotAllowed {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ACLNotAllowed(bytes32,address)";
            const SELECTOR: [u8; 4] = [157u8, 227u8, 57u8, 44u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.handle),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `AddressEmptyCode(address)` and selector `0x9996b315`.
```solidity
error AddressEmptyCode(address target);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AddressEmptyCode {
        #[allow(missing_docs)]
        pub target: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AddressEmptyCode> for UnderlyingRustTuple<'_> {
            fn from(value: AddressEmptyCode) -> Self {
                (value.target,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for AddressEmptyCode {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { target: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AddressEmptyCode {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AddressEmptyCode(address)";
            const SELECTOR: [u8; 4] = [153u8, 150u8, 179u8, 21u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.target,
                    ),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `DivisionByZero()` and selector `0x23d359a3`.
```solidity
error DivisionByZero();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DivisionByZero;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<DivisionByZero> for UnderlyingRustTuple<'_> {
            fn from(value: DivisionByZero) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for DivisionByZero {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for DivisionByZero {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "DivisionByZero()";
            const SELECTOR: [u8; 4] = [35u8, 211u8, 89u8, 163u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `ERC1967InvalidImplementation(address)` and selector `0x4c9c8ce3`.
```solidity
error ERC1967InvalidImplementation(address implementation);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC1967InvalidImplementation {
        #[allow(missing_docs)]
        pub implementation: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC1967InvalidImplementation>
        for UnderlyingRustTuple<'_> {
            fn from(value: ERC1967InvalidImplementation) -> Self {
                (value.implementation,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ERC1967InvalidImplementation {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { implementation: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC1967InvalidImplementation {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC1967InvalidImplementation(address)";
            const SELECTOR: [u8; 4] = [76u8, 156u8, 140u8, 227u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.implementation,
                    ),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `ERC1967NonPayable()` and selector `0xb398979f`.
```solidity
error ERC1967NonPayable();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC1967NonPayable;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC1967NonPayable> for UnderlyingRustTuple<'_> {
            fn from(value: ERC1967NonPayable) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ERC1967NonPayable {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC1967NonPayable {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC1967NonPayable()";
            const SELECTOR: [u8; 4] = [179u8, 152u8, 151u8, 159u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `FailedCall()` and selector `0xd6bda275`.
```solidity
error FailedCall();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct FailedCall;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<FailedCall> for UnderlyingRustTuple<'_> {
            fn from(value: FailedCall) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for FailedCall {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for FailedCall {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "FailedCall()";
            const SELECTOR: [u8; 4] = [214u8, 189u8, 162u8, 117u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `IncompatibleTypes()` and selector `0x1f3158c7`.
```solidity
error IncompatibleTypes();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct IncompatibleTypes;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<IncompatibleTypes> for UnderlyingRustTuple<'_> {
            fn from(value: IncompatibleTypes) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for IncompatibleTypes {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for IncompatibleTypes {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "IncompatibleTypes()";
            const SELECTOR: [u8; 4] = [31u8, 49u8, 88u8, 199u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidByteLength(uint8,uint256)` and selector `0xb30c0c57`.
```solidity
error InvalidByteLength(FheType typeOf, uint256 length);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidByteLength {
        #[allow(missing_docs)]
        pub typeOf: <FheType as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub length: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (FheType, alloy::sol_types::sol_data::Uint<256>);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            <FheType as alloy::sol_types::SolType>::RustType,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidByteLength> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidByteLength) -> Self {
                (value.typeOf, value.length)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidByteLength {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    typeOf: tuple.0,
                    length: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidByteLength {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidByteLength(uint8,uint256)";
            const SELECTOR: [u8; 4] = [179u8, 12u8, 12u8, 87u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <FheType as alloy_sol_types::SolType>::tokenize(&self.typeOf),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.length),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidInitialization()` and selector `0xf92ee8a9`.
```solidity
error InvalidInitialization();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidInitialization;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidInitialization> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidInitialization) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidInitialization {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidInitialization {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidInitialization()";
            const SELECTOR: [u8; 4] = [249u8, 46u8, 232u8, 169u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidType()` and selector `0xb9688461`.
```solidity
error InvalidType();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidType;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidType> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidType) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidType {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidType {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidType()";
            const SELECTOR: [u8; 4] = [185u8, 104u8, 132u8, 97u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `IsNotScalar()` and selector `0x4f224e53`.
```solidity
error IsNotScalar();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct IsNotScalar;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<IsNotScalar> for UnderlyingRustTuple<'_> {
            fn from(value: IsNotScalar) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for IsNotScalar {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for IsNotScalar {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "IsNotScalar()";
            const SELECTOR: [u8; 4] = [79u8, 34u8, 78u8, 83u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `NotHostOwner(address)` and selector `0x21bfda10`.
```solidity
error NotHostOwner(address sender);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NotHostOwner {
        #[allow(missing_docs)]
        pub sender: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NotHostOwner> for UnderlyingRustTuple<'_> {
            fn from(value: NotHostOwner) -> Self {
                (value.sender,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NotHostOwner {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { sender: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NotHostOwner {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NotHostOwner(address)";
            const SELECTOR: [u8; 4] = [33u8, 191u8, 218u8, 16u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sender,
                    ),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `NotInitializing()` and selector `0xd7e6bcf8`.
```solidity
error NotInitializing();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NotInitializing;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NotInitializing> for UnderlyingRustTuple<'_> {
            fn from(value: NotInitializing) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NotInitializing {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NotInitializing {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NotInitializing()";
            const SELECTOR: [u8; 4] = [215u8, 230u8, 188u8, 248u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `NotInitializingFromEmptyProxy()` and selector `0x6f4f731f`.
```solidity
error NotInitializingFromEmptyProxy();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NotInitializingFromEmptyProxy;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NotInitializingFromEmptyProxy>
        for UnderlyingRustTuple<'_> {
            fn from(value: NotInitializingFromEmptyProxy) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for NotInitializingFromEmptyProxy {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NotInitializingFromEmptyProxy {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NotInitializingFromEmptyProxy()";
            const SELECTOR: [u8; 4] = [111u8, 79u8, 115u8, 31u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `NotPowerOfTwo()` and selector `0x24e8e742`.
```solidity
error NotPowerOfTwo();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NotPowerOfTwo;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NotPowerOfTwo> for UnderlyingRustTuple<'_> {
            fn from(value: NotPowerOfTwo) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NotPowerOfTwo {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NotPowerOfTwo {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NotPowerOfTwo()";
            const SELECTOR: [u8; 4] = [36u8, 232u8, 231u8, 66u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `ScalarByteIsNotBoolean()` and selector `0xdf7bf325`.
```solidity
error ScalarByteIsNotBoolean();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ScalarByteIsNotBoolean;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ScalarByteIsNotBoolean> for UnderlyingRustTuple<'_> {
            fn from(value: ScalarByteIsNotBoolean) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ScalarByteIsNotBoolean {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ScalarByteIsNotBoolean {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ScalarByteIsNotBoolean()";
            const SELECTOR: [u8; 4] = [223u8, 123u8, 243u8, 37u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `SecondOperandIsNotScalar()` and selector `0x4dde0d98`.
```solidity
error SecondOperandIsNotScalar();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SecondOperandIsNotScalar;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<SecondOperandIsNotScalar>
        for UnderlyingRustTuple<'_> {
            fn from(value: SecondOperandIsNotScalar) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for SecondOperandIsNotScalar {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for SecondOperandIsNotScalar {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "SecondOperandIsNotScalar()";
            const SELECTOR: [u8; 4] = [77u8, 222u8, 13u8, 152u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `UUPSUnauthorizedCallContext()` and selector `0xe07c8dba`.
```solidity
error UUPSUnauthorizedCallContext();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct UUPSUnauthorizedCallContext;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UUPSUnauthorizedCallContext>
        for UnderlyingRustTuple<'_> {
            fn from(value: UUPSUnauthorizedCallContext) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for UUPSUnauthorizedCallContext {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for UUPSUnauthorizedCallContext {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "UUPSUnauthorizedCallContext()";
            const SELECTOR: [u8; 4] = [224u8, 124u8, 141u8, 186u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `UUPSUnsupportedProxiableUUID(bytes32)` and selector `0xaa1d49a4`.
```solidity
error UUPSUnsupportedProxiableUUID(bytes32 slot);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct UUPSUnsupportedProxiableUUID {
        #[allow(missing_docs)]
        pub slot: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UUPSUnsupportedProxiableUUID>
        for UnderlyingRustTuple<'_> {
            fn from(value: UUPSUnsupportedProxiableUUID) -> Self {
                (value.slot,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for UUPSUnsupportedProxiableUUID {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { slot: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for UUPSUnsupportedProxiableUUID {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "UUPSUnsupportedProxiableUUID(bytes32)";
            const SELECTOR: [u8; 4] = [170u8, 29u8, 73u8, 164u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.slot),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `UnsupportedType()` and selector `0xc6de466a`.
```solidity
error UnsupportedType();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct UnsupportedType;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnsupportedType> for UnderlyingRustTuple<'_> {
            fn from(value: UnsupportedType) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for UnsupportedType {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for UnsupportedType {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "UnsupportedType()";
            const SELECTOR: [u8; 4] = [198u8, 222u8, 70u8, 106u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `UpperBoundAboveMaxTypeValue()` and selector `0xc7dadf45`.
```solidity
error UpperBoundAboveMaxTypeValue();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct UpperBoundAboveMaxTypeValue;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UpperBoundAboveMaxTypeValue>
        for UnderlyingRustTuple<'_> {
            fn from(value: UpperBoundAboveMaxTypeValue) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for UpperBoundAboveMaxTypeValue {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for UpperBoundAboveMaxTypeValue {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "UpperBoundAboveMaxTypeValue()";
            const SELECTOR: [u8; 4] = [199u8, 218u8, 223u8, 69u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `Cast(address,bytes32,uint8,bytes32)` and selector `0x31ccae6a2f8e3ced1692f77c8f668133e4afdaaa35afe844ff4659a6c27e627f`.
```solidity
event Cast(address indexed caller, bytes32 ct, FheType toType, bytes32 result);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Cast {
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub ct: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub toType: <FheType as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Cast {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                FheType,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "Cast(address,bytes32,uint8,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                49u8, 204u8, 174u8, 106u8, 47u8, 142u8, 60u8, 237u8, 22u8, 146u8, 247u8,
                124u8, 143u8, 102u8, 129u8, 51u8, 228u8, 175u8, 218u8, 170u8, 53u8,
                175u8, 232u8, 68u8, 255u8, 70u8, 89u8, 166u8, 194u8, 126u8, 98u8, 127u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    caller: topics.1,
                    ct: data.0,
                    toType: data.1,
                    result: data.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.ct),
                    <FheType as alloy_sol_types::SolType>::tokenize(&self.toType),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.caller.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.caller,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Cast {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Cast> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Cast) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `FheAdd(address,bytes32,bytes32,bytes1,bytes32)` and selector `0xdb9050d65240431621d61d6f94b970e63f53a67a5766614ee6e5c5bbd41c8e2e`.
```solidity
event FheAdd(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct FheAdd {
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for FheAdd {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "FheAdd(address,bytes32,bytes32,bytes1,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                219u8, 144u8, 80u8, 214u8, 82u8, 64u8, 67u8, 22u8, 33u8, 214u8, 29u8,
                111u8, 148u8, 185u8, 112u8, 230u8, 63u8, 83u8, 166u8, 122u8, 87u8, 102u8,
                97u8, 78u8, 230u8, 229u8, 197u8, 187u8, 212u8, 28u8, 142u8, 46u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    caller: topics.1,
                    lhs: data.0,
                    rhs: data.1,
                    scalarByte: data.2,
                    result: data.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.caller.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.caller,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for FheAdd {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&FheAdd> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &FheAdd) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `FheBitAnd(address,bytes32,bytes32,bytes1,bytes32)` and selector `0xe42486b0ccdbef81a2075c48c8e515c079aea73c8b82429997c72a2fe1bf4fef`.
```solidity
event FheBitAnd(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct FheBitAnd {
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for FheBitAnd {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "FheBitAnd(address,bytes32,bytes32,bytes1,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                228u8, 36u8, 134u8, 176u8, 204u8, 219u8, 239u8, 129u8, 162u8, 7u8, 92u8,
                72u8, 200u8, 229u8, 21u8, 192u8, 121u8, 174u8, 167u8, 60u8, 139u8, 130u8,
                66u8, 153u8, 151u8, 199u8, 42u8, 47u8, 225u8, 191u8, 79u8, 239u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    caller: topics.1,
                    lhs: data.0,
                    rhs: data.1,
                    scalarByte: data.2,
                    result: data.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.caller.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.caller,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for FheBitAnd {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&FheBitAnd> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &FheBitAnd) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `FheBitOr(address,bytes32,bytes32,bytes1,bytes32)` and selector `0x56df279bbfb03d9ed097bbe2f28d520ca0c1161206327926e98664d70d2c24c4`.
```solidity
event FheBitOr(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct FheBitOr {
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for FheBitOr {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "FheBitOr(address,bytes32,bytes32,bytes1,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                86u8, 223u8, 39u8, 155u8, 191u8, 176u8, 61u8, 158u8, 208u8, 151u8, 187u8,
                226u8, 242u8, 141u8, 82u8, 12u8, 160u8, 193u8, 22u8, 18u8, 6u8, 50u8,
                121u8, 38u8, 233u8, 134u8, 100u8, 215u8, 13u8, 44u8, 36u8, 196u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    caller: topics.1,
                    lhs: data.0,
                    rhs: data.1,
                    scalarByte: data.2,
                    result: data.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.caller.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.caller,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for FheBitOr {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&FheBitOr> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &FheBitOr) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `FheBitXor(address,bytes32,bytes32,bytes1,bytes32)` and selector `0x4d32284bd3193ecaa44e1ceca32f41c5d6c32803a92e07967dd3ee4229721582`.
```solidity
event FheBitXor(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct FheBitXor {
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for FheBitXor {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "FheBitXor(address,bytes32,bytes32,bytes1,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                77u8, 50u8, 40u8, 75u8, 211u8, 25u8, 62u8, 202u8, 164u8, 78u8, 28u8,
                236u8, 163u8, 47u8, 65u8, 197u8, 214u8, 195u8, 40u8, 3u8, 169u8, 46u8,
                7u8, 150u8, 125u8, 211u8, 238u8, 66u8, 41u8, 114u8, 21u8, 130u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    caller: topics.1,
                    lhs: data.0,
                    rhs: data.1,
                    scalarByte: data.2,
                    result: data.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.caller.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.caller,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for FheBitXor {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&FheBitXor> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &FheBitXor) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `FheDiv(address,bytes32,bytes32,bytes1,bytes32)` and selector `0x3bab2ee0e2f90f4690c6a87bf63cf1a6b626086e95f231860b152966e8dabbf7`.
```solidity
event FheDiv(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct FheDiv {
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for FheDiv {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "FheDiv(address,bytes32,bytes32,bytes1,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                59u8, 171u8, 46u8, 224u8, 226u8, 249u8, 15u8, 70u8, 144u8, 198u8, 168u8,
                123u8, 246u8, 60u8, 241u8, 166u8, 182u8, 38u8, 8u8, 110u8, 149u8, 242u8,
                49u8, 134u8, 11u8, 21u8, 41u8, 102u8, 232u8, 218u8, 187u8, 247u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    caller: topics.1,
                    lhs: data.0,
                    rhs: data.1,
                    scalarByte: data.2,
                    result: data.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.caller.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.caller,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for FheDiv {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&FheDiv> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &FheDiv) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `FheEq(address,bytes32,bytes32,bytes1,bytes32)` and selector `0xb3d5c664ec86575818e8d75ff25c5f867250df8954088549c41c848cd10e76cb`.
```solidity
event FheEq(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct FheEq {
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for FheEq {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "FheEq(address,bytes32,bytes32,bytes1,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                179u8, 213u8, 198u8, 100u8, 236u8, 134u8, 87u8, 88u8, 24u8, 232u8, 215u8,
                95u8, 242u8, 92u8, 95u8, 134u8, 114u8, 80u8, 223u8, 137u8, 84u8, 8u8,
                133u8, 73u8, 196u8, 28u8, 132u8, 140u8, 209u8, 14u8, 118u8, 203u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    caller: topics.1,
                    lhs: data.0,
                    rhs: data.1,
                    scalarByte: data.2,
                    result: data.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.caller.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.caller,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for FheEq {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&FheEq> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &FheEq) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `FheGe(address,bytes32,bytes32,bytes1,bytes32)` and selector `0x38c3a63c4230de5b741f494ffb54e3087104030279bc7bccee8ad9ad31712b21`.
```solidity
event FheGe(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct FheGe {
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for FheGe {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "FheGe(address,bytes32,bytes32,bytes1,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                56u8, 195u8, 166u8, 60u8, 66u8, 48u8, 222u8, 91u8, 116u8, 31u8, 73u8,
                79u8, 251u8, 84u8, 227u8, 8u8, 113u8, 4u8, 3u8, 2u8, 121u8, 188u8, 123u8,
                204u8, 238u8, 138u8, 217u8, 173u8, 49u8, 113u8, 43u8, 33u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    caller: topics.1,
                    lhs: data.0,
                    rhs: data.1,
                    scalarByte: data.2,
                    result: data.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.caller.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.caller,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for FheGe {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&FheGe> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &FheGe) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `FheGt(address,bytes32,bytes32,bytes1,bytes32)` and selector `0xc9ff8f0d18a3f766ce5de3de216076050140e4fc2652f5e0e745f6fc836cda8b`.
```solidity
event FheGt(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct FheGt {
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for FheGt {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "FheGt(address,bytes32,bytes32,bytes1,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                201u8, 255u8, 143u8, 13u8, 24u8, 163u8, 247u8, 102u8, 206u8, 93u8, 227u8,
                222u8, 33u8, 96u8, 118u8, 5u8, 1u8, 64u8, 228u8, 252u8, 38u8, 82u8,
                245u8, 224u8, 231u8, 69u8, 246u8, 252u8, 131u8, 108u8, 218u8, 139u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    caller: topics.1,
                    lhs: data.0,
                    rhs: data.1,
                    scalarByte: data.2,
                    result: data.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.caller.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.caller,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for FheGt {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&FheGt> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &FheGt) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `FheIfThenElse(address,bytes32,bytes32,bytes32,bytes32)` and selector `0x60be9d61aad849facc28c38b048cb5c4be3420b8fa2233e08cfa06be1b6d1c3e`.
```solidity
event FheIfThenElse(address indexed caller, bytes32 control, bytes32 ifTrue, bytes32 ifFalse, bytes32 result);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct FheIfThenElse {
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub control: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub ifTrue: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub ifFalse: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for FheIfThenElse {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "FheIfThenElse(address,bytes32,bytes32,bytes32,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                96u8, 190u8, 157u8, 97u8, 170u8, 216u8, 73u8, 250u8, 204u8, 40u8, 195u8,
                139u8, 4u8, 140u8, 181u8, 196u8, 190u8, 52u8, 32u8, 184u8, 250u8, 34u8,
                51u8, 224u8, 140u8, 250u8, 6u8, 190u8, 27u8, 109u8, 28u8, 62u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    caller: topics.1,
                    control: data.0,
                    ifTrue: data.1,
                    ifFalse: data.2,
                    result: data.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.control),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.ifTrue),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.ifFalse),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.caller.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.caller,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for FheIfThenElse {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&FheIfThenElse> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &FheIfThenElse) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `FheLe(address,bytes32,bytes32,bytes1,bytes32)` and selector `0xdef2e704a077284a07f3d0b436db88f5d981b69f58ab7c1ae623252718a6de01`.
```solidity
event FheLe(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct FheLe {
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for FheLe {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "FheLe(address,bytes32,bytes32,bytes1,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                222u8, 242u8, 231u8, 4u8, 160u8, 119u8, 40u8, 74u8, 7u8, 243u8, 208u8,
                180u8, 54u8, 219u8, 136u8, 245u8, 217u8, 129u8, 182u8, 159u8, 88u8,
                171u8, 124u8, 26u8, 230u8, 35u8, 37u8, 39u8, 24u8, 166u8, 222u8, 1u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    caller: topics.1,
                    lhs: data.0,
                    rhs: data.1,
                    scalarByte: data.2,
                    result: data.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.caller.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.caller,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for FheLe {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&FheLe> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &FheLe) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `FheLt(address,bytes32,bytes32,bytes1,bytes32)` and selector `0x0d483b100d8c73b208984ec697caa3091521ee5525ce69edcf97d7e395d3d059`.
```solidity
event FheLt(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct FheLt {
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for FheLt {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "FheLt(address,bytes32,bytes32,bytes1,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                13u8, 72u8, 59u8, 16u8, 13u8, 140u8, 115u8, 178u8, 8u8, 152u8, 78u8,
                198u8, 151u8, 202u8, 163u8, 9u8, 21u8, 33u8, 238u8, 85u8, 37u8, 206u8,
                105u8, 237u8, 207u8, 151u8, 215u8, 227u8, 149u8, 211u8, 208u8, 89u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    caller: topics.1,
                    lhs: data.0,
                    rhs: data.1,
                    scalarByte: data.2,
                    result: data.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.caller.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.caller,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for FheLt {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&FheLt> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &FheLt) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `FheMax(address,bytes32,bytes32,bytes1,bytes32)` and selector `0xfd7c9208f956bf0c6ab76a667f04361245ad3e0a2d0eff92eb827acfcca68ea9`.
```solidity
event FheMax(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct FheMax {
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for FheMax {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "FheMax(address,bytes32,bytes32,bytes1,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                253u8, 124u8, 146u8, 8u8, 249u8, 86u8, 191u8, 12u8, 106u8, 183u8, 106u8,
                102u8, 127u8, 4u8, 54u8, 18u8, 69u8, 173u8, 62u8, 10u8, 45u8, 14u8,
                255u8, 146u8, 235u8, 130u8, 122u8, 207u8, 204u8, 166u8, 142u8, 169u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    caller: topics.1,
                    lhs: data.0,
                    rhs: data.1,
                    scalarByte: data.2,
                    result: data.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.caller.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.caller,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for FheMax {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&FheMax> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &FheMax) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `FheMin(address,bytes32,bytes32,bytes1,bytes32)` and selector `0xc11d62b13c360a83082487064be1ec0878b2f0be4f012bf59f89e128063d47ff`.
```solidity
event FheMin(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct FheMin {
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for FheMin {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "FheMin(address,bytes32,bytes32,bytes1,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                193u8, 29u8, 98u8, 177u8, 60u8, 54u8, 10u8, 131u8, 8u8, 36u8, 135u8, 6u8,
                75u8, 225u8, 236u8, 8u8, 120u8, 178u8, 240u8, 190u8, 79u8, 1u8, 43u8,
                245u8, 159u8, 137u8, 225u8, 40u8, 6u8, 61u8, 71u8, 255u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    caller: topics.1,
                    lhs: data.0,
                    rhs: data.1,
                    scalarByte: data.2,
                    result: data.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.caller.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.caller,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for FheMin {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&FheMin> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &FheMin) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `FheMul(address,bytes32,bytes32,bytes1,bytes32)` and selector `0x215346a4f9f975e6d5484e290bd4e53ca14453a9d282ebd3ccedb2a0f171753d`.
```solidity
event FheMul(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct FheMul {
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for FheMul {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "FheMul(address,bytes32,bytes32,bytes1,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                33u8, 83u8, 70u8, 164u8, 249u8, 249u8, 117u8, 230u8, 213u8, 72u8, 78u8,
                41u8, 11u8, 212u8, 229u8, 60u8, 161u8, 68u8, 83u8, 169u8, 210u8, 130u8,
                235u8, 211u8, 204u8, 237u8, 178u8, 160u8, 241u8, 113u8, 117u8, 61u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    caller: topics.1,
                    lhs: data.0,
                    rhs: data.1,
                    scalarByte: data.2,
                    result: data.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.caller.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.caller,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for FheMul {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&FheMul> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &FheMul) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `FheNe(address,bytes32,bytes32,bytes1,bytes32)` and selector `0x6960c1e88f61c352dba34d1bbf6753e302795264d5d8ae82f7983c7004651e5d`.
```solidity
event FheNe(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct FheNe {
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for FheNe {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "FheNe(address,bytes32,bytes32,bytes1,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                105u8, 96u8, 193u8, 232u8, 143u8, 97u8, 195u8, 82u8, 219u8, 163u8, 77u8,
                27u8, 191u8, 103u8, 83u8, 227u8, 2u8, 121u8, 82u8, 100u8, 213u8, 216u8,
                174u8, 130u8, 247u8, 152u8, 60u8, 112u8, 4u8, 101u8, 30u8, 93u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    caller: topics.1,
                    lhs: data.0,
                    rhs: data.1,
                    scalarByte: data.2,
                    result: data.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.caller.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.caller,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for FheNe {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&FheNe> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &FheNe) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `FheNeg(address,bytes32,bytes32)` and selector `0x8c664d3c3ca583fc5803b8a91c49644bbd9550bfa87967c73ad1de83027768c0`.
```solidity
event FheNeg(address indexed caller, bytes32 ct, bytes32 result);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct FheNeg {
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub ct: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for FheNeg {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "FheNeg(address,bytes32,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                140u8, 102u8, 77u8, 60u8, 60u8, 165u8, 131u8, 252u8, 88u8, 3u8, 184u8,
                169u8, 28u8, 73u8, 100u8, 75u8, 189u8, 149u8, 80u8, 191u8, 168u8, 121u8,
                103u8, 199u8, 58u8, 209u8, 222u8, 131u8, 2u8, 119u8, 104u8, 192u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    caller: topics.1,
                    ct: data.0,
                    result: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.ct),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.caller.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.caller,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for FheNeg {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&FheNeg> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &FheNeg) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `FheNot(address,bytes32,bytes32)` and selector `0x55aff4cc7a3d160c83f1f15b818011ede841a0b4597fb14dcd3603df3a11e5e0`.
```solidity
event FheNot(address indexed caller, bytes32 ct, bytes32 result);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct FheNot {
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub ct: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for FheNot {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "FheNot(address,bytes32,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                85u8, 175u8, 244u8, 204u8, 122u8, 61u8, 22u8, 12u8, 131u8, 241u8, 241u8,
                91u8, 129u8, 128u8, 17u8, 237u8, 232u8, 65u8, 160u8, 180u8, 89u8, 127u8,
                177u8, 77u8, 205u8, 54u8, 3u8, 223u8, 58u8, 17u8, 229u8, 224u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    caller: topics.1,
                    ct: data.0,
                    result: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.ct),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.caller.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.caller,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for FheNot {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&FheNot> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &FheNot) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `FheRand(address,uint8,bytes16,bytes32)` and selector `0x0c8aca6017003326051e19913ef02631f24b801125e1fa8a1d812e868319fda6`.
```solidity
event FheRand(address indexed caller, FheType randType, bytes16 seed, bytes32 result);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct FheRand {
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub randType: <FheType as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub seed: alloy::sol_types::private::FixedBytes<16>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for FheRand {
            type DataTuple<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<16>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "FheRand(address,uint8,bytes16,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                12u8, 138u8, 202u8, 96u8, 23u8, 0u8, 51u8, 38u8, 5u8, 30u8, 25u8, 145u8,
                62u8, 240u8, 38u8, 49u8, 242u8, 75u8, 128u8, 17u8, 37u8, 225u8, 250u8,
                138u8, 29u8, 129u8, 46u8, 134u8, 131u8, 25u8, 253u8, 166u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    caller: topics.1,
                    randType: data.0,
                    seed: data.1,
                    result: data.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <FheType as alloy_sol_types::SolType>::tokenize(&self.randType),
                    <alloy::sol_types::sol_data::FixedBytes<
                        16,
                    > as alloy_sol_types::SolType>::tokenize(&self.seed),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.caller.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.caller,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for FheRand {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&FheRand> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &FheRand) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `FheRandBounded(address,uint256,uint8,bytes16,bytes32)` and selector `0x5222d96b836727a1d6fe1ee9aef27f9bb507bd41794defa376ff6c648aaf8ff1`.
```solidity
event FheRandBounded(address indexed caller, uint256 upperBound, FheType randType, bytes16 seed, bytes32 result);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct FheRandBounded {
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub upperBound: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub randType: <FheType as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub seed: alloy::sol_types::private::FixedBytes<16>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for FheRandBounded {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                FheType,
                alloy::sol_types::sol_data::FixedBytes<16>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "FheRandBounded(address,uint256,uint8,bytes16,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                82u8, 34u8, 217u8, 107u8, 131u8, 103u8, 39u8, 161u8, 214u8, 254u8, 30u8,
                233u8, 174u8, 242u8, 127u8, 155u8, 181u8, 7u8, 189u8, 65u8, 121u8, 77u8,
                239u8, 163u8, 118u8, 255u8, 108u8, 100u8, 138u8, 175u8, 143u8, 241u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    caller: topics.1,
                    upperBound: data.0,
                    randType: data.1,
                    seed: data.2,
                    result: data.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.upperBound),
                    <FheType as alloy_sol_types::SolType>::tokenize(&self.randType),
                    <alloy::sol_types::sol_data::FixedBytes<
                        16,
                    > as alloy_sol_types::SolType>::tokenize(&self.seed),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.caller.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.caller,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for FheRandBounded {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&FheRandBounded> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &FheRandBounded) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `FheRem(address,bytes32,bytes32,bytes1,bytes32)` and selector `0x0e691cd0bf8c4e9308e4ced1bb9c964117dc5c5bb9b9ab5bdfebf2c9b13a897c`.
```solidity
event FheRem(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct FheRem {
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for FheRem {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "FheRem(address,bytes32,bytes32,bytes1,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                14u8, 105u8, 28u8, 208u8, 191u8, 140u8, 78u8, 147u8, 8u8, 228u8, 206u8,
                209u8, 187u8, 156u8, 150u8, 65u8, 23u8, 220u8, 92u8, 91u8, 185u8, 185u8,
                171u8, 91u8, 223u8, 235u8, 242u8, 201u8, 177u8, 58u8, 137u8, 124u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    caller: topics.1,
                    lhs: data.0,
                    rhs: data.1,
                    scalarByte: data.2,
                    result: data.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.caller.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.caller,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for FheRem {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&FheRem> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &FheRem) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `FheRotl(address,bytes32,bytes32,bytes1,bytes32)` and selector `0xeb0e4f8dc74058194d0602425fe602f955c222200f7f10c6fe67992f7b24c7e9`.
```solidity
event FheRotl(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct FheRotl {
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for FheRotl {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "FheRotl(address,bytes32,bytes32,bytes1,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                235u8, 14u8, 79u8, 141u8, 199u8, 64u8, 88u8, 25u8, 77u8, 6u8, 2u8, 66u8,
                95u8, 230u8, 2u8, 249u8, 85u8, 194u8, 34u8, 32u8, 15u8, 127u8, 16u8,
                198u8, 254u8, 103u8, 153u8, 47u8, 123u8, 36u8, 199u8, 233u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    caller: topics.1,
                    lhs: data.0,
                    rhs: data.1,
                    scalarByte: data.2,
                    result: data.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.caller.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.caller,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for FheRotl {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&FheRotl> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &FheRotl) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `FheRotr(address,bytes32,bytes32,bytes1,bytes32)` and selector `0xc148675905d07ad5496f8ef4d8195c907503f3ec12fd10ed5f21240abc693634`.
```solidity
event FheRotr(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct FheRotr {
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for FheRotr {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "FheRotr(address,bytes32,bytes32,bytes1,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                193u8, 72u8, 103u8, 89u8, 5u8, 208u8, 122u8, 213u8, 73u8, 111u8, 142u8,
                244u8, 216u8, 25u8, 92u8, 144u8, 117u8, 3u8, 243u8, 236u8, 18u8, 253u8,
                16u8, 237u8, 95u8, 33u8, 36u8, 10u8, 188u8, 105u8, 54u8, 52u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    caller: topics.1,
                    lhs: data.0,
                    rhs: data.1,
                    scalarByte: data.2,
                    result: data.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.caller.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.caller,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for FheRotr {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&FheRotr> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &FheRotr) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `FheShl(address,bytes32,bytes32,bytes1,bytes32)` and selector `0xe84282aaebcca698443e39a2a948a345d0d2ebc654af5cb657a2d7e8053bf6cb`.
```solidity
event FheShl(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct FheShl {
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for FheShl {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "FheShl(address,bytes32,bytes32,bytes1,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                232u8, 66u8, 130u8, 170u8, 235u8, 204u8, 166u8, 152u8, 68u8, 62u8, 57u8,
                162u8, 169u8, 72u8, 163u8, 69u8, 208u8, 210u8, 235u8, 198u8, 84u8, 175u8,
                92u8, 182u8, 87u8, 162u8, 215u8, 232u8, 5u8, 59u8, 246u8, 203u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    caller: topics.1,
                    lhs: data.0,
                    rhs: data.1,
                    scalarByte: data.2,
                    result: data.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.caller.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.caller,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for FheShl {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&FheShl> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &FheShl) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `FheShr(address,bytes32,bytes32,bytes1,bytes32)` and selector `0x324220bfc9cb158b492991c03c309cd86e5345cac45aacae2092ddabe31fa3d8`.
```solidity
event FheShr(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct FheShr {
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for FheShr {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "FheShr(address,bytes32,bytes32,bytes1,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                50u8, 66u8, 32u8, 191u8, 201u8, 203u8, 21u8, 139u8, 73u8, 41u8, 145u8,
                192u8, 60u8, 48u8, 156u8, 216u8, 110u8, 83u8, 69u8, 202u8, 196u8, 90u8,
                172u8, 174u8, 32u8, 146u8, 221u8, 171u8, 227u8, 31u8, 163u8, 216u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    caller: topics.1,
                    lhs: data.0,
                    rhs: data.1,
                    scalarByte: data.2,
                    result: data.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.caller.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.caller,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for FheShr {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&FheShr> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &FheShr) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `FheSub(address,bytes32,bytes32,bytes1,bytes32)` and selector `0xeb6d37bd271abe1395b21d6d78f3487d6584862872c29ffd3f90736ee99b7393`.
```solidity
event FheSub(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct FheSub {
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for FheSub {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "FheSub(address,bytes32,bytes32,bytes1,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                235u8, 109u8, 55u8, 189u8, 39u8, 26u8, 190u8, 19u8, 149u8, 178u8, 29u8,
                109u8, 120u8, 243u8, 72u8, 125u8, 101u8, 132u8, 134u8, 40u8, 114u8,
                194u8, 159u8, 253u8, 63u8, 144u8, 115u8, 110u8, 233u8, 155u8, 115u8,
                147u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    caller: topics.1,
                    lhs: data.0,
                    rhs: data.1,
                    scalarByte: data.2,
                    result: data.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.caller.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.caller,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for FheSub {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&FheSub> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &FheSub) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `Initialized(uint64)` and selector `0xc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d2`.
```solidity
event Initialized(uint64 version);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Initialized {
        #[allow(missing_docs)]
        pub version: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Initialized {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "Initialized(uint64)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                199u8, 245u8, 5u8, 178u8, 243u8, 113u8, 174u8, 33u8, 117u8, 238u8, 73u8,
                19u8, 244u8, 73u8, 158u8, 31u8, 38u8, 51u8, 167u8, 181u8, 147u8, 99u8,
                33u8, 238u8, 209u8, 205u8, 174u8, 182u8, 17u8, 81u8, 129u8, 210u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { version: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.version),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Initialized {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Initialized> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Initialized) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `TrivialEncrypt(address,uint256,uint8,bytes32)` and selector `0x063ccd1bba45151d91f6a418065047a3d048d058a922535747bb2b575a01d236`.
```solidity
event TrivialEncrypt(address indexed caller, uint256 pt, FheType toType, bytes32 result);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct TrivialEncrypt {
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub pt: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub toType: <FheType as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for TrivialEncrypt {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                FheType,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "TrivialEncrypt(address,uint256,uint8,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                6u8, 60u8, 205u8, 27u8, 186u8, 69u8, 21u8, 29u8, 145u8, 246u8, 164u8,
                24u8, 6u8, 80u8, 71u8, 163u8, 208u8, 72u8, 208u8, 88u8, 169u8, 34u8,
                83u8, 87u8, 71u8, 187u8, 43u8, 87u8, 90u8, 1u8, 210u8, 54u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    caller: topics.1,
                    pt: data.0,
                    toType: data.1,
                    result: data.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.pt),
                    <FheType as alloy_sol_types::SolType>::tokenize(&self.toType),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.caller.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.caller,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for TrivialEncrypt {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&TrivialEncrypt> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &TrivialEncrypt) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `Upgraded(address)` and selector `0xbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b`.
```solidity
event Upgraded(address indexed implementation);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Upgraded {
        #[allow(missing_docs)]
        pub implementation: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Upgraded {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "Upgraded(address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                188u8, 124u8, 215u8, 90u8, 32u8, 238u8, 39u8, 253u8, 154u8, 222u8, 186u8,
                179u8, 32u8, 65u8, 247u8, 85u8, 33u8, 77u8, 188u8, 107u8, 255u8, 169u8,
                12u8, 192u8, 34u8, 91u8, 57u8, 218u8, 46u8, 92u8, 45u8, 59u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { implementation: topics.1 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.implementation.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.implementation,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Upgraded {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Upgraded> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Upgraded) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `VerifyInput(address,bytes32,address,bytes,uint8,bytes32)` and selector `0xdc370db33589e73371dc3ee42c789c003d336eefcb7c3f56fe0f51ae5b1d9702`.
```solidity
event VerifyInput(address indexed caller, bytes32 inputHandle, address userAddress, bytes inputProof, FheType inputType, bytes32 result);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct VerifyInput {
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub inputHandle: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub userAddress: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub inputProof: alloy::sol_types::private::Bytes,
        #[allow(missing_docs)]
        pub inputType: <FheType as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for VerifyInput {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bytes,
                FheType,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "VerifyInput(address,bytes32,address,bytes,uint8,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                220u8, 55u8, 13u8, 179u8, 53u8, 137u8, 231u8, 51u8, 113u8, 220u8, 62u8,
                228u8, 44u8, 120u8, 156u8, 0u8, 61u8, 51u8, 110u8, 239u8, 203u8, 124u8,
                63u8, 86u8, 254u8, 15u8, 81u8, 174u8, 91u8, 29u8, 151u8, 2u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    caller: topics.1,
                    inputHandle: data.0,
                    userAddress: data.1,
                    inputProof: data.2,
                    inputType: data.3,
                    result: data.4,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.inputHandle),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.userAddress,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.inputProof,
                    ),
                    <FheType as alloy_sol_types::SolType>::tokenize(&self.inputType),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.caller.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.caller,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for VerifyInput {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&VerifyInput> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &VerifyInput) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Constructor`.
```solidity
constructor();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct constructorCall {}
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<constructorCall> for UnderlyingRustTuple<'_> {
                fn from(value: constructorCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for constructorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolConstructor for constructorCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `UPGRADE_INTERFACE_VERSION()` and selector `0xad3cb1cc`.
```solidity
function UPGRADE_INTERFACE_VERSION() external view returns (string memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct UPGRADE_INTERFACE_VERSIONCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`UPGRADE_INTERFACE_VERSION()`](UPGRADE_INTERFACE_VERSIONCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct UPGRADE_INTERFACE_VERSIONReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UPGRADE_INTERFACE_VERSIONCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: UPGRADE_INTERFACE_VERSIONCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for UPGRADE_INTERFACE_VERSIONCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UPGRADE_INTERFACE_VERSIONReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: UPGRADE_INTERFACE_VERSIONReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for UPGRADE_INTERFACE_VERSIONReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for UPGRADE_INTERFACE_VERSIONCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::String;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "UPGRADE_INTERFACE_VERSION()";
            const SELECTOR: [u8; 4] = [173u8, 60u8, 177u8, 204u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: UPGRADE_INTERFACE_VERSIONReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: UPGRADE_INTERFACE_VERSIONReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `cast(bytes32,uint8)` and selector `0x1c89ee44`.
```solidity
function cast(bytes32 ct, FheType toType) external returns (bytes32 result);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct castCall {
        #[allow(missing_docs)]
        pub ct: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub toType: <FheType as alloy::sol_types::SolType>::RustType,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`cast(bytes32,uint8)`](castCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct castReturn {
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                FheType,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                <FheType as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<castCall> for UnderlyingRustTuple<'_> {
                fn from(value: castCall) -> Self {
                    (value.ct, value.toType)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for castCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        ct: tuple.0,
                        toType: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<castReturn> for UnderlyingRustTuple<'_> {
                fn from(value: castReturn) -> Self {
                    (value.result,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for castReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { result: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for castCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>, FheType);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "cast(bytes32,uint8)";
            const SELECTOR: [u8; 4] = [28u8, 137u8, 238u8, 68u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.ct),
                    <FheType as alloy_sol_types::SolType>::tokenize(&self.toType),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: castReturn = r.into();
                        r.result
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: castReturn = r.into();
                        r.result
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `fheAdd(bytes32,bytes32,bytes1)` and selector `0x117b2f38`.
```solidity
function fheAdd(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheAddCall {
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`fheAdd(bytes32,bytes32,bytes1)`](fheAddCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheAddReturn {
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<1>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheAddCall> for UnderlyingRustTuple<'_> {
                fn from(value: fheAddCall) -> Self {
                    (value.lhs, value.rhs, value.scalarByte)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheAddCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        lhs: tuple.0,
                        rhs: tuple.1,
                        scalarByte: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheAddReturn> for UnderlyingRustTuple<'_> {
                fn from(value: fheAddReturn) -> Self {
                    (value.result,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheAddReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { result: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for fheAddCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "fheAdd(bytes32,bytes32,bytes1)";
            const SELECTOR: [u8; 4] = [17u8, 123u8, 47u8, 56u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: fheAddReturn = r.into();
                        r.result
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: fheAddReturn = r.into();
                        r.result
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `fheBitAnd(bytes32,bytes32,bytes1)` and selector `0xd99882d5`.
```solidity
function fheBitAnd(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheBitAndCall {
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`fheBitAnd(bytes32,bytes32,bytes1)`](fheBitAndCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheBitAndReturn {
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<1>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheBitAndCall> for UnderlyingRustTuple<'_> {
                fn from(value: fheBitAndCall) -> Self {
                    (value.lhs, value.rhs, value.scalarByte)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheBitAndCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        lhs: tuple.0,
                        rhs: tuple.1,
                        scalarByte: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheBitAndReturn> for UnderlyingRustTuple<'_> {
                fn from(value: fheBitAndReturn) -> Self {
                    (value.result,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheBitAndReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { result: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for fheBitAndCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "fheBitAnd(bytes32,bytes32,bytes1)";
            const SELECTOR: [u8; 4] = [217u8, 152u8, 130u8, 213u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: fheBitAndReturn = r.into();
                        r.result
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: fheBitAndReturn = r.into();
                        r.result
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `fheBitOr(bytes32,bytes32,bytes1)` and selector `0x63a2db29`.
```solidity
function fheBitOr(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheBitOrCall {
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`fheBitOr(bytes32,bytes32,bytes1)`](fheBitOrCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheBitOrReturn {
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<1>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheBitOrCall> for UnderlyingRustTuple<'_> {
                fn from(value: fheBitOrCall) -> Self {
                    (value.lhs, value.rhs, value.scalarByte)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheBitOrCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        lhs: tuple.0,
                        rhs: tuple.1,
                        scalarByte: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheBitOrReturn> for UnderlyingRustTuple<'_> {
                fn from(value: fheBitOrReturn) -> Self {
                    (value.result,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheBitOrReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { result: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for fheBitOrCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "fheBitOr(bytes32,bytes32,bytes1)";
            const SELECTOR: [u8; 4] = [99u8, 162u8, 219u8, 41u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: fheBitOrReturn = r.into();
                        r.result
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: fheBitOrReturn = r.into();
                        r.result
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `fheBitXor(bytes32,bytes32,bytes1)` and selector `0x8b49ceb4`.
```solidity
function fheBitXor(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheBitXorCall {
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`fheBitXor(bytes32,bytes32,bytes1)`](fheBitXorCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheBitXorReturn {
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<1>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheBitXorCall> for UnderlyingRustTuple<'_> {
                fn from(value: fheBitXorCall) -> Self {
                    (value.lhs, value.rhs, value.scalarByte)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheBitXorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        lhs: tuple.0,
                        rhs: tuple.1,
                        scalarByte: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheBitXorReturn> for UnderlyingRustTuple<'_> {
                fn from(value: fheBitXorReturn) -> Self {
                    (value.result,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheBitXorReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { result: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for fheBitXorCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "fheBitXor(bytes32,bytes32,bytes1)";
            const SELECTOR: [u8; 4] = [139u8, 73u8, 206u8, 180u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: fheBitXorReturn = r.into();
                        r.result
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: fheBitXorReturn = r.into();
                        r.result
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `fheDiv(bytes32,bytes32,bytes1)` and selector `0x5a53accb`.
```solidity
function fheDiv(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheDivCall {
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`fheDiv(bytes32,bytes32,bytes1)`](fheDivCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheDivReturn {
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<1>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheDivCall> for UnderlyingRustTuple<'_> {
                fn from(value: fheDivCall) -> Self {
                    (value.lhs, value.rhs, value.scalarByte)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheDivCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        lhs: tuple.0,
                        rhs: tuple.1,
                        scalarByte: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheDivReturn> for UnderlyingRustTuple<'_> {
                fn from(value: fheDivReturn) -> Self {
                    (value.result,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheDivReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { result: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for fheDivCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "fheDiv(bytes32,bytes32,bytes1)";
            const SELECTOR: [u8; 4] = [90u8, 83u8, 172u8, 203u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: fheDivReturn = r.into();
                        r.result
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: fheDivReturn = r.into();
                        r.result
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `fheEq(bytes32,bytes32,bytes1)` and selector `0xf77f3f1d`.
```solidity
function fheEq(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheEqCall {
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`fheEq(bytes32,bytes32,bytes1)`](fheEqCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheEqReturn {
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<1>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheEqCall> for UnderlyingRustTuple<'_> {
                fn from(value: fheEqCall) -> Self {
                    (value.lhs, value.rhs, value.scalarByte)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheEqCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        lhs: tuple.0,
                        rhs: tuple.1,
                        scalarByte: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheEqReturn> for UnderlyingRustTuple<'_> {
                fn from(value: fheEqReturn) -> Self {
                    (value.result,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheEqReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { result: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for fheEqCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "fheEq(bytes32,bytes32,bytes1)";
            const SELECTOR: [u8; 4] = [247u8, 127u8, 63u8, 29u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: fheEqReturn = r.into();
                        r.result
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: fheEqReturn = r.into();
                        r.result
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `fheGe(bytes32,bytes32,bytes1)` and selector `0x1391547f`.
```solidity
function fheGe(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheGeCall {
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`fheGe(bytes32,bytes32,bytes1)`](fheGeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheGeReturn {
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<1>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheGeCall> for UnderlyingRustTuple<'_> {
                fn from(value: fheGeCall) -> Self {
                    (value.lhs, value.rhs, value.scalarByte)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheGeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        lhs: tuple.0,
                        rhs: tuple.1,
                        scalarByte: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheGeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: fheGeReturn) -> Self {
                    (value.result,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheGeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { result: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for fheGeCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "fheGe(bytes32,bytes32,bytes1)";
            const SELECTOR: [u8; 4] = [19u8, 145u8, 84u8, 127u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: fheGeReturn = r.into();
                        r.result
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: fheGeReturn = r.into();
                        r.result
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `fheGt(bytes32,bytes32,bytes1)` and selector `0x85362ee7`.
```solidity
function fheGt(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheGtCall {
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`fheGt(bytes32,bytes32,bytes1)`](fheGtCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheGtReturn {
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<1>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheGtCall> for UnderlyingRustTuple<'_> {
                fn from(value: fheGtCall) -> Self {
                    (value.lhs, value.rhs, value.scalarByte)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheGtCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        lhs: tuple.0,
                        rhs: tuple.1,
                        scalarByte: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheGtReturn> for UnderlyingRustTuple<'_> {
                fn from(value: fheGtReturn) -> Self {
                    (value.result,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheGtReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { result: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for fheGtCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "fheGt(bytes32,bytes32,bytes1)";
            const SELECTOR: [u8; 4] = [133u8, 54u8, 46u8, 231u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: fheGtReturn = r.into();
                        r.result
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: fheGtReturn = r.into();
                        r.result
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `fheIfThenElse(bytes32,bytes32,bytes32)` and selector `0x7702dcff`.
```solidity
function fheIfThenElse(bytes32 control, bytes32 ifTrue, bytes32 ifFalse) external returns (bytes32 result);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheIfThenElseCall {
        #[allow(missing_docs)]
        pub control: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub ifTrue: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub ifFalse: alloy::sol_types::private::FixedBytes<32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`fheIfThenElse(bytes32,bytes32,bytes32)`](fheIfThenElseCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheIfThenElseReturn {
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheIfThenElseCall> for UnderlyingRustTuple<'_> {
                fn from(value: fheIfThenElseCall) -> Self {
                    (value.control, value.ifTrue, value.ifFalse)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheIfThenElseCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        control: tuple.0,
                        ifTrue: tuple.1,
                        ifFalse: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheIfThenElseReturn> for UnderlyingRustTuple<'_> {
                fn from(value: fheIfThenElseReturn) -> Self {
                    (value.result,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheIfThenElseReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { result: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for fheIfThenElseCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "fheIfThenElse(bytes32,bytes32,bytes32)";
            const SELECTOR: [u8; 4] = [119u8, 2u8, 220u8, 255u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.control),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.ifTrue),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.ifFalse),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: fheIfThenElseReturn = r.into();
                        r.result
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: fheIfThenElseReturn = r.into();
                        r.result
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `fheLe(bytes32,bytes32,bytes1)` and selector `0x7513a404`.
```solidity
function fheLe(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheLeCall {
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`fheLe(bytes32,bytes32,bytes1)`](fheLeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheLeReturn {
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<1>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheLeCall> for UnderlyingRustTuple<'_> {
                fn from(value: fheLeCall) -> Self {
                    (value.lhs, value.rhs, value.scalarByte)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheLeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        lhs: tuple.0,
                        rhs: tuple.1,
                        scalarByte: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheLeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: fheLeReturn) -> Self {
                    (value.result,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheLeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { result: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for fheLeCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "fheLe(bytes32,bytes32,bytes1)";
            const SELECTOR: [u8; 4] = [117u8, 19u8, 164u8, 4u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: fheLeReturn = r.into();
                        r.result
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: fheLeReturn = r.into();
                        r.result
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `fheLt(bytes32,bytes32,bytes1)` and selector `0x72107681`.
```solidity
function fheLt(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheLtCall {
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`fheLt(bytes32,bytes32,bytes1)`](fheLtCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheLtReturn {
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<1>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheLtCall> for UnderlyingRustTuple<'_> {
                fn from(value: fheLtCall) -> Self {
                    (value.lhs, value.rhs, value.scalarByte)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheLtCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        lhs: tuple.0,
                        rhs: tuple.1,
                        scalarByte: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheLtReturn> for UnderlyingRustTuple<'_> {
                fn from(value: fheLtReturn) -> Self {
                    (value.result,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheLtReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { result: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for fheLtCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "fheLt(bytes32,bytes32,bytes1)";
            const SELECTOR: [u8; 4] = [114u8, 16u8, 118u8, 129u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: fheLtReturn = r.into();
                        r.result
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: fheLtReturn = r.into();
                        r.result
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `fheMax(bytes32,bytes32,bytes1)` and selector `0x36318d64`.
```solidity
function fheMax(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheMaxCall {
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`fheMax(bytes32,bytes32,bytes1)`](fheMaxCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheMaxReturn {
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<1>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheMaxCall> for UnderlyingRustTuple<'_> {
                fn from(value: fheMaxCall) -> Self {
                    (value.lhs, value.rhs, value.scalarByte)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheMaxCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        lhs: tuple.0,
                        rhs: tuple.1,
                        scalarByte: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheMaxReturn> for UnderlyingRustTuple<'_> {
                fn from(value: fheMaxReturn) -> Self {
                    (value.result,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheMaxReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { result: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for fheMaxCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "fheMax(bytes32,bytes32,bytes1)";
            const SELECTOR: [u8; 4] = [54u8, 49u8, 141u8, 100u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: fheMaxReturn = r.into();
                        r.result
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: fheMaxReturn = r.into();
                        r.result
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `fheMin(bytes32,bytes32,bytes1)` and selector `0x04559f71`.
```solidity
function fheMin(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheMinCall {
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`fheMin(bytes32,bytes32,bytes1)`](fheMinCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheMinReturn {
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<1>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheMinCall> for UnderlyingRustTuple<'_> {
                fn from(value: fheMinCall) -> Self {
                    (value.lhs, value.rhs, value.scalarByte)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheMinCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        lhs: tuple.0,
                        rhs: tuple.1,
                        scalarByte: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheMinReturn> for UnderlyingRustTuple<'_> {
                fn from(value: fheMinReturn) -> Self {
                    (value.result,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheMinReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { result: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for fheMinCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "fheMin(bytes32,bytes32,bytes1)";
            const SELECTOR: [u8; 4] = [4u8, 85u8, 159u8, 113u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: fheMinReturn = r.into();
                        r.result
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: fheMinReturn = r.into();
                        r.result
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `fheMul(bytes32,bytes32,bytes1)` and selector `0x57f0a568`.
```solidity
function fheMul(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheMulCall {
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`fheMul(bytes32,bytes32,bytes1)`](fheMulCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheMulReturn {
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<1>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheMulCall> for UnderlyingRustTuple<'_> {
                fn from(value: fheMulCall) -> Self {
                    (value.lhs, value.rhs, value.scalarByte)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheMulCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        lhs: tuple.0,
                        rhs: tuple.1,
                        scalarByte: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheMulReturn> for UnderlyingRustTuple<'_> {
                fn from(value: fheMulReturn) -> Self {
                    (value.result,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheMulReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { result: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for fheMulCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "fheMul(bytes32,bytes32,bytes1)";
            const SELECTOR: [u8; 4] = [87u8, 240u8, 165u8, 104u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: fheMulReturn = r.into();
                        r.result
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: fheMulReturn = r.into();
                        r.result
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `fheNe(bytes32,bytes32,bytes1)` and selector `0xd8092cbc`.
```solidity
function fheNe(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheNeCall {
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`fheNe(bytes32,bytes32,bytes1)`](fheNeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheNeReturn {
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<1>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheNeCall> for UnderlyingRustTuple<'_> {
                fn from(value: fheNeCall) -> Self {
                    (value.lhs, value.rhs, value.scalarByte)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheNeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        lhs: tuple.0,
                        rhs: tuple.1,
                        scalarByte: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheNeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: fheNeReturn) -> Self {
                    (value.result,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheNeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { result: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for fheNeCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "fheNe(bytes32,bytes32,bytes1)";
            const SELECTOR: [u8; 4] = [216u8, 9u8, 44u8, 188u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: fheNeReturn = r.into();
                        r.result
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: fheNeReturn = r.into();
                        r.result
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `fheNeg(bytes32)` and selector `0xd580c063`.
```solidity
function fheNeg(bytes32 ct) external returns (bytes32 result);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheNegCall {
        #[allow(missing_docs)]
        pub ct: alloy::sol_types::private::FixedBytes<32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`fheNeg(bytes32)`](fheNegCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheNegReturn {
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheNegCall> for UnderlyingRustTuple<'_> {
                fn from(value: fheNegCall) -> Self {
                    (value.ct,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheNegCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { ct: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheNegReturn> for UnderlyingRustTuple<'_> {
                fn from(value: fheNegReturn) -> Self {
                    (value.result,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheNegReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { result: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for fheNegCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "fheNeg(bytes32)";
            const SELECTOR: [u8; 4] = [213u8, 128u8, 192u8, 99u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.ct),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: fheNegReturn = r.into();
                        r.result
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: fheNegReturn = r.into();
                        r.result
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `fheNot(bytes32)` and selector `0xf51ccfb0`.
```solidity
function fheNot(bytes32 ct) external returns (bytes32 result);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheNotCall {
        #[allow(missing_docs)]
        pub ct: alloy::sol_types::private::FixedBytes<32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`fheNot(bytes32)`](fheNotCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheNotReturn {
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheNotCall> for UnderlyingRustTuple<'_> {
                fn from(value: fheNotCall) -> Self {
                    (value.ct,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheNotCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { ct: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheNotReturn> for UnderlyingRustTuple<'_> {
                fn from(value: fheNotReturn) -> Self {
                    (value.result,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheNotReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { result: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for fheNotCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "fheNot(bytes32)";
            const SELECTOR: [u8; 4] = [245u8, 28u8, 207u8, 176u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.ct),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: fheNotReturn = r.into();
                        r.result
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: fheNotReturn = r.into();
                        r.result
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `fheRand(uint8)` and selector `0xd75d6e8a`.
```solidity
function fheRand(FheType randType) external returns (bytes32 result);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheRandCall {
        #[allow(missing_docs)]
        pub randType: <FheType as alloy::sol_types::SolType>::RustType,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`fheRand(uint8)`](fheRandCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheRandReturn {
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (FheType,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <FheType as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheRandCall> for UnderlyingRustTuple<'_> {
                fn from(value: fheRandCall) -> Self {
                    (value.randType,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheRandCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { randType: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheRandReturn> for UnderlyingRustTuple<'_> {
                fn from(value: fheRandReturn) -> Self {
                    (value.result,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheRandReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { result: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for fheRandCall {
            type Parameters<'a> = (FheType,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "fheRand(uint8)";
            const SELECTOR: [u8; 4] = [215u8, 93u8, 110u8, 138u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<FheType as alloy_sol_types::SolType>::tokenize(&self.randType),)
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: fheRandReturn = r.into();
                        r.result
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: fheRandReturn = r.into();
                        r.result
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `fheRandBounded(uint256,uint8)` and selector `0x48eef47e`.
```solidity
function fheRandBounded(uint256 upperBound, FheType randType) external returns (bytes32 result);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheRandBoundedCall {
        #[allow(missing_docs)]
        pub upperBound: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub randType: <FheType as alloy::sol_types::SolType>::RustType,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`fheRandBounded(uint256,uint8)`](fheRandBoundedCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheRandBoundedReturn {
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                FheType,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                <FheType as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheRandBoundedCall> for UnderlyingRustTuple<'_> {
                fn from(value: fheRandBoundedCall) -> Self {
                    (value.upperBound, value.randType)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheRandBoundedCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        upperBound: tuple.0,
                        randType: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheRandBoundedReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: fheRandBoundedReturn) -> Self {
                    (value.result,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for fheRandBoundedReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { result: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for fheRandBoundedCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>, FheType);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "fheRandBounded(uint256,uint8)";
            const SELECTOR: [u8; 4] = [72u8, 238u8, 244u8, 126u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.upperBound),
                    <FheType as alloy_sol_types::SolType>::tokenize(&self.randType),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: fheRandBoundedReturn = r.into();
                        r.result
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: fheRandBoundedReturn = r.into();
                        r.result
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `fheRem(bytes32,bytes32,bytes1)` and selector `0xcf4d18aa`.
```solidity
function fheRem(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheRemCall {
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`fheRem(bytes32,bytes32,bytes1)`](fheRemCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheRemReturn {
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<1>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheRemCall> for UnderlyingRustTuple<'_> {
                fn from(value: fheRemCall) -> Self {
                    (value.lhs, value.rhs, value.scalarByte)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheRemCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        lhs: tuple.0,
                        rhs: tuple.1,
                        scalarByte: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheRemReturn> for UnderlyingRustTuple<'_> {
                fn from(value: fheRemReturn) -> Self {
                    (value.result,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheRemReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { result: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for fheRemCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "fheRem(bytes32,bytes32,bytes1)";
            const SELECTOR: [u8; 4] = [207u8, 77u8, 24u8, 170u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: fheRemReturn = r.into();
                        r.result
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: fheRemReturn = r.into();
                        r.result
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `fheRotl(bytes32,bytes32,bytes1)` and selector `0x6754b360`.
```solidity
function fheRotl(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheRotlCall {
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`fheRotl(bytes32,bytes32,bytes1)`](fheRotlCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheRotlReturn {
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<1>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheRotlCall> for UnderlyingRustTuple<'_> {
                fn from(value: fheRotlCall) -> Self {
                    (value.lhs, value.rhs, value.scalarByte)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheRotlCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        lhs: tuple.0,
                        rhs: tuple.1,
                        scalarByte: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheRotlReturn> for UnderlyingRustTuple<'_> {
                fn from(value: fheRotlReturn) -> Self {
                    (value.result,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheRotlReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { result: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for fheRotlCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "fheRotl(bytes32,bytes32,bytes1)";
            const SELECTOR: [u8; 4] = [103u8, 84u8, 179u8, 96u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: fheRotlReturn = r.into();
                        r.result
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: fheRotlReturn = r.into();
                        r.result
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `fheRotr(bytes32,bytes32,bytes1)` and selector `0xc021329e`.
```solidity
function fheRotr(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheRotrCall {
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`fheRotr(bytes32,bytes32,bytes1)`](fheRotrCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheRotrReturn {
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<1>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheRotrCall> for UnderlyingRustTuple<'_> {
                fn from(value: fheRotrCall) -> Self {
                    (value.lhs, value.rhs, value.scalarByte)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheRotrCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        lhs: tuple.0,
                        rhs: tuple.1,
                        scalarByte: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheRotrReturn> for UnderlyingRustTuple<'_> {
                fn from(value: fheRotrReturn) -> Self {
                    (value.result,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheRotrReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { result: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for fheRotrCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "fheRotr(bytes32,bytes32,bytes1)";
            const SELECTOR: [u8; 4] = [192u8, 33u8, 50u8, 158u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: fheRotrReturn = r.into();
                        r.result
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: fheRotrReturn = r.into();
                        r.result
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `fheShl(bytes32,bytes32,bytes1)` and selector `0xccc480a1`.
```solidity
function fheShl(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheShlCall {
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`fheShl(bytes32,bytes32,bytes1)`](fheShlCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheShlReturn {
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<1>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheShlCall> for UnderlyingRustTuple<'_> {
                fn from(value: fheShlCall) -> Self {
                    (value.lhs, value.rhs, value.scalarByte)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheShlCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        lhs: tuple.0,
                        rhs: tuple.1,
                        scalarByte: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheShlReturn> for UnderlyingRustTuple<'_> {
                fn from(value: fheShlReturn) -> Self {
                    (value.result,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheShlReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { result: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for fheShlCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "fheShl(bytes32,bytes32,bytes1)";
            const SELECTOR: [u8; 4] = [204u8, 196u8, 128u8, 161u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: fheShlReturn = r.into();
                        r.result
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: fheShlReturn = r.into();
                        r.result
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `fheShr(bytes32,bytes32,bytes1)` and selector `0x91f98ffe`.
```solidity
function fheShr(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheShrCall {
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`fheShr(bytes32,bytes32,bytes1)`](fheShrCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheShrReturn {
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<1>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheShrCall> for UnderlyingRustTuple<'_> {
                fn from(value: fheShrCall) -> Self {
                    (value.lhs, value.rhs, value.scalarByte)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheShrCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        lhs: tuple.0,
                        rhs: tuple.1,
                        scalarByte: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheShrReturn> for UnderlyingRustTuple<'_> {
                fn from(value: fheShrReturn) -> Self {
                    (value.result,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheShrReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { result: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for fheShrCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "fheShr(bytes32,bytes32,bytes1)";
            const SELECTOR: [u8; 4] = [145u8, 249u8, 143u8, 254u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: fheShrReturn = r.into();
                        r.result
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: fheShrReturn = r.into();
                        r.result
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `fheSub(bytes32,bytes32,bytes1)` and selector `0x182b6d98`.
```solidity
function fheSub(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheSubCall {
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`fheSub(bytes32,bytes32,bytes1)`](fheSubCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheSubReturn {
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<1>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheSubCall> for UnderlyingRustTuple<'_> {
                fn from(value: fheSubCall) -> Self {
                    (value.lhs, value.rhs, value.scalarByte)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheSubCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        lhs: tuple.0,
                        rhs: tuple.1,
                        scalarByte: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheSubReturn> for UnderlyingRustTuple<'_> {
                fn from(value: fheSubReturn) -> Self {
                    (value.result,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheSubReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { result: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for fheSubCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "fheSub(bytes32,bytes32,bytes1)";
            const SELECTOR: [u8; 4] = [24u8, 43u8, 109u8, 152u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: fheSubReturn = r.into();
                        r.result
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: fheSubReturn = r.into();
                        r.result
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getACLAddress()` and selector `0xf6859bdc`.
```solidity
function getACLAddress() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getACLAddressCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getACLAddress()`](getACLAddressCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getACLAddressReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getACLAddressCall> for UnderlyingRustTuple<'_> {
                fn from(value: getACLAddressCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getACLAddressCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getACLAddressReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getACLAddressReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getACLAddressReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getACLAddressCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getACLAddress()";
            const SELECTOR: [u8; 4] = [246u8, 133u8, 155u8, 220u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getACLAddressReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getACLAddressReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getHCULimitAddress()` and selector `0xe0786972`.
```solidity
function getHCULimitAddress() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getHCULimitAddressCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getHCULimitAddress()`](getHCULimitAddressCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getHCULimitAddressReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getHCULimitAddressCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getHCULimitAddressCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getHCULimitAddressCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getHCULimitAddressReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getHCULimitAddressReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getHCULimitAddressReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getHCULimitAddressCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getHCULimitAddress()";
            const SELECTOR: [u8; 4] = [224u8, 120u8, 105u8, 114u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getHCULimitAddressReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getHCULimitAddressReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getHandleVersion()` and selector `0x7a297f4b`.
```solidity
function getHandleVersion() external pure returns (uint8);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getHandleVersionCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getHandleVersion()`](getHandleVersionCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getHandleVersionReturn {
        #[allow(missing_docs)]
        pub _0: u8,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getHandleVersionCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getHandleVersionCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getHandleVersionCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<8>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u8,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getHandleVersionReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getHandleVersionReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getHandleVersionReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getHandleVersionCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = u8;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<8>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getHandleVersion()";
            const SELECTOR: [u8; 4] = [122u8, 41u8, 127u8, 75u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getHandleVersionReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getHandleVersionReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getInputVerifierAddress()` and selector `0xa8c7c2c1`.
```solidity
function getInputVerifierAddress() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getInputVerifierAddressCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getInputVerifierAddress()`](getInputVerifierAddressCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getInputVerifierAddressReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getInputVerifierAddressCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getInputVerifierAddressCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getInputVerifierAddressCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getInputVerifierAddressReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getInputVerifierAddressReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getInputVerifierAddressReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getInputVerifierAddressCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getInputVerifierAddress()";
            const SELECTOR: [u8; 4] = [168u8, 199u8, 194u8, 193u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getInputVerifierAddressReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getInputVerifierAddressReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getVersion()` and selector `0x0d8e6e2c`.
```solidity
function getVersion() external pure returns (string memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getVersionCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getVersion()`](getVersionCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getVersionReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getVersionCall> for UnderlyingRustTuple<'_> {
                fn from(value: getVersionCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getVersionCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getVersionReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getVersionReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getVersionReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getVersionCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::String;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getVersion()";
            const SELECTOR: [u8; 4] = [13u8, 142u8, 110u8, 44u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getVersionReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getVersionReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `initializeFromEmptyProxy()` and selector `0x39f73810`.
```solidity
function initializeFromEmptyProxy() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct initializeFromEmptyProxyCall;
    ///Container type for the return parameters of the [`initializeFromEmptyProxy()`](initializeFromEmptyProxyCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct initializeFromEmptyProxyReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<initializeFromEmptyProxyCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: initializeFromEmptyProxyCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for initializeFromEmptyProxyCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<initializeFromEmptyProxyReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: initializeFromEmptyProxyReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for initializeFromEmptyProxyReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl initializeFromEmptyProxyReturn {
            fn _tokenize(
                &self,
            ) -> <initializeFromEmptyProxyCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for initializeFromEmptyProxyCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = initializeFromEmptyProxyReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "initializeFromEmptyProxy()";
            const SELECTOR: [u8; 4] = [57u8, 247u8, 56u8, 16u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                initializeFromEmptyProxyReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `proxiableUUID()` and selector `0x52d1902d`.
```solidity
function proxiableUUID() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct proxiableUUIDCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`proxiableUUID()`](proxiableUUIDCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct proxiableUUIDReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<proxiableUUIDCall> for UnderlyingRustTuple<'_> {
                fn from(value: proxiableUUIDCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for proxiableUUIDCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<proxiableUUIDReturn> for UnderlyingRustTuple<'_> {
                fn from(value: proxiableUUIDReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for proxiableUUIDReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for proxiableUUIDCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "proxiableUUID()";
            const SELECTOR: [u8; 4] = [82u8, 209u8, 144u8, 45u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: proxiableUUIDReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: proxiableUUIDReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `reinitializeV3()` and selector `0xbac22bb8`.
```solidity
function reinitializeV3() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct reinitializeV3Call;
    ///Container type for the return parameters of the [`reinitializeV3()`](reinitializeV3Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct reinitializeV3Return {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<reinitializeV3Call> for UnderlyingRustTuple<'_> {
                fn from(value: reinitializeV3Call) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for reinitializeV3Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<reinitializeV3Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: reinitializeV3Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for reinitializeV3Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl reinitializeV3Return {
            fn _tokenize(
                &self,
            ) -> <reinitializeV3Call as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for reinitializeV3Call {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = reinitializeV3Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "reinitializeV3()";
            const SELECTOR: [u8; 4] = [186u8, 194u8, 43u8, 184u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                reinitializeV3Return::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `trivialEncrypt(uint256,uint8)` and selector `0x9cd07acb`.
```solidity
function trivialEncrypt(uint256 pt, FheType toType) external returns (bytes32 result);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct trivialEncryptCall {
        #[allow(missing_docs)]
        pub pt: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub toType: <FheType as alloy::sol_types::SolType>::RustType,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`trivialEncrypt(uint256,uint8)`](trivialEncryptCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct trivialEncryptReturn {
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                FheType,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                <FheType as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<trivialEncryptCall> for UnderlyingRustTuple<'_> {
                fn from(value: trivialEncryptCall) -> Self {
                    (value.pt, value.toType)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for trivialEncryptCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        pt: tuple.0,
                        toType: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<trivialEncryptReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: trivialEncryptReturn) -> Self {
                    (value.result,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for trivialEncryptReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { result: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for trivialEncryptCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>, FheType);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "trivialEncrypt(uint256,uint8)";
            const SELECTOR: [u8; 4] = [156u8, 208u8, 122u8, 203u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.pt),
                    <FheType as alloy_sol_types::SolType>::tokenize(&self.toType),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: trivialEncryptReturn = r.into();
                        r.result
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: trivialEncryptReturn = r.into();
                        r.result
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `upgradeToAndCall(address,bytes)` and selector `0x4f1ef286`.
```solidity
function upgradeToAndCall(address newImplementation, bytes memory data) external payable;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct upgradeToAndCallCall {
        #[allow(missing_docs)]
        pub newImplementation: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub data: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`upgradeToAndCall(address,bytes)`](upgradeToAndCallCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct upgradeToAndCallReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<upgradeToAndCallCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: upgradeToAndCallCall) -> Self {
                    (value.newImplementation, value.data)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for upgradeToAndCallCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        newImplementation: tuple.0,
                        data: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<upgradeToAndCallReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: upgradeToAndCallReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for upgradeToAndCallReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl upgradeToAndCallReturn {
            fn _tokenize(
                &self,
            ) -> <upgradeToAndCallCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for upgradeToAndCallCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = upgradeToAndCallReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "upgradeToAndCall(address,bytes)";
            const SELECTOR: [u8; 4] = [79u8, 30u8, 242u8, 134u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.newImplementation,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.data,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                upgradeToAndCallReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `verifyInput(bytes32,address,bytes,uint8)` and selector `0x08bf832a`.
```solidity
function verifyInput(bytes32 inputHandle, address userAddress, bytes memory inputProof, FheType inputType) external returns (bytes32 result);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct verifyInputCall {
        #[allow(missing_docs)]
        pub inputHandle: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub userAddress: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub inputProof: alloy::sol_types::private::Bytes,
        #[allow(missing_docs)]
        pub inputType: <FheType as alloy::sol_types::SolType>::RustType,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`verifyInput(bytes32,address,bytes,uint8)`](verifyInputCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct verifyInputReturn {
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bytes,
                FheType,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Bytes,
                <FheType as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<verifyInputCall> for UnderlyingRustTuple<'_> {
                fn from(value: verifyInputCall) -> Self {
                    (
                        value.inputHandle,
                        value.userAddress,
                        value.inputProof,
                        value.inputType,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for verifyInputCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        inputHandle: tuple.0,
                        userAddress: tuple.1,
                        inputProof: tuple.2,
                        inputType: tuple.3,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<verifyInputReturn> for UnderlyingRustTuple<'_> {
                fn from(value: verifyInputReturn) -> Self {
                    (value.result,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for verifyInputReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { result: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for verifyInputCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bytes,
                FheType,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "verifyInput(bytes32,address,bytes,uint8)";
            const SELECTOR: [u8; 4] = [8u8, 191u8, 131u8, 42u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.inputHandle),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.userAddress,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.inputProof,
                    ),
                    <FheType as alloy_sol_types::SolType>::tokenize(&self.inputType),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: verifyInputReturn = r.into();
                        r.result
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: verifyInputReturn = r.into();
                        r.result
                    })
            }
        }
    };
    ///Container for all the [`FHEVMExecutor`](self) function calls.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive()]
    pub enum FHEVMExecutorCalls {
        #[allow(missing_docs)]
        UPGRADE_INTERFACE_VERSION(UPGRADE_INTERFACE_VERSIONCall),
        #[allow(missing_docs)]
        cast(castCall),
        #[allow(missing_docs)]
        fheAdd(fheAddCall),
        #[allow(missing_docs)]
        fheBitAnd(fheBitAndCall),
        #[allow(missing_docs)]
        fheBitOr(fheBitOrCall),
        #[allow(missing_docs)]
        fheBitXor(fheBitXorCall),
        #[allow(missing_docs)]
        fheDiv(fheDivCall),
        #[allow(missing_docs)]
        fheEq(fheEqCall),
        #[allow(missing_docs)]
        fheGe(fheGeCall),
        #[allow(missing_docs)]
        fheGt(fheGtCall),
        #[allow(missing_docs)]
        fheIfThenElse(fheIfThenElseCall),
        #[allow(missing_docs)]
        fheLe(fheLeCall),
        #[allow(missing_docs)]
        fheLt(fheLtCall),
        #[allow(missing_docs)]
        fheMax(fheMaxCall),
        #[allow(missing_docs)]
        fheMin(fheMinCall),
        #[allow(missing_docs)]
        fheMul(fheMulCall),
        #[allow(missing_docs)]
        fheNe(fheNeCall),
        #[allow(missing_docs)]
        fheNeg(fheNegCall),
        #[allow(missing_docs)]
        fheNot(fheNotCall),
        #[allow(missing_docs)]
        fheRand(fheRandCall),
        #[allow(missing_docs)]
        fheRandBounded(fheRandBoundedCall),
        #[allow(missing_docs)]
        fheRem(fheRemCall),
        #[allow(missing_docs)]
        fheRotl(fheRotlCall),
        #[allow(missing_docs)]
        fheRotr(fheRotrCall),
        #[allow(missing_docs)]
        fheShl(fheShlCall),
        #[allow(missing_docs)]
        fheShr(fheShrCall),
        #[allow(missing_docs)]
        fheSub(fheSubCall),
        #[allow(missing_docs)]
        getACLAddress(getACLAddressCall),
        #[allow(missing_docs)]
        getHCULimitAddress(getHCULimitAddressCall),
        #[allow(missing_docs)]
        getHandleVersion(getHandleVersionCall),
        #[allow(missing_docs)]
        getInputVerifierAddress(getInputVerifierAddressCall),
        #[allow(missing_docs)]
        getVersion(getVersionCall),
        #[allow(missing_docs)]
        initializeFromEmptyProxy(initializeFromEmptyProxyCall),
        #[allow(missing_docs)]
        proxiableUUID(proxiableUUIDCall),
        #[allow(missing_docs)]
        reinitializeV3(reinitializeV3Call),
        #[allow(missing_docs)]
        trivialEncrypt(trivialEncryptCall),
        #[allow(missing_docs)]
        upgradeToAndCall(upgradeToAndCallCall),
        #[allow(missing_docs)]
        verifyInput(verifyInputCall),
    }
    #[automatically_derived]
    impl FHEVMExecutorCalls {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [4u8, 85u8, 159u8, 113u8],
            [8u8, 191u8, 131u8, 42u8],
            [13u8, 142u8, 110u8, 44u8],
            [17u8, 123u8, 47u8, 56u8],
            [19u8, 145u8, 84u8, 127u8],
            [24u8, 43u8, 109u8, 152u8],
            [28u8, 137u8, 238u8, 68u8],
            [54u8, 49u8, 141u8, 100u8],
            [57u8, 247u8, 56u8, 16u8],
            [72u8, 238u8, 244u8, 126u8],
            [79u8, 30u8, 242u8, 134u8],
            [82u8, 209u8, 144u8, 45u8],
            [87u8, 240u8, 165u8, 104u8],
            [90u8, 83u8, 172u8, 203u8],
            [99u8, 162u8, 219u8, 41u8],
            [103u8, 84u8, 179u8, 96u8],
            [114u8, 16u8, 118u8, 129u8],
            [117u8, 19u8, 164u8, 4u8],
            [119u8, 2u8, 220u8, 255u8],
            [122u8, 41u8, 127u8, 75u8],
            [133u8, 54u8, 46u8, 231u8],
            [139u8, 73u8, 206u8, 180u8],
            [145u8, 249u8, 143u8, 254u8],
            [156u8, 208u8, 122u8, 203u8],
            [168u8, 199u8, 194u8, 193u8],
            [173u8, 60u8, 177u8, 204u8],
            [186u8, 194u8, 43u8, 184u8],
            [192u8, 33u8, 50u8, 158u8],
            [204u8, 196u8, 128u8, 161u8],
            [207u8, 77u8, 24u8, 170u8],
            [213u8, 128u8, 192u8, 99u8],
            [215u8, 93u8, 110u8, 138u8],
            [216u8, 9u8, 44u8, 188u8],
            [217u8, 152u8, 130u8, 213u8],
            [224u8, 120u8, 105u8, 114u8],
            [245u8, 28u8, 207u8, 176u8],
            [246u8, 133u8, 155u8, 220u8],
            [247u8, 127u8, 63u8, 29u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for FHEVMExecutorCalls {
        const NAME: &'static str = "FHEVMExecutorCalls";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 38usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::UPGRADE_INTERFACE_VERSION(_) => {
                    <UPGRADE_INTERFACE_VERSIONCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::cast(_) => <castCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::fheAdd(_) => <fheAddCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::fheBitAnd(_) => {
                    <fheBitAndCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::fheBitOr(_) => <fheBitOrCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::fheBitXor(_) => {
                    <fheBitXorCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::fheDiv(_) => <fheDivCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::fheEq(_) => <fheEqCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::fheGe(_) => <fheGeCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::fheGt(_) => <fheGtCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::fheIfThenElse(_) => {
                    <fheIfThenElseCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::fheLe(_) => <fheLeCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::fheLt(_) => <fheLtCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::fheMax(_) => <fheMaxCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::fheMin(_) => <fheMinCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::fheMul(_) => <fheMulCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::fheNe(_) => <fheNeCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::fheNeg(_) => <fheNegCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::fheNot(_) => <fheNotCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::fheRand(_) => <fheRandCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::fheRandBounded(_) => {
                    <fheRandBoundedCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::fheRem(_) => <fheRemCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::fheRotl(_) => <fheRotlCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::fheRotr(_) => <fheRotrCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::fheShl(_) => <fheShlCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::fheShr(_) => <fheShrCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::fheSub(_) => <fheSubCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::getACLAddress(_) => {
                    <getACLAddressCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getHCULimitAddress(_) => {
                    <getHCULimitAddressCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getHandleVersion(_) => {
                    <getHandleVersionCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getInputVerifierAddress(_) => {
                    <getInputVerifierAddressCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getVersion(_) => {
                    <getVersionCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::initializeFromEmptyProxy(_) => {
                    <initializeFromEmptyProxyCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::proxiableUUID(_) => {
                    <proxiableUUIDCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::reinitializeV3(_) => {
                    <reinitializeV3Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::trivialEncrypt(_) => {
                    <trivialEncryptCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::upgradeToAndCall(_) => {
                    <upgradeToAndCallCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::verifyInput(_) => {
                    <verifyInputCall as alloy_sol_types::SolCall>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<FHEVMExecutorCalls>] = &[
                {
                    fn fheMin(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheMinCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(FHEVMExecutorCalls::fheMin)
                    }
                    fheMin
                },
                {
                    fn verifyInput(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <verifyInputCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(FHEVMExecutorCalls::verifyInput)
                    }
                    verifyInput
                },
                {
                    fn getVersion(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <getVersionCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(FHEVMExecutorCalls::getVersion)
                    }
                    getVersion
                },
                {
                    fn fheAdd(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheAddCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(FHEVMExecutorCalls::fheAdd)
                    }
                    fheAdd
                },
                {
                    fn fheGe(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheGeCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(FHEVMExecutorCalls::fheGe)
                    }
                    fheGe
                },
                {
                    fn fheSub(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheSubCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(FHEVMExecutorCalls::fheSub)
                    }
                    fheSub
                },
                {
                    fn cast(data: &[u8]) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <castCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(FHEVMExecutorCalls::cast)
                    }
                    cast
                },
                {
                    fn fheMax(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheMaxCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(FHEVMExecutorCalls::fheMax)
                    }
                    fheMax
                },
                {
                    fn initializeFromEmptyProxy(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <initializeFromEmptyProxyCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(FHEVMExecutorCalls::initializeFromEmptyProxy)
                    }
                    initializeFromEmptyProxy
                },
                {
                    fn fheRandBounded(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheRandBoundedCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(FHEVMExecutorCalls::fheRandBounded)
                    }
                    fheRandBounded
                },
                {
                    fn upgradeToAndCall(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <upgradeToAndCallCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(FHEVMExecutorCalls::upgradeToAndCall)
                    }
                    upgradeToAndCall
                },
                {
                    fn proxiableUUID(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <proxiableUUIDCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(FHEVMExecutorCalls::proxiableUUID)
                    }
                    proxiableUUID
                },
                {
                    fn fheMul(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheMulCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(FHEVMExecutorCalls::fheMul)
                    }
                    fheMul
                },
                {
                    fn fheDiv(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheDivCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(FHEVMExecutorCalls::fheDiv)
                    }
                    fheDiv
                },
                {
                    fn fheBitOr(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheBitOrCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(FHEVMExecutorCalls::fheBitOr)
                    }
                    fheBitOr
                },
                {
                    fn fheRotl(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheRotlCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(FHEVMExecutorCalls::fheRotl)
                    }
                    fheRotl
                },
                {
                    fn fheLt(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheLtCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(FHEVMExecutorCalls::fheLt)
                    }
                    fheLt
                },
                {
                    fn fheLe(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheLeCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(FHEVMExecutorCalls::fheLe)
                    }
                    fheLe
                },
                {
                    fn fheIfThenElse(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheIfThenElseCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(FHEVMExecutorCalls::fheIfThenElse)
                    }
                    fheIfThenElse
                },
                {
                    fn getHandleVersion(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <getHandleVersionCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(FHEVMExecutorCalls::getHandleVersion)
                    }
                    getHandleVersion
                },
                {
                    fn fheGt(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheGtCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(FHEVMExecutorCalls::fheGt)
                    }
                    fheGt
                },
                {
                    fn fheBitXor(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheBitXorCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(FHEVMExecutorCalls::fheBitXor)
                    }
                    fheBitXor
                },
                {
                    fn fheShr(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheShrCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(FHEVMExecutorCalls::fheShr)
                    }
                    fheShr
                },
                {
                    fn trivialEncrypt(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <trivialEncryptCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(FHEVMExecutorCalls::trivialEncrypt)
                    }
                    trivialEncrypt
                },
                {
                    fn getInputVerifierAddress(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <getInputVerifierAddressCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(FHEVMExecutorCalls::getInputVerifierAddress)
                    }
                    getInputVerifierAddress
                },
                {
                    fn UPGRADE_INTERFACE_VERSION(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <UPGRADE_INTERFACE_VERSIONCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(FHEVMExecutorCalls::UPGRADE_INTERFACE_VERSION)
                    }
                    UPGRADE_INTERFACE_VERSION
                },
                {
                    fn reinitializeV3(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <reinitializeV3Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(FHEVMExecutorCalls::reinitializeV3)
                    }
                    reinitializeV3
                },
                {
                    fn fheRotr(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheRotrCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(FHEVMExecutorCalls::fheRotr)
                    }
                    fheRotr
                },
                {
                    fn fheShl(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheShlCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(FHEVMExecutorCalls::fheShl)
                    }
                    fheShl
                },
                {
                    fn fheRem(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheRemCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(FHEVMExecutorCalls::fheRem)
                    }
                    fheRem
                },
                {
                    fn fheNeg(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheNegCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(FHEVMExecutorCalls::fheNeg)
                    }
                    fheNeg
                },
                {
                    fn fheRand(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheRandCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(FHEVMExecutorCalls::fheRand)
                    }
                    fheRand
                },
                {
                    fn fheNe(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheNeCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(FHEVMExecutorCalls::fheNe)
                    }
                    fheNe
                },
                {
                    fn fheBitAnd(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheBitAndCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(FHEVMExecutorCalls::fheBitAnd)
                    }
                    fheBitAnd
                },
                {
                    fn getHCULimitAddress(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <getHCULimitAddressCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(FHEVMExecutorCalls::getHCULimitAddress)
                    }
                    getHCULimitAddress
                },
                {
                    fn fheNot(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheNotCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(FHEVMExecutorCalls::fheNot)
                    }
                    fheNot
                },
                {
                    fn getACLAddress(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <getACLAddressCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(FHEVMExecutorCalls::getACLAddress)
                    }
                    getACLAddress
                },
                {
                    fn fheEq(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheEqCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(FHEVMExecutorCalls::fheEq)
                    }
                    fheEq
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data)
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw_validate(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_VALIDATE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<FHEVMExecutorCalls>] = &[
                {
                    fn fheMin(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheMinCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::fheMin)
                    }
                    fheMin
                },
                {
                    fn verifyInput(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <verifyInputCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::verifyInput)
                    }
                    verifyInput
                },
                {
                    fn getVersion(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <getVersionCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::getVersion)
                    }
                    getVersion
                },
                {
                    fn fheAdd(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheAddCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::fheAdd)
                    }
                    fheAdd
                },
                {
                    fn fheGe(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheGeCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::fheGe)
                    }
                    fheGe
                },
                {
                    fn fheSub(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheSubCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::fheSub)
                    }
                    fheSub
                },
                {
                    fn cast(data: &[u8]) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <castCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::cast)
                    }
                    cast
                },
                {
                    fn fheMax(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheMaxCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::fheMax)
                    }
                    fheMax
                },
                {
                    fn initializeFromEmptyProxy(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <initializeFromEmptyProxyCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::initializeFromEmptyProxy)
                    }
                    initializeFromEmptyProxy
                },
                {
                    fn fheRandBounded(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheRandBoundedCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::fheRandBounded)
                    }
                    fheRandBounded
                },
                {
                    fn upgradeToAndCall(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <upgradeToAndCallCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::upgradeToAndCall)
                    }
                    upgradeToAndCall
                },
                {
                    fn proxiableUUID(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <proxiableUUIDCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::proxiableUUID)
                    }
                    proxiableUUID
                },
                {
                    fn fheMul(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheMulCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::fheMul)
                    }
                    fheMul
                },
                {
                    fn fheDiv(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheDivCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::fheDiv)
                    }
                    fheDiv
                },
                {
                    fn fheBitOr(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheBitOrCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::fheBitOr)
                    }
                    fheBitOr
                },
                {
                    fn fheRotl(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheRotlCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::fheRotl)
                    }
                    fheRotl
                },
                {
                    fn fheLt(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheLtCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::fheLt)
                    }
                    fheLt
                },
                {
                    fn fheLe(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheLeCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::fheLe)
                    }
                    fheLe
                },
                {
                    fn fheIfThenElse(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheIfThenElseCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::fheIfThenElse)
                    }
                    fheIfThenElse
                },
                {
                    fn getHandleVersion(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <getHandleVersionCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::getHandleVersion)
                    }
                    getHandleVersion
                },
                {
                    fn fheGt(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheGtCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::fheGt)
                    }
                    fheGt
                },
                {
                    fn fheBitXor(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheBitXorCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::fheBitXor)
                    }
                    fheBitXor
                },
                {
                    fn fheShr(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheShrCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::fheShr)
                    }
                    fheShr
                },
                {
                    fn trivialEncrypt(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <trivialEncryptCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::trivialEncrypt)
                    }
                    trivialEncrypt
                },
                {
                    fn getInputVerifierAddress(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <getInputVerifierAddressCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::getInputVerifierAddress)
                    }
                    getInputVerifierAddress
                },
                {
                    fn UPGRADE_INTERFACE_VERSION(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <UPGRADE_INTERFACE_VERSIONCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::UPGRADE_INTERFACE_VERSION)
                    }
                    UPGRADE_INTERFACE_VERSION
                },
                {
                    fn reinitializeV3(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <reinitializeV3Call as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::reinitializeV3)
                    }
                    reinitializeV3
                },
                {
                    fn fheRotr(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheRotrCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::fheRotr)
                    }
                    fheRotr
                },
                {
                    fn fheShl(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheShlCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::fheShl)
                    }
                    fheShl
                },
                {
                    fn fheRem(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheRemCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::fheRem)
                    }
                    fheRem
                },
                {
                    fn fheNeg(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheNegCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::fheNeg)
                    }
                    fheNeg
                },
                {
                    fn fheRand(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheRandCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::fheRand)
                    }
                    fheRand
                },
                {
                    fn fheNe(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheNeCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::fheNe)
                    }
                    fheNe
                },
                {
                    fn fheBitAnd(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheBitAndCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::fheBitAnd)
                    }
                    fheBitAnd
                },
                {
                    fn getHCULimitAddress(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <getHCULimitAddressCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::getHCULimitAddress)
                    }
                    getHCULimitAddress
                },
                {
                    fn fheNot(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheNotCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::fheNot)
                    }
                    fheNot
                },
                {
                    fn getACLAddress(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <getACLAddressCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::getACLAddress)
                    }
                    getACLAddress
                },
                {
                    fn fheEq(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheEqCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::fheEq)
                    }
                    fheEq
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_VALIDATE_SHIMS[idx](data)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::UPGRADE_INTERFACE_VERSION(inner) => {
                    <UPGRADE_INTERFACE_VERSIONCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::cast(inner) => {
                    <castCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::fheAdd(inner) => {
                    <fheAddCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::fheBitAnd(inner) => {
                    <fheBitAndCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::fheBitOr(inner) => {
                    <fheBitOrCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::fheBitXor(inner) => {
                    <fheBitXorCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::fheDiv(inner) => {
                    <fheDivCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::fheEq(inner) => {
                    <fheEqCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::fheGe(inner) => {
                    <fheGeCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::fheGt(inner) => {
                    <fheGtCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::fheIfThenElse(inner) => {
                    <fheIfThenElseCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::fheLe(inner) => {
                    <fheLeCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::fheLt(inner) => {
                    <fheLtCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::fheMax(inner) => {
                    <fheMaxCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::fheMin(inner) => {
                    <fheMinCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::fheMul(inner) => {
                    <fheMulCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::fheNe(inner) => {
                    <fheNeCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::fheNeg(inner) => {
                    <fheNegCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::fheNot(inner) => {
                    <fheNotCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::fheRand(inner) => {
                    <fheRandCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::fheRandBounded(inner) => {
                    <fheRandBoundedCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::fheRem(inner) => {
                    <fheRemCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::fheRotl(inner) => {
                    <fheRotlCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::fheRotr(inner) => {
                    <fheRotrCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::fheShl(inner) => {
                    <fheShlCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::fheShr(inner) => {
                    <fheShrCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::fheSub(inner) => {
                    <fheSubCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::getACLAddress(inner) => {
                    <getACLAddressCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getHCULimitAddress(inner) => {
                    <getHCULimitAddressCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getHandleVersion(inner) => {
                    <getHandleVersionCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getInputVerifierAddress(inner) => {
                    <getInputVerifierAddressCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getVersion(inner) => {
                    <getVersionCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::initializeFromEmptyProxy(inner) => {
                    <initializeFromEmptyProxyCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::proxiableUUID(inner) => {
                    <proxiableUUIDCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::reinitializeV3(inner) => {
                    <reinitializeV3Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::trivialEncrypt(inner) => {
                    <trivialEncryptCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::upgradeToAndCall(inner) => {
                    <upgradeToAndCallCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::verifyInput(inner) => {
                    <verifyInputCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::UPGRADE_INTERFACE_VERSION(inner) => {
                    <UPGRADE_INTERFACE_VERSIONCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::cast(inner) => {
                    <castCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::fheAdd(inner) => {
                    <fheAddCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::fheBitAnd(inner) => {
                    <fheBitAndCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::fheBitOr(inner) => {
                    <fheBitOrCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::fheBitXor(inner) => {
                    <fheBitXorCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::fheDiv(inner) => {
                    <fheDivCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::fheEq(inner) => {
                    <fheEqCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::fheGe(inner) => {
                    <fheGeCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::fheGt(inner) => {
                    <fheGtCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::fheIfThenElse(inner) => {
                    <fheIfThenElseCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::fheLe(inner) => {
                    <fheLeCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::fheLt(inner) => {
                    <fheLtCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::fheMax(inner) => {
                    <fheMaxCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::fheMin(inner) => {
                    <fheMinCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::fheMul(inner) => {
                    <fheMulCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::fheNe(inner) => {
                    <fheNeCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::fheNeg(inner) => {
                    <fheNegCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::fheNot(inner) => {
                    <fheNotCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::fheRand(inner) => {
                    <fheRandCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::fheRandBounded(inner) => {
                    <fheRandBoundedCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::fheRem(inner) => {
                    <fheRemCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::fheRotl(inner) => {
                    <fheRotlCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::fheRotr(inner) => {
                    <fheRotrCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::fheShl(inner) => {
                    <fheShlCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::fheShr(inner) => {
                    <fheShrCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::fheSub(inner) => {
                    <fheSubCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::getACLAddress(inner) => {
                    <getACLAddressCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getHCULimitAddress(inner) => {
                    <getHCULimitAddressCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getHandleVersion(inner) => {
                    <getHandleVersionCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getInputVerifierAddress(inner) => {
                    <getInputVerifierAddressCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getVersion(inner) => {
                    <getVersionCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::initializeFromEmptyProxy(inner) => {
                    <initializeFromEmptyProxyCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::proxiableUUID(inner) => {
                    <proxiableUUIDCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::reinitializeV3(inner) => {
                    <reinitializeV3Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::trivialEncrypt(inner) => {
                    <trivialEncryptCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::upgradeToAndCall(inner) => {
                    <upgradeToAndCallCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::verifyInput(inner) => {
                    <verifyInputCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`FHEVMExecutor`](self) custom errors.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub enum FHEVMExecutorErrors {
        #[allow(missing_docs)]
        ACLNotAllowed(ACLNotAllowed),
        #[allow(missing_docs)]
        AddressEmptyCode(AddressEmptyCode),
        #[allow(missing_docs)]
        DivisionByZero(DivisionByZero),
        #[allow(missing_docs)]
        ERC1967InvalidImplementation(ERC1967InvalidImplementation),
        #[allow(missing_docs)]
        ERC1967NonPayable(ERC1967NonPayable),
        #[allow(missing_docs)]
        FailedCall(FailedCall),
        #[allow(missing_docs)]
        IncompatibleTypes(IncompatibleTypes),
        #[allow(missing_docs)]
        InvalidByteLength(InvalidByteLength),
        #[allow(missing_docs)]
        InvalidInitialization(InvalidInitialization),
        #[allow(missing_docs)]
        InvalidType(InvalidType),
        #[allow(missing_docs)]
        IsNotScalar(IsNotScalar),
        #[allow(missing_docs)]
        NotHostOwner(NotHostOwner),
        #[allow(missing_docs)]
        NotInitializing(NotInitializing),
        #[allow(missing_docs)]
        NotInitializingFromEmptyProxy(NotInitializingFromEmptyProxy),
        #[allow(missing_docs)]
        NotPowerOfTwo(NotPowerOfTwo),
        #[allow(missing_docs)]
        ScalarByteIsNotBoolean(ScalarByteIsNotBoolean),
        #[allow(missing_docs)]
        SecondOperandIsNotScalar(SecondOperandIsNotScalar),
        #[allow(missing_docs)]
        UUPSUnauthorizedCallContext(UUPSUnauthorizedCallContext),
        #[allow(missing_docs)]
        UUPSUnsupportedProxiableUUID(UUPSUnsupportedProxiableUUID),
        #[allow(missing_docs)]
        UnsupportedType(UnsupportedType),
        #[allow(missing_docs)]
        UpperBoundAboveMaxTypeValue(UpperBoundAboveMaxTypeValue),
    }
    #[automatically_derived]
    impl FHEVMExecutorErrors {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [31u8, 49u8, 88u8, 199u8],
            [33u8, 191u8, 218u8, 16u8],
            [35u8, 211u8, 89u8, 163u8],
            [36u8, 232u8, 231u8, 66u8],
            [76u8, 156u8, 140u8, 227u8],
            [77u8, 222u8, 13u8, 152u8],
            [79u8, 34u8, 78u8, 83u8],
            [111u8, 79u8, 115u8, 31u8],
            [153u8, 150u8, 179u8, 21u8],
            [157u8, 227u8, 57u8, 44u8],
            [170u8, 29u8, 73u8, 164u8],
            [179u8, 12u8, 12u8, 87u8],
            [179u8, 152u8, 151u8, 159u8],
            [185u8, 104u8, 132u8, 97u8],
            [198u8, 222u8, 70u8, 106u8],
            [199u8, 218u8, 223u8, 69u8],
            [214u8, 189u8, 162u8, 117u8],
            [215u8, 230u8, 188u8, 248u8],
            [223u8, 123u8, 243u8, 37u8],
            [224u8, 124u8, 141u8, 186u8],
            [249u8, 46u8, 232u8, 169u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for FHEVMExecutorErrors {
        const NAME: &'static str = "FHEVMExecutorErrors";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 21usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::ACLNotAllowed(_) => {
                    <ACLNotAllowed as alloy_sol_types::SolError>::SELECTOR
                }
                Self::AddressEmptyCode(_) => {
                    <AddressEmptyCode as alloy_sol_types::SolError>::SELECTOR
                }
                Self::DivisionByZero(_) => {
                    <DivisionByZero as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC1967InvalidImplementation(_) => {
                    <ERC1967InvalidImplementation as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC1967NonPayable(_) => {
                    <ERC1967NonPayable as alloy_sol_types::SolError>::SELECTOR
                }
                Self::FailedCall(_) => {
                    <FailedCall as alloy_sol_types::SolError>::SELECTOR
                }
                Self::IncompatibleTypes(_) => {
                    <IncompatibleTypes as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidByteLength(_) => {
                    <InvalidByteLength as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidInitialization(_) => {
                    <InvalidInitialization as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidType(_) => {
                    <InvalidType as alloy_sol_types::SolError>::SELECTOR
                }
                Self::IsNotScalar(_) => {
                    <IsNotScalar as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NotHostOwner(_) => {
                    <NotHostOwner as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NotInitializing(_) => {
                    <NotInitializing as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NotInitializingFromEmptyProxy(_) => {
                    <NotInitializingFromEmptyProxy as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NotPowerOfTwo(_) => {
                    <NotPowerOfTwo as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ScalarByteIsNotBoolean(_) => {
                    <ScalarByteIsNotBoolean as alloy_sol_types::SolError>::SELECTOR
                }
                Self::SecondOperandIsNotScalar(_) => {
                    <SecondOperandIsNotScalar as alloy_sol_types::SolError>::SELECTOR
                }
                Self::UUPSUnauthorizedCallContext(_) => {
                    <UUPSUnauthorizedCallContext as alloy_sol_types::SolError>::SELECTOR
                }
                Self::UUPSUnsupportedProxiableUUID(_) => {
                    <UUPSUnsupportedProxiableUUID as alloy_sol_types::SolError>::SELECTOR
                }
                Self::UnsupportedType(_) => {
                    <UnsupportedType as alloy_sol_types::SolError>::SELECTOR
                }
                Self::UpperBoundAboveMaxTypeValue(_) => {
                    <UpperBoundAboveMaxTypeValue as alloy_sol_types::SolError>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<FHEVMExecutorErrors>] = &[
                {
                    fn IncompatibleTypes(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <IncompatibleTypes as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(FHEVMExecutorErrors::IncompatibleTypes)
                    }
                    IncompatibleTypes
                },
                {
                    fn NotHostOwner(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <NotHostOwner as alloy_sol_types::SolError>::abi_decode_raw(data)
                            .map(FHEVMExecutorErrors::NotHostOwner)
                    }
                    NotHostOwner
                },
                {
                    fn DivisionByZero(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <DivisionByZero as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(FHEVMExecutorErrors::DivisionByZero)
                    }
                    DivisionByZero
                },
                {
                    fn NotPowerOfTwo(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <NotPowerOfTwo as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(FHEVMExecutorErrors::NotPowerOfTwo)
                    }
                    NotPowerOfTwo
                },
                {
                    fn ERC1967InvalidImplementation(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <ERC1967InvalidImplementation as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(FHEVMExecutorErrors::ERC1967InvalidImplementation)
                    }
                    ERC1967InvalidImplementation
                },
                {
                    fn SecondOperandIsNotScalar(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <SecondOperandIsNotScalar as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(FHEVMExecutorErrors::SecondOperandIsNotScalar)
                    }
                    SecondOperandIsNotScalar
                },
                {
                    fn IsNotScalar(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <IsNotScalar as alloy_sol_types::SolError>::abi_decode_raw(data)
                            .map(FHEVMExecutorErrors::IsNotScalar)
                    }
                    IsNotScalar
                },
                {
                    fn NotInitializingFromEmptyProxy(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <NotInitializingFromEmptyProxy as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(FHEVMExecutorErrors::NotInitializingFromEmptyProxy)
                    }
                    NotInitializingFromEmptyProxy
                },
                {
                    fn AddressEmptyCode(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <AddressEmptyCode as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(FHEVMExecutorErrors::AddressEmptyCode)
                    }
                    AddressEmptyCode
                },
                {
                    fn ACLNotAllowed(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <ACLNotAllowed as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(FHEVMExecutorErrors::ACLNotAllowed)
                    }
                    ACLNotAllowed
                },
                {
                    fn UUPSUnsupportedProxiableUUID(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <UUPSUnsupportedProxiableUUID as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(FHEVMExecutorErrors::UUPSUnsupportedProxiableUUID)
                    }
                    UUPSUnsupportedProxiableUUID
                },
                {
                    fn InvalidByteLength(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <InvalidByteLength as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(FHEVMExecutorErrors::InvalidByteLength)
                    }
                    InvalidByteLength
                },
                {
                    fn ERC1967NonPayable(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <ERC1967NonPayable as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(FHEVMExecutorErrors::ERC1967NonPayable)
                    }
                    ERC1967NonPayable
                },
                {
                    fn InvalidType(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <InvalidType as alloy_sol_types::SolError>::abi_decode_raw(data)
                            .map(FHEVMExecutorErrors::InvalidType)
                    }
                    InvalidType
                },
                {
                    fn UnsupportedType(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <UnsupportedType as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(FHEVMExecutorErrors::UnsupportedType)
                    }
                    UnsupportedType
                },
                {
                    fn UpperBoundAboveMaxTypeValue(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <UpperBoundAboveMaxTypeValue as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(FHEVMExecutorErrors::UpperBoundAboveMaxTypeValue)
                    }
                    UpperBoundAboveMaxTypeValue
                },
                {
                    fn FailedCall(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <FailedCall as alloy_sol_types::SolError>::abi_decode_raw(data)
                            .map(FHEVMExecutorErrors::FailedCall)
                    }
                    FailedCall
                },
                {
                    fn NotInitializing(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <NotInitializing as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(FHEVMExecutorErrors::NotInitializing)
                    }
                    NotInitializing
                },
                {
                    fn ScalarByteIsNotBoolean(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <ScalarByteIsNotBoolean as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(FHEVMExecutorErrors::ScalarByteIsNotBoolean)
                    }
                    ScalarByteIsNotBoolean
                },
                {
                    fn UUPSUnauthorizedCallContext(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <UUPSUnauthorizedCallContext as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(FHEVMExecutorErrors::UUPSUnauthorizedCallContext)
                    }
                    UUPSUnauthorizedCallContext
                },
                {
                    fn InvalidInitialization(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <InvalidInitialization as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(FHEVMExecutorErrors::InvalidInitialization)
                    }
                    InvalidInitialization
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data)
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw_validate(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_VALIDATE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<FHEVMExecutorErrors>] = &[
                {
                    fn IncompatibleTypes(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <IncompatibleTypes as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorErrors::IncompatibleTypes)
                    }
                    IncompatibleTypes
                },
                {
                    fn NotHostOwner(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <NotHostOwner as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorErrors::NotHostOwner)
                    }
                    NotHostOwner
                },
                {
                    fn DivisionByZero(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <DivisionByZero as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorErrors::DivisionByZero)
                    }
                    DivisionByZero
                },
                {
                    fn NotPowerOfTwo(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <NotPowerOfTwo as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorErrors::NotPowerOfTwo)
                    }
                    NotPowerOfTwo
                },
                {
                    fn ERC1967InvalidImplementation(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <ERC1967InvalidImplementation as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorErrors::ERC1967InvalidImplementation)
                    }
                    ERC1967InvalidImplementation
                },
                {
                    fn SecondOperandIsNotScalar(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <SecondOperandIsNotScalar as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorErrors::SecondOperandIsNotScalar)
                    }
                    SecondOperandIsNotScalar
                },
                {
                    fn IsNotScalar(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <IsNotScalar as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorErrors::IsNotScalar)
                    }
                    IsNotScalar
                },
                {
                    fn NotInitializingFromEmptyProxy(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <NotInitializingFromEmptyProxy as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorErrors::NotInitializingFromEmptyProxy)
                    }
                    NotInitializingFromEmptyProxy
                },
                {
                    fn AddressEmptyCode(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <AddressEmptyCode as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorErrors::AddressEmptyCode)
                    }
                    AddressEmptyCode
                },
                {
                    fn ACLNotAllowed(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <ACLNotAllowed as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorErrors::ACLNotAllowed)
                    }
                    ACLNotAllowed
                },
                {
                    fn UUPSUnsupportedProxiableUUID(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <UUPSUnsupportedProxiableUUID as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorErrors::UUPSUnsupportedProxiableUUID)
                    }
                    UUPSUnsupportedProxiableUUID
                },
                {
                    fn InvalidByteLength(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <InvalidByteLength as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorErrors::InvalidByteLength)
                    }
                    InvalidByteLength
                },
                {
                    fn ERC1967NonPayable(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <ERC1967NonPayable as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorErrors::ERC1967NonPayable)
                    }
                    ERC1967NonPayable
                },
                {
                    fn InvalidType(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <InvalidType as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorErrors::InvalidType)
                    }
                    InvalidType
                },
                {
                    fn UnsupportedType(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <UnsupportedType as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorErrors::UnsupportedType)
                    }
                    UnsupportedType
                },
                {
                    fn UpperBoundAboveMaxTypeValue(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <UpperBoundAboveMaxTypeValue as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorErrors::UpperBoundAboveMaxTypeValue)
                    }
                    UpperBoundAboveMaxTypeValue
                },
                {
                    fn FailedCall(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <FailedCall as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorErrors::FailedCall)
                    }
                    FailedCall
                },
                {
                    fn NotInitializing(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <NotInitializing as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorErrors::NotInitializing)
                    }
                    NotInitializing
                },
                {
                    fn ScalarByteIsNotBoolean(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <ScalarByteIsNotBoolean as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorErrors::ScalarByteIsNotBoolean)
                    }
                    ScalarByteIsNotBoolean
                },
                {
                    fn UUPSUnauthorizedCallContext(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <UUPSUnauthorizedCallContext as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorErrors::UUPSUnauthorizedCallContext)
                    }
                    UUPSUnauthorizedCallContext
                },
                {
                    fn InvalidInitialization(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <InvalidInitialization as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorErrors::InvalidInitialization)
                    }
                    InvalidInitialization
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_VALIDATE_SHIMS[idx](data)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::ACLNotAllowed(inner) => {
                    <ACLNotAllowed as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::AddressEmptyCode(inner) => {
                    <AddressEmptyCode as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::DivisionByZero(inner) => {
                    <DivisionByZero as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC1967InvalidImplementation(inner) => {
                    <ERC1967InvalidImplementation as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC1967NonPayable(inner) => {
                    <ERC1967NonPayable as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::FailedCall(inner) => {
                    <FailedCall as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::IncompatibleTypes(inner) => {
                    <IncompatibleTypes as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidByteLength(inner) => {
                    <InvalidByteLength as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidInitialization(inner) => {
                    <InvalidInitialization as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidType(inner) => {
                    <InvalidType as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::IsNotScalar(inner) => {
                    <IsNotScalar as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::NotHostOwner(inner) => {
                    <NotHostOwner as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::NotInitializing(inner) => {
                    <NotInitializing as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NotInitializingFromEmptyProxy(inner) => {
                    <NotInitializingFromEmptyProxy as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NotPowerOfTwo(inner) => {
                    <NotPowerOfTwo as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::ScalarByteIsNotBoolean(inner) => {
                    <ScalarByteIsNotBoolean as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::SecondOperandIsNotScalar(inner) => {
                    <SecondOperandIsNotScalar as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::UUPSUnauthorizedCallContext(inner) => {
                    <UUPSUnauthorizedCallContext as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::UUPSUnsupportedProxiableUUID(inner) => {
                    <UUPSUnsupportedProxiableUUID as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::UnsupportedType(inner) => {
                    <UnsupportedType as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::UpperBoundAboveMaxTypeValue(inner) => {
                    <UpperBoundAboveMaxTypeValue as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::ACLNotAllowed(inner) => {
                    <ACLNotAllowed as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::AddressEmptyCode(inner) => {
                    <AddressEmptyCode as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::DivisionByZero(inner) => {
                    <DivisionByZero as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC1967InvalidImplementation(inner) => {
                    <ERC1967InvalidImplementation as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC1967NonPayable(inner) => {
                    <ERC1967NonPayable as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::FailedCall(inner) => {
                    <FailedCall as alloy_sol_types::SolError>::abi_encode_raw(inner, out)
                }
                Self::IncompatibleTypes(inner) => {
                    <IncompatibleTypes as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidByteLength(inner) => {
                    <InvalidByteLength as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidInitialization(inner) => {
                    <InvalidInitialization as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidType(inner) => {
                    <InvalidType as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::IsNotScalar(inner) => {
                    <IsNotScalar as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NotHostOwner(inner) => {
                    <NotHostOwner as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NotInitializing(inner) => {
                    <NotInitializing as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NotInitializingFromEmptyProxy(inner) => {
                    <NotInitializingFromEmptyProxy as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NotPowerOfTwo(inner) => {
                    <NotPowerOfTwo as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ScalarByteIsNotBoolean(inner) => {
                    <ScalarByteIsNotBoolean as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::SecondOperandIsNotScalar(inner) => {
                    <SecondOperandIsNotScalar as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::UUPSUnauthorizedCallContext(inner) => {
                    <UUPSUnauthorizedCallContext as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::UUPSUnsupportedProxiableUUID(inner) => {
                    <UUPSUnsupportedProxiableUUID as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::UnsupportedType(inner) => {
                    <UnsupportedType as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::UpperBoundAboveMaxTypeValue(inner) => {
                    <UpperBoundAboveMaxTypeValue as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`FHEVMExecutor`](self) events.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub enum FHEVMExecutorEvents {
        #[allow(missing_docs)]
        Cast(Cast),
        #[allow(missing_docs)]
        FheAdd(FheAdd),
        #[allow(missing_docs)]
        FheBitAnd(FheBitAnd),
        #[allow(missing_docs)]
        FheBitOr(FheBitOr),
        #[allow(missing_docs)]
        FheBitXor(FheBitXor),
        #[allow(missing_docs)]
        FheDiv(FheDiv),
        #[allow(missing_docs)]
        FheEq(FheEq),
        #[allow(missing_docs)]
        FheGe(FheGe),
        #[allow(missing_docs)]
        FheGt(FheGt),
        #[allow(missing_docs)]
        FheIfThenElse(FheIfThenElse),
        #[allow(missing_docs)]
        FheLe(FheLe),
        #[allow(missing_docs)]
        FheLt(FheLt),
        #[allow(missing_docs)]
        FheMax(FheMax),
        #[allow(missing_docs)]
        FheMin(FheMin),
        #[allow(missing_docs)]
        FheMul(FheMul),
        #[allow(missing_docs)]
        FheNe(FheNe),
        #[allow(missing_docs)]
        FheNeg(FheNeg),
        #[allow(missing_docs)]
        FheNot(FheNot),
        #[allow(missing_docs)]
        FheRand(FheRand),
        #[allow(missing_docs)]
        FheRandBounded(FheRandBounded),
        #[allow(missing_docs)]
        FheRem(FheRem),
        #[allow(missing_docs)]
        FheRotl(FheRotl),
        #[allow(missing_docs)]
        FheRotr(FheRotr),
        #[allow(missing_docs)]
        FheShl(FheShl),
        #[allow(missing_docs)]
        FheShr(FheShr),
        #[allow(missing_docs)]
        FheSub(FheSub),
        #[allow(missing_docs)]
        Initialized(Initialized),
        #[allow(missing_docs)]
        TrivialEncrypt(TrivialEncrypt),
        #[allow(missing_docs)]
        Upgraded(Upgraded),
        #[allow(missing_docs)]
        VerifyInput(VerifyInput),
    }
    #[automatically_derived]
    impl FHEVMExecutorEvents {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 32usize]] = &[
            [
                6u8, 60u8, 205u8, 27u8, 186u8, 69u8, 21u8, 29u8, 145u8, 246u8, 164u8,
                24u8, 6u8, 80u8, 71u8, 163u8, 208u8, 72u8, 208u8, 88u8, 169u8, 34u8,
                83u8, 87u8, 71u8, 187u8, 43u8, 87u8, 90u8, 1u8, 210u8, 54u8,
            ],
            [
                12u8, 138u8, 202u8, 96u8, 23u8, 0u8, 51u8, 38u8, 5u8, 30u8, 25u8, 145u8,
                62u8, 240u8, 38u8, 49u8, 242u8, 75u8, 128u8, 17u8, 37u8, 225u8, 250u8,
                138u8, 29u8, 129u8, 46u8, 134u8, 131u8, 25u8, 253u8, 166u8,
            ],
            [
                13u8, 72u8, 59u8, 16u8, 13u8, 140u8, 115u8, 178u8, 8u8, 152u8, 78u8,
                198u8, 151u8, 202u8, 163u8, 9u8, 21u8, 33u8, 238u8, 85u8, 37u8, 206u8,
                105u8, 237u8, 207u8, 151u8, 215u8, 227u8, 149u8, 211u8, 208u8, 89u8,
            ],
            [
                14u8, 105u8, 28u8, 208u8, 191u8, 140u8, 78u8, 147u8, 8u8, 228u8, 206u8,
                209u8, 187u8, 156u8, 150u8, 65u8, 23u8, 220u8, 92u8, 91u8, 185u8, 185u8,
                171u8, 91u8, 223u8, 235u8, 242u8, 201u8, 177u8, 58u8, 137u8, 124u8,
            ],
            [
                33u8, 83u8, 70u8, 164u8, 249u8, 249u8, 117u8, 230u8, 213u8, 72u8, 78u8,
                41u8, 11u8, 212u8, 229u8, 60u8, 161u8, 68u8, 83u8, 169u8, 210u8, 130u8,
                235u8, 211u8, 204u8, 237u8, 178u8, 160u8, 241u8, 113u8, 117u8, 61u8,
            ],
            [
                49u8, 204u8, 174u8, 106u8, 47u8, 142u8, 60u8, 237u8, 22u8, 146u8, 247u8,
                124u8, 143u8, 102u8, 129u8, 51u8, 228u8, 175u8, 218u8, 170u8, 53u8,
                175u8, 232u8, 68u8, 255u8, 70u8, 89u8, 166u8, 194u8, 126u8, 98u8, 127u8,
            ],
            [
                50u8, 66u8, 32u8, 191u8, 201u8, 203u8, 21u8, 139u8, 73u8, 41u8, 145u8,
                192u8, 60u8, 48u8, 156u8, 216u8, 110u8, 83u8, 69u8, 202u8, 196u8, 90u8,
                172u8, 174u8, 32u8, 146u8, 221u8, 171u8, 227u8, 31u8, 163u8, 216u8,
            ],
            [
                56u8, 195u8, 166u8, 60u8, 66u8, 48u8, 222u8, 91u8, 116u8, 31u8, 73u8,
                79u8, 251u8, 84u8, 227u8, 8u8, 113u8, 4u8, 3u8, 2u8, 121u8, 188u8, 123u8,
                204u8, 238u8, 138u8, 217u8, 173u8, 49u8, 113u8, 43u8, 33u8,
            ],
            [
                59u8, 171u8, 46u8, 224u8, 226u8, 249u8, 15u8, 70u8, 144u8, 198u8, 168u8,
                123u8, 246u8, 60u8, 241u8, 166u8, 182u8, 38u8, 8u8, 110u8, 149u8, 242u8,
                49u8, 134u8, 11u8, 21u8, 41u8, 102u8, 232u8, 218u8, 187u8, 247u8,
            ],
            [
                77u8, 50u8, 40u8, 75u8, 211u8, 25u8, 62u8, 202u8, 164u8, 78u8, 28u8,
                236u8, 163u8, 47u8, 65u8, 197u8, 214u8, 195u8, 40u8, 3u8, 169u8, 46u8,
                7u8, 150u8, 125u8, 211u8, 238u8, 66u8, 41u8, 114u8, 21u8, 130u8,
            ],
            [
                82u8, 34u8, 217u8, 107u8, 131u8, 103u8, 39u8, 161u8, 214u8, 254u8, 30u8,
                233u8, 174u8, 242u8, 127u8, 155u8, 181u8, 7u8, 189u8, 65u8, 121u8, 77u8,
                239u8, 163u8, 118u8, 255u8, 108u8, 100u8, 138u8, 175u8, 143u8, 241u8,
            ],
            [
                85u8, 175u8, 244u8, 204u8, 122u8, 61u8, 22u8, 12u8, 131u8, 241u8, 241u8,
                91u8, 129u8, 128u8, 17u8, 237u8, 232u8, 65u8, 160u8, 180u8, 89u8, 127u8,
                177u8, 77u8, 205u8, 54u8, 3u8, 223u8, 58u8, 17u8, 229u8, 224u8,
            ],
            [
                86u8, 223u8, 39u8, 155u8, 191u8, 176u8, 61u8, 158u8, 208u8, 151u8, 187u8,
                226u8, 242u8, 141u8, 82u8, 12u8, 160u8, 193u8, 22u8, 18u8, 6u8, 50u8,
                121u8, 38u8, 233u8, 134u8, 100u8, 215u8, 13u8, 44u8, 36u8, 196u8,
            ],
            [
                96u8, 190u8, 157u8, 97u8, 170u8, 216u8, 73u8, 250u8, 204u8, 40u8, 195u8,
                139u8, 4u8, 140u8, 181u8, 196u8, 190u8, 52u8, 32u8, 184u8, 250u8, 34u8,
                51u8, 224u8, 140u8, 250u8, 6u8, 190u8, 27u8, 109u8, 28u8, 62u8,
            ],
            [
                105u8, 96u8, 193u8, 232u8, 143u8, 97u8, 195u8, 82u8, 219u8, 163u8, 77u8,
                27u8, 191u8, 103u8, 83u8, 227u8, 2u8, 121u8, 82u8, 100u8, 213u8, 216u8,
                174u8, 130u8, 247u8, 152u8, 60u8, 112u8, 4u8, 101u8, 30u8, 93u8,
            ],
            [
                140u8, 102u8, 77u8, 60u8, 60u8, 165u8, 131u8, 252u8, 88u8, 3u8, 184u8,
                169u8, 28u8, 73u8, 100u8, 75u8, 189u8, 149u8, 80u8, 191u8, 168u8, 121u8,
                103u8, 199u8, 58u8, 209u8, 222u8, 131u8, 2u8, 119u8, 104u8, 192u8,
            ],
            [
                179u8, 213u8, 198u8, 100u8, 236u8, 134u8, 87u8, 88u8, 24u8, 232u8, 215u8,
                95u8, 242u8, 92u8, 95u8, 134u8, 114u8, 80u8, 223u8, 137u8, 84u8, 8u8,
                133u8, 73u8, 196u8, 28u8, 132u8, 140u8, 209u8, 14u8, 118u8, 203u8,
            ],
            [
                188u8, 124u8, 215u8, 90u8, 32u8, 238u8, 39u8, 253u8, 154u8, 222u8, 186u8,
                179u8, 32u8, 65u8, 247u8, 85u8, 33u8, 77u8, 188u8, 107u8, 255u8, 169u8,
                12u8, 192u8, 34u8, 91u8, 57u8, 218u8, 46u8, 92u8, 45u8, 59u8,
            ],
            [
                193u8, 29u8, 98u8, 177u8, 60u8, 54u8, 10u8, 131u8, 8u8, 36u8, 135u8, 6u8,
                75u8, 225u8, 236u8, 8u8, 120u8, 178u8, 240u8, 190u8, 79u8, 1u8, 43u8,
                245u8, 159u8, 137u8, 225u8, 40u8, 6u8, 61u8, 71u8, 255u8,
            ],
            [
                193u8, 72u8, 103u8, 89u8, 5u8, 208u8, 122u8, 213u8, 73u8, 111u8, 142u8,
                244u8, 216u8, 25u8, 92u8, 144u8, 117u8, 3u8, 243u8, 236u8, 18u8, 253u8,
                16u8, 237u8, 95u8, 33u8, 36u8, 10u8, 188u8, 105u8, 54u8, 52u8,
            ],
            [
                199u8, 245u8, 5u8, 178u8, 243u8, 113u8, 174u8, 33u8, 117u8, 238u8, 73u8,
                19u8, 244u8, 73u8, 158u8, 31u8, 38u8, 51u8, 167u8, 181u8, 147u8, 99u8,
                33u8, 238u8, 209u8, 205u8, 174u8, 182u8, 17u8, 81u8, 129u8, 210u8,
            ],
            [
                201u8, 255u8, 143u8, 13u8, 24u8, 163u8, 247u8, 102u8, 206u8, 93u8, 227u8,
                222u8, 33u8, 96u8, 118u8, 5u8, 1u8, 64u8, 228u8, 252u8, 38u8, 82u8,
                245u8, 224u8, 231u8, 69u8, 246u8, 252u8, 131u8, 108u8, 218u8, 139u8,
            ],
            [
                219u8, 144u8, 80u8, 214u8, 82u8, 64u8, 67u8, 22u8, 33u8, 214u8, 29u8,
                111u8, 148u8, 185u8, 112u8, 230u8, 63u8, 83u8, 166u8, 122u8, 87u8, 102u8,
                97u8, 78u8, 230u8, 229u8, 197u8, 187u8, 212u8, 28u8, 142u8, 46u8,
            ],
            [
                220u8, 55u8, 13u8, 179u8, 53u8, 137u8, 231u8, 51u8, 113u8, 220u8, 62u8,
                228u8, 44u8, 120u8, 156u8, 0u8, 61u8, 51u8, 110u8, 239u8, 203u8, 124u8,
                63u8, 86u8, 254u8, 15u8, 81u8, 174u8, 91u8, 29u8, 151u8, 2u8,
            ],
            [
                222u8, 242u8, 231u8, 4u8, 160u8, 119u8, 40u8, 74u8, 7u8, 243u8, 208u8,
                180u8, 54u8, 219u8, 136u8, 245u8, 217u8, 129u8, 182u8, 159u8, 88u8,
                171u8, 124u8, 26u8, 230u8, 35u8, 37u8, 39u8, 24u8, 166u8, 222u8, 1u8,
            ],
            [
                228u8, 36u8, 134u8, 176u8, 204u8, 219u8, 239u8, 129u8, 162u8, 7u8, 92u8,
                72u8, 200u8, 229u8, 21u8, 192u8, 121u8, 174u8, 167u8, 60u8, 139u8, 130u8,
                66u8, 153u8, 151u8, 199u8, 42u8, 47u8, 225u8, 191u8, 79u8, 239u8,
            ],
            [
                232u8, 66u8, 130u8, 170u8, 235u8, 204u8, 166u8, 152u8, 68u8, 62u8, 57u8,
                162u8, 169u8, 72u8, 163u8, 69u8, 208u8, 210u8, 235u8, 198u8, 84u8, 175u8,
                92u8, 182u8, 87u8, 162u8, 215u8, 232u8, 5u8, 59u8, 246u8, 203u8,
            ],
            [
                235u8, 14u8, 79u8, 141u8, 199u8, 64u8, 88u8, 25u8, 77u8, 6u8, 2u8, 66u8,
                95u8, 230u8, 2u8, 249u8, 85u8, 194u8, 34u8, 32u8, 15u8, 127u8, 16u8,
                198u8, 254u8, 103u8, 153u8, 47u8, 123u8, 36u8, 199u8, 233u8,
            ],
            [
                235u8, 109u8, 55u8, 189u8, 39u8, 26u8, 190u8, 19u8, 149u8, 178u8, 29u8,
                109u8, 120u8, 243u8, 72u8, 125u8, 101u8, 132u8, 134u8, 40u8, 114u8,
                194u8, 159u8, 253u8, 63u8, 144u8, 115u8, 110u8, 233u8, 155u8, 115u8,
                147u8,
            ],
            [
                253u8, 124u8, 146u8, 8u8, 249u8, 86u8, 191u8, 12u8, 106u8, 183u8, 106u8,
                102u8, 127u8, 4u8, 54u8, 18u8, 69u8, 173u8, 62u8, 10u8, 45u8, 14u8,
                255u8, 146u8, 235u8, 130u8, 122u8, 207u8, 204u8, 166u8, 142u8, 169u8,
            ],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolEventInterface for FHEVMExecutorEvents {
        const NAME: &'static str = "FHEVMExecutorEvents";
        const COUNT: usize = 30usize;
        fn decode_raw_log(
            topics: &[alloy_sol_types::Word],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            match topics.first().copied() {
                Some(<Cast as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Cast as alloy_sol_types::SolEvent>::decode_raw_log(topics, data)
                        .map(Self::Cast)
                }
                Some(<FheAdd as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <FheAdd as alloy_sol_types::SolEvent>::decode_raw_log(topics, data)
                        .map(Self::FheAdd)
                }
                Some(<FheBitAnd as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <FheBitAnd as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::FheBitAnd)
                }
                Some(<FheBitOr as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <FheBitOr as alloy_sol_types::SolEvent>::decode_raw_log(topics, data)
                        .map(Self::FheBitOr)
                }
                Some(<FheBitXor as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <FheBitXor as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::FheBitXor)
                }
                Some(<FheDiv as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <FheDiv as alloy_sol_types::SolEvent>::decode_raw_log(topics, data)
                        .map(Self::FheDiv)
                }
                Some(<FheEq as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <FheEq as alloy_sol_types::SolEvent>::decode_raw_log(topics, data)
                        .map(Self::FheEq)
                }
                Some(<FheGe as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <FheGe as alloy_sol_types::SolEvent>::decode_raw_log(topics, data)
                        .map(Self::FheGe)
                }
                Some(<FheGt as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <FheGt as alloy_sol_types::SolEvent>::decode_raw_log(topics, data)
                        .map(Self::FheGt)
                }
                Some(<FheIfThenElse as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <FheIfThenElse as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::FheIfThenElse)
                }
                Some(<FheLe as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <FheLe as alloy_sol_types::SolEvent>::decode_raw_log(topics, data)
                        .map(Self::FheLe)
                }
                Some(<FheLt as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <FheLt as alloy_sol_types::SolEvent>::decode_raw_log(topics, data)
                        .map(Self::FheLt)
                }
                Some(<FheMax as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <FheMax as alloy_sol_types::SolEvent>::decode_raw_log(topics, data)
                        .map(Self::FheMax)
                }
                Some(<FheMin as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <FheMin as alloy_sol_types::SolEvent>::decode_raw_log(topics, data)
                        .map(Self::FheMin)
                }
                Some(<FheMul as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <FheMul as alloy_sol_types::SolEvent>::decode_raw_log(topics, data)
                        .map(Self::FheMul)
                }
                Some(<FheNe as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <FheNe as alloy_sol_types::SolEvent>::decode_raw_log(topics, data)
                        .map(Self::FheNe)
                }
                Some(<FheNeg as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <FheNeg as alloy_sol_types::SolEvent>::decode_raw_log(topics, data)
                        .map(Self::FheNeg)
                }
                Some(<FheNot as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <FheNot as alloy_sol_types::SolEvent>::decode_raw_log(topics, data)
                        .map(Self::FheNot)
                }
                Some(<FheRand as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <FheRand as alloy_sol_types::SolEvent>::decode_raw_log(topics, data)
                        .map(Self::FheRand)
                }
                Some(<FheRandBounded as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <FheRandBounded as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::FheRandBounded)
                }
                Some(<FheRem as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <FheRem as alloy_sol_types::SolEvent>::decode_raw_log(topics, data)
                        .map(Self::FheRem)
                }
                Some(<FheRotl as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <FheRotl as alloy_sol_types::SolEvent>::decode_raw_log(topics, data)
                        .map(Self::FheRotl)
                }
                Some(<FheRotr as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <FheRotr as alloy_sol_types::SolEvent>::decode_raw_log(topics, data)
                        .map(Self::FheRotr)
                }
                Some(<FheShl as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <FheShl as alloy_sol_types::SolEvent>::decode_raw_log(topics, data)
                        .map(Self::FheShl)
                }
                Some(<FheShr as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <FheShr as alloy_sol_types::SolEvent>::decode_raw_log(topics, data)
                        .map(Self::FheShr)
                }
                Some(<FheSub as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <FheSub as alloy_sol_types::SolEvent>::decode_raw_log(topics, data)
                        .map(Self::FheSub)
                }
                Some(<Initialized as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Initialized as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::Initialized)
                }
                Some(<TrivialEncrypt as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <TrivialEncrypt as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::TrivialEncrypt)
                }
                Some(<Upgraded as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Upgraded as alloy_sol_types::SolEvent>::decode_raw_log(topics, data)
                        .map(Self::Upgraded)
                }
                Some(<VerifyInput as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <VerifyInput as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::VerifyInput)
                }
                _ => {
                    alloy_sol_types::private::Err(alloy_sol_types::Error::InvalidLog {
                        name: <Self as alloy_sol_types::SolEventInterface>::NAME,
                        log: alloy_sol_types::private::Box::new(
                            alloy_sol_types::private::LogData::new_unchecked(
                                topics.to_vec(),
                                data.to_vec().into(),
                            ),
                        ),
                    })
                }
            }
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::private::IntoLogData for FHEVMExecutorEvents {
        fn to_log_data(&self) -> alloy_sol_types::private::LogData {
            match self {
                Self::Cast(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::FheAdd(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::FheBitAnd(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::FheBitOr(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::FheBitXor(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::FheDiv(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::FheEq(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::FheGe(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::FheGt(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::FheIfThenElse(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::FheLe(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::FheLt(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::FheMax(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::FheMin(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::FheMul(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::FheNe(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::FheNeg(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::FheNot(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::FheRand(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::FheRandBounded(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::FheRem(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::FheRotl(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::FheRotr(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::FheShl(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::FheShr(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::FheSub(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Initialized(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::TrivialEncrypt(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Upgraded(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::VerifyInput(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
            }
        }
        fn into_log_data(self) -> alloy_sol_types::private::LogData {
            match self {
                Self::Cast(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::FheAdd(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::FheBitAnd(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::FheBitOr(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::FheBitXor(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::FheDiv(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::FheEq(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::FheGe(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::FheGt(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::FheIfThenElse(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::FheLe(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::FheLt(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::FheMax(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::FheMin(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::FheMul(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::FheNe(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::FheNeg(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::FheNot(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::FheRand(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::FheRandBounded(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::FheRem(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::FheRotl(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::FheRotr(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::FheShl(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::FheShr(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::FheSub(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Initialized(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::TrivialEncrypt(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Upgraded(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::VerifyInput(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`FHEVMExecutor`](self) contract instance.

See the [wrapper's documentation](`FHEVMExecutorInstance`) for more details.*/
    #[inline]
    pub const fn new<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> FHEVMExecutorInstance<P, N> {
        FHEVMExecutorInstance::<P, N>::new(address, provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
    ) -> impl ::core::future::Future<
        Output = alloy_contract::Result<FHEVMExecutorInstance<P, N>>,
    > {
        FHEVMExecutorInstance::<P, N>::deploy(provider)
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(provider: P) -> alloy_contract::RawCallBuilder<P, N> {
        FHEVMExecutorInstance::<P, N>::deploy_builder(provider)
    }
    /**A [`FHEVMExecutor`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`FHEVMExecutor`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct FHEVMExecutorInstance<P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network: ::core::marker::PhantomData<N>,
    }
    #[automatically_derived]
    impl<P, N> ::core::fmt::Debug for FHEVMExecutorInstance<P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("FHEVMExecutorInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > FHEVMExecutorInstance<P, N> {
        /**Creates a new wrapper around an on-chain [`FHEVMExecutor`](self) contract instance.

See the [wrapper's documentation](`FHEVMExecutorInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            provider: P,
        ) -> Self {
            Self {
                address,
                provider,
                _network: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            provider: P,
        ) -> alloy_contract::Result<FHEVMExecutorInstance<P, N>> {
            let call_builder = Self::deploy_builder(provider);
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(provider: P) -> alloy_contract::RawCallBuilder<P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                provider,
                ::core::clone::Clone::clone(&BYTECODE),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<P: ::core::clone::Clone, N> FHEVMExecutorInstance<&P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> FHEVMExecutorInstance<P, N> {
            FHEVMExecutorInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > FHEVMExecutorInstance<P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<&P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        ///Creates a new call builder for the [`UPGRADE_INTERFACE_VERSION`] function.
        pub fn UPGRADE_INTERFACE_VERSION(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, UPGRADE_INTERFACE_VERSIONCall, N> {
            self.call_builder(&UPGRADE_INTERFACE_VERSIONCall)
        }
        ///Creates a new call builder for the [`cast`] function.
        pub fn cast(
            &self,
            ct: alloy::sol_types::private::FixedBytes<32>,
            toType: <FheType as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<&P, castCall, N> {
            self.call_builder(&castCall { ct, toType })
        }
        ///Creates a new call builder for the [`fheAdd`] function.
        pub fn fheAdd(
            &self,
            lhs: alloy::sol_types::private::FixedBytes<32>,
            rhs: alloy::sol_types::private::FixedBytes<32>,
            scalarByte: alloy::sol_types::private::FixedBytes<1>,
        ) -> alloy_contract::SolCallBuilder<&P, fheAddCall, N> {
            self.call_builder(&fheAddCall { lhs, rhs, scalarByte })
        }
        ///Creates a new call builder for the [`fheBitAnd`] function.
        pub fn fheBitAnd(
            &self,
            lhs: alloy::sol_types::private::FixedBytes<32>,
            rhs: alloy::sol_types::private::FixedBytes<32>,
            scalarByte: alloy::sol_types::private::FixedBytes<1>,
        ) -> alloy_contract::SolCallBuilder<&P, fheBitAndCall, N> {
            self.call_builder(
                &fheBitAndCall {
                    lhs,
                    rhs,
                    scalarByte,
                },
            )
        }
        ///Creates a new call builder for the [`fheBitOr`] function.
        pub fn fheBitOr(
            &self,
            lhs: alloy::sol_types::private::FixedBytes<32>,
            rhs: alloy::sol_types::private::FixedBytes<32>,
            scalarByte: alloy::sol_types::private::FixedBytes<1>,
        ) -> alloy_contract::SolCallBuilder<&P, fheBitOrCall, N> {
            self.call_builder(
                &fheBitOrCall {
                    lhs,
                    rhs,
                    scalarByte,
                },
            )
        }
        ///Creates a new call builder for the [`fheBitXor`] function.
        pub fn fheBitXor(
            &self,
            lhs: alloy::sol_types::private::FixedBytes<32>,
            rhs: alloy::sol_types::private::FixedBytes<32>,
            scalarByte: alloy::sol_types::private::FixedBytes<1>,
        ) -> alloy_contract::SolCallBuilder<&P, fheBitXorCall, N> {
            self.call_builder(
                &fheBitXorCall {
                    lhs,
                    rhs,
                    scalarByte,
                },
            )
        }
        ///Creates a new call builder for the [`fheDiv`] function.
        pub fn fheDiv(
            &self,
            lhs: alloy::sol_types::private::FixedBytes<32>,
            rhs: alloy::sol_types::private::FixedBytes<32>,
            scalarByte: alloy::sol_types::private::FixedBytes<1>,
        ) -> alloy_contract::SolCallBuilder<&P, fheDivCall, N> {
            self.call_builder(&fheDivCall { lhs, rhs, scalarByte })
        }
        ///Creates a new call builder for the [`fheEq`] function.
        pub fn fheEq(
            &self,
            lhs: alloy::sol_types::private::FixedBytes<32>,
            rhs: alloy::sol_types::private::FixedBytes<32>,
            scalarByte: alloy::sol_types::private::FixedBytes<1>,
        ) -> alloy_contract::SolCallBuilder<&P, fheEqCall, N> {
            self.call_builder(&fheEqCall { lhs, rhs, scalarByte })
        }
        ///Creates a new call builder for the [`fheGe`] function.
        pub fn fheGe(
            &self,
            lhs: alloy::sol_types::private::FixedBytes<32>,
            rhs: alloy::sol_types::private::FixedBytes<32>,
            scalarByte: alloy::sol_types::private::FixedBytes<1>,
        ) -> alloy_contract::SolCallBuilder<&P, fheGeCall, N> {
            self.call_builder(&fheGeCall { lhs, rhs, scalarByte })
        }
        ///Creates a new call builder for the [`fheGt`] function.
        pub fn fheGt(
            &self,
            lhs: alloy::sol_types::private::FixedBytes<32>,
            rhs: alloy::sol_types::private::FixedBytes<32>,
            scalarByte: alloy::sol_types::private::FixedBytes<1>,
        ) -> alloy_contract::SolCallBuilder<&P, fheGtCall, N> {
            self.call_builder(&fheGtCall { lhs, rhs, scalarByte })
        }
        ///Creates a new call builder for the [`fheIfThenElse`] function.
        pub fn fheIfThenElse(
            &self,
            control: alloy::sol_types::private::FixedBytes<32>,
            ifTrue: alloy::sol_types::private::FixedBytes<32>,
            ifFalse: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<&P, fheIfThenElseCall, N> {
            self.call_builder(
                &fheIfThenElseCall {
                    control,
                    ifTrue,
                    ifFalse,
                },
            )
        }
        ///Creates a new call builder for the [`fheLe`] function.
        pub fn fheLe(
            &self,
            lhs: alloy::sol_types::private::FixedBytes<32>,
            rhs: alloy::sol_types::private::FixedBytes<32>,
            scalarByte: alloy::sol_types::private::FixedBytes<1>,
        ) -> alloy_contract::SolCallBuilder<&P, fheLeCall, N> {
            self.call_builder(&fheLeCall { lhs, rhs, scalarByte })
        }
        ///Creates a new call builder for the [`fheLt`] function.
        pub fn fheLt(
            &self,
            lhs: alloy::sol_types::private::FixedBytes<32>,
            rhs: alloy::sol_types::private::FixedBytes<32>,
            scalarByte: alloy::sol_types::private::FixedBytes<1>,
        ) -> alloy_contract::SolCallBuilder<&P, fheLtCall, N> {
            self.call_builder(&fheLtCall { lhs, rhs, scalarByte })
        }
        ///Creates a new call builder for the [`fheMax`] function.
        pub fn fheMax(
            &self,
            lhs: alloy::sol_types::private::FixedBytes<32>,
            rhs: alloy::sol_types::private::FixedBytes<32>,
            scalarByte: alloy::sol_types::private::FixedBytes<1>,
        ) -> alloy_contract::SolCallBuilder<&P, fheMaxCall, N> {
            self.call_builder(&fheMaxCall { lhs, rhs, scalarByte })
        }
        ///Creates a new call builder for the [`fheMin`] function.
        pub fn fheMin(
            &self,
            lhs: alloy::sol_types::private::FixedBytes<32>,
            rhs: alloy::sol_types::private::FixedBytes<32>,
            scalarByte: alloy::sol_types::private::FixedBytes<1>,
        ) -> alloy_contract::SolCallBuilder<&P, fheMinCall, N> {
            self.call_builder(&fheMinCall { lhs, rhs, scalarByte })
        }
        ///Creates a new call builder for the [`fheMul`] function.
        pub fn fheMul(
            &self,
            lhs: alloy::sol_types::private::FixedBytes<32>,
            rhs: alloy::sol_types::private::FixedBytes<32>,
            scalarByte: alloy::sol_types::private::FixedBytes<1>,
        ) -> alloy_contract::SolCallBuilder<&P, fheMulCall, N> {
            self.call_builder(&fheMulCall { lhs, rhs, scalarByte })
        }
        ///Creates a new call builder for the [`fheNe`] function.
        pub fn fheNe(
            &self,
            lhs: alloy::sol_types::private::FixedBytes<32>,
            rhs: alloy::sol_types::private::FixedBytes<32>,
            scalarByte: alloy::sol_types::private::FixedBytes<1>,
        ) -> alloy_contract::SolCallBuilder<&P, fheNeCall, N> {
            self.call_builder(&fheNeCall { lhs, rhs, scalarByte })
        }
        ///Creates a new call builder for the [`fheNeg`] function.
        pub fn fheNeg(
            &self,
            ct: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<&P, fheNegCall, N> {
            self.call_builder(&fheNegCall { ct })
        }
        ///Creates a new call builder for the [`fheNot`] function.
        pub fn fheNot(
            &self,
            ct: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<&P, fheNotCall, N> {
            self.call_builder(&fheNotCall { ct })
        }
        ///Creates a new call builder for the [`fheRand`] function.
        pub fn fheRand(
            &self,
            randType: <FheType as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<&P, fheRandCall, N> {
            self.call_builder(&fheRandCall { randType })
        }
        ///Creates a new call builder for the [`fheRandBounded`] function.
        pub fn fheRandBounded(
            &self,
            upperBound: alloy::sol_types::private::primitives::aliases::U256,
            randType: <FheType as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<&P, fheRandBoundedCall, N> {
            self.call_builder(
                &fheRandBoundedCall {
                    upperBound,
                    randType,
                },
            )
        }
        ///Creates a new call builder for the [`fheRem`] function.
        pub fn fheRem(
            &self,
            lhs: alloy::sol_types::private::FixedBytes<32>,
            rhs: alloy::sol_types::private::FixedBytes<32>,
            scalarByte: alloy::sol_types::private::FixedBytes<1>,
        ) -> alloy_contract::SolCallBuilder<&P, fheRemCall, N> {
            self.call_builder(&fheRemCall { lhs, rhs, scalarByte })
        }
        ///Creates a new call builder for the [`fheRotl`] function.
        pub fn fheRotl(
            &self,
            lhs: alloy::sol_types::private::FixedBytes<32>,
            rhs: alloy::sol_types::private::FixedBytes<32>,
            scalarByte: alloy::sol_types::private::FixedBytes<1>,
        ) -> alloy_contract::SolCallBuilder<&P, fheRotlCall, N> {
            self.call_builder(
                &fheRotlCall {
                    lhs,
                    rhs,
                    scalarByte,
                },
            )
        }
        ///Creates a new call builder for the [`fheRotr`] function.
        pub fn fheRotr(
            &self,
            lhs: alloy::sol_types::private::FixedBytes<32>,
            rhs: alloy::sol_types::private::FixedBytes<32>,
            scalarByte: alloy::sol_types::private::FixedBytes<1>,
        ) -> alloy_contract::SolCallBuilder<&P, fheRotrCall, N> {
            self.call_builder(
                &fheRotrCall {
                    lhs,
                    rhs,
                    scalarByte,
                },
            )
        }
        ///Creates a new call builder for the [`fheShl`] function.
        pub fn fheShl(
            &self,
            lhs: alloy::sol_types::private::FixedBytes<32>,
            rhs: alloy::sol_types::private::FixedBytes<32>,
            scalarByte: alloy::sol_types::private::FixedBytes<1>,
        ) -> alloy_contract::SolCallBuilder<&P, fheShlCall, N> {
            self.call_builder(&fheShlCall { lhs, rhs, scalarByte })
        }
        ///Creates a new call builder for the [`fheShr`] function.
        pub fn fheShr(
            &self,
            lhs: alloy::sol_types::private::FixedBytes<32>,
            rhs: alloy::sol_types::private::FixedBytes<32>,
            scalarByte: alloy::sol_types::private::FixedBytes<1>,
        ) -> alloy_contract::SolCallBuilder<&P, fheShrCall, N> {
            self.call_builder(&fheShrCall { lhs, rhs, scalarByte })
        }
        ///Creates a new call builder for the [`fheSub`] function.
        pub fn fheSub(
            &self,
            lhs: alloy::sol_types::private::FixedBytes<32>,
            rhs: alloy::sol_types::private::FixedBytes<32>,
            scalarByte: alloy::sol_types::private::FixedBytes<1>,
        ) -> alloy_contract::SolCallBuilder<&P, fheSubCall, N> {
            self.call_builder(&fheSubCall { lhs, rhs, scalarByte })
        }
        ///Creates a new call builder for the [`getACLAddress`] function.
        pub fn getACLAddress(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, getACLAddressCall, N> {
            self.call_builder(&getACLAddressCall)
        }
        ///Creates a new call builder for the [`getHCULimitAddress`] function.
        pub fn getHCULimitAddress(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, getHCULimitAddressCall, N> {
            self.call_builder(&getHCULimitAddressCall)
        }
        ///Creates a new call builder for the [`getHandleVersion`] function.
        pub fn getHandleVersion(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, getHandleVersionCall, N> {
            self.call_builder(&getHandleVersionCall)
        }
        ///Creates a new call builder for the [`getInputVerifierAddress`] function.
        pub fn getInputVerifierAddress(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, getInputVerifierAddressCall, N> {
            self.call_builder(&getInputVerifierAddressCall)
        }
        ///Creates a new call builder for the [`getVersion`] function.
        pub fn getVersion(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, getVersionCall, N> {
            self.call_builder(&getVersionCall)
        }
        ///Creates a new call builder for the [`initializeFromEmptyProxy`] function.
        pub fn initializeFromEmptyProxy(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, initializeFromEmptyProxyCall, N> {
            self.call_builder(&initializeFromEmptyProxyCall)
        }
        ///Creates a new call builder for the [`proxiableUUID`] function.
        pub fn proxiableUUID(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, proxiableUUIDCall, N> {
            self.call_builder(&proxiableUUIDCall)
        }
        ///Creates a new call builder for the [`reinitializeV3`] function.
        pub fn reinitializeV3(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, reinitializeV3Call, N> {
            self.call_builder(&reinitializeV3Call)
        }
        ///Creates a new call builder for the [`trivialEncrypt`] function.
        pub fn trivialEncrypt(
            &self,
            pt: alloy::sol_types::private::primitives::aliases::U256,
            toType: <FheType as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<&P, trivialEncryptCall, N> {
            self.call_builder(&trivialEncryptCall { pt, toType })
        }
        ///Creates a new call builder for the [`upgradeToAndCall`] function.
        pub fn upgradeToAndCall(
            &self,
            newImplementation: alloy::sol_types::private::Address,
            data: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<&P, upgradeToAndCallCall, N> {
            self.call_builder(
                &upgradeToAndCallCall {
                    newImplementation,
                    data,
                },
            )
        }
        ///Creates a new call builder for the [`verifyInput`] function.
        pub fn verifyInput(
            &self,
            inputHandle: alloy::sol_types::private::FixedBytes<32>,
            userAddress: alloy::sol_types::private::Address,
            inputProof: alloy::sol_types::private::Bytes,
            inputType: <FheType as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<&P, verifyInputCall, N> {
            self.call_builder(
                &verifyInputCall {
                    inputHandle,
                    userAddress,
                    inputProof,
                    inputType,
                },
            )
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > FHEVMExecutorInstance<P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<&P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
        ///Creates a new event filter for the [`Cast`] event.
        pub fn Cast_filter(&self) -> alloy_contract::Event<&P, Cast, N> {
            self.event_filter::<Cast>()
        }
        ///Creates a new event filter for the [`FheAdd`] event.
        pub fn FheAdd_filter(&self) -> alloy_contract::Event<&P, FheAdd, N> {
            self.event_filter::<FheAdd>()
        }
        ///Creates a new event filter for the [`FheBitAnd`] event.
        pub fn FheBitAnd_filter(&self) -> alloy_contract::Event<&P, FheBitAnd, N> {
            self.event_filter::<FheBitAnd>()
        }
        ///Creates a new event filter for the [`FheBitOr`] event.
        pub fn FheBitOr_filter(&self) -> alloy_contract::Event<&P, FheBitOr, N> {
            self.event_filter::<FheBitOr>()
        }
        ///Creates a new event filter for the [`FheBitXor`] event.
        pub fn FheBitXor_filter(&self) -> alloy_contract::Event<&P, FheBitXor, N> {
            self.event_filter::<FheBitXor>()
        }
        ///Creates a new event filter for the [`FheDiv`] event.
        pub fn FheDiv_filter(&self) -> alloy_contract::Event<&P, FheDiv, N> {
            self.event_filter::<FheDiv>()
        }
        ///Creates a new event filter for the [`FheEq`] event.
        pub fn FheEq_filter(&self) -> alloy_contract::Event<&P, FheEq, N> {
            self.event_filter::<FheEq>()
        }
        ///Creates a new event filter for the [`FheGe`] event.
        pub fn FheGe_filter(&self) -> alloy_contract::Event<&P, FheGe, N> {
            self.event_filter::<FheGe>()
        }
        ///Creates a new event filter for the [`FheGt`] event.
        pub fn FheGt_filter(&self) -> alloy_contract::Event<&P, FheGt, N> {
            self.event_filter::<FheGt>()
        }
        ///Creates a new event filter for the [`FheIfThenElse`] event.
        pub fn FheIfThenElse_filter(
            &self,
        ) -> alloy_contract::Event<&P, FheIfThenElse, N> {
            self.event_filter::<FheIfThenElse>()
        }
        ///Creates a new event filter for the [`FheLe`] event.
        pub fn FheLe_filter(&self) -> alloy_contract::Event<&P, FheLe, N> {
            self.event_filter::<FheLe>()
        }
        ///Creates a new event filter for the [`FheLt`] event.
        pub fn FheLt_filter(&self) -> alloy_contract::Event<&P, FheLt, N> {
            self.event_filter::<FheLt>()
        }
        ///Creates a new event filter for the [`FheMax`] event.
        pub fn FheMax_filter(&self) -> alloy_contract::Event<&P, FheMax, N> {
            self.event_filter::<FheMax>()
        }
        ///Creates a new event filter for the [`FheMin`] event.
        pub fn FheMin_filter(&self) -> alloy_contract::Event<&P, FheMin, N> {
            self.event_filter::<FheMin>()
        }
        ///Creates a new event filter for the [`FheMul`] event.
        pub fn FheMul_filter(&self) -> alloy_contract::Event<&P, FheMul, N> {
            self.event_filter::<FheMul>()
        }
        ///Creates a new event filter for the [`FheNe`] event.
        pub fn FheNe_filter(&self) -> alloy_contract::Event<&P, FheNe, N> {
            self.event_filter::<FheNe>()
        }
        ///Creates a new event filter for the [`FheNeg`] event.
        pub fn FheNeg_filter(&self) -> alloy_contract::Event<&P, FheNeg, N> {
            self.event_filter::<FheNeg>()
        }
        ///Creates a new event filter for the [`FheNot`] event.
        pub fn FheNot_filter(&self) -> alloy_contract::Event<&P, FheNot, N> {
            self.event_filter::<FheNot>()
        }
        ///Creates a new event filter for the [`FheRand`] event.
        pub fn FheRand_filter(&self) -> alloy_contract::Event<&P, FheRand, N> {
            self.event_filter::<FheRand>()
        }
        ///Creates a new event filter for the [`FheRandBounded`] event.
        pub fn FheRandBounded_filter(
            &self,
        ) -> alloy_contract::Event<&P, FheRandBounded, N> {
            self.event_filter::<FheRandBounded>()
        }
        ///Creates a new event filter for the [`FheRem`] event.
        pub fn FheRem_filter(&self) -> alloy_contract::Event<&P, FheRem, N> {
            self.event_filter::<FheRem>()
        }
        ///Creates a new event filter for the [`FheRotl`] event.
        pub fn FheRotl_filter(&self) -> alloy_contract::Event<&P, FheRotl, N> {
            self.event_filter::<FheRotl>()
        }
        ///Creates a new event filter for the [`FheRotr`] event.
        pub fn FheRotr_filter(&self) -> alloy_contract::Event<&P, FheRotr, N> {
            self.event_filter::<FheRotr>()
        }
        ///Creates a new event filter for the [`FheShl`] event.
        pub fn FheShl_filter(&self) -> alloy_contract::Event<&P, FheShl, N> {
            self.event_filter::<FheShl>()
        }
        ///Creates a new event filter for the [`FheShr`] event.
        pub fn FheShr_filter(&self) -> alloy_contract::Event<&P, FheShr, N> {
            self.event_filter::<FheShr>()
        }
        ///Creates a new event filter for the [`FheSub`] event.
        pub fn FheSub_filter(&self) -> alloy_contract::Event<&P, FheSub, N> {
            self.event_filter::<FheSub>()
        }
        ///Creates a new event filter for the [`Initialized`] event.
        pub fn Initialized_filter(&self) -> alloy_contract::Event<&P, Initialized, N> {
            self.event_filter::<Initialized>()
        }
        ///Creates a new event filter for the [`TrivialEncrypt`] event.
        pub fn TrivialEncrypt_filter(
            &self,
        ) -> alloy_contract::Event<&P, TrivialEncrypt, N> {
            self.event_filter::<TrivialEncrypt>()
        }
        ///Creates a new event filter for the [`Upgraded`] event.
        pub fn Upgraded_filter(&self) -> alloy_contract::Event<&P, Upgraded, N> {
            self.event_filter::<Upgraded>()
        }
        ///Creates a new event filter for the [`VerifyInput`] event.
        pub fn VerifyInput_filter(&self) -> alloy_contract::Event<&P, VerifyInput, N> {
            self.event_filter::<VerifyInput>()
        }
    }
}
