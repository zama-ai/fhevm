/**

Generated by the following Solidity interface...
```solidity
interface FHEVMExecutor {
    type FheType is uint8;

    error ACLNotAllowed(bytes32 handle, address account);
    error AddressEmptyCode(address target);
    error DivisionByZero();
    error ERC1967InvalidImplementation(address implementation);
    error ERC1967NonPayable();
    error FailedCall();
    error IncompatibleTypes();
    error InvalidByteLength(FheType typeOf, uint256 length);
    error InvalidInitialization();
    error InvalidType();
    error IsNotScalar();
    error NotHostOwner(address sender);
    error NotInitializing();
    error NotInitializingFromEmptyProxy();
    error NotPowerOfTwo();
    error ScalarByteIsNotBoolean();
    error SecondOperandIsNotScalar();
    error UUPSUnauthorizedCallContext();
    error UUPSUnsupportedProxiableUUID(bytes32 slot);
    error UnsupportedType();
    error UpperBoundAboveMaxTypeValue();

    event Cast(address indexed caller, bytes32 ct, FheType toType, bytes32 result);
    event FheAdd(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
    event FheBitAnd(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
    event FheBitOr(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
    event FheBitXor(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
    event FheDiv(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
    event FheEq(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
    event FheGe(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
    event FheGt(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
    event FheIfThenElse(address indexed caller, bytes32 control, bytes32 ifTrue, bytes32 ifFalse, bytes32 result);
    event FheLe(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
    event FheLt(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
    event FheMax(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
    event FheMin(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
    event FheMul(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
    event FheNe(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
    event FheNeg(address indexed caller, bytes32 ct, bytes32 result);
    event FheNot(address indexed caller, bytes32 ct, bytes32 result);
    event FheRand(address indexed caller, FheType randType, bytes16 seed, bytes32 result);
    event FheRandBounded(address indexed caller, uint256 upperBound, FheType randType, bytes16 seed, bytes32 result);
    event FheRem(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
    event FheRotl(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
    event FheRotr(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
    event FheShl(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
    event FheShr(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
    event FheSub(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
    event Initialized(uint64 version);
    event TrivialEncrypt(address indexed caller, uint256 pt, FheType toType, bytes32 result);
    event Upgraded(address indexed implementation);
    event VerifyInput(address indexed caller, bytes32 inputHandle, address userAddress, bytes inputProof, FheType inputType, bytes32 result);

    constructor();

    function UPGRADE_INTERFACE_VERSION() external view returns (string memory);
    function cast(bytes32 ct, FheType toType) external returns (bytes32 result);
    function fheAdd(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
    function fheBitAnd(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
    function fheBitOr(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
    function fheBitXor(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
    function fheDiv(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
    function fheEq(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
    function fheGe(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
    function fheGt(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
    function fheIfThenElse(bytes32 control, bytes32 ifTrue, bytes32 ifFalse) external returns (bytes32 result);
    function fheLe(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
    function fheLt(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
    function fheMax(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
    function fheMin(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
    function fheMul(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
    function fheNe(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
    function fheNeg(bytes32 ct) external returns (bytes32 result);
    function fheNot(bytes32 ct) external returns (bytes32 result);
    function fheRand(FheType randType) external returns (bytes32 result);
    function fheRandBounded(uint256 upperBound, FheType randType) external returns (bytes32 result);
    function fheRem(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
    function fheRotl(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
    function fheRotr(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
    function fheShl(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
    function fheShr(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
    function fheSub(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
    function getACLAddress() external view returns (address);
    function getHCULimitAddress() external view returns (address);
    function getHandleVersion() external pure returns (uint8);
    function getInputVerifierAddress() external view returns (address);
    function getVersion() external pure returns (string memory);
    function initializeFromEmptyProxy() external;
    function proxiableUUID() external view returns (bytes32);
    function trivialEncrypt(uint256 pt, FheType toType) external returns (bytes32 result);
    function upgradeToAndCall(address newImplementation, bytes memory data) external payable;
    function verifyInput(bytes32 inputHandle, address userAddress, bytes memory inputProof, FheType inputType) external returns (bytes32 result);
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "constructor",
    "inputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "UPGRADE_INTERFACE_VERSION",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "cast",
    "inputs": [
      {
        "name": "ct",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "toType",
        "type": "uint8",
        "internalType": "enum FheType"
      }
    ],
    "outputs": [
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "fheAdd",
    "inputs": [
      {
        "name": "lhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "internalType": "bytes1"
      }
    ],
    "outputs": [
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "fheBitAnd",
    "inputs": [
      {
        "name": "lhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "internalType": "bytes1"
      }
    ],
    "outputs": [
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "fheBitOr",
    "inputs": [
      {
        "name": "lhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "internalType": "bytes1"
      }
    ],
    "outputs": [
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "fheBitXor",
    "inputs": [
      {
        "name": "lhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "internalType": "bytes1"
      }
    ],
    "outputs": [
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "fheDiv",
    "inputs": [
      {
        "name": "lhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "internalType": "bytes1"
      }
    ],
    "outputs": [
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "fheEq",
    "inputs": [
      {
        "name": "lhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "internalType": "bytes1"
      }
    ],
    "outputs": [
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "fheGe",
    "inputs": [
      {
        "name": "lhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "internalType": "bytes1"
      }
    ],
    "outputs": [
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "fheGt",
    "inputs": [
      {
        "name": "lhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "internalType": "bytes1"
      }
    ],
    "outputs": [
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "fheIfThenElse",
    "inputs": [
      {
        "name": "control",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "ifTrue",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "ifFalse",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "fheLe",
    "inputs": [
      {
        "name": "lhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "internalType": "bytes1"
      }
    ],
    "outputs": [
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "fheLt",
    "inputs": [
      {
        "name": "lhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "internalType": "bytes1"
      }
    ],
    "outputs": [
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "fheMax",
    "inputs": [
      {
        "name": "lhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "internalType": "bytes1"
      }
    ],
    "outputs": [
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "fheMin",
    "inputs": [
      {
        "name": "lhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "internalType": "bytes1"
      }
    ],
    "outputs": [
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "fheMul",
    "inputs": [
      {
        "name": "lhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "internalType": "bytes1"
      }
    ],
    "outputs": [
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "fheNe",
    "inputs": [
      {
        "name": "lhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "internalType": "bytes1"
      }
    ],
    "outputs": [
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "fheNeg",
    "inputs": [
      {
        "name": "ct",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "fheNot",
    "inputs": [
      {
        "name": "ct",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "fheRand",
    "inputs": [
      {
        "name": "randType",
        "type": "uint8",
        "internalType": "enum FheType"
      }
    ],
    "outputs": [
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "fheRandBounded",
    "inputs": [
      {
        "name": "upperBound",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "randType",
        "type": "uint8",
        "internalType": "enum FheType"
      }
    ],
    "outputs": [
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "fheRem",
    "inputs": [
      {
        "name": "lhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "internalType": "bytes1"
      }
    ],
    "outputs": [
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "fheRotl",
    "inputs": [
      {
        "name": "lhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "internalType": "bytes1"
      }
    ],
    "outputs": [
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "fheRotr",
    "inputs": [
      {
        "name": "lhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "internalType": "bytes1"
      }
    ],
    "outputs": [
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "fheShl",
    "inputs": [
      {
        "name": "lhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "internalType": "bytes1"
      }
    ],
    "outputs": [
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "fheShr",
    "inputs": [
      {
        "name": "lhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "internalType": "bytes1"
      }
    ],
    "outputs": [
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "fheSub",
    "inputs": [
      {
        "name": "lhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "internalType": "bytes1"
      }
    ],
    "outputs": [
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "getACLAddress",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getHCULimitAddress",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getHandleVersion",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint8",
        "internalType": "uint8"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "getInputVerifierAddress",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getVersion",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "initializeFromEmptyProxy",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "proxiableUUID",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "trivialEncrypt",
    "inputs": [
      {
        "name": "pt",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "toType",
        "type": "uint8",
        "internalType": "enum FheType"
      }
    ],
    "outputs": [
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "upgradeToAndCall",
    "inputs": [
      {
        "name": "newImplementation",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "data",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [],
    "stateMutability": "payable"
  },
  {
    "type": "function",
    "name": "verifyInput",
    "inputs": [
      {
        "name": "inputHandle",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "userAddress",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "inputProof",
        "type": "bytes",
        "internalType": "bytes"
      },
      {
        "name": "inputType",
        "type": "uint8",
        "internalType": "enum FheType"
      }
    ],
    "outputs": [
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "event",
    "name": "Cast",
    "inputs": [
      {
        "name": "caller",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "ct",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "toType",
        "type": "uint8",
        "indexed": false,
        "internalType": "enum FheType"
      },
      {
        "name": "result",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "FheAdd",
    "inputs": [
      {
        "name": "caller",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "lhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "indexed": false,
        "internalType": "bytes1"
      },
      {
        "name": "result",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "FheBitAnd",
    "inputs": [
      {
        "name": "caller",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "lhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "indexed": false,
        "internalType": "bytes1"
      },
      {
        "name": "result",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "FheBitOr",
    "inputs": [
      {
        "name": "caller",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "lhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "indexed": false,
        "internalType": "bytes1"
      },
      {
        "name": "result",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "FheBitXor",
    "inputs": [
      {
        "name": "caller",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "lhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "indexed": false,
        "internalType": "bytes1"
      },
      {
        "name": "result",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "FheDiv",
    "inputs": [
      {
        "name": "caller",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "lhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "indexed": false,
        "internalType": "bytes1"
      },
      {
        "name": "result",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "FheEq",
    "inputs": [
      {
        "name": "caller",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "lhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "indexed": false,
        "internalType": "bytes1"
      },
      {
        "name": "result",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "FheGe",
    "inputs": [
      {
        "name": "caller",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "lhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "indexed": false,
        "internalType": "bytes1"
      },
      {
        "name": "result",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "FheGt",
    "inputs": [
      {
        "name": "caller",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "lhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "indexed": false,
        "internalType": "bytes1"
      },
      {
        "name": "result",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "FheIfThenElse",
    "inputs": [
      {
        "name": "caller",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "control",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "ifTrue",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "ifFalse",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "result",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "FheLe",
    "inputs": [
      {
        "name": "caller",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "lhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "indexed": false,
        "internalType": "bytes1"
      },
      {
        "name": "result",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "FheLt",
    "inputs": [
      {
        "name": "caller",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "lhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "indexed": false,
        "internalType": "bytes1"
      },
      {
        "name": "result",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "FheMax",
    "inputs": [
      {
        "name": "caller",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "lhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "indexed": false,
        "internalType": "bytes1"
      },
      {
        "name": "result",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "FheMin",
    "inputs": [
      {
        "name": "caller",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "lhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "indexed": false,
        "internalType": "bytes1"
      },
      {
        "name": "result",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "FheMul",
    "inputs": [
      {
        "name": "caller",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "lhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "indexed": false,
        "internalType": "bytes1"
      },
      {
        "name": "result",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "FheNe",
    "inputs": [
      {
        "name": "caller",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "lhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "indexed": false,
        "internalType": "bytes1"
      },
      {
        "name": "result",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "FheNeg",
    "inputs": [
      {
        "name": "caller",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "ct",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "result",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "FheNot",
    "inputs": [
      {
        "name": "caller",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "ct",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "result",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "FheRand",
    "inputs": [
      {
        "name": "caller",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "randType",
        "type": "uint8",
        "indexed": false,
        "internalType": "enum FheType"
      },
      {
        "name": "seed",
        "type": "bytes16",
        "indexed": false,
        "internalType": "bytes16"
      },
      {
        "name": "result",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "FheRandBounded",
    "inputs": [
      {
        "name": "caller",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "upperBound",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "randType",
        "type": "uint8",
        "indexed": false,
        "internalType": "enum FheType"
      },
      {
        "name": "seed",
        "type": "bytes16",
        "indexed": false,
        "internalType": "bytes16"
      },
      {
        "name": "result",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "FheRem",
    "inputs": [
      {
        "name": "caller",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "lhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "indexed": false,
        "internalType": "bytes1"
      },
      {
        "name": "result",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "FheRotl",
    "inputs": [
      {
        "name": "caller",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "lhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "indexed": false,
        "internalType": "bytes1"
      },
      {
        "name": "result",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "FheRotr",
    "inputs": [
      {
        "name": "caller",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "lhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "indexed": false,
        "internalType": "bytes1"
      },
      {
        "name": "result",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "FheShl",
    "inputs": [
      {
        "name": "caller",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "lhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "indexed": false,
        "internalType": "bytes1"
      },
      {
        "name": "result",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "FheShr",
    "inputs": [
      {
        "name": "caller",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "lhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "indexed": false,
        "internalType": "bytes1"
      },
      {
        "name": "result",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "FheSub",
    "inputs": [
      {
        "name": "caller",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "lhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "indexed": false,
        "internalType": "bytes1"
      },
      {
        "name": "result",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Initialized",
    "inputs": [
      {
        "name": "version",
        "type": "uint64",
        "indexed": false,
        "internalType": "uint64"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "TrivialEncrypt",
    "inputs": [
      {
        "name": "caller",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "pt",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "toType",
        "type": "uint8",
        "indexed": false,
        "internalType": "enum FheType"
      },
      {
        "name": "result",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Upgraded",
    "inputs": [
      {
        "name": "implementation",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "VerifyInput",
    "inputs": [
      {
        "name": "caller",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "inputHandle",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "userAddress",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      },
      {
        "name": "inputProof",
        "type": "bytes",
        "indexed": false,
        "internalType": "bytes"
      },
      {
        "name": "inputType",
        "type": "uint8",
        "indexed": false,
        "internalType": "enum FheType"
      },
      {
        "name": "result",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "error",
    "name": "ACLNotAllowed",
    "inputs": [
      {
        "name": "handle",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "AddressEmptyCode",
    "inputs": [
      {
        "name": "target",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "DivisionByZero",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ERC1967InvalidImplementation",
    "inputs": [
      {
        "name": "implementation",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "ERC1967NonPayable",
    "inputs": []
  },
  {
    "type": "error",
    "name": "FailedCall",
    "inputs": []
  },
  {
    "type": "error",
    "name": "IncompatibleTypes",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidByteLength",
    "inputs": [
      {
        "name": "typeOf",
        "type": "uint8",
        "internalType": "enum FheType"
      },
      {
        "name": "length",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "InvalidInitialization",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidType",
    "inputs": []
  },
  {
    "type": "error",
    "name": "IsNotScalar",
    "inputs": []
  },
  {
    "type": "error",
    "name": "NotHostOwner",
    "inputs": [
      {
        "name": "sender",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "NotInitializing",
    "inputs": []
  },
  {
    "type": "error",
    "name": "NotInitializingFromEmptyProxy",
    "inputs": []
  },
  {
    "type": "error",
    "name": "NotPowerOfTwo",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ScalarByteIsNotBoolean",
    "inputs": []
  },
  {
    "type": "error",
    "name": "SecondOperandIsNotScalar",
    "inputs": []
  },
  {
    "type": "error",
    "name": "UUPSUnauthorizedCallContext",
    "inputs": []
  },
  {
    "type": "error",
    "name": "UUPSUnsupportedProxiableUUID",
    "inputs": [
      {
        "name": "slot",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ]
  },
  {
    "type": "error",
    "name": "UnsupportedType",
    "inputs": []
  },
  {
    "type": "error",
    "name": "UpperBoundAboveMaxTypeValue",
    "inputs": []
  }
]
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod FHEVMExecutor {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x60a06040523073ffffffffffffffffffffffffffffffffffffffff1660809073ffffffffffffffffffffffffffffffffffffffff1681525034801562000043575f80fd5b50620000546200005a60201b60201c565b620001c4565b5f6200006b6200015e60201b60201c565b9050805f0160089054906101000a900460ff1615620000b6576040517ff92ee8a900000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b67ffffffffffffffff8016815f015f9054906101000a900467ffffffffffffffff1667ffffffffffffffff16146200015b5767ffffffffffffffff815f015f6101000a81548167ffffffffffffffff021916908367ffffffffffffffff1602179055507fc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d267ffffffffffffffff604051620001529190620001a9565b60405180910390a15b50565b5f7ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00905090565b5f67ffffffffffffffff82169050919050565b620001a38162000185565b82525050565b5f602082019050620001be5f83018462000198565b92915050565b60805161714d620001eb5f395f8181614c0801528181614c5d0152614eff015261714d5ff3fe608060405260043610610219575f3560e01c80637702dcff11610122578063ccc480a1116100aa578063d99882d51161006e578063d99882d5146108fd578063e078697214610939578063f51ccfb014610963578063f6859bdc1461099f578063f77f3f1d146109c957610219565b8063ccc480a1146107d1578063cf4d18aa1461080d578063d580c06314610849578063d75d6e8a14610885578063d8092cbc146108c157610219565b806391f98ffe116100f157806391f98ffe146106c95780639cd07acb14610705578063a8c7c2c114610741578063ad3cb1cc1461076b578063c021329e1461079557610219565b80637702dcff146105eb5780637a297f4b1461062757806385362ee7146106515780638b49ceb41461068d57610219565b806348eef47e116101a55780635a53accb116101745780635a53accb146104bf57806363a2db29146104fb5780636754b3601461053757806372107681146105735780637513a404146105af57610219565b806348eef47e146104015780634f1ef2861461043d57806352d1902d1461045957806357f0a5681461048357610219565b80631391547f116101ec5780631391547f146102fb578063182b6d98146103375780631c89ee441461037357806336318d64146103af57806339f73810146103eb57610219565b806304559f711461021d57806308bf832a146102595780630d8e6e2c14610295578063117b2f38146102bf575b5f80fd5b348015610228575f80fd5b50610243600480360381019061023e9190615f2c565b610a05565b6040516102509190615f8b565b60405180910390f35b348015610264575f80fd5b5061027f600480360381019061027a919061615d565b610bb4565b60405161028c9190615f8b565b60405180910390f35b3480156102a0575f80fd5b506102a9610dd1565b6040516102b69190616257565b60405180910390f35b3480156102ca575f80fd5b506102e560048036038101906102e09190615f2c565b610e4c565b6040516102f29190615f8b565b60405180910390f35b348015610306575f80fd5b50610321600480360381019061031c9190615f2c565b610ffa565b60405161032e9190615f8b565b60405180910390f35b348015610342575f80fd5b5061035d60048036038101906103589190615f2c565b6111a9565b60405161036a9190615f8b565b60405180910390f35b34801561037e575f80fd5b5061039960048036038101906103949190616277565b611358565b6040516103a69190615f8b565b60405180910390f35b3480156103ba575f80fd5b506103d560048036038101906103d09190615f2c565b611869565b6040516103e29190615f8b565b60405180910390f35b3480156103f6575f80fd5b506103ff611a18565b005b34801561040c575f80fd5b50610427600480360381019061042291906162e8565b611b88565b6040516104349190615f8b565b60405180910390f35b61045760048036038101906104529190616326565b611bfc565b005b348015610464575f80fd5b5061046d611c1b565b60405161047a9190615f8b565b60405180910390f35b34801561048e575f80fd5b506104a960048036038101906104a49190615f2c565b611c4c565b6040516104b69190615f8b565b60405180910390f35b3480156104ca575f80fd5b506104e560048036038101906104e09190615f2c565b611dfb565b6040516104f29190615f8b565b60405180910390f35b348015610506575f80fd5b50610521600480360381019061051c9190615f2c565b612044565b60405161052e9190615f8b565b60405180910390f35b348015610542575f80fd5b5061055d60048036038101906105589190615f2c565b61223c565b60405161056a9190615f8b565b60405180910390f35b34801561057e575f80fd5b5061059960048036038101906105949190615f2c565b612410565b6040516105a69190615f8b565b60405180910390f35b3480156105ba575f80fd5b506105d560048036038101906105d09190615f2c565b6125bf565b6040516105e29190615f8b565b60405180910390f35b3480156105f6575f80fd5b50610611600480360381019061060c9190616380565b61276e565b60405161061e9190615f8b565b60405180910390f35b348015610632575f80fd5b5061063b61298a565b60405161064891906163eb565b60405180910390f35b34801561065c575f80fd5b5061067760048036038101906106729190615f2c565b61298e565b6040516106849190615f8b565b60405180910390f35b348015610698575f80fd5b506106b360048036038101906106ae9190615f2c565b612b3d565b6040516106c09190615f8b565b60405180910390f35b3480156106d4575f80fd5b506106ef60048036038101906106ea9190615f2c565b612d35565b6040516106fc9190615f8b565b60405180910390f35b348015610710575f80fd5b5061072b600480360381019061072691906162e8565b612f09565b6040516107389190615f8b565b60405180910390f35b34801561074c575f80fd5b50610755613229565b6040516107629190616413565b60405180910390f35b348015610776575f80fd5b5061077f613244565b60405161078c9190616257565b60405180910390f35b3480156107a0575f80fd5b506107bb60048036038101906107b69190615f2c565b61327d565b6040516107c89190615f8b565b60405180910390f35b3480156107dc575f80fd5b506107f760048036038101906107f29190615f2c565b613451565b6040516108049190615f8b565b60405180910390f35b348015610818575f80fd5b50610833600480360381019061082e9190615f2c565b613625565b6040516108409190615f8b565b60405180910390f35b348015610854575f80fd5b5061086f600480360381019061086a919061642c565b61386e565b60405161087c9190615f8b565b60405180910390f35b348015610890575f80fd5b506108ab60048036038101906108a69190616457565b613a35565b6040516108b89190615f8b565b60405180910390f35b3480156108cc575f80fd5b506108e760048036038101906108e29190615f2c565b613aa5565b6040516108f49190615f8b565b60405180910390f35b348015610908575f80fd5b50610923600480360381019061091e9190615f2c565b613cc2565b6040516109309190615f8b565b60405180910390f35b348015610944575f80fd5b5061094d613eba565b60405161095a9190616413565b60405180910390f35b34801561096e575f80fd5b506109896004803603810190610984919061642c565b613ed5565b6040516109969190615f8b565b60405180910390f35b3480156109aa575f80fd5b506109b36140c0565b6040516109c09190616413565b60405180910390f35b3480156109d4575f80fd5b506109ef60048036038101906109ea9190615f2c565b6140db565b6040516109fc9190615f8b565b60405180910390f35b5f8060066053811115610a1b57610a1a616482565b5b60ff166001901b60056053811115610a3657610a35616482565b5b60ff166001901b60046053811115610a5157610a50616482565b5b60ff166001901b60036053811115610a6c57610a6b616482565b5b60ff166001901b60026053811115610a8757610a86616482565b5b60ff166001901b610a9891906164dc565b610aa291906164dc565b610aac91906164dc565b610ab691906164dc565b90505f610ac386836142f8565b9050610ad360128787878561435e565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff1663642b149082868989886040518663ffffffff1660e01b8152600401610b2a959493929190616564565b5f604051808303815f87803b158015610b41575f80fd5b505af1158015610b53573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167fc11d62b13c360a83082487064be1ec0878b2f0be4f012bf59f89e128063d47ff87878787604051610ba394939291906165b5565b60405180910390a250509392505050565b5f8060405180604001604052808673ffffffffffffffffffffffffffffffffffffffff1681526020013373ffffffffffffffffffffffffffffffffffffffff1681525090505f610c038761468e565b9050806053811115610c1857610c17616482565b5b846053811115610c2b57610c2a616482565b5b14610c62576040517fb968846100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b7336772142b74871f255cbd7a3e89b401d3e45825f73ffffffffffffffffffffffffffffffffffffffff1663e6317df58389886040518463ffffffff1660e01b8152600401610cb393929190616686565b6020604051808303815f875af1158015610ccf573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610cf391906166d6565b92507350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff16633e395cec84336040518363ffffffff1660e01b8152600401610d44929190616701565b5f604051808303815f87803b158015610d5b575f80fd5b505af1158015610d6d573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167fdc370db33589e73371dc3ee42c789c003d336eefcb7c3f56fe0f51ae5b1d97028888888888604051610dbf959493929190616728565b60405180910390a25050949350505050565b60606040518060400160405280600d81526020017f464845564d4578656375746f7200000000000000000000000000000000000000815250610e125f6146c6565b610e1c60016146c6565b610e255f6146c6565b604051602001610e38949392919061684e565b604051602081830303815290604052905090565b5f8060066053811115610e6257610e61616482565b5b60ff166001901b60056053811115610e7d57610e7c616482565b5b60ff166001901b60046053811115610e9857610e97616482565b5b60ff166001901b60036053811115610eb357610eb2616482565b5b60ff166001901b60026053811115610ece57610ecd616482565b5b60ff166001901b610edf91906164dc565b610ee991906164dc565b610ef391906164dc565b610efd91906164dc565b90505f610f0a86836142f8565b9050610f195f8787878561435e565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff1663fdad4c9682868989886040518663ffffffff1660e01b8152600401610f70959493929190616564565b5f604051808303815f87803b158015610f87575f80fd5b505af1158015610f99573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167fdb9050d65240431621d61d6f94b970e63f53a67a5766614ee6e5c5bbd41c8e2e87878787604051610fe994939291906165b5565b60405180910390a250509392505050565b5f80600660538111156110105761100f616482565b5b60ff166001901b6005605381111561102b5761102a616482565b5b60ff166001901b6004605381111561104657611045616482565b5b60ff166001901b6003605381111561106157611060616482565b5b60ff166001901b6002605381111561107c5761107b616482565b5b60ff166001901b61108d91906164dc565b61109791906164dc565b6110a191906164dc565b6110ab91906164dc565b90505f6110b886836142f8565b90506110c8600e8787875f61435e565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff16636bb3c61182868989886040518663ffffffff1660e01b815260040161111f959493929190616564565b5f604051808303815f87803b158015611136575f80fd5b505af1158015611148573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167f38c3a63c4230de5b741f494ffb54e3087104030279bc7bccee8ad9ad31712b218787878760405161119894939291906165b5565b60405180910390a250509392505050565b5f80600660538111156111bf576111be616482565b5b60ff166001901b600560538111156111da576111d9616482565b5b60ff166001901b600460538111156111f5576111f4616482565b5b60ff166001901b600360538111156112105761120f616482565b5b60ff166001901b6002605381111561122b5761122a616482565b5b60ff166001901b61123c91906164dc565b61124691906164dc565b61125091906164dc565b61125a91906164dc565b90505f61126786836142f8565b905061127760018787878561435e565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff16639075310882868989886040518663ffffffff1660e01b81526004016112ce959493929190616564565b5f604051808303815f87803b1580156112e5575f80fd5b505af11580156112f7573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167feb6d37bd271abe1395b21d6d78f3487d6584862872c29ffd3f90736ee99b73938787878760405161134794939291906165b5565b60405180910390a250509392505050565b5f7350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff166382027b6d84336040518363ffffffff1660e01b81526004016113a8929190616701565b602060405180830381865afa1580156113c3573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906113e791906168e1565b61142a5782336040517f9de3392c000000000000000000000000000000000000000000000000000000008152600401611421929190616701565b60405180910390fd5b5f6008605381111561143f5761143e616482565b5b60ff166001901b6006605381111561145a57611459616482565b5b60ff166001901b6005605381111561147557611474616482565b5b60ff166001901b600460538111156114905761148f616482565b5b60ff166001901b600360538111156114ab576114aa616482565b5b60ff166001901b600260538111156114c6576114c5616482565b5b60ff166001901b5f60538111156114e0576114df616482565b5b60ff166001901b6114f191906164dc565b6114fb91906164dc565b61150591906164dc565b61150f91906164dc565b61151991906164dc565b61152391906164dc565b90505f61153085836142f8565b90505f6008605381111561154757611546616482565b5b60ff166001901b6006605381111561156257611561616482565b5b60ff166001901b6005605381111561157d5761157c616482565b5b60ff166001901b6004605381111561159857611597616482565b5b60ff166001901b600360538111156115b3576115b2616482565b5b60ff166001901b600260538111156115ce576115cd616482565b5b60ff166001901b6115df91906164dc565b6115e991906164dc565b6115f391906164dc565b6115fd91906164dc565b61160791906164dc565b90505f8186605381111561161e5761161d616482565b5b60ff166001901b160361165d576040517fc6de466a00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b8460538111156116705761166f616482565b5b82605381111561168357611682616482565b5b036116ba576040517fb968846100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b601786867350157cffd6bbfa2dece204a89ec419c23ef5755d466040516020016116e8959493929190616a5f565b60405160208183030381529060405280519060200120935061170a8486614790565b9350611714614809565b73233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff166302dd62768688876040518463ffffffff1660e01b815260040161176593929190616abd565b5f604051808303815f87803b15801561177c575f80fd5b505af115801561178e573d5f803e3d5ffd5b505050507350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff16633e395cec85336040518363ffffffff1660e01b81526004016117e1929190616701565b5f604051808303815f87803b1580156117f8575f80fd5b505af115801561180a573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167f31ccae6a2f8e3ced1692f77c8f668133e4afdaaa35afe844ff4659a6c27e627f87878760405161185893929190616af2565b60405180910390a250505092915050565b5f806006605381111561187f5761187e616482565b5b60ff166001901b6005605381111561189a57611899616482565b5b60ff166001901b600460538111156118b5576118b4616482565b5b60ff166001901b600360538111156118d0576118cf616482565b5b60ff166001901b600260538111156118eb576118ea616482565b5b60ff166001901b6118fc91906164dc565b61190691906164dc565b61191091906164dc565b61191a91906164dc565b90505f61192786836142f8565b905061193760138787878561435e565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff1663acb5f38882868989886040518663ffffffff1660e01b815260040161198e959493929190616564565b5f604051808303815f87803b1580156119a5575f80fd5b505af11580156119b7573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167ffd7c9208f956bf0c6ab76a667f04361245ad3e0a2d0eff92eb827acfcca68ea987878787604051611a0794939291906165b5565b60405180910390a250509392505050565b6001611a22614885565b67ffffffffffffffff1614611a63576040517f6f4f731f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60025f611a6e6148a9565b9050805f0160089054906101000a900460ff1680611ab657508167ffffffffffffffff16815f015f9054906101000a900467ffffffffffffffff1667ffffffffffffffff1610155b15611aed576040517ff92ee8a900000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b81815f015f6101000a81548167ffffffffffffffff021916908367ffffffffffffffff1602179055506001815f0160086101000a81548160ff0219169083151502179055505f815f0160086101000a81548160ff0219169083151502179055507fc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d282604051611b7c9190616b49565b60405180910390a15050565b5f80611b926148d0565b9050611b9f84848361494d565b91503373ffffffffffffffffffffffffffffffffffffffff167f5222d96b836727a1d6fe1ee9aef27f9bb507bd41794defa376ff6c648aaf8ff185858486604051611bed9493929190616bab565b60405180910390a25092915050565b611c04614c06565b611c0d82614cec565b611c178282614ddf565b5050565b5f611c24614efd565b7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5f1b905090565b5f8060066053811115611c6257611c61616482565b5b60ff166001901b60056053811115611c7d57611c7c616482565b5b60ff166001901b60046053811115611c9857611c97616482565b5b60ff166001901b60036053811115611cb357611cb2616482565b5b60ff166001901b60026053811115611cce57611ccd616482565b5b60ff166001901b611cdf91906164dc565b611ce991906164dc565b611cf391906164dc565b611cfd91906164dc565b90505f611d0a86836142f8565b9050611d1a60028787878561435e565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff16633c16ff0d82868989886040518663ffffffff1660e01b8152600401611d71959493929190616564565b5f604051808303815f87803b158015611d88575f80fd5b505af1158015611d9a573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167f215346a4f9f975e6d5484e290bd4e53ca14453a9d282ebd3ccedb2a0f171753d87878787604051611dea94939291906165b5565b60405180910390a250509392505050565b5f600160f81b827effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191614611e5b576040517f4f224e5300000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f801b8303611e96576040517f23d359a300000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f60066053811115611eab57611eaa616482565b5b60ff166001901b60056053811115611ec657611ec5616482565b5b60ff166001901b60046053811115611ee157611ee0616482565b5b60ff166001901b60036053811115611efc57611efb616482565b5b60ff166001901b60026053811115611f1757611f16616482565b5b60ff166001901b611f2891906164dc565b611f3291906164dc565b611f3c91906164dc565b611f4691906164dc565b90505f611f5386836142f8565b9050611f6360038787878561435e565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff1663406b451382868989886040518663ffffffff1660e01b8152600401611fba959493929190616564565b5f604051808303815f87803b158015611fd1575f80fd5b505af1158015611fe3573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167f3bab2ee0e2f90f4690c6a87bf63cf1a6b626086e95f231860b152966e8dabbf78787878760405161203394939291906165b5565b60405180910390a250509392505050565b5f806008605381111561205a57612059616482565b5b60ff166001901b6006605381111561207557612074616482565b5b60ff166001901b600560538111156120905761208f616482565b5b60ff166001901b600460538111156120ab576120aa616482565b5b60ff166001901b600360538111156120c6576120c5616482565b5b60ff166001901b600260538111156120e1576120e0616482565b5b60ff166001901b5f60538111156120fb576120fa616482565b5b60ff166001901b61210c91906164dc565b61211691906164dc565b61212091906164dc565b61212a91906164dc565b61213491906164dc565b61213e91906164dc565b90505f61214b86836142f8565b905061215b60068787878561435e565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff1663e8e399ad82868989886040518663ffffffff1660e01b81526004016121b2959493929190616564565b5f604051808303815f87803b1580156121c9575f80fd5b505af11580156121db573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167f56df279bbfb03d9ed097bbe2f28d520ca0c1161206327926e98664d70d2c24c48787878760405161222b94939291906165b5565b60405180910390a250509392505050565b5f806008605381111561225257612251616482565b5b60ff166001901b6006605381111561226d5761226c616482565b5b60ff166001901b6005605381111561228857612287616482565b5b60ff166001901b600460538111156122a3576122a2616482565b5b60ff166001901b600360538111156122be576122bd616482565b5b60ff166001901b600260538111156122d9576122d8616482565b5b60ff166001901b6122ea91906164dc565b6122f491906164dc565b6122fe91906164dc565b61230891906164dc565b61231291906164dc565b90505f61231f86836142f8565b905061232f600a8787878561435e565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff166314526e8782868989886040518663ffffffff1660e01b8152600401612386959493929190616564565b5f604051808303815f87803b15801561239d575f80fd5b505af11580156123af573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167feb0e4f8dc74058194d0602425fe602f955c222200f7f10c6fe67992f7b24c7e9878787876040516123ff94939291906165b5565b60405180910390a250509392505050565b5f806006605381111561242657612425616482565b5b60ff166001901b6005605381111561244157612440616482565b5b60ff166001901b6004605381111561245c5761245b616482565b5b60ff166001901b6003605381111561247757612476616482565b5b60ff166001901b6002605381111561249257612491616482565b5b60ff166001901b6124a391906164dc565b6124ad91906164dc565b6124b791906164dc565b6124c191906164dc565b90505f6124ce86836142f8565b90506124de60118787875f61435e565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff16631339c5ee82868989886040518663ffffffff1660e01b8152600401612535959493929190616564565b5f604051808303815f87803b15801561254c575f80fd5b505af115801561255e573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167f0d483b100d8c73b208984ec697caa3091521ee5525ce69edcf97d7e395d3d059878787876040516125ae94939291906165b5565b60405180910390a250509392505050565b5f80600660538111156125d5576125d4616482565b5b60ff166001901b600560538111156125f0576125ef616482565b5b60ff166001901b6004605381111561260b5761260a616482565b5b60ff166001901b6003605381111561262657612625616482565b5b60ff166001901b6002605381111561264157612640616482565b5b60ff166001901b61265291906164dc565b61265c91906164dc565b61266691906164dc565b61267091906164dc565b90505f61267d86836142f8565b905061268d60108787875f61435e565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff1663d47f3d5982868989886040518663ffffffff1660e01b81526004016126e4959493929190616564565b5f604051808303815f87803b1580156126fb575f80fd5b505af115801561270d573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167fdef2e704a077284a07f3d0b436db88f5d981b69f58ab7c1ae623252718a6de018787878760405161275d94939291906165b5565b60405180910390a250509392505050565b5f806008605381111561278457612783616482565b5b60ff166001901b6007605381111561279f5761279e616482565b5b60ff166001901b600660538111156127ba576127b9616482565b5b60ff166001901b600560538111156127d5576127d4616482565b5b60ff166001901b600460538111156127f0576127ef616482565b5b60ff166001901b6003605381111561280b5761280a616482565b5b60ff166001901b6002605381111561282657612825616482565b5b60ff166001901b5f60538111156128405761283f616482565b5b60ff166001901b61285191906164dc565b61285b91906164dc565b61286591906164dc565b61286f91906164dc565b61287991906164dc565b61288391906164dc565b61288d91906164dc565b90505f61289a85836142f8565b90506128a96019878787614f84565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff16634e72676982888888886040518663ffffffff1660e01b8152600401612900959493929190616bee565b5f604051808303815f87803b158015612917575f80fd5b505af1158015612929573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167f60be9d61aad849facc28c38b048cb5c4be3420b8fa2233e08cfa06be1b6d1c3e878787876040516129799493929190616c3f565b60405180910390a250509392505050565b5f90565b5f80600660538111156129a4576129a3616482565b5b60ff166001901b600560538111156129bf576129be616482565b5b60ff166001901b600460538111156129da576129d9616482565b5b60ff166001901b600360538111156129f5576129f4616482565b5b60ff166001901b60026053811115612a1057612a0f616482565b5b60ff166001901b612a2191906164dc565b612a2b91906164dc565b612a3591906164dc565b612a3f91906164dc565b90505f612a4c86836142f8565b9050612a5c600f8787875f61435e565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff1663859a1b7082868989886040518663ffffffff1660e01b8152600401612ab3959493929190616564565b5f604051808303815f87803b158015612aca575f80fd5b505af1158015612adc573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167fc9ff8f0d18a3f766ce5de3de216076050140e4fc2652f5e0e745f6fc836cda8b87878787604051612b2c94939291906165b5565b60405180910390a250509392505050565b5f8060086053811115612b5357612b52616482565b5b60ff166001901b60066053811115612b6e57612b6d616482565b5b60ff166001901b60056053811115612b8957612b88616482565b5b60ff166001901b60046053811115612ba457612ba3616482565b5b60ff166001901b60036053811115612bbf57612bbe616482565b5b60ff166001901b60026053811115612bda57612bd9616482565b5b60ff166001901b5f6053811115612bf457612bf3616482565b5b60ff166001901b612c0591906164dc565b612c0f91906164dc565b612c1991906164dc565b612c2391906164dc565b612c2d91906164dc565b612c3791906164dc565b90505f612c4486836142f8565b9050612c5460078787878561435e565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff16631434ba4d82868989886040518663ffffffff1660e01b8152600401612cab959493929190616564565b5f604051808303815f87803b158015612cc2575f80fd5b505af1158015612cd4573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167f4d32284bd3193ecaa44e1ceca32f41c5d6c32803a92e07967dd3ee422972158287878787604051612d2494939291906165b5565b60405180910390a250509392505050565b5f8060086053811115612d4b57612d4a616482565b5b60ff166001901b60066053811115612d6657612d65616482565b5b60ff166001901b60056053811115612d8157612d80616482565b5b60ff166001901b60046053811115612d9c57612d9b616482565b5b60ff166001901b60036053811115612db757612db6616482565b5b60ff166001901b60026053811115612dd257612dd1616482565b5b60ff166001901b612de391906164dc565b612ded91906164dc565b612df791906164dc565b612e0191906164dc565b612e0b91906164dc565b90505f612e1886836142f8565b9050612e2860098787878561435e565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff16631ed91ff682868989886040518663ffffffff1660e01b8152600401612e7f959493929190616564565b5f604051808303815f87803b158015612e96575f80fd5b505af1158015612ea8573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167f324220bfc9cb158b492991c03c309cd86e5345cac45aacae2092ddabe31fa3d887878787604051612ef894939291906165b5565b60405180910390a250509392505050565b5f8060086053811115612f1f57612f1e616482565b5b60ff166001901b60076053811115612f3a57612f39616482565b5b60ff166001901b60066053811115612f5557612f54616482565b5b60ff166001901b60056053811115612f7057612f6f616482565b5b60ff166001901b60046053811115612f8b57612f8a616482565b5b60ff166001901b60036053811115612fa657612fa5616482565b5b60ff166001901b60026053811115612fc157612fc0616482565b5b60ff166001901b5f6053811115612fdb57612fda616482565b5b60ff166001901b612fec91906164dc565b612ff691906164dc565b61300091906164dc565b61300a91906164dc565b61301491906164dc565b61301e91906164dc565b61302891906164dc565b90505f8184605381111561303f5761303e616482565b5b60ff166001901b160361307e576040517fc6de466a00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b601884847350157cffd6bbfa2dece204a89ec419c23ef5755d466040516020016130ac959493929190616c82565b6040516020818303038152906040528051906020012091506130ce8284614790565b91506130d8614809565b73233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff1663348c318584846040518363ffffffff1660e01b8152600401613127929190616ce0565b5f604051808303815f87803b15801561313e575f80fd5b505af1158015613150573d5f803e3d5ffd5b505050507350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff16633e395cec83336040518363ffffffff1660e01b81526004016131a3929190616701565b5f604051808303815f87803b1580156131ba575f80fd5b505af11580156131cc573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167f063ccd1bba45151d91f6a418065047a3d048d058a922535747bb2b575a01d23685858560405161321a93929190616d07565b60405180910390a25092915050565b5f7336772142b74871f255cbd7a3e89b401d3e45825f905090565b6040518060400160405280600581526020017f352e302e3000000000000000000000000000000000000000000000000000000081525081565b5f806008605381111561329357613292616482565b5b60ff166001901b600660538111156132ae576132ad616482565b5b60ff166001901b600560538111156132c9576132c8616482565b5b60ff166001901b600460538111156132e4576132e3616482565b5b60ff166001901b600360538111156132ff576132fe616482565b5b60ff166001901b6002605381111561331a57613319616482565b5b60ff166001901b61332b91906164dc565b61333591906164dc565b61333f91906164dc565b61334991906164dc565b61335391906164dc565b90505f61336086836142f8565b9050613370600b8787878561435e565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff1663669181c082868989886040518663ffffffff1660e01b81526004016133c7959493929190616564565b5f604051808303815f87803b1580156133de575f80fd5b505af11580156133f0573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167fc148675905d07ad5496f8ef4d8195c907503f3ec12fd10ed5f21240abc6936348787878760405161344094939291906165b5565b60405180910390a250509392505050565b5f806008605381111561346757613466616482565b5b60ff166001901b6006605381111561348257613481616482565b5b60ff166001901b6005605381111561349d5761349c616482565b5b60ff166001901b600460538111156134b8576134b7616482565b5b60ff166001901b600360538111156134d3576134d2616482565b5b60ff166001901b600260538111156134ee576134ed616482565b5b60ff166001901b6134ff91906164dc565b61350991906164dc565b61351391906164dc565b61351d91906164dc565b61352791906164dc565b90505f61353486836142f8565b905061354460088787878561435e565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff166383e6a72082868989886040518663ffffffff1660e01b815260040161359b959493929190616564565b5f604051808303815f87803b1580156135b2575f80fd5b505af11580156135c4573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167fe84282aaebcca698443e39a2a948a345d0d2ebc654af5cb657a2d7e8053bf6cb8787878760405161361494939291906165b5565b60405180910390a250509392505050565b5f600160f81b827effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191614613685576040517f4f224e5300000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f801b83036136c0576040517f23d359a300000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f600660538111156136d5576136d4616482565b5b60ff166001901b600560538111156136f0576136ef616482565b5b60ff166001901b6004605381111561370b5761370a616482565b5b60ff166001901b6003605381111561372657613725616482565b5b60ff166001901b6002605381111561374157613740616482565b5b60ff166001901b61375291906164dc565b61375c91906164dc565b61376691906164dc565b61377091906164dc565b90505f61377d86836142f8565b905061378d60048787878561435e565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff1663fa08e38d82868989886040518663ffffffff1660e01b81526004016137e4959493929190616564565b5f604051808303815f87803b1580156137fb575f80fd5b505af115801561380d573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167f0e691cd0bf8c4e9308e4ced1bb9c964117dc5c5bb9b9ab5bdfebf2c9b13a897c8787878760405161385d94939291906165b5565b60405180910390a250509392505050565b5f806008605381111561388457613883616482565b5b60ff166001901b6006605381111561389f5761389e616482565b5b60ff166001901b600560538111156138ba576138b9616482565b5b60ff166001901b600460538111156138d5576138d4616482565b5b60ff166001901b600360538111156138f0576138ef616482565b5b60ff166001901b6002605381111561390b5761390a616482565b5b60ff166001901b61391c91906164dc565b61392691906164dc565b61393091906164dc565b61393a91906164dc565b61394491906164dc565b90505f61395184836142f8565b905061395e6014856153b8565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff1663a4c98f3e8286866040518463ffffffff1660e01b81526004016139b193929190616abd565b5f604051808303815f87803b1580156139c8575f80fd5b505af11580156139da573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167f8c664d3c3ca583fc5803b8a91c49644bbd9550bfa87967c73ad1de83027768c08585604051613a26929190616d3c565b60405180910390a25050919050565b5f80613a3f6148d0565b9050613a4b8382615570565b91503373ffffffffffffffffffffffffffffffffffffffff167f0c8aca6017003326051e19913ef02631f24b801125e1fa8a1d812e868319fda6848385604051613a9793929190616d63565b60405180910390a250919050565b5f8060086053811115613abb57613aba616482565b5b60ff166001901b60076053811115613ad657613ad5616482565b5b60ff166001901b60066053811115613af157613af0616482565b5b60ff166001901b60056053811115613b0c57613b0b616482565b5b60ff166001901b60046053811115613b2757613b26616482565b5b60ff166001901b60036053811115613b4257613b41616482565b5b60ff166001901b60026053811115613b5d57613b5c616482565b5b60ff166001901b5f6053811115613b7757613b76616482565b5b60ff166001901b613b8891906164dc565b613b9291906164dc565b613b9c91906164dc565b613ba691906164dc565b613bb091906164dc565b613bba91906164dc565b613bc491906164dc565b90505f613bd186836142f8565b9050613be1600d8787875f61435e565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff1663fa5defdb82868989886040518663ffffffff1660e01b8152600401613c38959493929190616564565b5f604051808303815f87803b158015613c4f575f80fd5b505af1158015613c61573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167f6960c1e88f61c352dba34d1bbf6753e302795264d5d8ae82f7983c7004651e5d87878787604051613cb194939291906165b5565b60405180910390a250509392505050565b5f8060086053811115613cd857613cd7616482565b5b60ff166001901b60066053811115613cf357613cf2616482565b5b60ff166001901b60056053811115613d0e57613d0d616482565b5b60ff166001901b60046053811115613d2957613d28616482565b5b60ff166001901b60036053811115613d4457613d43616482565b5b60ff166001901b60026053811115613d5f57613d5e616482565b5b60ff166001901b5f6053811115613d7957613d78616482565b5b60ff166001901b613d8a91906164dc565b613d9491906164dc565b613d9e91906164dc565b613da891906164dc565b613db291906164dc565b613dbc91906164dc565b90505f613dc986836142f8565b9050613dd960058787878561435e565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff16631856d91d82868989886040518663ffffffff1660e01b8152600401613e30959493929190616564565b5f604051808303815f87803b158015613e47575f80fd5b505af1158015613e59573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167fe42486b0ccdbef81a2075c48c8e515c079aea73c8b82429997c72a2fe1bf4fef87878787604051613ea994939291906165b5565b60405180910390a250509392505050565b5f73233ff88a48c172d29f675403e6a8e302b0f032d9905090565b5f8060086053811115613eeb57613eea616482565b5b60ff166001901b60066053811115613f0657613f05616482565b5b60ff166001901b60056053811115613f2157613f20616482565b5b60ff166001901b60046053811115613f3c57613f3b616482565b5b60ff166001901b60036053811115613f5757613f56616482565b5b60ff166001901b60026053811115613f7257613f71616482565b5b60ff166001901b5f6053811115613f8c57613f8b616482565b5b60ff166001901b613f9d91906164dc565b613fa791906164dc565b613fb191906164dc565b613fbb91906164dc565b613fc591906164dc565b613fcf91906164dc565b90505f613fdc84836142f8565b9050613fe96015856153b8565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff1663fc063c628286866040518463ffffffff1660e01b815260040161403c93929190616abd565b5f604051808303815f87803b158015614053575f80fd5b505af1158015614065573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167f55aff4cc7a3d160c83f1f15b818011ede841a0b4597fb14dcd3603df3a11e5e085856040516140b1929190616d3c565b60405180910390a25050919050565b5f7350157cffd6bbfa2dece204a89ec419c23ef5755d905090565b5f80600860538111156140f1576140f0616482565b5b60ff166001901b6007605381111561410c5761410b616482565b5b60ff166001901b6006605381111561412757614126616482565b5b60ff166001901b6005605381111561414257614141616482565b5b60ff166001901b6004605381111561415d5761415c616482565b5b60ff166001901b6003605381111561417857614177616482565b5b60ff166001901b6002605381111561419357614192616482565b5b60ff166001901b5f60538111156141ad576141ac616482565b5b60ff166001901b6141be91906164dc565b6141c891906164dc565b6141d291906164dc565b6141dc91906164dc565b6141e691906164dc565b6141f091906164dc565b6141fa91906164dc565b90505f61420786836142f8565b9050614217600c8787875f61435e565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff166394e70e4f82868989886040518663ffffffff1660e01b815260040161426e959493929190616564565b5f604051808303815f87803b158015614285575f80fd5b505af1158015614297573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167fb3d5c664ec86575818e8d75ff25c5f867250df8954088549c41c848cd10e76cb878787876040516142e794939291906165b5565b60405180910390a250509392505050565b5f6143028361468e565b90505f8282605381111561431957614318616482565b5b60ff166001901b1603614358576040517fc6de466a00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b92915050565b5f614367614809565b61437083615801565b7350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff166382027b6d86336040518363ffffffff1660e01b81526004016143bf929190616701565b602060405180830381865afa1580156143da573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906143fe91906168e1565b6144415784336040517f9de3392c000000000000000000000000000000000000000000000000000000008152600401614438929190616701565b60405180910390fd5b5f60f81b837effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916036145b6577350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff166382027b6d85336040518363ffffffff1660e01b81526004016144bc929190616701565b602060405180830381865afa1580156144d7573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906144fb91906168e1565b61453e5783336040517f9de3392c000000000000000000000000000000000000000000000000000000008152600401614535929190616701565b60405180910390fd5b5f6145488561468e565b90505f6145548761468e565b905081605381111561456957614568616482565b5b81605381111561457c5761457b616482565b5b146145b3576040517f1f3158c700000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b50505b858585857350157cffd6bbfa2dece204a89ec419c23ef5755d466040516020016145e596959493929190616db8565b6040516020818303038152906040528051906020012090506146078183614790565b90507350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff16633e395cec82336040518363ffffffff1660e01b8152600401614658929190616701565b5f604051808303815f87803b15801561466f575f80fd5b505af1158015614681573d5f803e3d5ffd5b5050505095945050505050565b5f81601e602081106146a3576146a2616e27565b5b1a60f81b60f81c60ff1660538111156146bf576146be616482565b5b9050919050565b60605f60016146d484615845565b0190505f8167ffffffffffffffff8111156146f2576146f1616016565b5b6040519080825280601f01601f1916602001820160405280156147245781602001600182028036833780820191505090505b5090505f82602001820190505b600115614785578080600190039150507f3031323334353637383961626364656600000000000000000000000000000000600a86061a8153600a858161477a57614779616e54565b5b0494505f8503614731575b819350505050919050565b5f7fffffffffffffffffffffffffffffffffffffffffff00000000000000000000005f1b83169050605060ff5f1b901b8117905060104667ffffffffffffffff165f1b901b8117905060088260538111156147ee576147ed616482565b5b60ff165f1b901b811790505f60ff165f1b8117905092915050565b73233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff166367a7457b336040518263ffffffff1660e01b81526004016148569190616413565b5f604051808303815f87803b15801561486d575f80fd5b505af115801561487f573d5f803e3d5ffd5b50505050565b5f61488e6148a9565b5f015f9054906101000a900467ffffffffffffffff16905090565b5f7ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00905090565b5f806148da615996565b9050805f01547350157cffd6bbfa2dece204a89ec419c23ef5755d466001436149039190616e81565b4042604051602001614919959493929190616eb4565b604051602081830303815290604052805190602001209150805f015f81548092919061494490616f12565b91905055505090565b5f806008605381111561496357614962616482565b5b60ff166001901b6006605381111561497e5761497d616482565b5b60ff166001901b6005605381111561499957614998616482565b5b60ff166001901b600460538111156149b4576149b3616482565b5b60ff166001901b600360538111156149cf576149ce616482565b5b60ff166001901b600260538111156149ea576149e9616482565b5b60ff166001901b6149fb91906164dc565b614a0591906164dc565b614a0f91906164dc565b614a1991906164dc565b614a2391906164dc565b90505f81856053811115614a3a57614a39616482565b5b60ff166001901b1603614a79576040517fc6de466a00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b614a82856159bd565b614ab8576040517f24e8e74200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b614ac285856159e1565b601b858585604051602001614ada9493929190616f79565b604051602081830303815290604052805190602001209150614afc8285614790565b9150614b06614809565b73233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff1663cc86678285846040518363ffffffff1660e01b8152600401614b55929190616ce0565b5f604051808303815f87803b158015614b6c575f80fd5b505af1158015614b7e573d5f803e3d5ffd5b505050507350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff16633e395cec83336040518363ffffffff1660e01b8152600401614bd1929190616701565b5f604051808303815f87803b158015614be8575f80fd5b505af1158015614bfa573d5f803e3d5ffd5b50505050509392505050565b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff163073ffffffffffffffffffffffffffffffffffffffff161480614cb357507f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16614c9a615b31565b73ffffffffffffffffffffffffffffffffffffffff1614155b15614cea576040517fe07c8dba00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b565b7350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff16638da5cb5b6040518163ffffffff1660e01b8152600401602060405180830381865afa158015614d49573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190614d6d9190616fda565b73ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614614ddc57336040517f21bfda10000000000000000000000000000000000000000000000000000000008152600401614dd39190616413565b60405180910390fd5b50565b8173ffffffffffffffffffffffffffffffffffffffff166352d1902d6040518163ffffffff1660e01b8152600401602060405180830381865afa925050508015614e4757506040513d601f19601f82011682018060405250810190614e4491906166d6565b60015b614e8857816040517f4c9c8ce3000000000000000000000000000000000000000000000000000000008152600401614e7f9190616413565b60405180910390fd5b7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5f1b8114614eee57806040517faa1d49a4000000000000000000000000000000000000000000000000000000008152600401614ee59190615f8b565b60405180910390fd5b614ef88383615b84565b505050565b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff163073ffffffffffffffffffffffffffffffffffffffff1614614f82576040517fe07c8dba00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b565b5f614f8d614809565b7350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff166382027b6d85336040518363ffffffff1660e01b8152600401614fdc929190616701565b602060405180830381865afa158015614ff7573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061501b91906168e1565b61505e5783336040517f9de3392c000000000000000000000000000000000000000000000000000000008152600401615055929190616701565b60405180910390fd5b7350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff166382027b6d84336040518363ffffffff1660e01b81526004016150ad929190616701565b602060405180830381865afa1580156150c8573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906150ec91906168e1565b61512f5782336040517f9de3392c000000000000000000000000000000000000000000000000000000008152600401615126929190616701565b60405180910390fd5b7350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff166382027b6d83336040518363ffffffff1660e01b815260040161517e929190616701565b602060405180830381865afa158015615199573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906151bd91906168e1565b6152005781336040517f9de3392c0000000000000000000000000000000000000000000000000000000081526004016151f7929190616701565b60405180910390fd5b5f61520a8561468e565b90505f6152168561468e565b90505f6152228561468e565b90505f605381111561523757615236616482565b5b83605381111561524a57615249616482565b5b14615281576040517fc6de466a00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b80605381111561529457615293616482565b5b8260538111156152a7576152a6616482565b5b146152de576040517f1f3158c700000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b878787877350157cffd6bbfa2dece204a89ec419c23ef5755d4660405160200161530d96959493929190617005565b60405160208183030381529060405280519060200120935061532f8483614790565b93507350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff16633e395cec85336040518363ffffffff1660e01b8152600401615380929190616701565b5f604051808303815f87803b158015615397575f80fd5b505af11580156153a9573d5f803e3d5ffd5b50505050505050949350505050565b5f6153c1614809565b7350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff166382027b6d83336040518363ffffffff1660e01b8152600401615410929190616701565b602060405180830381865afa15801561542b573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061544f91906168e1565b6154925781336040517f9de3392c000000000000000000000000000000000000000000000000000000008152600401615489929190616701565b60405180910390fd5b82827350157cffd6bbfa2dece204a89ec419c23ef5755d466040516020016154bd9493929190617074565b6040516020818303038152906040528051906020012090505f6154df8361468e565b90506154eb8282614790565b91507350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff16633e395cec83336040518363ffffffff1660e01b815260040161553c929190616701565b5f604051808303815f87803b158015615553575f80fd5b505af1158015615565573d5f803e3d5ffd5b505050505092915050565b5f806008605381111561558657615585616482565b5b60ff166001901b600660538111156155a1576155a0616482565b5b60ff166001901b600560538111156155bc576155bb616482565b5b60ff166001901b600460538111156155d7576155d6616482565b5b60ff166001901b600360538111156155f2576155f1616482565b5b60ff166001901b6002605381111561560d5761560c616482565b5b60ff166001901b5f605381111561562757615626616482565b5b60ff166001901b61563891906164dc565b61564291906164dc565b61564c91906164dc565b61565691906164dc565b61566091906164dc565b61566a91906164dc565b90505f8185605381111561568157615680616482565b5b60ff166001901b16036156c0576040517fc6de466a00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b601a84846040516020016156d6939291906170c1565b6040516020818303038152906040528051906020012091506156f88285614790565b9150615702614809565b73233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff166309b04e8f85846040518363ffffffff1660e01b8152600401615751929190616ce0565b5f604051808303815f87803b158015615768575f80fd5b505af115801561577a573d5f803e3d5ffd5b505050507350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff16633e395cec83336040518363ffffffff1660e01b81526004016157cd929190616701565b5f604051808303815f87803b1580156157e4575f80fd5b505af11580156157f6573d5f803e3d5ffd5b505050505092915050565b60018160f81c60ff161115615842576040517fdf7bf32500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b50565b5f805f90507a184f03e93ff9f4daa797ed6e38ed64bf6a1f01000000000000000083106158a1577a184f03e93ff9f4daa797ed6e38ed64bf6a1f010000000000000000838161589757615896616e54565b5b0492506040810190505b6d04ee2d6d415b85acef810000000083106158de576d04ee2d6d415b85acef810000000083816158d4576158d3616e54565b5b0492506020810190505b662386f26fc10000831061590d57662386f26fc10000838161590357615902616e54565b5b0492506010810190505b6305f5e1008310615936576305f5e100838161592c5761592b616e54565b5b0492506008810190505b612710831061595b57612710838161595157615950616e54565b5b0492506004810190505b6064831061597e576064838161597457615973616e54565b5b0492506002810190505b600a831061598d576001810190505b80915050919050565b5f7f4613e1771f6b755d243e536fb5a23c5b15e2826575fee921e8fe7a22a760c800905090565b5f80821180156159da57505f6001836159d69190616e81565b8316145b9050919050565b600260538111156159f5576159f4616482565b5b816053811115615a0857615a07616482565b5b03615a1e57615a1982610100615bf6565b615b2d565b60036053811115615a3257615a31616482565b5b816053811115615a4557615a44616482565b5b03615a5c57615a578262010000615bf6565b615b2d565b60046053811115615a7057615a6f616482565b5b816053811115615a8357615a82616482565b5b03615a9c57615a9782640100000000615bf6565b615b2d565b60056053811115615ab057615aaf616482565b5b816053811115615ac357615ac2616482565b5b03615ae057615adb8268010000000000000000615bf6565b615b2d565b60066053811115615af457615af3616482565b5b816053811115615b0757615b06616482565b5b03615b2c57615b2782700100000000000000000000000000000000615bf6565b615b2d565b5b5050565b5f615b5d7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5f1b615c34565b5f015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905090565b615b8d82615c3d565b8173ffffffffffffffffffffffffffffffffffffffff167fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b60405160405180910390a25f81511115615be957615be38282615d06565b50615bf2565b615bf1615d86565b5b5050565b80821115615c30576040517fc7dadf4500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5050565b5f819050919050565b5f8173ffffffffffffffffffffffffffffffffffffffff163b03615c9857806040517f4c9c8ce3000000000000000000000000000000000000000000000000000000008152600401615c8f9190616413565b60405180910390fd5b80615cc47f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5f1b615c34565b5f015f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555050565b60605f808473ffffffffffffffffffffffffffffffffffffffff1684604051615d2f9190617137565b5f60405180830381855af49150503d805f8114615d67576040519150601f19603f3d011682016040523d82523d5f602084013e615d6c565b606091505b5091509150615d7c858383615dc2565b9250505092915050565b5f341115615dc0576040517fb398979f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b565b606082615dd757615dd282615e4f565b615e47565b5f8251148015615dfd57505f8473ffffffffffffffffffffffffffffffffffffffff163b145b15615e3f57836040517f9996b315000000000000000000000000000000000000000000000000000000008152600401615e369190616413565b60405180910390fd5b819050615e48565b5b9392505050565b5f81511115615e615780518082602001fd5b6040517fd6bda27500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f604051905090565b5f80fd5b5f80fd5b5f819050919050565b615eb681615ea4565b8114615ec0575f80fd5b50565b5f81359050615ed181615ead565b92915050565b5f7fff0000000000000000000000000000000000000000000000000000000000000082169050919050565b615f0b81615ed7565b8114615f15575f80fd5b50565b5f81359050615f2681615f02565b92915050565b5f805f60608486031215615f4357615f42615e9c565b5b5f615f5086828701615ec3565b9350506020615f6186828701615ec3565b9250506040615f7286828701615f18565b9150509250925092565b615f8581615ea4565b82525050565b5f602082019050615f9e5f830184615f7c565b92915050565b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f615fcd82615fa4565b9050919050565b615fdd81615fc3565b8114615fe7575f80fd5b50565b5f81359050615ff881615fd4565b92915050565b5f80fd5b5f80fd5b5f601f19601f8301169050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b61604c82616006565b810181811067ffffffffffffffff8211171561606b5761606a616016565b5b80604052505050565b5f61607d615e93565b90506160898282616043565b919050565b5f67ffffffffffffffff8211156160a8576160a7616016565b5b6160b182616006565b9050602081019050919050565b828183375f83830152505050565b5f6160de6160d98461608e565b616074565b9050828152602081018484840111156160fa576160f9616002565b5b6161058482856160be565b509392505050565b5f82601f83011261612157616120615ffe565b5b81356161318482602086016160cc565b91505092915050565b60548110616146575f80fd5b50565b5f813590506161578161613a565b92915050565b5f805f806080858703121561617557616174615e9c565b5b5f61618287828801615ec3565b945050602061619387828801615fea565b935050604085013567ffffffffffffffff8111156161b4576161b3615ea0565b5b6161c08782880161610d565b92505060606161d187828801616149565b91505092959194509250565b5f81519050919050565b5f82825260208201905092915050565b5f5b838110156162145780820151818401526020810190506161f9565b5f8484015250505050565b5f616229826161dd565b61623381856161e7565b93506162438185602086016161f7565b61624c81616006565b840191505092915050565b5f6020820190508181035f83015261626f818461621f565b905092915050565b5f806040838503121561628d5761628c615e9c565b5b5f61629a85828601615ec3565b92505060206162ab85828601616149565b9150509250929050565b5f819050919050565b6162c7816162b5565b81146162d1575f80fd5b50565b5f813590506162e2816162be565b92915050565b5f80604083850312156162fe576162fd615e9c565b5b5f61630b858286016162d4565b925050602061631c85828601616149565b9150509250929050565b5f806040838503121561633c5761633b615e9c565b5b5f61634985828601615fea565b925050602083013567ffffffffffffffff81111561636a57616369615ea0565b5b6163768582860161610d565b9150509250929050565b5f805f6060848603121561639757616396615e9c565b5b5f6163a486828701615ec3565b93505060206163b586828701615ec3565b92505060406163c686828701615ec3565b9150509250925092565b5f60ff82169050919050565b6163e5816163d0565b82525050565b5f6020820190506163fe5f8301846163dc565b92915050565b61640d81615fc3565b82525050565b5f6020820190506164265f830184616404565b92915050565b5f6020828403121561644157616440615e9c565b5b5f61644e84828501615ec3565b91505092915050565b5f6020828403121561646c5761646b615e9c565b5b5f61647984828501616149565b91505092915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52602160045260245ffd5b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5f6164e6826162b5565b91506164f1836162b5565b9250828201905080821115616509576165086164af565b5b92915050565b605481106165205761651f616482565b5b50565b5f8190506165308261650f565b919050565b5f61653f82616523565b9050919050565b61654f81616535565b82525050565b61655e81615ed7565b82525050565b5f60a0820190506165775f830188616546565b6165846020830187616555565b6165916040830186615f7c565b61659e6060830185615f7c565b6165ab6080830184615f7c565b9695505050505050565b5f6080820190506165c85f830187615f7c565b6165d56020830186615f7c565b6165e26040830185616555565b6165ef6060830184615f7c565b95945050505050565b61660181615fc3565b82525050565b604082015f82015161661b5f8501826165f8565b50602082015161662e60208501826165f8565b50505050565b5f81519050919050565b5f82825260208201905092915050565b5f61665882616634565b616662818561663e565b93506166728185602086016161f7565b61667b81616006565b840191505092915050565b5f6080820190506166995f830186616607565b6166a66040830185615f7c565b81810360608301526166b8818461664e565b9050949350505050565b5f815190506166d081615ead565b92915050565b5f602082840312156166eb576166ea615e9c565b5b5f6166f8848285016166c2565b91505092915050565b5f6040820190506167145f830185615f7c565b6167216020830184616404565b9392505050565b5f60a08201905061673b5f830188615f7c565b6167486020830187616404565b818103604083015261675a818661664e565b90506167696060830185616546565b6167766080830184615f7c565b9695505050505050565b5f81905092915050565b5f616794826161dd565b61679e8185616780565b93506167ae8185602086016161f7565b80840191505092915050565b7f20760000000000000000000000000000000000000000000000000000000000005f82015250565b5f6167ee600283616780565b91506167f9826167ba565b600282019050919050565b7f2e000000000000000000000000000000000000000000000000000000000000005f82015250565b5f616838600183616780565b915061684382616804565b600182019050919050565b5f616859828761678a565b9150616864826167e2565b9150616870828661678a565b915061687b8261682c565b9150616887828561678a565b91506168928261682c565b915061689e828461678a565b915081905095945050505050565b5f8115159050919050565b6168c0816168ac565b81146168ca575f80fd5b50565b5f815190506168db816168b7565b92915050565b5f602082840312156168f6576168f5615e9c565b5b5f616903848285016168cd565b91505092915050565b601c811061691d5761691c616482565b5b50565b5f81905061692d8261690c565b919050565b5f61693c82616920565b9050919050565b5f8160f81b9050919050565b5f61695982616943565b9050919050565b61697161696c82616932565b61694f565b82525050565b5f819050919050565b61699161698c82615ea4565b616977565b82525050565b6169a86169a382616535565b61694f565b82525050565b5f819050919050565b5f6169d16169cc6169c784615fa4565b6169ae565b615fa4565b9050919050565b5f6169e2826169b7565b9050919050565b5f6169f3826169d8565b9050919050565b5f8160601b9050919050565b5f616a10826169fa565b9050919050565b5f616a2182616a06565b9050919050565b616a39616a34826169e9565b616a17565b82525050565b5f819050919050565b616a59616a54826162b5565b616a3f565b82525050565b5f616a6a8288616960565b600182019150616a7a8287616980565b602082019150616a8a8286616997565b600182019150616a9a8285616a28565b601482019150616aaa8284616a48565b6020820191508190509695505050505050565b5f606082019050616ad05f830186616546565b616add6020830185615f7c565b616aea6040830184615f7c565b949350505050565b5f606082019050616b055f830186615f7c565b616b126020830185616546565b616b1f6040830184615f7c565b949350505050565b5f67ffffffffffffffff82169050919050565b616b4381616b27565b82525050565b5f602082019050616b5c5f830184616b3a565b92915050565b616b6b816162b5565b82525050565b5f7fffffffffffffffffffffffffffffffff0000000000000000000000000000000082169050919050565b616ba581616b71565b82525050565b5f608082019050616bbe5f830187616b62565b616bcb6020830186616546565b616bd86040830185616b9c565b616be56060830184615f7c565b95945050505050565b5f60a082019050616c015f830188616546565b616c0e6020830187615f7c565b616c1b6040830186615f7c565b616c286060830185615f7c565b616c356080830184615f7c565b9695505050505050565b5f608082019050616c525f830187615f7c565b616c5f6020830186615f7c565b616c6c6040830185615f7c565b616c796060830184615f7c565b95945050505050565b5f616c8d8288616960565b600182019150616c9d8287616a48565b602082019150616cad8286616997565b600182019150616cbd8285616a28565b601482019150616ccd8284616a48565b6020820191508190509695505050505050565b5f604082019050616cf35f830185616546565b616d006020830184615f7c565b9392505050565b5f606082019050616d1a5f830186616b62565b616d276020830185616546565b616d346040830184615f7c565b949350505050565b5f604082019050616d4f5f830185615f7c565b616d5c6020830184615f7c565b9392505050565b5f606082019050616d765f830186616546565b616d836020830185616b9c565b616d906040830184615f7c565b949350505050565b5f819050919050565b616db2616dad82615ed7565b616d98565b82525050565b5f616dc38289616960565b600182019150616dd38288616980565b602082019150616de38287616980565b602082019150616df38286616da1565b600182019150616e038285616a28565b601482019150616e138284616a48565b602082019150819050979650505050505050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603260045260245ffd5b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601260045260245ffd5b5f616e8b826162b5565b9150616e96836162b5565b9250828203905081811115616eae57616ead6164af565b5b92915050565b5f616ebf8288616a48565b602082019150616ecf8287616a28565b601482019150616edf8286616a48565b602082019150616eef8285616980565b602082019150616eff8284616a48565b6020820191508190509695505050505050565b5f616f1c826162b5565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8203616f4e57616f4d6164af565b5b600182019050919050565b5f819050919050565b616f73616f6e82616b71565b616f59565b82525050565b5f616f848287616960565b600182019150616f948286616a48565b602082019150616fa48285616997565b600182019150616fb48284616f62565b60108201915081905095945050505050565b5f81519050616fd481615fd4565b92915050565b5f60208284031215616fef57616fee615e9c565b5b5f616ffc84828501616fc6565b91505092915050565b5f6170108289616960565b6001820191506170208288616980565b6020820191506170308287616980565b6020820191506170408286616980565b6020820191506170508285616a28565b6014820191506170608284616a48565b602082019150819050979650505050505050565b5f61707f8287616960565b60018201915061708f8286616980565b60208201915061709f8285616a28565b6014820191506170af8284616a48565b60208201915081905095945050505050565b5f6170cc8286616960565b6001820191506170dc8285616997565b6001820191506170ec8284616f62565b601082019150819050949350505050565b5f81905092915050565b5f61711182616634565b61711b81856170fd565b935061712b8185602086016161f7565b80840191505092915050565b5f6171428284617107565b91508190509291505056
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\xA0`@R0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`\x80\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81RP4\x80\x15b\0\0CW_\x80\xFD[Pb\0\0Tb\0\0Z` \x1B` \x1CV[b\0\x01\xC4V[_b\0\0kb\0\x01^` \x1B` \x1CV[\x90P\x80_\x01`\x08\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x15b\0\0\xB6W`@Q\x7F\xF9.\xE8\xA9\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\x16\x81_\x01_\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14b\0\x01[Wg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81_\x01_a\x01\0\n\x81T\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP\x7F\xC7\xF5\x05\xB2\xF3q\xAE!u\xEEI\x13\xF4I\x9E\x1F&3\xA7\xB5\x93c!\xEE\xD1\xCD\xAE\xB6\x11Q\x81\xD2g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@Qb\0\x01R\x91\x90b\0\x01\xA9V[`@Q\x80\x91\x03\x90\xA1[PV[_\x7F\xF0\xC5~\x16\x84\r\xF0@\xF1P\x88\xDC/\x81\xFE9\x1C9#\xBE\xC7>#\xA9f.\xFC\x9C\"\x9Cj\0\x90P\x90V[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[b\0\x01\xA3\x81b\0\x01\x85V[\x82RPPV[_` \x82\x01\x90Pb\0\x01\xBE_\x83\x01\x84b\0\x01\x98V[\x92\x91PPV[`\x80QaqMb\0\x01\xEB_9_\x81\x81aL\x08\x01R\x81\x81aL]\x01RaN\xFF\x01RaqM_\xF3\xFE`\x80`@R`\x046\x10a\x02\x19W_5`\xE0\x1C\x80cw\x02\xDC\xFF\x11a\x01\"W\x80c\xCC\xC4\x80\xA1\x11a\0\xAAW\x80c\xD9\x98\x82\xD5\x11a\0nW\x80c\xD9\x98\x82\xD5\x14a\x08\xFDW\x80c\xE0xir\x14a\t9W\x80c\xF5\x1C\xCF\xB0\x14a\tcW\x80c\xF6\x85\x9B\xDC\x14a\t\x9FW\x80c\xF7\x7F?\x1D\x14a\t\xC9Wa\x02\x19V[\x80c\xCC\xC4\x80\xA1\x14a\x07\xD1W\x80c\xCFM\x18\xAA\x14a\x08\rW\x80c\xD5\x80\xC0c\x14a\x08IW\x80c\xD7]n\x8A\x14a\x08\x85W\x80c\xD8\t,\xBC\x14a\x08\xC1Wa\x02\x19V[\x80c\x91\xF9\x8F\xFE\x11a\0\xF1W\x80c\x91\xF9\x8F\xFE\x14a\x06\xC9W\x80c\x9C\xD0z\xCB\x14a\x07\x05W\x80c\xA8\xC7\xC2\xC1\x14a\x07AW\x80c\xAD<\xB1\xCC\x14a\x07kW\x80c\xC0!2\x9E\x14a\x07\x95Wa\x02\x19V[\x80cw\x02\xDC\xFF\x14a\x05\xEBW\x80cz)\x7FK\x14a\x06'W\x80c\x856.\xE7\x14a\x06QW\x80c\x8BI\xCE\xB4\x14a\x06\x8DWa\x02\x19V[\x80cH\xEE\xF4~\x11a\x01\xA5W\x80cZS\xAC\xCB\x11a\x01tW\x80cZS\xAC\xCB\x14a\x04\xBFW\x80cc\xA2\xDB)\x14a\x04\xFBW\x80cgT\xB3`\x14a\x057W\x80cr\x10v\x81\x14a\x05sW\x80cu\x13\xA4\x04\x14a\x05\xAFWa\x02\x19V[\x80cH\xEE\xF4~\x14a\x04\x01W\x80cO\x1E\xF2\x86\x14a\x04=W\x80cR\xD1\x90-\x14a\x04YW\x80cW\xF0\xA5h\x14a\x04\x83Wa\x02\x19V[\x80c\x13\x91T\x7F\x11a\x01\xECW\x80c\x13\x91T\x7F\x14a\x02\xFBW\x80c\x18+m\x98\x14a\x037W\x80c\x1C\x89\xEED\x14a\x03sW\x80c61\x8Dd\x14a\x03\xAFW\x80c9\xF78\x10\x14a\x03\xEBWa\x02\x19V[\x80c\x04U\x9Fq\x14a\x02\x1DW\x80c\x08\xBF\x83*\x14a\x02YW\x80c\r\x8En,\x14a\x02\x95W\x80c\x11{/8\x14a\x02\xBFW[_\x80\xFD[4\x80\x15a\x02(W_\x80\xFD[Pa\x02C`\x04\x806\x03\x81\x01\x90a\x02>\x91\x90a_,V[a\n\x05V[`@Qa\x02P\x91\x90a_\x8BV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x02dW_\x80\xFD[Pa\x02\x7F`\x04\x806\x03\x81\x01\x90a\x02z\x91\x90aa]V[a\x0B\xB4V[`@Qa\x02\x8C\x91\x90a_\x8BV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x02\xA0W_\x80\xFD[Pa\x02\xA9a\r\xD1V[`@Qa\x02\xB6\x91\x90abWV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x02\xCAW_\x80\xFD[Pa\x02\xE5`\x04\x806\x03\x81\x01\x90a\x02\xE0\x91\x90a_,V[a\x0ELV[`@Qa\x02\xF2\x91\x90a_\x8BV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x03\x06W_\x80\xFD[Pa\x03!`\x04\x806\x03\x81\x01\x90a\x03\x1C\x91\x90a_,V[a\x0F\xFAV[`@Qa\x03.\x91\x90a_\x8BV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x03BW_\x80\xFD[Pa\x03]`\x04\x806\x03\x81\x01\x90a\x03X\x91\x90a_,V[a\x11\xA9V[`@Qa\x03j\x91\x90a_\x8BV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x03~W_\x80\xFD[Pa\x03\x99`\x04\x806\x03\x81\x01\x90a\x03\x94\x91\x90abwV[a\x13XV[`@Qa\x03\xA6\x91\x90a_\x8BV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x03\xBAW_\x80\xFD[Pa\x03\xD5`\x04\x806\x03\x81\x01\x90a\x03\xD0\x91\x90a_,V[a\x18iV[`@Qa\x03\xE2\x91\x90a_\x8BV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x03\xF6W_\x80\xFD[Pa\x03\xFFa\x1A\x18V[\0[4\x80\x15a\x04\x0CW_\x80\xFD[Pa\x04'`\x04\x806\x03\x81\x01\x90a\x04\"\x91\x90ab\xE8V[a\x1B\x88V[`@Qa\x044\x91\x90a_\x8BV[`@Q\x80\x91\x03\x90\xF3[a\x04W`\x04\x806\x03\x81\x01\x90a\x04R\x91\x90ac&V[a\x1B\xFCV[\0[4\x80\x15a\x04dW_\x80\xFD[Pa\x04ma\x1C\x1BV[`@Qa\x04z\x91\x90a_\x8BV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x04\x8EW_\x80\xFD[Pa\x04\xA9`\x04\x806\x03\x81\x01\x90a\x04\xA4\x91\x90a_,V[a\x1CLV[`@Qa\x04\xB6\x91\x90a_\x8BV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x04\xCAW_\x80\xFD[Pa\x04\xE5`\x04\x806\x03\x81\x01\x90a\x04\xE0\x91\x90a_,V[a\x1D\xFBV[`@Qa\x04\xF2\x91\x90a_\x8BV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x05\x06W_\x80\xFD[Pa\x05!`\x04\x806\x03\x81\x01\x90a\x05\x1C\x91\x90a_,V[a DV[`@Qa\x05.\x91\x90a_\x8BV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x05BW_\x80\xFD[Pa\x05]`\x04\x806\x03\x81\x01\x90a\x05X\x91\x90a_,V[a\"<V[`@Qa\x05j\x91\x90a_\x8BV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x05~W_\x80\xFD[Pa\x05\x99`\x04\x806\x03\x81\x01\x90a\x05\x94\x91\x90a_,V[a$\x10V[`@Qa\x05\xA6\x91\x90a_\x8BV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x05\xBAW_\x80\xFD[Pa\x05\xD5`\x04\x806\x03\x81\x01\x90a\x05\xD0\x91\x90a_,V[a%\xBFV[`@Qa\x05\xE2\x91\x90a_\x8BV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x05\xF6W_\x80\xFD[Pa\x06\x11`\x04\x806\x03\x81\x01\x90a\x06\x0C\x91\x90ac\x80V[a'nV[`@Qa\x06\x1E\x91\x90a_\x8BV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x062W_\x80\xFD[Pa\x06;a)\x8AV[`@Qa\x06H\x91\x90ac\xEBV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x06\\W_\x80\xFD[Pa\x06w`\x04\x806\x03\x81\x01\x90a\x06r\x91\x90a_,V[a)\x8EV[`@Qa\x06\x84\x91\x90a_\x8BV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x06\x98W_\x80\xFD[Pa\x06\xB3`\x04\x806\x03\x81\x01\x90a\x06\xAE\x91\x90a_,V[a+=V[`@Qa\x06\xC0\x91\x90a_\x8BV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x06\xD4W_\x80\xFD[Pa\x06\xEF`\x04\x806\x03\x81\x01\x90a\x06\xEA\x91\x90a_,V[a-5V[`@Qa\x06\xFC\x91\x90a_\x8BV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x07\x10W_\x80\xFD[Pa\x07+`\x04\x806\x03\x81\x01\x90a\x07&\x91\x90ab\xE8V[a/\tV[`@Qa\x078\x91\x90a_\x8BV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x07LW_\x80\xFD[Pa\x07Ua2)V[`@Qa\x07b\x91\x90ad\x13V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x07vW_\x80\xFD[Pa\x07\x7Fa2DV[`@Qa\x07\x8C\x91\x90abWV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x07\xA0W_\x80\xFD[Pa\x07\xBB`\x04\x806\x03\x81\x01\x90a\x07\xB6\x91\x90a_,V[a2}V[`@Qa\x07\xC8\x91\x90a_\x8BV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x07\xDCW_\x80\xFD[Pa\x07\xF7`\x04\x806\x03\x81\x01\x90a\x07\xF2\x91\x90a_,V[a4QV[`@Qa\x08\x04\x91\x90a_\x8BV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x08\x18W_\x80\xFD[Pa\x083`\x04\x806\x03\x81\x01\x90a\x08.\x91\x90a_,V[a6%V[`@Qa\x08@\x91\x90a_\x8BV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x08TW_\x80\xFD[Pa\x08o`\x04\x806\x03\x81\x01\x90a\x08j\x91\x90ad,V[a8nV[`@Qa\x08|\x91\x90a_\x8BV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x08\x90W_\x80\xFD[Pa\x08\xAB`\x04\x806\x03\x81\x01\x90a\x08\xA6\x91\x90adWV[a:5V[`@Qa\x08\xB8\x91\x90a_\x8BV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x08\xCCW_\x80\xFD[Pa\x08\xE7`\x04\x806\x03\x81\x01\x90a\x08\xE2\x91\x90a_,V[a:\xA5V[`@Qa\x08\xF4\x91\x90a_\x8BV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\t\x08W_\x80\xFD[Pa\t#`\x04\x806\x03\x81\x01\x90a\t\x1E\x91\x90a_,V[a<\xC2V[`@Qa\t0\x91\x90a_\x8BV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\tDW_\x80\xFD[Pa\tMa>\xBAV[`@Qa\tZ\x91\x90ad\x13V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\tnW_\x80\xFD[Pa\t\x89`\x04\x806\x03\x81\x01\x90a\t\x84\x91\x90ad,V[a>\xD5V[`@Qa\t\x96\x91\x90a_\x8BV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\t\xAAW_\x80\xFD[Pa\t\xB3a@\xC0V[`@Qa\t\xC0\x91\x90ad\x13V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\t\xD4W_\x80\xFD[Pa\t\xEF`\x04\x806\x03\x81\x01\x90a\t\xEA\x91\x90a_,V[a@\xDBV[`@Qa\t\xFC\x91\x90a_\x8BV[`@Q\x80\x91\x03\x90\xF3[_\x80`\x06`S\x81\x11\x15a\n\x1BWa\n\x1Aad\x82V[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a\n6Wa\n5ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a\nQWa\nPad\x82V[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a\nlWa\nkad\x82V[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a\n\x87Wa\n\x86ad\x82V[[`\xFF\x16`\x01\x90\x1Ba\n\x98\x91\x90ad\xDCV[a\n\xA2\x91\x90ad\xDCV[a\n\xAC\x91\x90ad\xDCV[a\n\xB6\x91\x90ad\xDCV[\x90P_a\n\xC3\x86\x83aB\xF8V[\x90Pa\n\xD3`\x12\x87\x87\x87\x85aC^V[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16cd+\x14\x90\x82\x86\x89\x89\x88`@Q\x86c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x0B*\x95\x94\x93\x92\x91\x90aedV[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x0BAW_\x80\xFD[PZ\xF1\x15\x80\x15a\x0BSW=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xC1\x1Db\xB1<6\n\x83\x08$\x87\x06K\xE1\xEC\x08x\xB2\xF0\xBEO\x01+\xF5\x9F\x89\xE1(\x06=G\xFF\x87\x87\x87\x87`@Qa\x0B\xA3\x94\x93\x92\x91\x90ae\xB5V[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_\x80`@Q\x80`@\x01`@R\x80\x86s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x013s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81RP\x90P_a\x0C\x03\x87aF\x8EV[\x90P\x80`S\x81\x11\x15a\x0C\x18Wa\x0C\x17ad\x82V[[\x84`S\x81\x11\x15a\x0C+Wa\x0C*ad\x82V[[\x14a\x0CbW`@Q\x7F\xB9h\x84a\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[s6w!B\xB7Hq\xF2U\xCB\xD7\xA3\xE8\x9B@\x1D>E\x82_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xE61}\xF5\x83\x89\x88`@Q\x84c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x0C\xB3\x93\x92\x91\x90af\x86V[` `@Q\x80\x83\x03\x81_\x87Z\xF1\x15\x80\x15a\x0C\xCFW=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x0C\xF3\x91\x90af\xD6V[\x92PsP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c>9\\\xEC\x843`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\rD\x92\x91\x90ag\x01V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\r[W_\x80\xFD[PZ\xF1\x15\x80\x15a\rmW=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xDC7\r\xB35\x89\xE73q\xDC>\xE4,x\x9C\0=3n\xEF\xCB|?V\xFE\x0FQ\xAE[\x1D\x97\x02\x88\x88\x88\x88\x88`@Qa\r\xBF\x95\x94\x93\x92\x91\x90ag(V[`@Q\x80\x91\x03\x90\xA2PP\x94\x93PPPPV[```@Q\x80`@\x01`@R\x80`\r\x81R` \x01\x7FFHEVMExecutor\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81RPa\x0E\x12_aF\xC6V[a\x0E\x1C`\x01aF\xC6V[a\x0E%_aF\xC6V[`@Q` \x01a\x0E8\x94\x93\x92\x91\x90ahNV[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x90P\x90V[_\x80`\x06`S\x81\x11\x15a\x0EbWa\x0Eaad\x82V[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a\x0E}Wa\x0E|ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a\x0E\x98Wa\x0E\x97ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a\x0E\xB3Wa\x0E\xB2ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a\x0E\xCEWa\x0E\xCDad\x82V[[`\xFF\x16`\x01\x90\x1Ba\x0E\xDF\x91\x90ad\xDCV[a\x0E\xE9\x91\x90ad\xDCV[a\x0E\xF3\x91\x90ad\xDCV[a\x0E\xFD\x91\x90ad\xDCV[\x90P_a\x0F\n\x86\x83aB\xF8V[\x90Pa\x0F\x19_\x87\x87\x87\x85aC^V[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xFD\xADL\x96\x82\x86\x89\x89\x88`@Q\x86c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x0Fp\x95\x94\x93\x92\x91\x90aedV[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x0F\x87W_\x80\xFD[PZ\xF1\x15\x80\x15a\x0F\x99W=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xDB\x90P\xD6R@C\x16!\xD6\x1Do\x94\xB9p\xE6?S\xA6zWfaN\xE6\xE5\xC5\xBB\xD4\x1C\x8E.\x87\x87\x87\x87`@Qa\x0F\xE9\x94\x93\x92\x91\x90ae\xB5V[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_\x80`\x06`S\x81\x11\x15a\x10\x10Wa\x10\x0Fad\x82V[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a\x10+Wa\x10*ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a\x10FWa\x10Ead\x82V[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a\x10aWa\x10`ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a\x10|Wa\x10{ad\x82V[[`\xFF\x16`\x01\x90\x1Ba\x10\x8D\x91\x90ad\xDCV[a\x10\x97\x91\x90ad\xDCV[a\x10\xA1\x91\x90ad\xDCV[a\x10\xAB\x91\x90ad\xDCV[\x90P_a\x10\xB8\x86\x83aB\xF8V[\x90Pa\x10\xC8`\x0E\x87\x87\x87_aC^V[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16ck\xB3\xC6\x11\x82\x86\x89\x89\x88`@Q\x86c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x11\x1F\x95\x94\x93\x92\x91\x90aedV[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x116W_\x80\xFD[PZ\xF1\x15\x80\x15a\x11HW=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F8\xC3\xA6<B0\xDE[t\x1FIO\xFBT\xE3\x08q\x04\x03\x02y\xBC{\xCC\xEE\x8A\xD9\xAD1q+!\x87\x87\x87\x87`@Qa\x11\x98\x94\x93\x92\x91\x90ae\xB5V[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_\x80`\x06`S\x81\x11\x15a\x11\xBFWa\x11\xBEad\x82V[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a\x11\xDAWa\x11\xD9ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a\x11\xF5Wa\x11\xF4ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a\x12\x10Wa\x12\x0Fad\x82V[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a\x12+Wa\x12*ad\x82V[[`\xFF\x16`\x01\x90\x1Ba\x12<\x91\x90ad\xDCV[a\x12F\x91\x90ad\xDCV[a\x12P\x91\x90ad\xDCV[a\x12Z\x91\x90ad\xDCV[\x90P_a\x12g\x86\x83aB\xF8V[\x90Pa\x12w`\x01\x87\x87\x87\x85aC^V[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x90u1\x08\x82\x86\x89\x89\x88`@Q\x86c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x12\xCE\x95\x94\x93\x92\x91\x90aedV[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x12\xE5W_\x80\xFD[PZ\xF1\x15\x80\x15a\x12\xF7W=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xEBm7\xBD'\x1A\xBE\x13\x95\xB2\x1Dmx\xF3H}e\x84\x86(r\xC2\x9F\xFD?\x90sn\xE9\x9Bs\x93\x87\x87\x87\x87`@Qa\x13G\x94\x93\x92\x91\x90ae\xB5V[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_sP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x82\x02{m\x843`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x13\xA8\x92\x91\x90ag\x01V[` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x13\xC3W=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x13\xE7\x91\x90ah\xE1V[a\x14*W\x823`@Q\x7F\x9D\xE39,\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x14!\x92\x91\x90ag\x01V[`@Q\x80\x91\x03\x90\xFD[_`\x08`S\x81\x11\x15a\x14?Wa\x14>ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x06`S\x81\x11\x15a\x14ZWa\x14Yad\x82V[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a\x14uWa\x14tad\x82V[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a\x14\x90Wa\x14\x8Fad\x82V[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a\x14\xABWa\x14\xAAad\x82V[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a\x14\xC6Wa\x14\xC5ad\x82V[[`\xFF\x16`\x01\x90\x1B_`S\x81\x11\x15a\x14\xE0Wa\x14\xDFad\x82V[[`\xFF\x16`\x01\x90\x1Ba\x14\xF1\x91\x90ad\xDCV[a\x14\xFB\x91\x90ad\xDCV[a\x15\x05\x91\x90ad\xDCV[a\x15\x0F\x91\x90ad\xDCV[a\x15\x19\x91\x90ad\xDCV[a\x15#\x91\x90ad\xDCV[\x90P_a\x150\x85\x83aB\xF8V[\x90P_`\x08`S\x81\x11\x15a\x15GWa\x15Fad\x82V[[`\xFF\x16`\x01\x90\x1B`\x06`S\x81\x11\x15a\x15bWa\x15aad\x82V[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a\x15}Wa\x15|ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a\x15\x98Wa\x15\x97ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a\x15\xB3Wa\x15\xB2ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a\x15\xCEWa\x15\xCDad\x82V[[`\xFF\x16`\x01\x90\x1Ba\x15\xDF\x91\x90ad\xDCV[a\x15\xE9\x91\x90ad\xDCV[a\x15\xF3\x91\x90ad\xDCV[a\x15\xFD\x91\x90ad\xDCV[a\x16\x07\x91\x90ad\xDCV[\x90P_\x81\x86`S\x81\x11\x15a\x16\x1EWa\x16\x1Dad\x82V[[`\xFF\x16`\x01\x90\x1B\x16\x03a\x16]W`@Q\x7F\xC6\xDEFj\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x84`S\x81\x11\x15a\x16pWa\x16oad\x82V[[\x82`S\x81\x11\x15a\x16\x83Wa\x16\x82ad\x82V[[\x03a\x16\xBAW`@Q\x7F\xB9h\x84a\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x17\x86\x86sP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]F`@Q` \x01a\x16\xE8\x95\x94\x93\x92\x91\x90aj_V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x93Pa\x17\n\x84\x86aG\x90V[\x93Pa\x17\x14aH\tV[s#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x02\xDDbv\x86\x88\x87`@Q\x84c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x17e\x93\x92\x91\x90aj\xBDV[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x17|W_\x80\xFD[PZ\xF1\x15\x80\x15a\x17\x8EW=_\x80>=_\xFD[PPPPsP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c>9\\\xEC\x853`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x17\xE1\x92\x91\x90ag\x01V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x17\xF8W_\x80\xFD[PZ\xF1\x15\x80\x15a\x18\nW=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F1\xCC\xAEj/\x8E<\xED\x16\x92\xF7|\x8Ff\x813\xE4\xAF\xDA\xAA5\xAF\xE8D\xFFFY\xA6\xC2~b\x7F\x87\x87\x87`@Qa\x18X\x93\x92\x91\x90aj\xF2V[`@Q\x80\x91\x03\x90\xA2PPP\x92\x91PPV[_\x80`\x06`S\x81\x11\x15a\x18\x7FWa\x18~ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a\x18\x9AWa\x18\x99ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a\x18\xB5Wa\x18\xB4ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a\x18\xD0Wa\x18\xCFad\x82V[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a\x18\xEBWa\x18\xEAad\x82V[[`\xFF\x16`\x01\x90\x1Ba\x18\xFC\x91\x90ad\xDCV[a\x19\x06\x91\x90ad\xDCV[a\x19\x10\x91\x90ad\xDCV[a\x19\x1A\x91\x90ad\xDCV[\x90P_a\x19'\x86\x83aB\xF8V[\x90Pa\x197`\x13\x87\x87\x87\x85aC^V[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xAC\xB5\xF3\x88\x82\x86\x89\x89\x88`@Q\x86c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x19\x8E\x95\x94\x93\x92\x91\x90aedV[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x19\xA5W_\x80\xFD[PZ\xF1\x15\x80\x15a\x19\xB7W=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xFD|\x92\x08\xF9V\xBF\x0Cj\xB7jf\x7F\x046\x12E\xAD>\n-\x0E\xFF\x92\xEB\x82z\xCF\xCC\xA6\x8E\xA9\x87\x87\x87\x87`@Qa\x1A\x07\x94\x93\x92\x91\x90ae\xB5V[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[`\x01a\x1A\"aH\x85V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x1AcW`@Q\x7FoOs\x1F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x02_a\x1AnaH\xA9V[\x90P\x80_\x01`\x08\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x80a\x1A\xB6WP\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81_\x01_\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x10\x15[\x15a\x1A\xEDW`@Q\x7F\xF9.\xE8\xA9\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x81\x81_\x01_a\x01\0\n\x81T\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP`\x01\x81_\x01`\x08a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP_\x81_\x01`\x08a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP\x7F\xC7\xF5\x05\xB2\xF3q\xAE!u\xEEI\x13\xF4I\x9E\x1F&3\xA7\xB5\x93c!\xEE\xD1\xCD\xAE\xB6\x11Q\x81\xD2\x82`@Qa\x1B|\x91\x90akIV[`@Q\x80\x91\x03\x90\xA1PPV[_\x80a\x1B\x92aH\xD0V[\x90Pa\x1B\x9F\x84\x84\x83aIMV[\x91P3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7FR\"\xD9k\x83g'\xA1\xD6\xFE\x1E\xE9\xAE\xF2\x7F\x9B\xB5\x07\xBDAyM\xEF\xA3v\xFFld\x8A\xAF\x8F\xF1\x85\x85\x84\x86`@Qa\x1B\xED\x94\x93\x92\x91\x90ak\xABV[`@Q\x80\x91\x03\x90\xA2P\x92\x91PPV[a\x1C\x04aL\x06V[a\x1C\r\x82aL\xECV[a\x1C\x17\x82\x82aM\xDFV[PPV[_a\x1C$aN\xFDV[\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC_\x1B\x90P\x90V[_\x80`\x06`S\x81\x11\x15a\x1CbWa\x1Caad\x82V[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a\x1C}Wa\x1C|ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a\x1C\x98Wa\x1C\x97ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a\x1C\xB3Wa\x1C\xB2ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a\x1C\xCEWa\x1C\xCDad\x82V[[`\xFF\x16`\x01\x90\x1Ba\x1C\xDF\x91\x90ad\xDCV[a\x1C\xE9\x91\x90ad\xDCV[a\x1C\xF3\x91\x90ad\xDCV[a\x1C\xFD\x91\x90ad\xDCV[\x90P_a\x1D\n\x86\x83aB\xF8V[\x90Pa\x1D\x1A`\x02\x87\x87\x87\x85aC^V[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c<\x16\xFF\r\x82\x86\x89\x89\x88`@Q\x86c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x1Dq\x95\x94\x93\x92\x91\x90aedV[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x1D\x88W_\x80\xFD[PZ\xF1\x15\x80\x15a\x1D\x9AW=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F!SF\xA4\xF9\xF9u\xE6\xD5HN)\x0B\xD4\xE5<\xA1DS\xA9\xD2\x82\xEB\xD3\xCC\xED\xB2\xA0\xF1qu=\x87\x87\x87\x87`@Qa\x1D\xEA\x94\x93\x92\x91\x90ae\xB5V[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_`\x01`\xF8\x1B\x82~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x14a\x1E[W`@Q\x7FO\"NS\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x80\x1B\x83\x03a\x1E\x96W`@Q\x7F#\xD3Y\xA3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\x06`S\x81\x11\x15a\x1E\xABWa\x1E\xAAad\x82V[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a\x1E\xC6Wa\x1E\xC5ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a\x1E\xE1Wa\x1E\xE0ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a\x1E\xFCWa\x1E\xFBad\x82V[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a\x1F\x17Wa\x1F\x16ad\x82V[[`\xFF\x16`\x01\x90\x1Ba\x1F(\x91\x90ad\xDCV[a\x1F2\x91\x90ad\xDCV[a\x1F<\x91\x90ad\xDCV[a\x1FF\x91\x90ad\xDCV[\x90P_a\x1FS\x86\x83aB\xF8V[\x90Pa\x1Fc`\x03\x87\x87\x87\x85aC^V[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c@kE\x13\x82\x86\x89\x89\x88`@Q\x86c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x1F\xBA\x95\x94\x93\x92\x91\x90aedV[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x1F\xD1W_\x80\xFD[PZ\xF1\x15\x80\x15a\x1F\xE3W=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F;\xAB.\xE0\xE2\xF9\x0FF\x90\xC6\xA8{\xF6<\xF1\xA6\xB6&\x08n\x95\xF21\x86\x0B\x15)f\xE8\xDA\xBB\xF7\x87\x87\x87\x87`@Qa 3\x94\x93\x92\x91\x90ae\xB5V[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_\x80`\x08`S\x81\x11\x15a ZWa Yad\x82V[[`\xFF\x16`\x01\x90\x1B`\x06`S\x81\x11\x15a uWa tad\x82V[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a \x90Wa \x8Fad\x82V[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a \xABWa \xAAad\x82V[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a \xC6Wa \xC5ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a \xE1Wa \xE0ad\x82V[[`\xFF\x16`\x01\x90\x1B_`S\x81\x11\x15a \xFBWa \xFAad\x82V[[`\xFF\x16`\x01\x90\x1Ba!\x0C\x91\x90ad\xDCV[a!\x16\x91\x90ad\xDCV[a! \x91\x90ad\xDCV[a!*\x91\x90ad\xDCV[a!4\x91\x90ad\xDCV[a!>\x91\x90ad\xDCV[\x90P_a!K\x86\x83aB\xF8V[\x90Pa![`\x06\x87\x87\x87\x85aC^V[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xE8\xE3\x99\xAD\x82\x86\x89\x89\x88`@Q\x86c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a!\xB2\x95\x94\x93\x92\x91\x90aedV[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a!\xC9W_\x80\xFD[PZ\xF1\x15\x80\x15a!\xDBW=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7FV\xDF'\x9B\xBF\xB0=\x9E\xD0\x97\xBB\xE2\xF2\x8DR\x0C\xA0\xC1\x16\x12\x062y&\xE9\x86d\xD7\r,$\xC4\x87\x87\x87\x87`@Qa\"+\x94\x93\x92\x91\x90ae\xB5V[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_\x80`\x08`S\x81\x11\x15a\"RWa\"Qad\x82V[[`\xFF\x16`\x01\x90\x1B`\x06`S\x81\x11\x15a\"mWa\"lad\x82V[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a\"\x88Wa\"\x87ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a\"\xA3Wa\"\xA2ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a\"\xBEWa\"\xBDad\x82V[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a\"\xD9Wa\"\xD8ad\x82V[[`\xFF\x16`\x01\x90\x1Ba\"\xEA\x91\x90ad\xDCV[a\"\xF4\x91\x90ad\xDCV[a\"\xFE\x91\x90ad\xDCV[a#\x08\x91\x90ad\xDCV[a#\x12\x91\x90ad\xDCV[\x90P_a#\x1F\x86\x83aB\xF8V[\x90Pa#/`\n\x87\x87\x87\x85aC^V[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x14Rn\x87\x82\x86\x89\x89\x88`@Q\x86c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a#\x86\x95\x94\x93\x92\x91\x90aedV[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a#\x9DW_\x80\xFD[PZ\xF1\x15\x80\x15a#\xAFW=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xEB\x0EO\x8D\xC7@X\x19M\x06\x02B_\xE6\x02\xF9U\xC2\" \x0F\x7F\x10\xC6\xFEg\x99/{$\xC7\xE9\x87\x87\x87\x87`@Qa#\xFF\x94\x93\x92\x91\x90ae\xB5V[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_\x80`\x06`S\x81\x11\x15a$&Wa$%ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a$AWa$@ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a$\\Wa$[ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a$wWa$vad\x82V[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a$\x92Wa$\x91ad\x82V[[`\xFF\x16`\x01\x90\x1Ba$\xA3\x91\x90ad\xDCV[a$\xAD\x91\x90ad\xDCV[a$\xB7\x91\x90ad\xDCV[a$\xC1\x91\x90ad\xDCV[\x90P_a$\xCE\x86\x83aB\xF8V[\x90Pa$\xDE`\x11\x87\x87\x87_aC^V[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x139\xC5\xEE\x82\x86\x89\x89\x88`@Q\x86c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a%5\x95\x94\x93\x92\x91\x90aedV[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a%LW_\x80\xFD[PZ\xF1\x15\x80\x15a%^W=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\rH;\x10\r\x8Cs\xB2\x08\x98N\xC6\x97\xCA\xA3\t\x15!\xEEU%\xCEi\xED\xCF\x97\xD7\xE3\x95\xD3\xD0Y\x87\x87\x87\x87`@Qa%\xAE\x94\x93\x92\x91\x90ae\xB5V[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_\x80`\x06`S\x81\x11\x15a%\xD5Wa%\xD4ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a%\xF0Wa%\xEFad\x82V[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a&\x0BWa&\nad\x82V[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a&&Wa&%ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a&AWa&@ad\x82V[[`\xFF\x16`\x01\x90\x1Ba&R\x91\x90ad\xDCV[a&\\\x91\x90ad\xDCV[a&f\x91\x90ad\xDCV[a&p\x91\x90ad\xDCV[\x90P_a&}\x86\x83aB\xF8V[\x90Pa&\x8D`\x10\x87\x87\x87_aC^V[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xD4\x7F=Y\x82\x86\x89\x89\x88`@Q\x86c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a&\xE4\x95\x94\x93\x92\x91\x90aedV[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a&\xFBW_\x80\xFD[PZ\xF1\x15\x80\x15a'\rW=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xDE\xF2\xE7\x04\xA0w(J\x07\xF3\xD0\xB46\xDB\x88\xF5\xD9\x81\xB6\x9FX\xAB|\x1A\xE6#%'\x18\xA6\xDE\x01\x87\x87\x87\x87`@Qa']\x94\x93\x92\x91\x90ae\xB5V[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_\x80`\x08`S\x81\x11\x15a'\x84Wa'\x83ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x07`S\x81\x11\x15a'\x9FWa'\x9Ead\x82V[[`\xFF\x16`\x01\x90\x1B`\x06`S\x81\x11\x15a'\xBAWa'\xB9ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a'\xD5Wa'\xD4ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a'\xF0Wa'\xEFad\x82V[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a(\x0BWa(\nad\x82V[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a(&Wa(%ad\x82V[[`\xFF\x16`\x01\x90\x1B_`S\x81\x11\x15a(@Wa(?ad\x82V[[`\xFF\x16`\x01\x90\x1Ba(Q\x91\x90ad\xDCV[a([\x91\x90ad\xDCV[a(e\x91\x90ad\xDCV[a(o\x91\x90ad\xDCV[a(y\x91\x90ad\xDCV[a(\x83\x91\x90ad\xDCV[a(\x8D\x91\x90ad\xDCV[\x90P_a(\x9A\x85\x83aB\xF8V[\x90Pa(\xA9`\x19\x87\x87\x87aO\x84V[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16cNrgi\x82\x88\x88\x88\x88`@Q\x86c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a)\0\x95\x94\x93\x92\x91\x90ak\xEEV[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a)\x17W_\x80\xFD[PZ\xF1\x15\x80\x15a))W=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F`\xBE\x9Da\xAA\xD8I\xFA\xCC(\xC3\x8B\x04\x8C\xB5\xC4\xBE4 \xB8\xFA\"3\xE0\x8C\xFA\x06\xBE\x1Bm\x1C>\x87\x87\x87\x87`@Qa)y\x94\x93\x92\x91\x90al?V[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_\x90V[_\x80`\x06`S\x81\x11\x15a)\xA4Wa)\xA3ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a)\xBFWa)\xBEad\x82V[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a)\xDAWa)\xD9ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a)\xF5Wa)\xF4ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a*\x10Wa*\x0Fad\x82V[[`\xFF\x16`\x01\x90\x1Ba*!\x91\x90ad\xDCV[a*+\x91\x90ad\xDCV[a*5\x91\x90ad\xDCV[a*?\x91\x90ad\xDCV[\x90P_a*L\x86\x83aB\xF8V[\x90Pa*\\`\x0F\x87\x87\x87_aC^V[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x85\x9A\x1Bp\x82\x86\x89\x89\x88`@Q\x86c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a*\xB3\x95\x94\x93\x92\x91\x90aedV[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a*\xCAW_\x80\xFD[PZ\xF1\x15\x80\x15a*\xDCW=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xC9\xFF\x8F\r\x18\xA3\xF7f\xCE]\xE3\xDE!`v\x05\x01@\xE4\xFC&R\xF5\xE0\xE7E\xF6\xFC\x83l\xDA\x8B\x87\x87\x87\x87`@Qa+,\x94\x93\x92\x91\x90ae\xB5V[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_\x80`\x08`S\x81\x11\x15a+SWa+Rad\x82V[[`\xFF\x16`\x01\x90\x1B`\x06`S\x81\x11\x15a+nWa+mad\x82V[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a+\x89Wa+\x88ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a+\xA4Wa+\xA3ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a+\xBFWa+\xBEad\x82V[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a+\xDAWa+\xD9ad\x82V[[`\xFF\x16`\x01\x90\x1B_`S\x81\x11\x15a+\xF4Wa+\xF3ad\x82V[[`\xFF\x16`\x01\x90\x1Ba,\x05\x91\x90ad\xDCV[a,\x0F\x91\x90ad\xDCV[a,\x19\x91\x90ad\xDCV[a,#\x91\x90ad\xDCV[a,-\x91\x90ad\xDCV[a,7\x91\x90ad\xDCV[\x90P_a,D\x86\x83aB\xF8V[\x90Pa,T`\x07\x87\x87\x87\x85aC^V[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x144\xBAM\x82\x86\x89\x89\x88`@Q\x86c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a,\xAB\x95\x94\x93\x92\x91\x90aedV[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a,\xC2W_\x80\xFD[PZ\xF1\x15\x80\x15a,\xD4W=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7FM2(K\xD3\x19>\xCA\xA4N\x1C\xEC\xA3/A\xC5\xD6\xC3(\x03\xA9.\x07\x96}\xD3\xEEB)r\x15\x82\x87\x87\x87\x87`@Qa-$\x94\x93\x92\x91\x90ae\xB5V[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_\x80`\x08`S\x81\x11\x15a-KWa-Jad\x82V[[`\xFF\x16`\x01\x90\x1B`\x06`S\x81\x11\x15a-fWa-ead\x82V[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a-\x81Wa-\x80ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a-\x9CWa-\x9Bad\x82V[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a-\xB7Wa-\xB6ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a-\xD2Wa-\xD1ad\x82V[[`\xFF\x16`\x01\x90\x1Ba-\xE3\x91\x90ad\xDCV[a-\xED\x91\x90ad\xDCV[a-\xF7\x91\x90ad\xDCV[a.\x01\x91\x90ad\xDCV[a.\x0B\x91\x90ad\xDCV[\x90P_a.\x18\x86\x83aB\xF8V[\x90Pa.(`\t\x87\x87\x87\x85aC^V[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x1E\xD9\x1F\xF6\x82\x86\x89\x89\x88`@Q\x86c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a.\x7F\x95\x94\x93\x92\x91\x90aedV[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a.\x96W_\x80\xFD[PZ\xF1\x15\x80\x15a.\xA8W=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F2B \xBF\xC9\xCB\x15\x8BI)\x91\xC0<0\x9C\xD8nSE\xCA\xC4Z\xAC\xAE \x92\xDD\xAB\xE3\x1F\xA3\xD8\x87\x87\x87\x87`@Qa.\xF8\x94\x93\x92\x91\x90ae\xB5V[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_\x80`\x08`S\x81\x11\x15a/\x1FWa/\x1Ead\x82V[[`\xFF\x16`\x01\x90\x1B`\x07`S\x81\x11\x15a/:Wa/9ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x06`S\x81\x11\x15a/UWa/Tad\x82V[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a/pWa/oad\x82V[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a/\x8BWa/\x8Aad\x82V[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a/\xA6Wa/\xA5ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a/\xC1Wa/\xC0ad\x82V[[`\xFF\x16`\x01\x90\x1B_`S\x81\x11\x15a/\xDBWa/\xDAad\x82V[[`\xFF\x16`\x01\x90\x1Ba/\xEC\x91\x90ad\xDCV[a/\xF6\x91\x90ad\xDCV[a0\0\x91\x90ad\xDCV[a0\n\x91\x90ad\xDCV[a0\x14\x91\x90ad\xDCV[a0\x1E\x91\x90ad\xDCV[a0(\x91\x90ad\xDCV[\x90P_\x81\x84`S\x81\x11\x15a0?Wa0>ad\x82V[[`\xFF\x16`\x01\x90\x1B\x16\x03a0~W`@Q\x7F\xC6\xDEFj\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x18\x84\x84sP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]F`@Q` \x01a0\xAC\x95\x94\x93\x92\x91\x90al\x82V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x91Pa0\xCE\x82\x84aG\x90V[\x91Pa0\xD8aH\tV[s#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c4\x8C1\x85\x84\x84`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a1'\x92\x91\x90al\xE0V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a1>W_\x80\xFD[PZ\xF1\x15\x80\x15a1PW=_\x80>=_\xFD[PPPPsP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c>9\\\xEC\x833`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a1\xA3\x92\x91\x90ag\x01V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a1\xBAW_\x80\xFD[PZ\xF1\x15\x80\x15a1\xCCW=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\x06<\xCD\x1B\xBAE\x15\x1D\x91\xF6\xA4\x18\x06PG\xA3\xD0H\xD0X\xA9\"SWG\xBB+WZ\x01\xD26\x85\x85\x85`@Qa2\x1A\x93\x92\x91\x90am\x07V[`@Q\x80\x91\x03\x90\xA2P\x92\x91PPV[_s6w!B\xB7Hq\xF2U\xCB\xD7\xA3\xE8\x9B@\x1D>E\x82_\x90P\x90V[`@Q\x80`@\x01`@R\x80`\x05\x81R` \x01\x7F5.0.0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81RP\x81V[_\x80`\x08`S\x81\x11\x15a2\x93Wa2\x92ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x06`S\x81\x11\x15a2\xAEWa2\xADad\x82V[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a2\xC9Wa2\xC8ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a2\xE4Wa2\xE3ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a2\xFFWa2\xFEad\x82V[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a3\x1AWa3\x19ad\x82V[[`\xFF\x16`\x01\x90\x1Ba3+\x91\x90ad\xDCV[a35\x91\x90ad\xDCV[a3?\x91\x90ad\xDCV[a3I\x91\x90ad\xDCV[a3S\x91\x90ad\xDCV[\x90P_a3`\x86\x83aB\xF8V[\x90Pa3p`\x0B\x87\x87\x87\x85aC^V[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16cf\x91\x81\xC0\x82\x86\x89\x89\x88`@Q\x86c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a3\xC7\x95\x94\x93\x92\x91\x90aedV[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a3\xDEW_\x80\xFD[PZ\xF1\x15\x80\x15a3\xF0W=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xC1HgY\x05\xD0z\xD5Io\x8E\xF4\xD8\x19\\\x90u\x03\xF3\xEC\x12\xFD\x10\xED_!$\n\xBCi64\x87\x87\x87\x87`@Qa4@\x94\x93\x92\x91\x90ae\xB5V[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_\x80`\x08`S\x81\x11\x15a4gWa4fad\x82V[[`\xFF\x16`\x01\x90\x1B`\x06`S\x81\x11\x15a4\x82Wa4\x81ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a4\x9DWa4\x9Cad\x82V[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a4\xB8Wa4\xB7ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a4\xD3Wa4\xD2ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a4\xEEWa4\xEDad\x82V[[`\xFF\x16`\x01\x90\x1Ba4\xFF\x91\x90ad\xDCV[a5\t\x91\x90ad\xDCV[a5\x13\x91\x90ad\xDCV[a5\x1D\x91\x90ad\xDCV[a5'\x91\x90ad\xDCV[\x90P_a54\x86\x83aB\xF8V[\x90Pa5D`\x08\x87\x87\x87\x85aC^V[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x83\xE6\xA7 \x82\x86\x89\x89\x88`@Q\x86c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a5\x9B\x95\x94\x93\x92\x91\x90aedV[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a5\xB2W_\x80\xFD[PZ\xF1\x15\x80\x15a5\xC4W=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xE8B\x82\xAA\xEB\xCC\xA6\x98D>9\xA2\xA9H\xA3E\xD0\xD2\xEB\xC6T\xAF\\\xB6W\xA2\xD7\xE8\x05;\xF6\xCB\x87\x87\x87\x87`@Qa6\x14\x94\x93\x92\x91\x90ae\xB5V[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_`\x01`\xF8\x1B\x82~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x14a6\x85W`@Q\x7FO\"NS\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x80\x1B\x83\x03a6\xC0W`@Q\x7F#\xD3Y\xA3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\x06`S\x81\x11\x15a6\xD5Wa6\xD4ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a6\xF0Wa6\xEFad\x82V[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a7\x0BWa7\nad\x82V[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a7&Wa7%ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a7AWa7@ad\x82V[[`\xFF\x16`\x01\x90\x1Ba7R\x91\x90ad\xDCV[a7\\\x91\x90ad\xDCV[a7f\x91\x90ad\xDCV[a7p\x91\x90ad\xDCV[\x90P_a7}\x86\x83aB\xF8V[\x90Pa7\x8D`\x04\x87\x87\x87\x85aC^V[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xFA\x08\xE3\x8D\x82\x86\x89\x89\x88`@Q\x86c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a7\xE4\x95\x94\x93\x92\x91\x90aedV[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a7\xFBW_\x80\xFD[PZ\xF1\x15\x80\x15a8\rW=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\x0Ei\x1C\xD0\xBF\x8CN\x93\x08\xE4\xCE\xD1\xBB\x9C\x96A\x17\xDC\\[\xB9\xB9\xAB[\xDF\xEB\xF2\xC9\xB1:\x89|\x87\x87\x87\x87`@Qa8]\x94\x93\x92\x91\x90ae\xB5V[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_\x80`\x08`S\x81\x11\x15a8\x84Wa8\x83ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x06`S\x81\x11\x15a8\x9FWa8\x9Ead\x82V[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a8\xBAWa8\xB9ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a8\xD5Wa8\xD4ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a8\xF0Wa8\xEFad\x82V[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a9\x0BWa9\nad\x82V[[`\xFF\x16`\x01\x90\x1Ba9\x1C\x91\x90ad\xDCV[a9&\x91\x90ad\xDCV[a90\x91\x90ad\xDCV[a9:\x91\x90ad\xDCV[a9D\x91\x90ad\xDCV[\x90P_a9Q\x84\x83aB\xF8V[\x90Pa9^`\x14\x85aS\xB8V[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xA4\xC9\x8F>\x82\x86\x86`@Q\x84c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a9\xB1\x93\x92\x91\x90aj\xBDV[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a9\xC8W_\x80\xFD[PZ\xF1\x15\x80\x15a9\xDAW=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\x8CfM<<\xA5\x83\xFCX\x03\xB8\xA9\x1CIdK\xBD\x95P\xBF\xA8yg\xC7:\xD1\xDE\x83\x02wh\xC0\x85\x85`@Qa:&\x92\x91\x90am<V[`@Q\x80\x91\x03\x90\xA2PP\x91\x90PV[_\x80a:?aH\xD0V[\x90Pa:K\x83\x82aUpV[\x91P3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\x0C\x8A\xCA`\x17\x003&\x05\x1E\x19\x91>\xF0&1\xF2K\x80\x11%\xE1\xFA\x8A\x1D\x81.\x86\x83\x19\xFD\xA6\x84\x83\x85`@Qa:\x97\x93\x92\x91\x90amcV[`@Q\x80\x91\x03\x90\xA2P\x91\x90PV[_\x80`\x08`S\x81\x11\x15a:\xBBWa:\xBAad\x82V[[`\xFF\x16`\x01\x90\x1B`\x07`S\x81\x11\x15a:\xD6Wa:\xD5ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x06`S\x81\x11\x15a:\xF1Wa:\xF0ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a;\x0CWa;\x0Bad\x82V[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a;'Wa;&ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a;BWa;Aad\x82V[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a;]Wa;\\ad\x82V[[`\xFF\x16`\x01\x90\x1B_`S\x81\x11\x15a;wWa;vad\x82V[[`\xFF\x16`\x01\x90\x1Ba;\x88\x91\x90ad\xDCV[a;\x92\x91\x90ad\xDCV[a;\x9C\x91\x90ad\xDCV[a;\xA6\x91\x90ad\xDCV[a;\xB0\x91\x90ad\xDCV[a;\xBA\x91\x90ad\xDCV[a;\xC4\x91\x90ad\xDCV[\x90P_a;\xD1\x86\x83aB\xF8V[\x90Pa;\xE1`\r\x87\x87\x87_aC^V[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xFA]\xEF\xDB\x82\x86\x89\x89\x88`@Q\x86c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a<8\x95\x94\x93\x92\x91\x90aedV[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a<OW_\x80\xFD[PZ\xF1\x15\x80\x15a<aW=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7Fi`\xC1\xE8\x8Fa\xC3R\xDB\xA3M\x1B\xBFgS\xE3\x02yRd\xD5\xD8\xAE\x82\xF7\x98<p\x04e\x1E]\x87\x87\x87\x87`@Qa<\xB1\x94\x93\x92\x91\x90ae\xB5V[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_\x80`\x08`S\x81\x11\x15a<\xD8Wa<\xD7ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x06`S\x81\x11\x15a<\xF3Wa<\xF2ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a=\x0EWa=\rad\x82V[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a=)Wa=(ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a=DWa=Cad\x82V[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a=_Wa=^ad\x82V[[`\xFF\x16`\x01\x90\x1B_`S\x81\x11\x15a=yWa=xad\x82V[[`\xFF\x16`\x01\x90\x1Ba=\x8A\x91\x90ad\xDCV[a=\x94\x91\x90ad\xDCV[a=\x9E\x91\x90ad\xDCV[a=\xA8\x91\x90ad\xDCV[a=\xB2\x91\x90ad\xDCV[a=\xBC\x91\x90ad\xDCV[\x90P_a=\xC9\x86\x83aB\xF8V[\x90Pa=\xD9`\x05\x87\x87\x87\x85aC^V[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x18V\xD9\x1D\x82\x86\x89\x89\x88`@Q\x86c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a>0\x95\x94\x93\x92\x91\x90aedV[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a>GW_\x80\xFD[PZ\xF1\x15\x80\x15a>YW=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xE4$\x86\xB0\xCC\xDB\xEF\x81\xA2\x07\\H\xC8\xE5\x15\xC0y\xAE\xA7<\x8B\x82B\x99\x97\xC7*/\xE1\xBFO\xEF\x87\x87\x87\x87`@Qa>\xA9\x94\x93\x92\x91\x90ae\xB5V[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_s#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9\x90P\x90V[_\x80`\x08`S\x81\x11\x15a>\xEBWa>\xEAad\x82V[[`\xFF\x16`\x01\x90\x1B`\x06`S\x81\x11\x15a?\x06Wa?\x05ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a?!Wa? ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a?<Wa?;ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a?WWa?Vad\x82V[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a?rWa?qad\x82V[[`\xFF\x16`\x01\x90\x1B_`S\x81\x11\x15a?\x8CWa?\x8Bad\x82V[[`\xFF\x16`\x01\x90\x1Ba?\x9D\x91\x90ad\xDCV[a?\xA7\x91\x90ad\xDCV[a?\xB1\x91\x90ad\xDCV[a?\xBB\x91\x90ad\xDCV[a?\xC5\x91\x90ad\xDCV[a?\xCF\x91\x90ad\xDCV[\x90P_a?\xDC\x84\x83aB\xF8V[\x90Pa?\xE9`\x15\x85aS\xB8V[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xFC\x06<b\x82\x86\x86`@Q\x84c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a@<\x93\x92\x91\x90aj\xBDV[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a@SW_\x80\xFD[PZ\xF1\x15\x80\x15a@eW=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7FU\xAF\xF4\xCCz=\x16\x0C\x83\xF1\xF1[\x81\x80\x11\xED\xE8A\xA0\xB4Y\x7F\xB1M\xCD6\x03\xDF:\x11\xE5\xE0\x85\x85`@Qa@\xB1\x92\x91\x90am<V[`@Q\x80\x91\x03\x90\xA2PP\x91\x90PV[_sP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]\x90P\x90V[_\x80`\x08`S\x81\x11\x15a@\xF1Wa@\xF0ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x07`S\x81\x11\x15aA\x0CWaA\x0Bad\x82V[[`\xFF\x16`\x01\x90\x1B`\x06`S\x81\x11\x15aA'WaA&ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15aABWaAAad\x82V[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15aA]WaA\\ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15aAxWaAwad\x82V[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15aA\x93WaA\x92ad\x82V[[`\xFF\x16`\x01\x90\x1B_`S\x81\x11\x15aA\xADWaA\xACad\x82V[[`\xFF\x16`\x01\x90\x1BaA\xBE\x91\x90ad\xDCV[aA\xC8\x91\x90ad\xDCV[aA\xD2\x91\x90ad\xDCV[aA\xDC\x91\x90ad\xDCV[aA\xE6\x91\x90ad\xDCV[aA\xF0\x91\x90ad\xDCV[aA\xFA\x91\x90ad\xDCV[\x90P_aB\x07\x86\x83aB\xF8V[\x90PaB\x17`\x0C\x87\x87\x87_aC^V[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x94\xE7\x0EO\x82\x86\x89\x89\x88`@Q\x86c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01aBn\x95\x94\x93\x92\x91\x90aedV[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15aB\x85W_\x80\xFD[PZ\xF1\x15\x80\x15aB\x97W=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xB3\xD5\xC6d\xEC\x86WX\x18\xE8\xD7_\xF2\\_\x86rP\xDF\x89T\x08\x85I\xC4\x1C\x84\x8C\xD1\x0Ev\xCB\x87\x87\x87\x87`@QaB\xE7\x94\x93\x92\x91\x90ae\xB5V[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_aC\x02\x83aF\x8EV[\x90P_\x82\x82`S\x81\x11\x15aC\x19WaC\x18ad\x82V[[`\xFF\x16`\x01\x90\x1B\x16\x03aCXW`@Q\x7F\xC6\xDEFj\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x92\x91PPV[_aCgaH\tV[aCp\x83aX\x01V[sP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x82\x02{m\x863`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01aC\xBF\x92\x91\x90ag\x01V[` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15aC\xDAW=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90aC\xFE\x91\x90ah\xE1V[aDAW\x843`@Q\x7F\x9D\xE39,\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aD8\x92\x91\x90ag\x01V[`@Q\x80\x91\x03\x90\xFD[_`\xF8\x1B\x83~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x03aE\xB6WsP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x82\x02{m\x853`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01aD\xBC\x92\x91\x90ag\x01V[` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15aD\xD7W=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90aD\xFB\x91\x90ah\xE1V[aE>W\x833`@Q\x7F\x9D\xE39,\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aE5\x92\x91\x90ag\x01V[`@Q\x80\x91\x03\x90\xFD[_aEH\x85aF\x8EV[\x90P_aET\x87aF\x8EV[\x90P\x81`S\x81\x11\x15aEiWaEhad\x82V[[\x81`S\x81\x11\x15aE|WaE{ad\x82V[[\x14aE\xB3W`@Q\x7F\x1F1X\xC7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[PP[\x85\x85\x85\x85sP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]F`@Q` \x01aE\xE5\x96\x95\x94\x93\x92\x91\x90am\xB8V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x90PaF\x07\x81\x83aG\x90V[\x90PsP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c>9\\\xEC\x823`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01aFX\x92\x91\x90ag\x01V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15aFoW_\x80\xFD[PZ\xF1\x15\x80\x15aF\x81W=_\x80>=_\xFD[PPPP\x95\x94PPPPPV[_\x81`\x1E` \x81\x10aF\xA3WaF\xA2an'V[[\x1A`\xF8\x1B`\xF8\x1C`\xFF\x16`S\x81\x11\x15aF\xBFWaF\xBEad\x82V[[\x90P\x91\x90PV[``_`\x01aF\xD4\x84aXEV[\x01\x90P_\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15aF\xF2WaF\xF1a`\x16V[[`@Q\x90\x80\x82R\x80`\x1F\x01`\x1F\x19\x16` \x01\x82\x01`@R\x80\x15aG$W\x81` \x01`\x01\x82\x02\x806\x837\x80\x82\x01\x91PP\x90P[P\x90P_\x82` \x01\x82\x01\x90P[`\x01\x15aG\x85W\x80\x80`\x01\x90\x03\x91PP\x7F0123456789abcdef\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\n\x86\x06\x1A\x81S`\n\x85\x81aGzWaGyanTV[[\x04\x94P_\x85\x03aG1W[\x81\x93PPPP\x91\x90PV[_\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0_\x1B\x83\x16\x90P`P`\xFF_\x1B\x90\x1B\x81\x17\x90P`\x10Fg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16_\x1B\x90\x1B\x81\x17\x90P`\x08\x82`S\x81\x11\x15aG\xEEWaG\xEDad\x82V[[`\xFF\x16_\x1B\x90\x1B\x81\x17\x90P_`\xFF\x16_\x1B\x81\x17\x90P\x92\x91PPV[s#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16cg\xA7E{3`@Q\x82c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01aHV\x91\x90ad\x13V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15aHmW_\x80\xFD[PZ\xF1\x15\x80\x15aH\x7FW=_\x80>=_\xFD[PPPPV[_aH\x8EaH\xA9V[_\x01_\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P\x90V[_\x7F\xF0\xC5~\x16\x84\r\xF0@\xF1P\x88\xDC/\x81\xFE9\x1C9#\xBE\xC7>#\xA9f.\xFC\x9C\"\x9Cj\0\x90P\x90V[_\x80aH\xDAaY\x96V[\x90P\x80_\x01TsP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]F`\x01CaI\x03\x91\x90an\x81V[@B`@Q` \x01aI\x19\x95\x94\x93\x92\x91\x90an\xB4V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x91P\x80_\x01_\x81T\x80\x92\x91\x90aID\x90ao\x12V[\x91\x90PUPP\x90V[_\x80`\x08`S\x81\x11\x15aIcWaIbad\x82V[[`\xFF\x16`\x01\x90\x1B`\x06`S\x81\x11\x15aI~WaI}ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15aI\x99WaI\x98ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15aI\xB4WaI\xB3ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15aI\xCFWaI\xCEad\x82V[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15aI\xEAWaI\xE9ad\x82V[[`\xFF\x16`\x01\x90\x1BaI\xFB\x91\x90ad\xDCV[aJ\x05\x91\x90ad\xDCV[aJ\x0F\x91\x90ad\xDCV[aJ\x19\x91\x90ad\xDCV[aJ#\x91\x90ad\xDCV[\x90P_\x81\x85`S\x81\x11\x15aJ:WaJ9ad\x82V[[`\xFF\x16`\x01\x90\x1B\x16\x03aJyW`@Q\x7F\xC6\xDEFj\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[aJ\x82\x85aY\xBDV[aJ\xB8W`@Q\x7F$\xE8\xE7B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[aJ\xC2\x85\x85aY\xE1V[`\x1B\x85\x85\x85`@Q` \x01aJ\xDA\x94\x93\x92\x91\x90aoyV[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x91PaJ\xFC\x82\x85aG\x90V[\x91PaK\x06aH\tV[s#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xCC\x86g\x82\x85\x84`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01aKU\x92\x91\x90al\xE0V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15aKlW_\x80\xFD[PZ\xF1\x15\x80\x15aK~W=_\x80>=_\xFD[PPPPsP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c>9\\\xEC\x833`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01aK\xD1\x92\x91\x90ag\x01V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15aK\xE8W_\x80\xFD[PZ\xF1\x15\x80\x15aK\xFAW=_\x80>=_\xFD[PPPPP\x93\x92PPPV[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x160s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14\x80aL\xB3WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16aL\x9Aa[1V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14\x15[\x15aL\xEAW`@Q\x7F\xE0|\x8D\xBA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[V[sP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x8D\xA5\xCB[`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15aMIW=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90aMm\x91\x90ao\xDAV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14aM\xDCW3`@Q\x7F!\xBF\xDA\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aM\xD3\x91\x90ad\x13V[`@Q\x80\x91\x03\x90\xFD[PV[\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16cR\xD1\x90-`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x92PPP\x80\x15aNGWP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90aND\x91\x90af\xD6V[`\x01[aN\x88W\x81`@Q\x7FL\x9C\x8C\xE3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aN\x7F\x91\x90ad\x13V[`@Q\x80\x91\x03\x90\xFD[\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC_\x1B\x81\x14aN\xEEW\x80`@Q\x7F\xAA\x1DI\xA4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aN\xE5\x91\x90a_\x8BV[`@Q\x80\x91\x03\x90\xFD[aN\xF8\x83\x83a[\x84V[PPPV[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x160s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14aO\x82W`@Q\x7F\xE0|\x8D\xBA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[V[_aO\x8DaH\tV[sP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x82\x02{m\x853`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01aO\xDC\x92\x91\x90ag\x01V[` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15aO\xF7W=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90aP\x1B\x91\x90ah\xE1V[aP^W\x833`@Q\x7F\x9D\xE39,\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aPU\x92\x91\x90ag\x01V[`@Q\x80\x91\x03\x90\xFD[sP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x82\x02{m\x843`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01aP\xAD\x92\x91\x90ag\x01V[` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15aP\xC8W=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90aP\xEC\x91\x90ah\xE1V[aQ/W\x823`@Q\x7F\x9D\xE39,\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aQ&\x92\x91\x90ag\x01V[`@Q\x80\x91\x03\x90\xFD[sP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x82\x02{m\x833`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01aQ~\x92\x91\x90ag\x01V[` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15aQ\x99W=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90aQ\xBD\x91\x90ah\xE1V[aR\0W\x813`@Q\x7F\x9D\xE39,\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aQ\xF7\x92\x91\x90ag\x01V[`@Q\x80\x91\x03\x90\xFD[_aR\n\x85aF\x8EV[\x90P_aR\x16\x85aF\x8EV[\x90P_aR\"\x85aF\x8EV[\x90P_`S\x81\x11\x15aR7WaR6ad\x82V[[\x83`S\x81\x11\x15aRJWaRIad\x82V[[\x14aR\x81W`@Q\x7F\xC6\xDEFj\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x80`S\x81\x11\x15aR\x94WaR\x93ad\x82V[[\x82`S\x81\x11\x15aR\xA7WaR\xA6ad\x82V[[\x14aR\xDEW`@Q\x7F\x1F1X\xC7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x87\x87\x87\x87sP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]F`@Q` \x01aS\r\x96\x95\x94\x93\x92\x91\x90ap\x05V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x93PaS/\x84\x83aG\x90V[\x93PsP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c>9\\\xEC\x853`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01aS\x80\x92\x91\x90ag\x01V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15aS\x97W_\x80\xFD[PZ\xF1\x15\x80\x15aS\xA9W=_\x80>=_\xFD[PPPPPPP\x94\x93PPPPV[_aS\xC1aH\tV[sP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x82\x02{m\x833`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01aT\x10\x92\x91\x90ag\x01V[` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15aT+W=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90aTO\x91\x90ah\xE1V[aT\x92W\x813`@Q\x7F\x9D\xE39,\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aT\x89\x92\x91\x90ag\x01V[`@Q\x80\x91\x03\x90\xFD[\x82\x82sP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]F`@Q` \x01aT\xBD\x94\x93\x92\x91\x90aptV[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x90P_aT\xDF\x83aF\x8EV[\x90PaT\xEB\x82\x82aG\x90V[\x91PsP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c>9\\\xEC\x833`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01aU<\x92\x91\x90ag\x01V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15aUSW_\x80\xFD[PZ\xF1\x15\x80\x15aUeW=_\x80>=_\xFD[PPPPP\x92\x91PPV[_\x80`\x08`S\x81\x11\x15aU\x86WaU\x85ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x06`S\x81\x11\x15aU\xA1WaU\xA0ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15aU\xBCWaU\xBBad\x82V[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15aU\xD7WaU\xD6ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15aU\xF2WaU\xF1ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15aV\rWaV\x0Cad\x82V[[`\xFF\x16`\x01\x90\x1B_`S\x81\x11\x15aV'WaV&ad\x82V[[`\xFF\x16`\x01\x90\x1BaV8\x91\x90ad\xDCV[aVB\x91\x90ad\xDCV[aVL\x91\x90ad\xDCV[aVV\x91\x90ad\xDCV[aV`\x91\x90ad\xDCV[aVj\x91\x90ad\xDCV[\x90P_\x81\x85`S\x81\x11\x15aV\x81WaV\x80ad\x82V[[`\xFF\x16`\x01\x90\x1B\x16\x03aV\xC0W`@Q\x7F\xC6\xDEFj\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x1A\x84\x84`@Q` \x01aV\xD6\x93\x92\x91\x90ap\xC1V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x91PaV\xF8\x82\x85aG\x90V[\x91PaW\x02aH\tV[s#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\t\xB0N\x8F\x85\x84`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01aWQ\x92\x91\x90al\xE0V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15aWhW_\x80\xFD[PZ\xF1\x15\x80\x15aWzW=_\x80>=_\xFD[PPPPsP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c>9\\\xEC\x833`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01aW\xCD\x92\x91\x90ag\x01V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15aW\xE4W_\x80\xFD[PZ\xF1\x15\x80\x15aW\xF6W=_\x80>=_\xFD[PPPPP\x92\x91PPV[`\x01\x81`\xF8\x1C`\xFF\x16\x11\x15aXBW`@Q\x7F\xDF{\xF3%\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[PV[_\x80_\x90Pz\x18O\x03\xE9?\xF9\xF4\xDA\xA7\x97\xEDn8\xEDd\xBFj\x1F\x01\0\0\0\0\0\0\0\0\x83\x10aX\xA1Wz\x18O\x03\xE9?\xF9\xF4\xDA\xA7\x97\xEDn8\xEDd\xBFj\x1F\x01\0\0\0\0\0\0\0\0\x83\x81aX\x97WaX\x96anTV[[\x04\x92P`@\x81\x01\x90P[m\x04\xEE-mA[\x85\xAC\xEF\x81\0\0\0\0\x83\x10aX\xDEWm\x04\xEE-mA[\x85\xAC\xEF\x81\0\0\0\0\x83\x81aX\xD4WaX\xD3anTV[[\x04\x92P` \x81\x01\x90P[f#\x86\xF2o\xC1\0\0\x83\x10aY\rWf#\x86\xF2o\xC1\0\0\x83\x81aY\x03WaY\x02anTV[[\x04\x92P`\x10\x81\x01\x90P[c\x05\xF5\xE1\0\x83\x10aY6Wc\x05\xF5\xE1\0\x83\x81aY,WaY+anTV[[\x04\x92P`\x08\x81\x01\x90P[a'\x10\x83\x10aY[Wa'\x10\x83\x81aYQWaYPanTV[[\x04\x92P`\x04\x81\x01\x90P[`d\x83\x10aY~W`d\x83\x81aYtWaYsanTV[[\x04\x92P`\x02\x81\x01\x90P[`\n\x83\x10aY\x8DW`\x01\x81\x01\x90P[\x80\x91PP\x91\x90PV[_\x7FF\x13\xE1w\x1Fku]$>So\xB5\xA2<[\x15\xE2\x82eu\xFE\xE9!\xE8\xFEz\"\xA7`\xC8\0\x90P\x90V[_\x80\x82\x11\x80\x15aY\xDAWP_`\x01\x83aY\xD6\x91\x90an\x81V[\x83\x16\x14[\x90P\x91\x90PV[`\x02`S\x81\x11\x15aY\xF5WaY\xF4ad\x82V[[\x81`S\x81\x11\x15aZ\x08WaZ\x07ad\x82V[[\x03aZ\x1EWaZ\x19\x82a\x01\0a[\xF6V[a[-V[`\x03`S\x81\x11\x15aZ2WaZ1ad\x82V[[\x81`S\x81\x11\x15aZEWaZDad\x82V[[\x03aZ\\WaZW\x82b\x01\0\0a[\xF6V[a[-V[`\x04`S\x81\x11\x15aZpWaZoad\x82V[[\x81`S\x81\x11\x15aZ\x83WaZ\x82ad\x82V[[\x03aZ\x9CWaZ\x97\x82d\x01\0\0\0\0a[\xF6V[a[-V[`\x05`S\x81\x11\x15aZ\xB0WaZ\xAFad\x82V[[\x81`S\x81\x11\x15aZ\xC3WaZ\xC2ad\x82V[[\x03aZ\xE0WaZ\xDB\x82h\x01\0\0\0\0\0\0\0\0a[\xF6V[a[-V[`\x06`S\x81\x11\x15aZ\xF4WaZ\xF3ad\x82V[[\x81`S\x81\x11\x15a[\x07Wa[\x06ad\x82V[[\x03a[,Wa['\x82p\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a[\xF6V[a[-V[[PPV[_a[]\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC_\x1Ba\\4V[_\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P\x90V[a[\x8D\x82a\\=V[\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xBC|\xD7Z \xEE'\xFD\x9A\xDE\xBA\xB3 A\xF7U!M\xBCk\xFF\xA9\x0C\xC0\"[9\xDA.\\-;`@Q`@Q\x80\x91\x03\x90\xA2_\x81Q\x11\x15a[\xE9Wa[\xE3\x82\x82a]\x06V[Pa[\xF2V[a[\xF1a]\x86V[[PPV[\x80\x82\x11\x15a\\0W`@Q\x7F\xC7\xDA\xDFE\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[PPV[_\x81\x90P\x91\x90PV[_\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16;\x03a\\\x98W\x80`@Q\x7FL\x9C\x8C\xE3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\\\x8F\x91\x90ad\x13V[`@Q\x80\x91\x03\x90\xFD[\x80a\\\xC4\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC_\x1Ba\\4V[_\x01_a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UPPV[``_\x80\x84s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x84`@Qa]/\x91\x90aq7V[_`@Q\x80\x83\x03\x81\x85Z\xF4\x91PP=\x80_\x81\x14a]gW`@Q\x91P`\x1F\x19`?=\x01\x16\x82\x01`@R=\x82R=_` \x84\x01>a]lV[``\x91P[P\x91P\x91Pa]|\x85\x83\x83a]\xC2V[\x92PPP\x92\x91PPV[_4\x11\x15a]\xC0W`@Q\x7F\xB3\x98\x97\x9F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[V[``\x82a]\xD7Wa]\xD2\x82a^OV[a^GV[_\x82Q\x14\x80\x15a]\xFDWP_\x84s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16;\x14[\x15a^?W\x83`@Q\x7F\x99\x96\xB3\x15\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a^6\x91\x90ad\x13V[`@Q\x80\x91\x03\x90\xFD[\x81\x90Pa^HV[[\x93\x92PPPV[_\x81Q\x11\x15a^aW\x80Q\x80\x82` \x01\xFD[`@Q\x7F\xD6\xBD\xA2u\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`@Q\x90P\x90V[_\x80\xFD[_\x80\xFD[_\x81\x90P\x91\x90PV[a^\xB6\x81a^\xA4V[\x81\x14a^\xC0W_\x80\xFD[PV[_\x815\x90Pa^\xD1\x81a^\xADV[\x92\x91PPV[_\x7F\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\x16\x90P\x91\x90PV[a_\x0B\x81a^\xD7V[\x81\x14a_\x15W_\x80\xFD[PV[_\x815\x90Pa_&\x81a_\x02V[\x92\x91PPV[_\x80_``\x84\x86\x03\x12\x15a_CWa_Ba^\x9CV[[_a_P\x86\x82\x87\x01a^\xC3V[\x93PP` a_a\x86\x82\x87\x01a^\xC3V[\x92PP`@a_r\x86\x82\x87\x01a_\x18V[\x91PP\x92P\x92P\x92V[a_\x85\x81a^\xA4V[\x82RPPV[_` \x82\x01\x90Pa_\x9E_\x83\x01\x84a_|V[\x92\x91PPV[_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[_a_\xCD\x82a_\xA4V[\x90P\x91\x90PV[a_\xDD\x81a_\xC3V[\x81\x14a_\xE7W_\x80\xFD[PV[_\x815\x90Pa_\xF8\x81a_\xD4V[\x92\x91PPV[_\x80\xFD[_\x80\xFD[_`\x1F\x19`\x1F\x83\x01\x16\x90P\x91\x90PV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`A`\x04R`$_\xFD[a`L\x82a`\x06V[\x81\x01\x81\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17\x15a`kWa`ja`\x16V[[\x80`@RPPPV[_a`}a^\x93V[\x90Pa`\x89\x82\x82a`CV[\x91\x90PV[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15a`\xA8Wa`\xA7a`\x16V[[a`\xB1\x82a`\x06V[\x90P` \x81\x01\x90P\x91\x90PV[\x82\x81\x837_\x83\x83\x01RPPPV[_a`\xDEa`\xD9\x84a`\x8EV[a`tV[\x90P\x82\x81R` \x81\x01\x84\x84\x84\x01\x11\x15a`\xFAWa`\xF9a`\x02V[[aa\x05\x84\x82\x85a`\xBEV[P\x93\x92PPPV[_\x82`\x1F\x83\x01\x12aa!Waa a_\xFEV[[\x815aa1\x84\x82` \x86\x01a`\xCCV[\x91PP\x92\x91PPV[`T\x81\x10aaFW_\x80\xFD[PV[_\x815\x90PaaW\x81aa:V[\x92\x91PPV[_\x80_\x80`\x80\x85\x87\x03\x12\x15aauWaata^\x9CV[[_aa\x82\x87\x82\x88\x01a^\xC3V[\x94PP` aa\x93\x87\x82\x88\x01a_\xEAV[\x93PP`@\x85\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15aa\xB4Waa\xB3a^\xA0V[[aa\xC0\x87\x82\x88\x01aa\rV[\x92PP``aa\xD1\x87\x82\x88\x01aaIV[\x91PP\x92\x95\x91\x94P\x92PV[_\x81Q\x90P\x91\x90PV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[_[\x83\x81\x10\x15ab\x14W\x80\x82\x01Q\x81\x84\x01R` \x81\x01\x90Paa\xF9V[_\x84\x84\x01RPPPPV[_ab)\x82aa\xDDV[ab3\x81\x85aa\xE7V[\x93PabC\x81\x85` \x86\x01aa\xF7V[abL\x81a`\x06V[\x84\x01\x91PP\x92\x91PPV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Rabo\x81\x84ab\x1FV[\x90P\x92\x91PPV[_\x80`@\x83\x85\x03\x12\x15ab\x8DWab\x8Ca^\x9CV[[_ab\x9A\x85\x82\x86\x01a^\xC3V[\x92PP` ab\xAB\x85\x82\x86\x01aaIV[\x91PP\x92P\x92\x90PV[_\x81\x90P\x91\x90PV[ab\xC7\x81ab\xB5V[\x81\x14ab\xD1W_\x80\xFD[PV[_\x815\x90Pab\xE2\x81ab\xBEV[\x92\x91PPV[_\x80`@\x83\x85\x03\x12\x15ab\xFEWab\xFDa^\x9CV[[_ac\x0B\x85\x82\x86\x01ab\xD4V[\x92PP` ac\x1C\x85\x82\x86\x01aaIV[\x91PP\x92P\x92\x90PV[_\x80`@\x83\x85\x03\x12\x15ac<Wac;a^\x9CV[[_acI\x85\x82\x86\x01a_\xEAV[\x92PP` \x83\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15acjWacia^\xA0V[[acv\x85\x82\x86\x01aa\rV[\x91PP\x92P\x92\x90PV[_\x80_``\x84\x86\x03\x12\x15ac\x97Wac\x96a^\x9CV[[_ac\xA4\x86\x82\x87\x01a^\xC3V[\x93PP` ac\xB5\x86\x82\x87\x01a^\xC3V[\x92PP`@ac\xC6\x86\x82\x87\x01a^\xC3V[\x91PP\x92P\x92P\x92V[_`\xFF\x82\x16\x90P\x91\x90PV[ac\xE5\x81ac\xD0V[\x82RPPV[_` \x82\x01\x90Pac\xFE_\x83\x01\x84ac\xDCV[\x92\x91PPV[ad\r\x81a_\xC3V[\x82RPPV[_` \x82\x01\x90Pad&_\x83\x01\x84ad\x04V[\x92\x91PPV[_` \x82\x84\x03\x12\x15adAWad@a^\x9CV[[_adN\x84\x82\x85\x01a^\xC3V[\x91PP\x92\x91PPV[_` \x82\x84\x03\x12\x15adlWadka^\x9CV[[_ady\x84\x82\x85\x01aaIV[\x91PP\x92\x91PPV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`!`\x04R`$_\xFD[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x11`\x04R`$_\xFD[_ad\xE6\x82ab\xB5V[\x91Pad\xF1\x83ab\xB5V[\x92P\x82\x82\x01\x90P\x80\x82\x11\x15ae\tWae\x08ad\xAFV[[\x92\x91PPV[`T\x81\x10ae Wae\x1Fad\x82V[[PV[_\x81\x90Pae0\x82ae\x0FV[\x91\x90PV[_ae?\x82ae#V[\x90P\x91\x90PV[aeO\x81ae5V[\x82RPPV[ae^\x81a^\xD7V[\x82RPPV[_`\xA0\x82\x01\x90Paew_\x83\x01\x88aeFV[ae\x84` \x83\x01\x87aeUV[ae\x91`@\x83\x01\x86a_|V[ae\x9E``\x83\x01\x85a_|V[ae\xAB`\x80\x83\x01\x84a_|V[\x96\x95PPPPPPV[_`\x80\x82\x01\x90Pae\xC8_\x83\x01\x87a_|V[ae\xD5` \x83\x01\x86a_|V[ae\xE2`@\x83\x01\x85aeUV[ae\xEF``\x83\x01\x84a_|V[\x95\x94PPPPPV[af\x01\x81a_\xC3V[\x82RPPV[`@\x82\x01_\x82\x01Qaf\x1B_\x85\x01\x82ae\xF8V[P` \x82\x01Qaf.` \x85\x01\x82ae\xF8V[PPPPV[_\x81Q\x90P\x91\x90PV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[_afX\x82af4V[afb\x81\x85af>V[\x93Pafr\x81\x85` \x86\x01aa\xF7V[af{\x81a`\x06V[\x84\x01\x91PP\x92\x91PPV[_`\x80\x82\x01\x90Paf\x99_\x83\x01\x86af\x07V[af\xA6`@\x83\x01\x85a_|V[\x81\x81\x03``\x83\x01Raf\xB8\x81\x84afNV[\x90P\x94\x93PPPPV[_\x81Q\x90Paf\xD0\x81a^\xADV[\x92\x91PPV[_` \x82\x84\x03\x12\x15af\xEBWaf\xEAa^\x9CV[[_af\xF8\x84\x82\x85\x01af\xC2V[\x91PP\x92\x91PPV[_`@\x82\x01\x90Pag\x14_\x83\x01\x85a_|V[ag!` \x83\x01\x84ad\x04V[\x93\x92PPPV[_`\xA0\x82\x01\x90Pag;_\x83\x01\x88a_|V[agH` \x83\x01\x87ad\x04V[\x81\x81\x03`@\x83\x01RagZ\x81\x86afNV[\x90Pagi``\x83\x01\x85aeFV[agv`\x80\x83\x01\x84a_|V[\x96\x95PPPPPPV[_\x81\x90P\x92\x91PPV[_ag\x94\x82aa\xDDV[ag\x9E\x81\x85ag\x80V[\x93Pag\xAE\x81\x85` \x86\x01aa\xF7V[\x80\x84\x01\x91PP\x92\x91PPV[\x7F v\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_ag\xEE`\x02\x83ag\x80V[\x91Pag\xF9\x82ag\xBAV[`\x02\x82\x01\x90P\x91\x90PV[\x7F.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_ah8`\x01\x83ag\x80V[\x91PahC\x82ah\x04V[`\x01\x82\x01\x90P\x91\x90PV[_ahY\x82\x87ag\x8AV[\x91Pahd\x82ag\xE2V[\x91Pahp\x82\x86ag\x8AV[\x91Pah{\x82ah,V[\x91Pah\x87\x82\x85ag\x8AV[\x91Pah\x92\x82ah,V[\x91Pah\x9E\x82\x84ag\x8AV[\x91P\x81\x90P\x95\x94PPPPPV[_\x81\x15\x15\x90P\x91\x90PV[ah\xC0\x81ah\xACV[\x81\x14ah\xCAW_\x80\xFD[PV[_\x81Q\x90Pah\xDB\x81ah\xB7V[\x92\x91PPV[_` \x82\x84\x03\x12\x15ah\xF6Wah\xF5a^\x9CV[[_ai\x03\x84\x82\x85\x01ah\xCDV[\x91PP\x92\x91PPV[`\x1C\x81\x10ai\x1DWai\x1Cad\x82V[[PV[_\x81\x90Pai-\x82ai\x0CV[\x91\x90PV[_ai<\x82ai V[\x90P\x91\x90PV[_\x81`\xF8\x1B\x90P\x91\x90PV[_aiY\x82aiCV[\x90P\x91\x90PV[aiqail\x82ai2V[aiOV[\x82RPPV[_\x81\x90P\x91\x90PV[ai\x91ai\x8C\x82a^\xA4V[aiwV[\x82RPPV[ai\xA8ai\xA3\x82ae5V[aiOV[\x82RPPV[_\x81\x90P\x91\x90PV[_ai\xD1ai\xCCai\xC7\x84a_\xA4V[ai\xAEV[a_\xA4V[\x90P\x91\x90PV[_ai\xE2\x82ai\xB7V[\x90P\x91\x90PV[_ai\xF3\x82ai\xD8V[\x90P\x91\x90PV[_\x81``\x1B\x90P\x91\x90PV[_aj\x10\x82ai\xFAV[\x90P\x91\x90PV[_aj!\x82aj\x06V[\x90P\x91\x90PV[aj9aj4\x82ai\xE9V[aj\x17V[\x82RPPV[_\x81\x90P\x91\x90PV[ajYajT\x82ab\xB5V[aj?V[\x82RPPV[_ajj\x82\x88ai`V[`\x01\x82\x01\x91Pajz\x82\x87ai\x80V[` \x82\x01\x91Paj\x8A\x82\x86ai\x97V[`\x01\x82\x01\x91Paj\x9A\x82\x85aj(V[`\x14\x82\x01\x91Paj\xAA\x82\x84ajHV[` \x82\x01\x91P\x81\x90P\x96\x95PPPPPPV[_``\x82\x01\x90Paj\xD0_\x83\x01\x86aeFV[aj\xDD` \x83\x01\x85a_|V[aj\xEA`@\x83\x01\x84a_|V[\x94\x93PPPPV[_``\x82\x01\x90Pak\x05_\x83\x01\x86a_|V[ak\x12` \x83\x01\x85aeFV[ak\x1F`@\x83\x01\x84a_|V[\x94\x93PPPPV[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[akC\x81ak'V[\x82RPPV[_` \x82\x01\x90Pak\\_\x83\x01\x84ak:V[\x92\x91PPV[akk\x81ab\xB5V[\x82RPPV[_\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\x16\x90P\x91\x90PV[ak\xA5\x81akqV[\x82RPPV[_`\x80\x82\x01\x90Pak\xBE_\x83\x01\x87akbV[ak\xCB` \x83\x01\x86aeFV[ak\xD8`@\x83\x01\x85ak\x9CV[ak\xE5``\x83\x01\x84a_|V[\x95\x94PPPPPV[_`\xA0\x82\x01\x90Pal\x01_\x83\x01\x88aeFV[al\x0E` \x83\x01\x87a_|V[al\x1B`@\x83\x01\x86a_|V[al(``\x83\x01\x85a_|V[al5`\x80\x83\x01\x84a_|V[\x96\x95PPPPPPV[_`\x80\x82\x01\x90PalR_\x83\x01\x87a_|V[al_` \x83\x01\x86a_|V[all`@\x83\x01\x85a_|V[aly``\x83\x01\x84a_|V[\x95\x94PPPPPV[_al\x8D\x82\x88ai`V[`\x01\x82\x01\x91Pal\x9D\x82\x87ajHV[` \x82\x01\x91Pal\xAD\x82\x86ai\x97V[`\x01\x82\x01\x91Pal\xBD\x82\x85aj(V[`\x14\x82\x01\x91Pal\xCD\x82\x84ajHV[` \x82\x01\x91P\x81\x90P\x96\x95PPPPPPV[_`@\x82\x01\x90Pal\xF3_\x83\x01\x85aeFV[am\0` \x83\x01\x84a_|V[\x93\x92PPPV[_``\x82\x01\x90Pam\x1A_\x83\x01\x86akbV[am'` \x83\x01\x85aeFV[am4`@\x83\x01\x84a_|V[\x94\x93PPPPV[_`@\x82\x01\x90PamO_\x83\x01\x85a_|V[am\\` \x83\x01\x84a_|V[\x93\x92PPPV[_``\x82\x01\x90Pamv_\x83\x01\x86aeFV[am\x83` \x83\x01\x85ak\x9CV[am\x90`@\x83\x01\x84a_|V[\x94\x93PPPPV[_\x81\x90P\x91\x90PV[am\xB2am\xAD\x82a^\xD7V[am\x98V[\x82RPPV[_am\xC3\x82\x89ai`V[`\x01\x82\x01\x91Pam\xD3\x82\x88ai\x80V[` \x82\x01\x91Pam\xE3\x82\x87ai\x80V[` \x82\x01\x91Pam\xF3\x82\x86am\xA1V[`\x01\x82\x01\x91Pan\x03\x82\x85aj(V[`\x14\x82\x01\x91Pan\x13\x82\x84ajHV[` \x82\x01\x91P\x81\x90P\x97\x96PPPPPPPV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`2`\x04R`$_\xFD[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x12`\x04R`$_\xFD[_an\x8B\x82ab\xB5V[\x91Pan\x96\x83ab\xB5V[\x92P\x82\x82\x03\x90P\x81\x81\x11\x15an\xAEWan\xADad\xAFV[[\x92\x91PPV[_an\xBF\x82\x88ajHV[` \x82\x01\x91Pan\xCF\x82\x87aj(V[`\x14\x82\x01\x91Pan\xDF\x82\x86ajHV[` \x82\x01\x91Pan\xEF\x82\x85ai\x80V[` \x82\x01\x91Pan\xFF\x82\x84ajHV[` \x82\x01\x91P\x81\x90P\x96\x95PPPPPPV[_ao\x1C\x82ab\xB5V[\x91P\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x03aoNWaoMad\xAFV[[`\x01\x82\x01\x90P\x91\x90PV[_\x81\x90P\x91\x90PV[aosaon\x82akqV[aoYV[\x82RPPV[_ao\x84\x82\x87ai`V[`\x01\x82\x01\x91Pao\x94\x82\x86ajHV[` \x82\x01\x91Pao\xA4\x82\x85ai\x97V[`\x01\x82\x01\x91Pao\xB4\x82\x84aobV[`\x10\x82\x01\x91P\x81\x90P\x95\x94PPPPPV[_\x81Q\x90Pao\xD4\x81a_\xD4V[\x92\x91PPV[_` \x82\x84\x03\x12\x15ao\xEFWao\xEEa^\x9CV[[_ao\xFC\x84\x82\x85\x01ao\xC6V[\x91PP\x92\x91PPV[_ap\x10\x82\x89ai`V[`\x01\x82\x01\x91Pap \x82\x88ai\x80V[` \x82\x01\x91Pap0\x82\x87ai\x80V[` \x82\x01\x91Pap@\x82\x86ai\x80V[` \x82\x01\x91PapP\x82\x85aj(V[`\x14\x82\x01\x91Pap`\x82\x84ajHV[` \x82\x01\x91P\x81\x90P\x97\x96PPPPPPPV[_ap\x7F\x82\x87ai`V[`\x01\x82\x01\x91Pap\x8F\x82\x86ai\x80V[` \x82\x01\x91Pap\x9F\x82\x85aj(V[`\x14\x82\x01\x91Pap\xAF\x82\x84ajHV[` \x82\x01\x91P\x81\x90P\x95\x94PPPPPV[_ap\xCC\x82\x86ai`V[`\x01\x82\x01\x91Pap\xDC\x82\x85ai\x97V[`\x01\x82\x01\x91Pap\xEC\x82\x84aobV[`\x10\x82\x01\x91P\x81\x90P\x94\x93PPPPV[_\x81\x90P\x92\x91PPV[_aq\x11\x82af4V[aq\x1B\x81\x85ap\xFDV[\x93Paq+\x81\x85` \x86\x01aa\xF7V[\x80\x84\x01\x91PP\x92\x91PPV[_aqB\x82\x84aq\x07V[\x91P\x81\x90P\x92\x91PPV",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x608060405260043610610219575f3560e01c80637702dcff11610122578063ccc480a1116100aa578063d99882d51161006e578063d99882d5146108fd578063e078697214610939578063f51ccfb014610963578063f6859bdc1461099f578063f77f3f1d146109c957610219565b8063ccc480a1146107d1578063cf4d18aa1461080d578063d580c06314610849578063d75d6e8a14610885578063d8092cbc146108c157610219565b806391f98ffe116100f157806391f98ffe146106c95780639cd07acb14610705578063a8c7c2c114610741578063ad3cb1cc1461076b578063c021329e1461079557610219565b80637702dcff146105eb5780637a297f4b1461062757806385362ee7146106515780638b49ceb41461068d57610219565b806348eef47e116101a55780635a53accb116101745780635a53accb146104bf57806363a2db29146104fb5780636754b3601461053757806372107681146105735780637513a404146105af57610219565b806348eef47e146104015780634f1ef2861461043d57806352d1902d1461045957806357f0a5681461048357610219565b80631391547f116101ec5780631391547f146102fb578063182b6d98146103375780631c89ee441461037357806336318d64146103af57806339f73810146103eb57610219565b806304559f711461021d57806308bf832a146102595780630d8e6e2c14610295578063117b2f38146102bf575b5f80fd5b348015610228575f80fd5b50610243600480360381019061023e9190615f2c565b610a05565b6040516102509190615f8b565b60405180910390f35b348015610264575f80fd5b5061027f600480360381019061027a919061615d565b610bb4565b60405161028c9190615f8b565b60405180910390f35b3480156102a0575f80fd5b506102a9610dd1565b6040516102b69190616257565b60405180910390f35b3480156102ca575f80fd5b506102e560048036038101906102e09190615f2c565b610e4c565b6040516102f29190615f8b565b60405180910390f35b348015610306575f80fd5b50610321600480360381019061031c9190615f2c565b610ffa565b60405161032e9190615f8b565b60405180910390f35b348015610342575f80fd5b5061035d60048036038101906103589190615f2c565b6111a9565b60405161036a9190615f8b565b60405180910390f35b34801561037e575f80fd5b5061039960048036038101906103949190616277565b611358565b6040516103a69190615f8b565b60405180910390f35b3480156103ba575f80fd5b506103d560048036038101906103d09190615f2c565b611869565b6040516103e29190615f8b565b60405180910390f35b3480156103f6575f80fd5b506103ff611a18565b005b34801561040c575f80fd5b50610427600480360381019061042291906162e8565b611b88565b6040516104349190615f8b565b60405180910390f35b61045760048036038101906104529190616326565b611bfc565b005b348015610464575f80fd5b5061046d611c1b565b60405161047a9190615f8b565b60405180910390f35b34801561048e575f80fd5b506104a960048036038101906104a49190615f2c565b611c4c565b6040516104b69190615f8b565b60405180910390f35b3480156104ca575f80fd5b506104e560048036038101906104e09190615f2c565b611dfb565b6040516104f29190615f8b565b60405180910390f35b348015610506575f80fd5b50610521600480360381019061051c9190615f2c565b612044565b60405161052e9190615f8b565b60405180910390f35b348015610542575f80fd5b5061055d60048036038101906105589190615f2c565b61223c565b60405161056a9190615f8b565b60405180910390f35b34801561057e575f80fd5b5061059960048036038101906105949190615f2c565b612410565b6040516105a69190615f8b565b60405180910390f35b3480156105ba575f80fd5b506105d560048036038101906105d09190615f2c565b6125bf565b6040516105e29190615f8b565b60405180910390f35b3480156105f6575f80fd5b50610611600480360381019061060c9190616380565b61276e565b60405161061e9190615f8b565b60405180910390f35b348015610632575f80fd5b5061063b61298a565b60405161064891906163eb565b60405180910390f35b34801561065c575f80fd5b5061067760048036038101906106729190615f2c565b61298e565b6040516106849190615f8b565b60405180910390f35b348015610698575f80fd5b506106b360048036038101906106ae9190615f2c565b612b3d565b6040516106c09190615f8b565b60405180910390f35b3480156106d4575f80fd5b506106ef60048036038101906106ea9190615f2c565b612d35565b6040516106fc9190615f8b565b60405180910390f35b348015610710575f80fd5b5061072b600480360381019061072691906162e8565b612f09565b6040516107389190615f8b565b60405180910390f35b34801561074c575f80fd5b50610755613229565b6040516107629190616413565b60405180910390f35b348015610776575f80fd5b5061077f613244565b60405161078c9190616257565b60405180910390f35b3480156107a0575f80fd5b506107bb60048036038101906107b69190615f2c565b61327d565b6040516107c89190615f8b565b60405180910390f35b3480156107dc575f80fd5b506107f760048036038101906107f29190615f2c565b613451565b6040516108049190615f8b565b60405180910390f35b348015610818575f80fd5b50610833600480360381019061082e9190615f2c565b613625565b6040516108409190615f8b565b60405180910390f35b348015610854575f80fd5b5061086f600480360381019061086a919061642c565b61386e565b60405161087c9190615f8b565b60405180910390f35b348015610890575f80fd5b506108ab60048036038101906108a69190616457565b613a35565b6040516108b89190615f8b565b60405180910390f35b3480156108cc575f80fd5b506108e760048036038101906108e29190615f2c565b613aa5565b6040516108f49190615f8b565b60405180910390f35b348015610908575f80fd5b50610923600480360381019061091e9190615f2c565b613cc2565b6040516109309190615f8b565b60405180910390f35b348015610944575f80fd5b5061094d613eba565b60405161095a9190616413565b60405180910390f35b34801561096e575f80fd5b506109896004803603810190610984919061642c565b613ed5565b6040516109969190615f8b565b60405180910390f35b3480156109aa575f80fd5b506109b36140c0565b6040516109c09190616413565b60405180910390f35b3480156109d4575f80fd5b506109ef60048036038101906109ea9190615f2c565b6140db565b6040516109fc9190615f8b565b60405180910390f35b5f8060066053811115610a1b57610a1a616482565b5b60ff166001901b60056053811115610a3657610a35616482565b5b60ff166001901b60046053811115610a5157610a50616482565b5b60ff166001901b60036053811115610a6c57610a6b616482565b5b60ff166001901b60026053811115610a8757610a86616482565b5b60ff166001901b610a9891906164dc565b610aa291906164dc565b610aac91906164dc565b610ab691906164dc565b90505f610ac386836142f8565b9050610ad360128787878561435e565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff1663642b149082868989886040518663ffffffff1660e01b8152600401610b2a959493929190616564565b5f604051808303815f87803b158015610b41575f80fd5b505af1158015610b53573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167fc11d62b13c360a83082487064be1ec0878b2f0be4f012bf59f89e128063d47ff87878787604051610ba394939291906165b5565b60405180910390a250509392505050565b5f8060405180604001604052808673ffffffffffffffffffffffffffffffffffffffff1681526020013373ffffffffffffffffffffffffffffffffffffffff1681525090505f610c038761468e565b9050806053811115610c1857610c17616482565b5b846053811115610c2b57610c2a616482565b5b14610c62576040517fb968846100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b7336772142b74871f255cbd7a3e89b401d3e45825f73ffffffffffffffffffffffffffffffffffffffff1663e6317df58389886040518463ffffffff1660e01b8152600401610cb393929190616686565b6020604051808303815f875af1158015610ccf573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610cf391906166d6565b92507350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff16633e395cec84336040518363ffffffff1660e01b8152600401610d44929190616701565b5f604051808303815f87803b158015610d5b575f80fd5b505af1158015610d6d573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167fdc370db33589e73371dc3ee42c789c003d336eefcb7c3f56fe0f51ae5b1d97028888888888604051610dbf959493929190616728565b60405180910390a25050949350505050565b60606040518060400160405280600d81526020017f464845564d4578656375746f7200000000000000000000000000000000000000815250610e125f6146c6565b610e1c60016146c6565b610e255f6146c6565b604051602001610e38949392919061684e565b604051602081830303815290604052905090565b5f8060066053811115610e6257610e61616482565b5b60ff166001901b60056053811115610e7d57610e7c616482565b5b60ff166001901b60046053811115610e9857610e97616482565b5b60ff166001901b60036053811115610eb357610eb2616482565b5b60ff166001901b60026053811115610ece57610ecd616482565b5b60ff166001901b610edf91906164dc565b610ee991906164dc565b610ef391906164dc565b610efd91906164dc565b90505f610f0a86836142f8565b9050610f195f8787878561435e565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff1663fdad4c9682868989886040518663ffffffff1660e01b8152600401610f70959493929190616564565b5f604051808303815f87803b158015610f87575f80fd5b505af1158015610f99573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167fdb9050d65240431621d61d6f94b970e63f53a67a5766614ee6e5c5bbd41c8e2e87878787604051610fe994939291906165b5565b60405180910390a250509392505050565b5f80600660538111156110105761100f616482565b5b60ff166001901b6005605381111561102b5761102a616482565b5b60ff166001901b6004605381111561104657611045616482565b5b60ff166001901b6003605381111561106157611060616482565b5b60ff166001901b6002605381111561107c5761107b616482565b5b60ff166001901b61108d91906164dc565b61109791906164dc565b6110a191906164dc565b6110ab91906164dc565b90505f6110b886836142f8565b90506110c8600e8787875f61435e565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff16636bb3c61182868989886040518663ffffffff1660e01b815260040161111f959493929190616564565b5f604051808303815f87803b158015611136575f80fd5b505af1158015611148573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167f38c3a63c4230de5b741f494ffb54e3087104030279bc7bccee8ad9ad31712b218787878760405161119894939291906165b5565b60405180910390a250509392505050565b5f80600660538111156111bf576111be616482565b5b60ff166001901b600560538111156111da576111d9616482565b5b60ff166001901b600460538111156111f5576111f4616482565b5b60ff166001901b600360538111156112105761120f616482565b5b60ff166001901b6002605381111561122b5761122a616482565b5b60ff166001901b61123c91906164dc565b61124691906164dc565b61125091906164dc565b61125a91906164dc565b90505f61126786836142f8565b905061127760018787878561435e565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff16639075310882868989886040518663ffffffff1660e01b81526004016112ce959493929190616564565b5f604051808303815f87803b1580156112e5575f80fd5b505af11580156112f7573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167feb6d37bd271abe1395b21d6d78f3487d6584862872c29ffd3f90736ee99b73938787878760405161134794939291906165b5565b60405180910390a250509392505050565b5f7350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff166382027b6d84336040518363ffffffff1660e01b81526004016113a8929190616701565b602060405180830381865afa1580156113c3573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906113e791906168e1565b61142a5782336040517f9de3392c000000000000000000000000000000000000000000000000000000008152600401611421929190616701565b60405180910390fd5b5f6008605381111561143f5761143e616482565b5b60ff166001901b6006605381111561145a57611459616482565b5b60ff166001901b6005605381111561147557611474616482565b5b60ff166001901b600460538111156114905761148f616482565b5b60ff166001901b600360538111156114ab576114aa616482565b5b60ff166001901b600260538111156114c6576114c5616482565b5b60ff166001901b5f60538111156114e0576114df616482565b5b60ff166001901b6114f191906164dc565b6114fb91906164dc565b61150591906164dc565b61150f91906164dc565b61151991906164dc565b61152391906164dc565b90505f61153085836142f8565b90505f6008605381111561154757611546616482565b5b60ff166001901b6006605381111561156257611561616482565b5b60ff166001901b6005605381111561157d5761157c616482565b5b60ff166001901b6004605381111561159857611597616482565b5b60ff166001901b600360538111156115b3576115b2616482565b5b60ff166001901b600260538111156115ce576115cd616482565b5b60ff166001901b6115df91906164dc565b6115e991906164dc565b6115f391906164dc565b6115fd91906164dc565b61160791906164dc565b90505f8186605381111561161e5761161d616482565b5b60ff166001901b160361165d576040517fc6de466a00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b8460538111156116705761166f616482565b5b82605381111561168357611682616482565b5b036116ba576040517fb968846100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b601786867350157cffd6bbfa2dece204a89ec419c23ef5755d466040516020016116e8959493929190616a5f565b60405160208183030381529060405280519060200120935061170a8486614790565b9350611714614809565b73233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff166302dd62768688876040518463ffffffff1660e01b815260040161176593929190616abd565b5f604051808303815f87803b15801561177c575f80fd5b505af115801561178e573d5f803e3d5ffd5b505050507350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff16633e395cec85336040518363ffffffff1660e01b81526004016117e1929190616701565b5f604051808303815f87803b1580156117f8575f80fd5b505af115801561180a573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167f31ccae6a2f8e3ced1692f77c8f668133e4afdaaa35afe844ff4659a6c27e627f87878760405161185893929190616af2565b60405180910390a250505092915050565b5f806006605381111561187f5761187e616482565b5b60ff166001901b6005605381111561189a57611899616482565b5b60ff166001901b600460538111156118b5576118b4616482565b5b60ff166001901b600360538111156118d0576118cf616482565b5b60ff166001901b600260538111156118eb576118ea616482565b5b60ff166001901b6118fc91906164dc565b61190691906164dc565b61191091906164dc565b61191a91906164dc565b90505f61192786836142f8565b905061193760138787878561435e565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff1663acb5f38882868989886040518663ffffffff1660e01b815260040161198e959493929190616564565b5f604051808303815f87803b1580156119a5575f80fd5b505af11580156119b7573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167ffd7c9208f956bf0c6ab76a667f04361245ad3e0a2d0eff92eb827acfcca68ea987878787604051611a0794939291906165b5565b60405180910390a250509392505050565b6001611a22614885565b67ffffffffffffffff1614611a63576040517f6f4f731f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60025f611a6e6148a9565b9050805f0160089054906101000a900460ff1680611ab657508167ffffffffffffffff16815f015f9054906101000a900467ffffffffffffffff1667ffffffffffffffff1610155b15611aed576040517ff92ee8a900000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b81815f015f6101000a81548167ffffffffffffffff021916908367ffffffffffffffff1602179055506001815f0160086101000a81548160ff0219169083151502179055505f815f0160086101000a81548160ff0219169083151502179055507fc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d282604051611b7c9190616b49565b60405180910390a15050565b5f80611b926148d0565b9050611b9f84848361494d565b91503373ffffffffffffffffffffffffffffffffffffffff167f5222d96b836727a1d6fe1ee9aef27f9bb507bd41794defa376ff6c648aaf8ff185858486604051611bed9493929190616bab565b60405180910390a25092915050565b611c04614c06565b611c0d82614cec565b611c178282614ddf565b5050565b5f611c24614efd565b7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5f1b905090565b5f8060066053811115611c6257611c61616482565b5b60ff166001901b60056053811115611c7d57611c7c616482565b5b60ff166001901b60046053811115611c9857611c97616482565b5b60ff166001901b60036053811115611cb357611cb2616482565b5b60ff166001901b60026053811115611cce57611ccd616482565b5b60ff166001901b611cdf91906164dc565b611ce991906164dc565b611cf391906164dc565b611cfd91906164dc565b90505f611d0a86836142f8565b9050611d1a60028787878561435e565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff16633c16ff0d82868989886040518663ffffffff1660e01b8152600401611d71959493929190616564565b5f604051808303815f87803b158015611d88575f80fd5b505af1158015611d9a573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167f215346a4f9f975e6d5484e290bd4e53ca14453a9d282ebd3ccedb2a0f171753d87878787604051611dea94939291906165b5565b60405180910390a250509392505050565b5f600160f81b827effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191614611e5b576040517f4f224e5300000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f801b8303611e96576040517f23d359a300000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f60066053811115611eab57611eaa616482565b5b60ff166001901b60056053811115611ec657611ec5616482565b5b60ff166001901b60046053811115611ee157611ee0616482565b5b60ff166001901b60036053811115611efc57611efb616482565b5b60ff166001901b60026053811115611f1757611f16616482565b5b60ff166001901b611f2891906164dc565b611f3291906164dc565b611f3c91906164dc565b611f4691906164dc565b90505f611f5386836142f8565b9050611f6360038787878561435e565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff1663406b451382868989886040518663ffffffff1660e01b8152600401611fba959493929190616564565b5f604051808303815f87803b158015611fd1575f80fd5b505af1158015611fe3573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167f3bab2ee0e2f90f4690c6a87bf63cf1a6b626086e95f231860b152966e8dabbf78787878760405161203394939291906165b5565b60405180910390a250509392505050565b5f806008605381111561205a57612059616482565b5b60ff166001901b6006605381111561207557612074616482565b5b60ff166001901b600560538111156120905761208f616482565b5b60ff166001901b600460538111156120ab576120aa616482565b5b60ff166001901b600360538111156120c6576120c5616482565b5b60ff166001901b600260538111156120e1576120e0616482565b5b60ff166001901b5f60538111156120fb576120fa616482565b5b60ff166001901b61210c91906164dc565b61211691906164dc565b61212091906164dc565b61212a91906164dc565b61213491906164dc565b61213e91906164dc565b90505f61214b86836142f8565b905061215b60068787878561435e565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff1663e8e399ad82868989886040518663ffffffff1660e01b81526004016121b2959493929190616564565b5f604051808303815f87803b1580156121c9575f80fd5b505af11580156121db573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167f56df279bbfb03d9ed097bbe2f28d520ca0c1161206327926e98664d70d2c24c48787878760405161222b94939291906165b5565b60405180910390a250509392505050565b5f806008605381111561225257612251616482565b5b60ff166001901b6006605381111561226d5761226c616482565b5b60ff166001901b6005605381111561228857612287616482565b5b60ff166001901b600460538111156122a3576122a2616482565b5b60ff166001901b600360538111156122be576122bd616482565b5b60ff166001901b600260538111156122d9576122d8616482565b5b60ff166001901b6122ea91906164dc565b6122f491906164dc565b6122fe91906164dc565b61230891906164dc565b61231291906164dc565b90505f61231f86836142f8565b905061232f600a8787878561435e565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff166314526e8782868989886040518663ffffffff1660e01b8152600401612386959493929190616564565b5f604051808303815f87803b15801561239d575f80fd5b505af11580156123af573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167feb0e4f8dc74058194d0602425fe602f955c222200f7f10c6fe67992f7b24c7e9878787876040516123ff94939291906165b5565b60405180910390a250509392505050565b5f806006605381111561242657612425616482565b5b60ff166001901b6005605381111561244157612440616482565b5b60ff166001901b6004605381111561245c5761245b616482565b5b60ff166001901b6003605381111561247757612476616482565b5b60ff166001901b6002605381111561249257612491616482565b5b60ff166001901b6124a391906164dc565b6124ad91906164dc565b6124b791906164dc565b6124c191906164dc565b90505f6124ce86836142f8565b90506124de60118787875f61435e565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff16631339c5ee82868989886040518663ffffffff1660e01b8152600401612535959493929190616564565b5f604051808303815f87803b15801561254c575f80fd5b505af115801561255e573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167f0d483b100d8c73b208984ec697caa3091521ee5525ce69edcf97d7e395d3d059878787876040516125ae94939291906165b5565b60405180910390a250509392505050565b5f80600660538111156125d5576125d4616482565b5b60ff166001901b600560538111156125f0576125ef616482565b5b60ff166001901b6004605381111561260b5761260a616482565b5b60ff166001901b6003605381111561262657612625616482565b5b60ff166001901b6002605381111561264157612640616482565b5b60ff166001901b61265291906164dc565b61265c91906164dc565b61266691906164dc565b61267091906164dc565b90505f61267d86836142f8565b905061268d60108787875f61435e565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff1663d47f3d5982868989886040518663ffffffff1660e01b81526004016126e4959493929190616564565b5f604051808303815f87803b1580156126fb575f80fd5b505af115801561270d573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167fdef2e704a077284a07f3d0b436db88f5d981b69f58ab7c1ae623252718a6de018787878760405161275d94939291906165b5565b60405180910390a250509392505050565b5f806008605381111561278457612783616482565b5b60ff166001901b6007605381111561279f5761279e616482565b5b60ff166001901b600660538111156127ba576127b9616482565b5b60ff166001901b600560538111156127d5576127d4616482565b5b60ff166001901b600460538111156127f0576127ef616482565b5b60ff166001901b6003605381111561280b5761280a616482565b5b60ff166001901b6002605381111561282657612825616482565b5b60ff166001901b5f60538111156128405761283f616482565b5b60ff166001901b61285191906164dc565b61285b91906164dc565b61286591906164dc565b61286f91906164dc565b61287991906164dc565b61288391906164dc565b61288d91906164dc565b90505f61289a85836142f8565b90506128a96019878787614f84565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff16634e72676982888888886040518663ffffffff1660e01b8152600401612900959493929190616bee565b5f604051808303815f87803b158015612917575f80fd5b505af1158015612929573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167f60be9d61aad849facc28c38b048cb5c4be3420b8fa2233e08cfa06be1b6d1c3e878787876040516129799493929190616c3f565b60405180910390a250509392505050565b5f90565b5f80600660538111156129a4576129a3616482565b5b60ff166001901b600560538111156129bf576129be616482565b5b60ff166001901b600460538111156129da576129d9616482565b5b60ff166001901b600360538111156129f5576129f4616482565b5b60ff166001901b60026053811115612a1057612a0f616482565b5b60ff166001901b612a2191906164dc565b612a2b91906164dc565b612a3591906164dc565b612a3f91906164dc565b90505f612a4c86836142f8565b9050612a5c600f8787875f61435e565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff1663859a1b7082868989886040518663ffffffff1660e01b8152600401612ab3959493929190616564565b5f604051808303815f87803b158015612aca575f80fd5b505af1158015612adc573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167fc9ff8f0d18a3f766ce5de3de216076050140e4fc2652f5e0e745f6fc836cda8b87878787604051612b2c94939291906165b5565b60405180910390a250509392505050565b5f8060086053811115612b5357612b52616482565b5b60ff166001901b60066053811115612b6e57612b6d616482565b5b60ff166001901b60056053811115612b8957612b88616482565b5b60ff166001901b60046053811115612ba457612ba3616482565b5b60ff166001901b60036053811115612bbf57612bbe616482565b5b60ff166001901b60026053811115612bda57612bd9616482565b5b60ff166001901b5f6053811115612bf457612bf3616482565b5b60ff166001901b612c0591906164dc565b612c0f91906164dc565b612c1991906164dc565b612c2391906164dc565b612c2d91906164dc565b612c3791906164dc565b90505f612c4486836142f8565b9050612c5460078787878561435e565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff16631434ba4d82868989886040518663ffffffff1660e01b8152600401612cab959493929190616564565b5f604051808303815f87803b158015612cc2575f80fd5b505af1158015612cd4573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167f4d32284bd3193ecaa44e1ceca32f41c5d6c32803a92e07967dd3ee422972158287878787604051612d2494939291906165b5565b60405180910390a250509392505050565b5f8060086053811115612d4b57612d4a616482565b5b60ff166001901b60066053811115612d6657612d65616482565b5b60ff166001901b60056053811115612d8157612d80616482565b5b60ff166001901b60046053811115612d9c57612d9b616482565b5b60ff166001901b60036053811115612db757612db6616482565b5b60ff166001901b60026053811115612dd257612dd1616482565b5b60ff166001901b612de391906164dc565b612ded91906164dc565b612df791906164dc565b612e0191906164dc565b612e0b91906164dc565b90505f612e1886836142f8565b9050612e2860098787878561435e565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff16631ed91ff682868989886040518663ffffffff1660e01b8152600401612e7f959493929190616564565b5f604051808303815f87803b158015612e96575f80fd5b505af1158015612ea8573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167f324220bfc9cb158b492991c03c309cd86e5345cac45aacae2092ddabe31fa3d887878787604051612ef894939291906165b5565b60405180910390a250509392505050565b5f8060086053811115612f1f57612f1e616482565b5b60ff166001901b60076053811115612f3a57612f39616482565b5b60ff166001901b60066053811115612f5557612f54616482565b5b60ff166001901b60056053811115612f7057612f6f616482565b5b60ff166001901b60046053811115612f8b57612f8a616482565b5b60ff166001901b60036053811115612fa657612fa5616482565b5b60ff166001901b60026053811115612fc157612fc0616482565b5b60ff166001901b5f6053811115612fdb57612fda616482565b5b60ff166001901b612fec91906164dc565b612ff691906164dc565b61300091906164dc565b61300a91906164dc565b61301491906164dc565b61301e91906164dc565b61302891906164dc565b90505f8184605381111561303f5761303e616482565b5b60ff166001901b160361307e576040517fc6de466a00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b601884847350157cffd6bbfa2dece204a89ec419c23ef5755d466040516020016130ac959493929190616c82565b6040516020818303038152906040528051906020012091506130ce8284614790565b91506130d8614809565b73233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff1663348c318584846040518363ffffffff1660e01b8152600401613127929190616ce0565b5f604051808303815f87803b15801561313e575f80fd5b505af1158015613150573d5f803e3d5ffd5b505050507350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff16633e395cec83336040518363ffffffff1660e01b81526004016131a3929190616701565b5f604051808303815f87803b1580156131ba575f80fd5b505af11580156131cc573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167f063ccd1bba45151d91f6a418065047a3d048d058a922535747bb2b575a01d23685858560405161321a93929190616d07565b60405180910390a25092915050565b5f7336772142b74871f255cbd7a3e89b401d3e45825f905090565b6040518060400160405280600581526020017f352e302e3000000000000000000000000000000000000000000000000000000081525081565b5f806008605381111561329357613292616482565b5b60ff166001901b600660538111156132ae576132ad616482565b5b60ff166001901b600560538111156132c9576132c8616482565b5b60ff166001901b600460538111156132e4576132e3616482565b5b60ff166001901b600360538111156132ff576132fe616482565b5b60ff166001901b6002605381111561331a57613319616482565b5b60ff166001901b61332b91906164dc565b61333591906164dc565b61333f91906164dc565b61334991906164dc565b61335391906164dc565b90505f61336086836142f8565b9050613370600b8787878561435e565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff1663669181c082868989886040518663ffffffff1660e01b81526004016133c7959493929190616564565b5f604051808303815f87803b1580156133de575f80fd5b505af11580156133f0573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167fc148675905d07ad5496f8ef4d8195c907503f3ec12fd10ed5f21240abc6936348787878760405161344094939291906165b5565b60405180910390a250509392505050565b5f806008605381111561346757613466616482565b5b60ff166001901b6006605381111561348257613481616482565b5b60ff166001901b6005605381111561349d5761349c616482565b5b60ff166001901b600460538111156134b8576134b7616482565b5b60ff166001901b600360538111156134d3576134d2616482565b5b60ff166001901b600260538111156134ee576134ed616482565b5b60ff166001901b6134ff91906164dc565b61350991906164dc565b61351391906164dc565b61351d91906164dc565b61352791906164dc565b90505f61353486836142f8565b905061354460088787878561435e565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff166383e6a72082868989886040518663ffffffff1660e01b815260040161359b959493929190616564565b5f604051808303815f87803b1580156135b2575f80fd5b505af11580156135c4573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167fe84282aaebcca698443e39a2a948a345d0d2ebc654af5cb657a2d7e8053bf6cb8787878760405161361494939291906165b5565b60405180910390a250509392505050565b5f600160f81b827effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191614613685576040517f4f224e5300000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f801b83036136c0576040517f23d359a300000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f600660538111156136d5576136d4616482565b5b60ff166001901b600560538111156136f0576136ef616482565b5b60ff166001901b6004605381111561370b5761370a616482565b5b60ff166001901b6003605381111561372657613725616482565b5b60ff166001901b6002605381111561374157613740616482565b5b60ff166001901b61375291906164dc565b61375c91906164dc565b61376691906164dc565b61377091906164dc565b90505f61377d86836142f8565b905061378d60048787878561435e565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff1663fa08e38d82868989886040518663ffffffff1660e01b81526004016137e4959493929190616564565b5f604051808303815f87803b1580156137fb575f80fd5b505af115801561380d573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167f0e691cd0bf8c4e9308e4ced1bb9c964117dc5c5bb9b9ab5bdfebf2c9b13a897c8787878760405161385d94939291906165b5565b60405180910390a250509392505050565b5f806008605381111561388457613883616482565b5b60ff166001901b6006605381111561389f5761389e616482565b5b60ff166001901b600560538111156138ba576138b9616482565b5b60ff166001901b600460538111156138d5576138d4616482565b5b60ff166001901b600360538111156138f0576138ef616482565b5b60ff166001901b6002605381111561390b5761390a616482565b5b60ff166001901b61391c91906164dc565b61392691906164dc565b61393091906164dc565b61393a91906164dc565b61394491906164dc565b90505f61395184836142f8565b905061395e6014856153b8565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff1663a4c98f3e8286866040518463ffffffff1660e01b81526004016139b193929190616abd565b5f604051808303815f87803b1580156139c8575f80fd5b505af11580156139da573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167f8c664d3c3ca583fc5803b8a91c49644bbd9550bfa87967c73ad1de83027768c08585604051613a26929190616d3c565b60405180910390a25050919050565b5f80613a3f6148d0565b9050613a4b8382615570565b91503373ffffffffffffffffffffffffffffffffffffffff167f0c8aca6017003326051e19913ef02631f24b801125e1fa8a1d812e868319fda6848385604051613a9793929190616d63565b60405180910390a250919050565b5f8060086053811115613abb57613aba616482565b5b60ff166001901b60076053811115613ad657613ad5616482565b5b60ff166001901b60066053811115613af157613af0616482565b5b60ff166001901b60056053811115613b0c57613b0b616482565b5b60ff166001901b60046053811115613b2757613b26616482565b5b60ff166001901b60036053811115613b4257613b41616482565b5b60ff166001901b60026053811115613b5d57613b5c616482565b5b60ff166001901b5f6053811115613b7757613b76616482565b5b60ff166001901b613b8891906164dc565b613b9291906164dc565b613b9c91906164dc565b613ba691906164dc565b613bb091906164dc565b613bba91906164dc565b613bc491906164dc565b90505f613bd186836142f8565b9050613be1600d8787875f61435e565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff1663fa5defdb82868989886040518663ffffffff1660e01b8152600401613c38959493929190616564565b5f604051808303815f87803b158015613c4f575f80fd5b505af1158015613c61573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167f6960c1e88f61c352dba34d1bbf6753e302795264d5d8ae82f7983c7004651e5d87878787604051613cb194939291906165b5565b60405180910390a250509392505050565b5f8060086053811115613cd857613cd7616482565b5b60ff166001901b60066053811115613cf357613cf2616482565b5b60ff166001901b60056053811115613d0e57613d0d616482565b5b60ff166001901b60046053811115613d2957613d28616482565b5b60ff166001901b60036053811115613d4457613d43616482565b5b60ff166001901b60026053811115613d5f57613d5e616482565b5b60ff166001901b5f6053811115613d7957613d78616482565b5b60ff166001901b613d8a91906164dc565b613d9491906164dc565b613d9e91906164dc565b613da891906164dc565b613db291906164dc565b613dbc91906164dc565b90505f613dc986836142f8565b9050613dd960058787878561435e565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff16631856d91d82868989886040518663ffffffff1660e01b8152600401613e30959493929190616564565b5f604051808303815f87803b158015613e47575f80fd5b505af1158015613e59573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167fe42486b0ccdbef81a2075c48c8e515c079aea73c8b82429997c72a2fe1bf4fef87878787604051613ea994939291906165b5565b60405180910390a250509392505050565b5f73233ff88a48c172d29f675403e6a8e302b0f032d9905090565b5f8060086053811115613eeb57613eea616482565b5b60ff166001901b60066053811115613f0657613f05616482565b5b60ff166001901b60056053811115613f2157613f20616482565b5b60ff166001901b60046053811115613f3c57613f3b616482565b5b60ff166001901b60036053811115613f5757613f56616482565b5b60ff166001901b60026053811115613f7257613f71616482565b5b60ff166001901b5f6053811115613f8c57613f8b616482565b5b60ff166001901b613f9d91906164dc565b613fa791906164dc565b613fb191906164dc565b613fbb91906164dc565b613fc591906164dc565b613fcf91906164dc565b90505f613fdc84836142f8565b9050613fe96015856153b8565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff1663fc063c628286866040518463ffffffff1660e01b815260040161403c93929190616abd565b5f604051808303815f87803b158015614053575f80fd5b505af1158015614065573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167f55aff4cc7a3d160c83f1f15b818011ede841a0b4597fb14dcd3603df3a11e5e085856040516140b1929190616d3c565b60405180910390a25050919050565b5f7350157cffd6bbfa2dece204a89ec419c23ef5755d905090565b5f80600860538111156140f1576140f0616482565b5b60ff166001901b6007605381111561410c5761410b616482565b5b60ff166001901b6006605381111561412757614126616482565b5b60ff166001901b6005605381111561414257614141616482565b5b60ff166001901b6004605381111561415d5761415c616482565b5b60ff166001901b6003605381111561417857614177616482565b5b60ff166001901b6002605381111561419357614192616482565b5b60ff166001901b5f60538111156141ad576141ac616482565b5b60ff166001901b6141be91906164dc565b6141c891906164dc565b6141d291906164dc565b6141dc91906164dc565b6141e691906164dc565b6141f091906164dc565b6141fa91906164dc565b90505f61420786836142f8565b9050614217600c8787875f61435e565b925073233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff166394e70e4f82868989886040518663ffffffff1660e01b815260040161426e959493929190616564565b5f604051808303815f87803b158015614285575f80fd5b505af1158015614297573d5f803e3d5ffd5b505050503373ffffffffffffffffffffffffffffffffffffffff167fb3d5c664ec86575818e8d75ff25c5f867250df8954088549c41c848cd10e76cb878787876040516142e794939291906165b5565b60405180910390a250509392505050565b5f6143028361468e565b90505f8282605381111561431957614318616482565b5b60ff166001901b1603614358576040517fc6de466a00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b92915050565b5f614367614809565b61437083615801565b7350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff166382027b6d86336040518363ffffffff1660e01b81526004016143bf929190616701565b602060405180830381865afa1580156143da573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906143fe91906168e1565b6144415784336040517f9de3392c000000000000000000000000000000000000000000000000000000008152600401614438929190616701565b60405180910390fd5b5f60f81b837effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916036145b6577350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff166382027b6d85336040518363ffffffff1660e01b81526004016144bc929190616701565b602060405180830381865afa1580156144d7573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906144fb91906168e1565b61453e5783336040517f9de3392c000000000000000000000000000000000000000000000000000000008152600401614535929190616701565b60405180910390fd5b5f6145488561468e565b90505f6145548761468e565b905081605381111561456957614568616482565b5b81605381111561457c5761457b616482565b5b146145b3576040517f1f3158c700000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b50505b858585857350157cffd6bbfa2dece204a89ec419c23ef5755d466040516020016145e596959493929190616db8565b6040516020818303038152906040528051906020012090506146078183614790565b90507350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff16633e395cec82336040518363ffffffff1660e01b8152600401614658929190616701565b5f604051808303815f87803b15801561466f575f80fd5b505af1158015614681573d5f803e3d5ffd5b5050505095945050505050565b5f81601e602081106146a3576146a2616e27565b5b1a60f81b60f81c60ff1660538111156146bf576146be616482565b5b9050919050565b60605f60016146d484615845565b0190505f8167ffffffffffffffff8111156146f2576146f1616016565b5b6040519080825280601f01601f1916602001820160405280156147245781602001600182028036833780820191505090505b5090505f82602001820190505b600115614785578080600190039150507f3031323334353637383961626364656600000000000000000000000000000000600a86061a8153600a858161477a57614779616e54565b5b0494505f8503614731575b819350505050919050565b5f7fffffffffffffffffffffffffffffffffffffffffff00000000000000000000005f1b83169050605060ff5f1b901b8117905060104667ffffffffffffffff165f1b901b8117905060088260538111156147ee576147ed616482565b5b60ff165f1b901b811790505f60ff165f1b8117905092915050565b73233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff166367a7457b336040518263ffffffff1660e01b81526004016148569190616413565b5f604051808303815f87803b15801561486d575f80fd5b505af115801561487f573d5f803e3d5ffd5b50505050565b5f61488e6148a9565b5f015f9054906101000a900467ffffffffffffffff16905090565b5f7ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00905090565b5f806148da615996565b9050805f01547350157cffd6bbfa2dece204a89ec419c23ef5755d466001436149039190616e81565b4042604051602001614919959493929190616eb4565b604051602081830303815290604052805190602001209150805f015f81548092919061494490616f12565b91905055505090565b5f806008605381111561496357614962616482565b5b60ff166001901b6006605381111561497e5761497d616482565b5b60ff166001901b6005605381111561499957614998616482565b5b60ff166001901b600460538111156149b4576149b3616482565b5b60ff166001901b600360538111156149cf576149ce616482565b5b60ff166001901b600260538111156149ea576149e9616482565b5b60ff166001901b6149fb91906164dc565b614a0591906164dc565b614a0f91906164dc565b614a1991906164dc565b614a2391906164dc565b90505f81856053811115614a3a57614a39616482565b5b60ff166001901b1603614a79576040517fc6de466a00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b614a82856159bd565b614ab8576040517f24e8e74200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b614ac285856159e1565b601b858585604051602001614ada9493929190616f79565b604051602081830303815290604052805190602001209150614afc8285614790565b9150614b06614809565b73233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff1663cc86678285846040518363ffffffff1660e01b8152600401614b55929190616ce0565b5f604051808303815f87803b158015614b6c575f80fd5b505af1158015614b7e573d5f803e3d5ffd5b505050507350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff16633e395cec83336040518363ffffffff1660e01b8152600401614bd1929190616701565b5f604051808303815f87803b158015614be8575f80fd5b505af1158015614bfa573d5f803e3d5ffd5b50505050509392505050565b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff163073ffffffffffffffffffffffffffffffffffffffff161480614cb357507f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16614c9a615b31565b73ffffffffffffffffffffffffffffffffffffffff1614155b15614cea576040517fe07c8dba00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b565b7350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff16638da5cb5b6040518163ffffffff1660e01b8152600401602060405180830381865afa158015614d49573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190614d6d9190616fda565b73ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614614ddc57336040517f21bfda10000000000000000000000000000000000000000000000000000000008152600401614dd39190616413565b60405180910390fd5b50565b8173ffffffffffffffffffffffffffffffffffffffff166352d1902d6040518163ffffffff1660e01b8152600401602060405180830381865afa925050508015614e4757506040513d601f19601f82011682018060405250810190614e4491906166d6565b60015b614e8857816040517f4c9c8ce3000000000000000000000000000000000000000000000000000000008152600401614e7f9190616413565b60405180910390fd5b7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5f1b8114614eee57806040517faa1d49a4000000000000000000000000000000000000000000000000000000008152600401614ee59190615f8b565b60405180910390fd5b614ef88383615b84565b505050565b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff163073ffffffffffffffffffffffffffffffffffffffff1614614f82576040517fe07c8dba00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b565b5f614f8d614809565b7350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff166382027b6d85336040518363ffffffff1660e01b8152600401614fdc929190616701565b602060405180830381865afa158015614ff7573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061501b91906168e1565b61505e5783336040517f9de3392c000000000000000000000000000000000000000000000000000000008152600401615055929190616701565b60405180910390fd5b7350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff166382027b6d84336040518363ffffffff1660e01b81526004016150ad929190616701565b602060405180830381865afa1580156150c8573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906150ec91906168e1565b61512f5782336040517f9de3392c000000000000000000000000000000000000000000000000000000008152600401615126929190616701565b60405180910390fd5b7350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff166382027b6d83336040518363ffffffff1660e01b815260040161517e929190616701565b602060405180830381865afa158015615199573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906151bd91906168e1565b6152005781336040517f9de3392c0000000000000000000000000000000000000000000000000000000081526004016151f7929190616701565b60405180910390fd5b5f61520a8561468e565b90505f6152168561468e565b90505f6152228561468e565b90505f605381111561523757615236616482565b5b83605381111561524a57615249616482565b5b14615281576040517fc6de466a00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b80605381111561529457615293616482565b5b8260538111156152a7576152a6616482565b5b146152de576040517f1f3158c700000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b878787877350157cffd6bbfa2dece204a89ec419c23ef5755d4660405160200161530d96959493929190617005565b60405160208183030381529060405280519060200120935061532f8483614790565b93507350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff16633e395cec85336040518363ffffffff1660e01b8152600401615380929190616701565b5f604051808303815f87803b158015615397575f80fd5b505af11580156153a9573d5f803e3d5ffd5b50505050505050949350505050565b5f6153c1614809565b7350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff166382027b6d83336040518363ffffffff1660e01b8152600401615410929190616701565b602060405180830381865afa15801561542b573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061544f91906168e1565b6154925781336040517f9de3392c000000000000000000000000000000000000000000000000000000008152600401615489929190616701565b60405180910390fd5b82827350157cffd6bbfa2dece204a89ec419c23ef5755d466040516020016154bd9493929190617074565b6040516020818303038152906040528051906020012090505f6154df8361468e565b90506154eb8282614790565b91507350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff16633e395cec83336040518363ffffffff1660e01b815260040161553c929190616701565b5f604051808303815f87803b158015615553575f80fd5b505af1158015615565573d5f803e3d5ffd5b505050505092915050565b5f806008605381111561558657615585616482565b5b60ff166001901b600660538111156155a1576155a0616482565b5b60ff166001901b600560538111156155bc576155bb616482565b5b60ff166001901b600460538111156155d7576155d6616482565b5b60ff166001901b600360538111156155f2576155f1616482565b5b60ff166001901b6002605381111561560d5761560c616482565b5b60ff166001901b5f605381111561562757615626616482565b5b60ff166001901b61563891906164dc565b61564291906164dc565b61564c91906164dc565b61565691906164dc565b61566091906164dc565b61566a91906164dc565b90505f8185605381111561568157615680616482565b5b60ff166001901b16036156c0576040517fc6de466a00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b601a84846040516020016156d6939291906170c1565b6040516020818303038152906040528051906020012091506156f88285614790565b9150615702614809565b73233ff88a48c172d29f675403e6a8e302b0f032d973ffffffffffffffffffffffffffffffffffffffff166309b04e8f85846040518363ffffffff1660e01b8152600401615751929190616ce0565b5f604051808303815f87803b158015615768575f80fd5b505af115801561577a573d5f803e3d5ffd5b505050507350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff16633e395cec83336040518363ffffffff1660e01b81526004016157cd929190616701565b5f604051808303815f87803b1580156157e4575f80fd5b505af11580156157f6573d5f803e3d5ffd5b505050505092915050565b60018160f81c60ff161115615842576040517fdf7bf32500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b50565b5f805f90507a184f03e93ff9f4daa797ed6e38ed64bf6a1f01000000000000000083106158a1577a184f03e93ff9f4daa797ed6e38ed64bf6a1f010000000000000000838161589757615896616e54565b5b0492506040810190505b6d04ee2d6d415b85acef810000000083106158de576d04ee2d6d415b85acef810000000083816158d4576158d3616e54565b5b0492506020810190505b662386f26fc10000831061590d57662386f26fc10000838161590357615902616e54565b5b0492506010810190505b6305f5e1008310615936576305f5e100838161592c5761592b616e54565b5b0492506008810190505b612710831061595b57612710838161595157615950616e54565b5b0492506004810190505b6064831061597e576064838161597457615973616e54565b5b0492506002810190505b600a831061598d576001810190505b80915050919050565b5f7f4613e1771f6b755d243e536fb5a23c5b15e2826575fee921e8fe7a22a760c800905090565b5f80821180156159da57505f6001836159d69190616e81565b8316145b9050919050565b600260538111156159f5576159f4616482565b5b816053811115615a0857615a07616482565b5b03615a1e57615a1982610100615bf6565b615b2d565b60036053811115615a3257615a31616482565b5b816053811115615a4557615a44616482565b5b03615a5c57615a578262010000615bf6565b615b2d565b60046053811115615a7057615a6f616482565b5b816053811115615a8357615a82616482565b5b03615a9c57615a9782640100000000615bf6565b615b2d565b60056053811115615ab057615aaf616482565b5b816053811115615ac357615ac2616482565b5b03615ae057615adb8268010000000000000000615bf6565b615b2d565b60066053811115615af457615af3616482565b5b816053811115615b0757615b06616482565b5b03615b2c57615b2782700100000000000000000000000000000000615bf6565b615b2d565b5b5050565b5f615b5d7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5f1b615c34565b5f015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905090565b615b8d82615c3d565b8173ffffffffffffffffffffffffffffffffffffffff167fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b60405160405180910390a25f81511115615be957615be38282615d06565b50615bf2565b615bf1615d86565b5b5050565b80821115615c30576040517fc7dadf4500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5050565b5f819050919050565b5f8173ffffffffffffffffffffffffffffffffffffffff163b03615c9857806040517f4c9c8ce3000000000000000000000000000000000000000000000000000000008152600401615c8f9190616413565b60405180910390fd5b80615cc47f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5f1b615c34565b5f015f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555050565b60605f808473ffffffffffffffffffffffffffffffffffffffff1684604051615d2f9190617137565b5f60405180830381855af49150503d805f8114615d67576040519150601f19603f3d011682016040523d82523d5f602084013e615d6c565b606091505b5091509150615d7c858383615dc2565b9250505092915050565b5f341115615dc0576040517fb398979f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b565b606082615dd757615dd282615e4f565b615e47565b5f8251148015615dfd57505f8473ffffffffffffffffffffffffffffffffffffffff163b145b15615e3f57836040517f9996b315000000000000000000000000000000000000000000000000000000008152600401615e369190616413565b60405180910390fd5b819050615e48565b5b9392505050565b5f81511115615e615780518082602001fd5b6040517fd6bda27500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f604051905090565b5f80fd5b5f80fd5b5f819050919050565b615eb681615ea4565b8114615ec0575f80fd5b50565b5f81359050615ed181615ead565b92915050565b5f7fff0000000000000000000000000000000000000000000000000000000000000082169050919050565b615f0b81615ed7565b8114615f15575f80fd5b50565b5f81359050615f2681615f02565b92915050565b5f805f60608486031215615f4357615f42615e9c565b5b5f615f5086828701615ec3565b9350506020615f6186828701615ec3565b9250506040615f7286828701615f18565b9150509250925092565b615f8581615ea4565b82525050565b5f602082019050615f9e5f830184615f7c565b92915050565b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f615fcd82615fa4565b9050919050565b615fdd81615fc3565b8114615fe7575f80fd5b50565b5f81359050615ff881615fd4565b92915050565b5f80fd5b5f80fd5b5f601f19601f8301169050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b61604c82616006565b810181811067ffffffffffffffff8211171561606b5761606a616016565b5b80604052505050565b5f61607d615e93565b90506160898282616043565b919050565b5f67ffffffffffffffff8211156160a8576160a7616016565b5b6160b182616006565b9050602081019050919050565b828183375f83830152505050565b5f6160de6160d98461608e565b616074565b9050828152602081018484840111156160fa576160f9616002565b5b6161058482856160be565b509392505050565b5f82601f83011261612157616120615ffe565b5b81356161318482602086016160cc565b91505092915050565b60548110616146575f80fd5b50565b5f813590506161578161613a565b92915050565b5f805f806080858703121561617557616174615e9c565b5b5f61618287828801615ec3565b945050602061619387828801615fea565b935050604085013567ffffffffffffffff8111156161b4576161b3615ea0565b5b6161c08782880161610d565b92505060606161d187828801616149565b91505092959194509250565b5f81519050919050565b5f82825260208201905092915050565b5f5b838110156162145780820151818401526020810190506161f9565b5f8484015250505050565b5f616229826161dd565b61623381856161e7565b93506162438185602086016161f7565b61624c81616006565b840191505092915050565b5f6020820190508181035f83015261626f818461621f565b905092915050565b5f806040838503121561628d5761628c615e9c565b5b5f61629a85828601615ec3565b92505060206162ab85828601616149565b9150509250929050565b5f819050919050565b6162c7816162b5565b81146162d1575f80fd5b50565b5f813590506162e2816162be565b92915050565b5f80604083850312156162fe576162fd615e9c565b5b5f61630b858286016162d4565b925050602061631c85828601616149565b9150509250929050565b5f806040838503121561633c5761633b615e9c565b5b5f61634985828601615fea565b925050602083013567ffffffffffffffff81111561636a57616369615ea0565b5b6163768582860161610d565b9150509250929050565b5f805f6060848603121561639757616396615e9c565b5b5f6163a486828701615ec3565b93505060206163b586828701615ec3565b92505060406163c686828701615ec3565b9150509250925092565b5f60ff82169050919050565b6163e5816163d0565b82525050565b5f6020820190506163fe5f8301846163dc565b92915050565b61640d81615fc3565b82525050565b5f6020820190506164265f830184616404565b92915050565b5f6020828403121561644157616440615e9c565b5b5f61644e84828501615ec3565b91505092915050565b5f6020828403121561646c5761646b615e9c565b5b5f61647984828501616149565b91505092915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52602160045260245ffd5b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5f6164e6826162b5565b91506164f1836162b5565b9250828201905080821115616509576165086164af565b5b92915050565b605481106165205761651f616482565b5b50565b5f8190506165308261650f565b919050565b5f61653f82616523565b9050919050565b61654f81616535565b82525050565b61655e81615ed7565b82525050565b5f60a0820190506165775f830188616546565b6165846020830187616555565b6165916040830186615f7c565b61659e6060830185615f7c565b6165ab6080830184615f7c565b9695505050505050565b5f6080820190506165c85f830187615f7c565b6165d56020830186615f7c565b6165e26040830185616555565b6165ef6060830184615f7c565b95945050505050565b61660181615fc3565b82525050565b604082015f82015161661b5f8501826165f8565b50602082015161662e60208501826165f8565b50505050565b5f81519050919050565b5f82825260208201905092915050565b5f61665882616634565b616662818561663e565b93506166728185602086016161f7565b61667b81616006565b840191505092915050565b5f6080820190506166995f830186616607565b6166a66040830185615f7c565b81810360608301526166b8818461664e565b9050949350505050565b5f815190506166d081615ead565b92915050565b5f602082840312156166eb576166ea615e9c565b5b5f6166f8848285016166c2565b91505092915050565b5f6040820190506167145f830185615f7c565b6167216020830184616404565b9392505050565b5f60a08201905061673b5f830188615f7c565b6167486020830187616404565b818103604083015261675a818661664e565b90506167696060830185616546565b6167766080830184615f7c565b9695505050505050565b5f81905092915050565b5f616794826161dd565b61679e8185616780565b93506167ae8185602086016161f7565b80840191505092915050565b7f20760000000000000000000000000000000000000000000000000000000000005f82015250565b5f6167ee600283616780565b91506167f9826167ba565b600282019050919050565b7f2e000000000000000000000000000000000000000000000000000000000000005f82015250565b5f616838600183616780565b915061684382616804565b600182019050919050565b5f616859828761678a565b9150616864826167e2565b9150616870828661678a565b915061687b8261682c565b9150616887828561678a565b91506168928261682c565b915061689e828461678a565b915081905095945050505050565b5f8115159050919050565b6168c0816168ac565b81146168ca575f80fd5b50565b5f815190506168db816168b7565b92915050565b5f602082840312156168f6576168f5615e9c565b5b5f616903848285016168cd565b91505092915050565b601c811061691d5761691c616482565b5b50565b5f81905061692d8261690c565b919050565b5f61693c82616920565b9050919050565b5f8160f81b9050919050565b5f61695982616943565b9050919050565b61697161696c82616932565b61694f565b82525050565b5f819050919050565b61699161698c82615ea4565b616977565b82525050565b6169a86169a382616535565b61694f565b82525050565b5f819050919050565b5f6169d16169cc6169c784615fa4565b6169ae565b615fa4565b9050919050565b5f6169e2826169b7565b9050919050565b5f6169f3826169d8565b9050919050565b5f8160601b9050919050565b5f616a10826169fa565b9050919050565b5f616a2182616a06565b9050919050565b616a39616a34826169e9565b616a17565b82525050565b5f819050919050565b616a59616a54826162b5565b616a3f565b82525050565b5f616a6a8288616960565b600182019150616a7a8287616980565b602082019150616a8a8286616997565b600182019150616a9a8285616a28565b601482019150616aaa8284616a48565b6020820191508190509695505050505050565b5f606082019050616ad05f830186616546565b616add6020830185615f7c565b616aea6040830184615f7c565b949350505050565b5f606082019050616b055f830186615f7c565b616b126020830185616546565b616b1f6040830184615f7c565b949350505050565b5f67ffffffffffffffff82169050919050565b616b4381616b27565b82525050565b5f602082019050616b5c5f830184616b3a565b92915050565b616b6b816162b5565b82525050565b5f7fffffffffffffffffffffffffffffffff0000000000000000000000000000000082169050919050565b616ba581616b71565b82525050565b5f608082019050616bbe5f830187616b62565b616bcb6020830186616546565b616bd86040830185616b9c565b616be56060830184615f7c565b95945050505050565b5f60a082019050616c015f830188616546565b616c0e6020830187615f7c565b616c1b6040830186615f7c565b616c286060830185615f7c565b616c356080830184615f7c565b9695505050505050565b5f608082019050616c525f830187615f7c565b616c5f6020830186615f7c565b616c6c6040830185615f7c565b616c796060830184615f7c565b95945050505050565b5f616c8d8288616960565b600182019150616c9d8287616a48565b602082019150616cad8286616997565b600182019150616cbd8285616a28565b601482019150616ccd8284616a48565b6020820191508190509695505050505050565b5f604082019050616cf35f830185616546565b616d006020830184615f7c565b9392505050565b5f606082019050616d1a5f830186616b62565b616d276020830185616546565b616d346040830184615f7c565b949350505050565b5f604082019050616d4f5f830185615f7c565b616d5c6020830184615f7c565b9392505050565b5f606082019050616d765f830186616546565b616d836020830185616b9c565b616d906040830184615f7c565b949350505050565b5f819050919050565b616db2616dad82615ed7565b616d98565b82525050565b5f616dc38289616960565b600182019150616dd38288616980565b602082019150616de38287616980565b602082019150616df38286616da1565b600182019150616e038285616a28565b601482019150616e138284616a48565b602082019150819050979650505050505050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603260045260245ffd5b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601260045260245ffd5b5f616e8b826162b5565b9150616e96836162b5565b9250828203905081811115616eae57616ead6164af565b5b92915050565b5f616ebf8288616a48565b602082019150616ecf8287616a28565b601482019150616edf8286616a48565b602082019150616eef8285616980565b602082019150616eff8284616a48565b6020820191508190509695505050505050565b5f616f1c826162b5565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8203616f4e57616f4d6164af565b5b600182019050919050565b5f819050919050565b616f73616f6e82616b71565b616f59565b82525050565b5f616f848287616960565b600182019150616f948286616a48565b602082019150616fa48285616997565b600182019150616fb48284616f62565b60108201915081905095945050505050565b5f81519050616fd481615fd4565b92915050565b5f60208284031215616fef57616fee615e9c565b5b5f616ffc84828501616fc6565b91505092915050565b5f6170108289616960565b6001820191506170208288616980565b6020820191506170308287616980565b6020820191506170408286616980565b6020820191506170508285616a28565b6014820191506170608284616a48565b602082019150819050979650505050505050565b5f61707f8287616960565b60018201915061708f8286616980565b60208201915061709f8285616a28565b6014820191506170af8284616a48565b60208201915081905095945050505050565b5f6170cc8286616960565b6001820191506170dc8285616997565b6001820191506170ec8284616f62565b601082019150819050949350505050565b5f81905092915050565b5f61711182616634565b61711b81856170fd565b935061712b8185602086016161f7565b80840191505092915050565b5f6171428284617107565b91508190509291505056
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R`\x046\x10a\x02\x19W_5`\xE0\x1C\x80cw\x02\xDC\xFF\x11a\x01\"W\x80c\xCC\xC4\x80\xA1\x11a\0\xAAW\x80c\xD9\x98\x82\xD5\x11a\0nW\x80c\xD9\x98\x82\xD5\x14a\x08\xFDW\x80c\xE0xir\x14a\t9W\x80c\xF5\x1C\xCF\xB0\x14a\tcW\x80c\xF6\x85\x9B\xDC\x14a\t\x9FW\x80c\xF7\x7F?\x1D\x14a\t\xC9Wa\x02\x19V[\x80c\xCC\xC4\x80\xA1\x14a\x07\xD1W\x80c\xCFM\x18\xAA\x14a\x08\rW\x80c\xD5\x80\xC0c\x14a\x08IW\x80c\xD7]n\x8A\x14a\x08\x85W\x80c\xD8\t,\xBC\x14a\x08\xC1Wa\x02\x19V[\x80c\x91\xF9\x8F\xFE\x11a\0\xF1W\x80c\x91\xF9\x8F\xFE\x14a\x06\xC9W\x80c\x9C\xD0z\xCB\x14a\x07\x05W\x80c\xA8\xC7\xC2\xC1\x14a\x07AW\x80c\xAD<\xB1\xCC\x14a\x07kW\x80c\xC0!2\x9E\x14a\x07\x95Wa\x02\x19V[\x80cw\x02\xDC\xFF\x14a\x05\xEBW\x80cz)\x7FK\x14a\x06'W\x80c\x856.\xE7\x14a\x06QW\x80c\x8BI\xCE\xB4\x14a\x06\x8DWa\x02\x19V[\x80cH\xEE\xF4~\x11a\x01\xA5W\x80cZS\xAC\xCB\x11a\x01tW\x80cZS\xAC\xCB\x14a\x04\xBFW\x80cc\xA2\xDB)\x14a\x04\xFBW\x80cgT\xB3`\x14a\x057W\x80cr\x10v\x81\x14a\x05sW\x80cu\x13\xA4\x04\x14a\x05\xAFWa\x02\x19V[\x80cH\xEE\xF4~\x14a\x04\x01W\x80cO\x1E\xF2\x86\x14a\x04=W\x80cR\xD1\x90-\x14a\x04YW\x80cW\xF0\xA5h\x14a\x04\x83Wa\x02\x19V[\x80c\x13\x91T\x7F\x11a\x01\xECW\x80c\x13\x91T\x7F\x14a\x02\xFBW\x80c\x18+m\x98\x14a\x037W\x80c\x1C\x89\xEED\x14a\x03sW\x80c61\x8Dd\x14a\x03\xAFW\x80c9\xF78\x10\x14a\x03\xEBWa\x02\x19V[\x80c\x04U\x9Fq\x14a\x02\x1DW\x80c\x08\xBF\x83*\x14a\x02YW\x80c\r\x8En,\x14a\x02\x95W\x80c\x11{/8\x14a\x02\xBFW[_\x80\xFD[4\x80\x15a\x02(W_\x80\xFD[Pa\x02C`\x04\x806\x03\x81\x01\x90a\x02>\x91\x90a_,V[a\n\x05V[`@Qa\x02P\x91\x90a_\x8BV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x02dW_\x80\xFD[Pa\x02\x7F`\x04\x806\x03\x81\x01\x90a\x02z\x91\x90aa]V[a\x0B\xB4V[`@Qa\x02\x8C\x91\x90a_\x8BV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x02\xA0W_\x80\xFD[Pa\x02\xA9a\r\xD1V[`@Qa\x02\xB6\x91\x90abWV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x02\xCAW_\x80\xFD[Pa\x02\xE5`\x04\x806\x03\x81\x01\x90a\x02\xE0\x91\x90a_,V[a\x0ELV[`@Qa\x02\xF2\x91\x90a_\x8BV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x03\x06W_\x80\xFD[Pa\x03!`\x04\x806\x03\x81\x01\x90a\x03\x1C\x91\x90a_,V[a\x0F\xFAV[`@Qa\x03.\x91\x90a_\x8BV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x03BW_\x80\xFD[Pa\x03]`\x04\x806\x03\x81\x01\x90a\x03X\x91\x90a_,V[a\x11\xA9V[`@Qa\x03j\x91\x90a_\x8BV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x03~W_\x80\xFD[Pa\x03\x99`\x04\x806\x03\x81\x01\x90a\x03\x94\x91\x90abwV[a\x13XV[`@Qa\x03\xA6\x91\x90a_\x8BV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x03\xBAW_\x80\xFD[Pa\x03\xD5`\x04\x806\x03\x81\x01\x90a\x03\xD0\x91\x90a_,V[a\x18iV[`@Qa\x03\xE2\x91\x90a_\x8BV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x03\xF6W_\x80\xFD[Pa\x03\xFFa\x1A\x18V[\0[4\x80\x15a\x04\x0CW_\x80\xFD[Pa\x04'`\x04\x806\x03\x81\x01\x90a\x04\"\x91\x90ab\xE8V[a\x1B\x88V[`@Qa\x044\x91\x90a_\x8BV[`@Q\x80\x91\x03\x90\xF3[a\x04W`\x04\x806\x03\x81\x01\x90a\x04R\x91\x90ac&V[a\x1B\xFCV[\0[4\x80\x15a\x04dW_\x80\xFD[Pa\x04ma\x1C\x1BV[`@Qa\x04z\x91\x90a_\x8BV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x04\x8EW_\x80\xFD[Pa\x04\xA9`\x04\x806\x03\x81\x01\x90a\x04\xA4\x91\x90a_,V[a\x1CLV[`@Qa\x04\xB6\x91\x90a_\x8BV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x04\xCAW_\x80\xFD[Pa\x04\xE5`\x04\x806\x03\x81\x01\x90a\x04\xE0\x91\x90a_,V[a\x1D\xFBV[`@Qa\x04\xF2\x91\x90a_\x8BV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x05\x06W_\x80\xFD[Pa\x05!`\x04\x806\x03\x81\x01\x90a\x05\x1C\x91\x90a_,V[a DV[`@Qa\x05.\x91\x90a_\x8BV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x05BW_\x80\xFD[Pa\x05]`\x04\x806\x03\x81\x01\x90a\x05X\x91\x90a_,V[a\"<V[`@Qa\x05j\x91\x90a_\x8BV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x05~W_\x80\xFD[Pa\x05\x99`\x04\x806\x03\x81\x01\x90a\x05\x94\x91\x90a_,V[a$\x10V[`@Qa\x05\xA6\x91\x90a_\x8BV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x05\xBAW_\x80\xFD[Pa\x05\xD5`\x04\x806\x03\x81\x01\x90a\x05\xD0\x91\x90a_,V[a%\xBFV[`@Qa\x05\xE2\x91\x90a_\x8BV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x05\xF6W_\x80\xFD[Pa\x06\x11`\x04\x806\x03\x81\x01\x90a\x06\x0C\x91\x90ac\x80V[a'nV[`@Qa\x06\x1E\x91\x90a_\x8BV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x062W_\x80\xFD[Pa\x06;a)\x8AV[`@Qa\x06H\x91\x90ac\xEBV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x06\\W_\x80\xFD[Pa\x06w`\x04\x806\x03\x81\x01\x90a\x06r\x91\x90a_,V[a)\x8EV[`@Qa\x06\x84\x91\x90a_\x8BV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x06\x98W_\x80\xFD[Pa\x06\xB3`\x04\x806\x03\x81\x01\x90a\x06\xAE\x91\x90a_,V[a+=V[`@Qa\x06\xC0\x91\x90a_\x8BV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x06\xD4W_\x80\xFD[Pa\x06\xEF`\x04\x806\x03\x81\x01\x90a\x06\xEA\x91\x90a_,V[a-5V[`@Qa\x06\xFC\x91\x90a_\x8BV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x07\x10W_\x80\xFD[Pa\x07+`\x04\x806\x03\x81\x01\x90a\x07&\x91\x90ab\xE8V[a/\tV[`@Qa\x078\x91\x90a_\x8BV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x07LW_\x80\xFD[Pa\x07Ua2)V[`@Qa\x07b\x91\x90ad\x13V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x07vW_\x80\xFD[Pa\x07\x7Fa2DV[`@Qa\x07\x8C\x91\x90abWV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x07\xA0W_\x80\xFD[Pa\x07\xBB`\x04\x806\x03\x81\x01\x90a\x07\xB6\x91\x90a_,V[a2}V[`@Qa\x07\xC8\x91\x90a_\x8BV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x07\xDCW_\x80\xFD[Pa\x07\xF7`\x04\x806\x03\x81\x01\x90a\x07\xF2\x91\x90a_,V[a4QV[`@Qa\x08\x04\x91\x90a_\x8BV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x08\x18W_\x80\xFD[Pa\x083`\x04\x806\x03\x81\x01\x90a\x08.\x91\x90a_,V[a6%V[`@Qa\x08@\x91\x90a_\x8BV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x08TW_\x80\xFD[Pa\x08o`\x04\x806\x03\x81\x01\x90a\x08j\x91\x90ad,V[a8nV[`@Qa\x08|\x91\x90a_\x8BV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x08\x90W_\x80\xFD[Pa\x08\xAB`\x04\x806\x03\x81\x01\x90a\x08\xA6\x91\x90adWV[a:5V[`@Qa\x08\xB8\x91\x90a_\x8BV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x08\xCCW_\x80\xFD[Pa\x08\xE7`\x04\x806\x03\x81\x01\x90a\x08\xE2\x91\x90a_,V[a:\xA5V[`@Qa\x08\xF4\x91\x90a_\x8BV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\t\x08W_\x80\xFD[Pa\t#`\x04\x806\x03\x81\x01\x90a\t\x1E\x91\x90a_,V[a<\xC2V[`@Qa\t0\x91\x90a_\x8BV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\tDW_\x80\xFD[Pa\tMa>\xBAV[`@Qa\tZ\x91\x90ad\x13V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\tnW_\x80\xFD[Pa\t\x89`\x04\x806\x03\x81\x01\x90a\t\x84\x91\x90ad,V[a>\xD5V[`@Qa\t\x96\x91\x90a_\x8BV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\t\xAAW_\x80\xFD[Pa\t\xB3a@\xC0V[`@Qa\t\xC0\x91\x90ad\x13V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\t\xD4W_\x80\xFD[Pa\t\xEF`\x04\x806\x03\x81\x01\x90a\t\xEA\x91\x90a_,V[a@\xDBV[`@Qa\t\xFC\x91\x90a_\x8BV[`@Q\x80\x91\x03\x90\xF3[_\x80`\x06`S\x81\x11\x15a\n\x1BWa\n\x1Aad\x82V[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a\n6Wa\n5ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a\nQWa\nPad\x82V[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a\nlWa\nkad\x82V[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a\n\x87Wa\n\x86ad\x82V[[`\xFF\x16`\x01\x90\x1Ba\n\x98\x91\x90ad\xDCV[a\n\xA2\x91\x90ad\xDCV[a\n\xAC\x91\x90ad\xDCV[a\n\xB6\x91\x90ad\xDCV[\x90P_a\n\xC3\x86\x83aB\xF8V[\x90Pa\n\xD3`\x12\x87\x87\x87\x85aC^V[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16cd+\x14\x90\x82\x86\x89\x89\x88`@Q\x86c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x0B*\x95\x94\x93\x92\x91\x90aedV[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x0BAW_\x80\xFD[PZ\xF1\x15\x80\x15a\x0BSW=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xC1\x1Db\xB1<6\n\x83\x08$\x87\x06K\xE1\xEC\x08x\xB2\xF0\xBEO\x01+\xF5\x9F\x89\xE1(\x06=G\xFF\x87\x87\x87\x87`@Qa\x0B\xA3\x94\x93\x92\x91\x90ae\xB5V[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_\x80`@Q\x80`@\x01`@R\x80\x86s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x013s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81RP\x90P_a\x0C\x03\x87aF\x8EV[\x90P\x80`S\x81\x11\x15a\x0C\x18Wa\x0C\x17ad\x82V[[\x84`S\x81\x11\x15a\x0C+Wa\x0C*ad\x82V[[\x14a\x0CbW`@Q\x7F\xB9h\x84a\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[s6w!B\xB7Hq\xF2U\xCB\xD7\xA3\xE8\x9B@\x1D>E\x82_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xE61}\xF5\x83\x89\x88`@Q\x84c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x0C\xB3\x93\x92\x91\x90af\x86V[` `@Q\x80\x83\x03\x81_\x87Z\xF1\x15\x80\x15a\x0C\xCFW=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x0C\xF3\x91\x90af\xD6V[\x92PsP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c>9\\\xEC\x843`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\rD\x92\x91\x90ag\x01V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\r[W_\x80\xFD[PZ\xF1\x15\x80\x15a\rmW=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xDC7\r\xB35\x89\xE73q\xDC>\xE4,x\x9C\0=3n\xEF\xCB|?V\xFE\x0FQ\xAE[\x1D\x97\x02\x88\x88\x88\x88\x88`@Qa\r\xBF\x95\x94\x93\x92\x91\x90ag(V[`@Q\x80\x91\x03\x90\xA2PP\x94\x93PPPPV[```@Q\x80`@\x01`@R\x80`\r\x81R` \x01\x7FFHEVMExecutor\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81RPa\x0E\x12_aF\xC6V[a\x0E\x1C`\x01aF\xC6V[a\x0E%_aF\xC6V[`@Q` \x01a\x0E8\x94\x93\x92\x91\x90ahNV[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x90P\x90V[_\x80`\x06`S\x81\x11\x15a\x0EbWa\x0Eaad\x82V[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a\x0E}Wa\x0E|ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a\x0E\x98Wa\x0E\x97ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a\x0E\xB3Wa\x0E\xB2ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a\x0E\xCEWa\x0E\xCDad\x82V[[`\xFF\x16`\x01\x90\x1Ba\x0E\xDF\x91\x90ad\xDCV[a\x0E\xE9\x91\x90ad\xDCV[a\x0E\xF3\x91\x90ad\xDCV[a\x0E\xFD\x91\x90ad\xDCV[\x90P_a\x0F\n\x86\x83aB\xF8V[\x90Pa\x0F\x19_\x87\x87\x87\x85aC^V[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xFD\xADL\x96\x82\x86\x89\x89\x88`@Q\x86c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x0Fp\x95\x94\x93\x92\x91\x90aedV[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x0F\x87W_\x80\xFD[PZ\xF1\x15\x80\x15a\x0F\x99W=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xDB\x90P\xD6R@C\x16!\xD6\x1Do\x94\xB9p\xE6?S\xA6zWfaN\xE6\xE5\xC5\xBB\xD4\x1C\x8E.\x87\x87\x87\x87`@Qa\x0F\xE9\x94\x93\x92\x91\x90ae\xB5V[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_\x80`\x06`S\x81\x11\x15a\x10\x10Wa\x10\x0Fad\x82V[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a\x10+Wa\x10*ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a\x10FWa\x10Ead\x82V[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a\x10aWa\x10`ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a\x10|Wa\x10{ad\x82V[[`\xFF\x16`\x01\x90\x1Ba\x10\x8D\x91\x90ad\xDCV[a\x10\x97\x91\x90ad\xDCV[a\x10\xA1\x91\x90ad\xDCV[a\x10\xAB\x91\x90ad\xDCV[\x90P_a\x10\xB8\x86\x83aB\xF8V[\x90Pa\x10\xC8`\x0E\x87\x87\x87_aC^V[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16ck\xB3\xC6\x11\x82\x86\x89\x89\x88`@Q\x86c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x11\x1F\x95\x94\x93\x92\x91\x90aedV[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x116W_\x80\xFD[PZ\xF1\x15\x80\x15a\x11HW=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F8\xC3\xA6<B0\xDE[t\x1FIO\xFBT\xE3\x08q\x04\x03\x02y\xBC{\xCC\xEE\x8A\xD9\xAD1q+!\x87\x87\x87\x87`@Qa\x11\x98\x94\x93\x92\x91\x90ae\xB5V[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_\x80`\x06`S\x81\x11\x15a\x11\xBFWa\x11\xBEad\x82V[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a\x11\xDAWa\x11\xD9ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a\x11\xF5Wa\x11\xF4ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a\x12\x10Wa\x12\x0Fad\x82V[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a\x12+Wa\x12*ad\x82V[[`\xFF\x16`\x01\x90\x1Ba\x12<\x91\x90ad\xDCV[a\x12F\x91\x90ad\xDCV[a\x12P\x91\x90ad\xDCV[a\x12Z\x91\x90ad\xDCV[\x90P_a\x12g\x86\x83aB\xF8V[\x90Pa\x12w`\x01\x87\x87\x87\x85aC^V[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x90u1\x08\x82\x86\x89\x89\x88`@Q\x86c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x12\xCE\x95\x94\x93\x92\x91\x90aedV[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x12\xE5W_\x80\xFD[PZ\xF1\x15\x80\x15a\x12\xF7W=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xEBm7\xBD'\x1A\xBE\x13\x95\xB2\x1Dmx\xF3H}e\x84\x86(r\xC2\x9F\xFD?\x90sn\xE9\x9Bs\x93\x87\x87\x87\x87`@Qa\x13G\x94\x93\x92\x91\x90ae\xB5V[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_sP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x82\x02{m\x843`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x13\xA8\x92\x91\x90ag\x01V[` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x13\xC3W=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x13\xE7\x91\x90ah\xE1V[a\x14*W\x823`@Q\x7F\x9D\xE39,\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x14!\x92\x91\x90ag\x01V[`@Q\x80\x91\x03\x90\xFD[_`\x08`S\x81\x11\x15a\x14?Wa\x14>ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x06`S\x81\x11\x15a\x14ZWa\x14Yad\x82V[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a\x14uWa\x14tad\x82V[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a\x14\x90Wa\x14\x8Fad\x82V[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a\x14\xABWa\x14\xAAad\x82V[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a\x14\xC6Wa\x14\xC5ad\x82V[[`\xFF\x16`\x01\x90\x1B_`S\x81\x11\x15a\x14\xE0Wa\x14\xDFad\x82V[[`\xFF\x16`\x01\x90\x1Ba\x14\xF1\x91\x90ad\xDCV[a\x14\xFB\x91\x90ad\xDCV[a\x15\x05\x91\x90ad\xDCV[a\x15\x0F\x91\x90ad\xDCV[a\x15\x19\x91\x90ad\xDCV[a\x15#\x91\x90ad\xDCV[\x90P_a\x150\x85\x83aB\xF8V[\x90P_`\x08`S\x81\x11\x15a\x15GWa\x15Fad\x82V[[`\xFF\x16`\x01\x90\x1B`\x06`S\x81\x11\x15a\x15bWa\x15aad\x82V[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a\x15}Wa\x15|ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a\x15\x98Wa\x15\x97ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a\x15\xB3Wa\x15\xB2ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a\x15\xCEWa\x15\xCDad\x82V[[`\xFF\x16`\x01\x90\x1Ba\x15\xDF\x91\x90ad\xDCV[a\x15\xE9\x91\x90ad\xDCV[a\x15\xF3\x91\x90ad\xDCV[a\x15\xFD\x91\x90ad\xDCV[a\x16\x07\x91\x90ad\xDCV[\x90P_\x81\x86`S\x81\x11\x15a\x16\x1EWa\x16\x1Dad\x82V[[`\xFF\x16`\x01\x90\x1B\x16\x03a\x16]W`@Q\x7F\xC6\xDEFj\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x84`S\x81\x11\x15a\x16pWa\x16oad\x82V[[\x82`S\x81\x11\x15a\x16\x83Wa\x16\x82ad\x82V[[\x03a\x16\xBAW`@Q\x7F\xB9h\x84a\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x17\x86\x86sP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]F`@Q` \x01a\x16\xE8\x95\x94\x93\x92\x91\x90aj_V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x93Pa\x17\n\x84\x86aG\x90V[\x93Pa\x17\x14aH\tV[s#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x02\xDDbv\x86\x88\x87`@Q\x84c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x17e\x93\x92\x91\x90aj\xBDV[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x17|W_\x80\xFD[PZ\xF1\x15\x80\x15a\x17\x8EW=_\x80>=_\xFD[PPPPsP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c>9\\\xEC\x853`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x17\xE1\x92\x91\x90ag\x01V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x17\xF8W_\x80\xFD[PZ\xF1\x15\x80\x15a\x18\nW=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F1\xCC\xAEj/\x8E<\xED\x16\x92\xF7|\x8Ff\x813\xE4\xAF\xDA\xAA5\xAF\xE8D\xFFFY\xA6\xC2~b\x7F\x87\x87\x87`@Qa\x18X\x93\x92\x91\x90aj\xF2V[`@Q\x80\x91\x03\x90\xA2PPP\x92\x91PPV[_\x80`\x06`S\x81\x11\x15a\x18\x7FWa\x18~ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a\x18\x9AWa\x18\x99ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a\x18\xB5Wa\x18\xB4ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a\x18\xD0Wa\x18\xCFad\x82V[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a\x18\xEBWa\x18\xEAad\x82V[[`\xFF\x16`\x01\x90\x1Ba\x18\xFC\x91\x90ad\xDCV[a\x19\x06\x91\x90ad\xDCV[a\x19\x10\x91\x90ad\xDCV[a\x19\x1A\x91\x90ad\xDCV[\x90P_a\x19'\x86\x83aB\xF8V[\x90Pa\x197`\x13\x87\x87\x87\x85aC^V[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xAC\xB5\xF3\x88\x82\x86\x89\x89\x88`@Q\x86c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x19\x8E\x95\x94\x93\x92\x91\x90aedV[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x19\xA5W_\x80\xFD[PZ\xF1\x15\x80\x15a\x19\xB7W=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xFD|\x92\x08\xF9V\xBF\x0Cj\xB7jf\x7F\x046\x12E\xAD>\n-\x0E\xFF\x92\xEB\x82z\xCF\xCC\xA6\x8E\xA9\x87\x87\x87\x87`@Qa\x1A\x07\x94\x93\x92\x91\x90ae\xB5V[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[`\x01a\x1A\"aH\x85V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x1AcW`@Q\x7FoOs\x1F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x02_a\x1AnaH\xA9V[\x90P\x80_\x01`\x08\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x80a\x1A\xB6WP\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81_\x01_\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x10\x15[\x15a\x1A\xEDW`@Q\x7F\xF9.\xE8\xA9\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x81\x81_\x01_a\x01\0\n\x81T\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP`\x01\x81_\x01`\x08a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP_\x81_\x01`\x08a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP\x7F\xC7\xF5\x05\xB2\xF3q\xAE!u\xEEI\x13\xF4I\x9E\x1F&3\xA7\xB5\x93c!\xEE\xD1\xCD\xAE\xB6\x11Q\x81\xD2\x82`@Qa\x1B|\x91\x90akIV[`@Q\x80\x91\x03\x90\xA1PPV[_\x80a\x1B\x92aH\xD0V[\x90Pa\x1B\x9F\x84\x84\x83aIMV[\x91P3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7FR\"\xD9k\x83g'\xA1\xD6\xFE\x1E\xE9\xAE\xF2\x7F\x9B\xB5\x07\xBDAyM\xEF\xA3v\xFFld\x8A\xAF\x8F\xF1\x85\x85\x84\x86`@Qa\x1B\xED\x94\x93\x92\x91\x90ak\xABV[`@Q\x80\x91\x03\x90\xA2P\x92\x91PPV[a\x1C\x04aL\x06V[a\x1C\r\x82aL\xECV[a\x1C\x17\x82\x82aM\xDFV[PPV[_a\x1C$aN\xFDV[\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC_\x1B\x90P\x90V[_\x80`\x06`S\x81\x11\x15a\x1CbWa\x1Caad\x82V[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a\x1C}Wa\x1C|ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a\x1C\x98Wa\x1C\x97ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a\x1C\xB3Wa\x1C\xB2ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a\x1C\xCEWa\x1C\xCDad\x82V[[`\xFF\x16`\x01\x90\x1Ba\x1C\xDF\x91\x90ad\xDCV[a\x1C\xE9\x91\x90ad\xDCV[a\x1C\xF3\x91\x90ad\xDCV[a\x1C\xFD\x91\x90ad\xDCV[\x90P_a\x1D\n\x86\x83aB\xF8V[\x90Pa\x1D\x1A`\x02\x87\x87\x87\x85aC^V[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c<\x16\xFF\r\x82\x86\x89\x89\x88`@Q\x86c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x1Dq\x95\x94\x93\x92\x91\x90aedV[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x1D\x88W_\x80\xFD[PZ\xF1\x15\x80\x15a\x1D\x9AW=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F!SF\xA4\xF9\xF9u\xE6\xD5HN)\x0B\xD4\xE5<\xA1DS\xA9\xD2\x82\xEB\xD3\xCC\xED\xB2\xA0\xF1qu=\x87\x87\x87\x87`@Qa\x1D\xEA\x94\x93\x92\x91\x90ae\xB5V[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_`\x01`\xF8\x1B\x82~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x14a\x1E[W`@Q\x7FO\"NS\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x80\x1B\x83\x03a\x1E\x96W`@Q\x7F#\xD3Y\xA3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\x06`S\x81\x11\x15a\x1E\xABWa\x1E\xAAad\x82V[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a\x1E\xC6Wa\x1E\xC5ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a\x1E\xE1Wa\x1E\xE0ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a\x1E\xFCWa\x1E\xFBad\x82V[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a\x1F\x17Wa\x1F\x16ad\x82V[[`\xFF\x16`\x01\x90\x1Ba\x1F(\x91\x90ad\xDCV[a\x1F2\x91\x90ad\xDCV[a\x1F<\x91\x90ad\xDCV[a\x1FF\x91\x90ad\xDCV[\x90P_a\x1FS\x86\x83aB\xF8V[\x90Pa\x1Fc`\x03\x87\x87\x87\x85aC^V[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c@kE\x13\x82\x86\x89\x89\x88`@Q\x86c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x1F\xBA\x95\x94\x93\x92\x91\x90aedV[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x1F\xD1W_\x80\xFD[PZ\xF1\x15\x80\x15a\x1F\xE3W=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F;\xAB.\xE0\xE2\xF9\x0FF\x90\xC6\xA8{\xF6<\xF1\xA6\xB6&\x08n\x95\xF21\x86\x0B\x15)f\xE8\xDA\xBB\xF7\x87\x87\x87\x87`@Qa 3\x94\x93\x92\x91\x90ae\xB5V[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_\x80`\x08`S\x81\x11\x15a ZWa Yad\x82V[[`\xFF\x16`\x01\x90\x1B`\x06`S\x81\x11\x15a uWa tad\x82V[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a \x90Wa \x8Fad\x82V[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a \xABWa \xAAad\x82V[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a \xC6Wa \xC5ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a \xE1Wa \xE0ad\x82V[[`\xFF\x16`\x01\x90\x1B_`S\x81\x11\x15a \xFBWa \xFAad\x82V[[`\xFF\x16`\x01\x90\x1Ba!\x0C\x91\x90ad\xDCV[a!\x16\x91\x90ad\xDCV[a! \x91\x90ad\xDCV[a!*\x91\x90ad\xDCV[a!4\x91\x90ad\xDCV[a!>\x91\x90ad\xDCV[\x90P_a!K\x86\x83aB\xF8V[\x90Pa![`\x06\x87\x87\x87\x85aC^V[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xE8\xE3\x99\xAD\x82\x86\x89\x89\x88`@Q\x86c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a!\xB2\x95\x94\x93\x92\x91\x90aedV[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a!\xC9W_\x80\xFD[PZ\xF1\x15\x80\x15a!\xDBW=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7FV\xDF'\x9B\xBF\xB0=\x9E\xD0\x97\xBB\xE2\xF2\x8DR\x0C\xA0\xC1\x16\x12\x062y&\xE9\x86d\xD7\r,$\xC4\x87\x87\x87\x87`@Qa\"+\x94\x93\x92\x91\x90ae\xB5V[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_\x80`\x08`S\x81\x11\x15a\"RWa\"Qad\x82V[[`\xFF\x16`\x01\x90\x1B`\x06`S\x81\x11\x15a\"mWa\"lad\x82V[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a\"\x88Wa\"\x87ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a\"\xA3Wa\"\xA2ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a\"\xBEWa\"\xBDad\x82V[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a\"\xD9Wa\"\xD8ad\x82V[[`\xFF\x16`\x01\x90\x1Ba\"\xEA\x91\x90ad\xDCV[a\"\xF4\x91\x90ad\xDCV[a\"\xFE\x91\x90ad\xDCV[a#\x08\x91\x90ad\xDCV[a#\x12\x91\x90ad\xDCV[\x90P_a#\x1F\x86\x83aB\xF8V[\x90Pa#/`\n\x87\x87\x87\x85aC^V[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x14Rn\x87\x82\x86\x89\x89\x88`@Q\x86c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a#\x86\x95\x94\x93\x92\x91\x90aedV[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a#\x9DW_\x80\xFD[PZ\xF1\x15\x80\x15a#\xAFW=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xEB\x0EO\x8D\xC7@X\x19M\x06\x02B_\xE6\x02\xF9U\xC2\" \x0F\x7F\x10\xC6\xFEg\x99/{$\xC7\xE9\x87\x87\x87\x87`@Qa#\xFF\x94\x93\x92\x91\x90ae\xB5V[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_\x80`\x06`S\x81\x11\x15a$&Wa$%ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a$AWa$@ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a$\\Wa$[ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a$wWa$vad\x82V[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a$\x92Wa$\x91ad\x82V[[`\xFF\x16`\x01\x90\x1Ba$\xA3\x91\x90ad\xDCV[a$\xAD\x91\x90ad\xDCV[a$\xB7\x91\x90ad\xDCV[a$\xC1\x91\x90ad\xDCV[\x90P_a$\xCE\x86\x83aB\xF8V[\x90Pa$\xDE`\x11\x87\x87\x87_aC^V[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x139\xC5\xEE\x82\x86\x89\x89\x88`@Q\x86c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a%5\x95\x94\x93\x92\x91\x90aedV[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a%LW_\x80\xFD[PZ\xF1\x15\x80\x15a%^W=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\rH;\x10\r\x8Cs\xB2\x08\x98N\xC6\x97\xCA\xA3\t\x15!\xEEU%\xCEi\xED\xCF\x97\xD7\xE3\x95\xD3\xD0Y\x87\x87\x87\x87`@Qa%\xAE\x94\x93\x92\x91\x90ae\xB5V[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_\x80`\x06`S\x81\x11\x15a%\xD5Wa%\xD4ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a%\xF0Wa%\xEFad\x82V[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a&\x0BWa&\nad\x82V[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a&&Wa&%ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a&AWa&@ad\x82V[[`\xFF\x16`\x01\x90\x1Ba&R\x91\x90ad\xDCV[a&\\\x91\x90ad\xDCV[a&f\x91\x90ad\xDCV[a&p\x91\x90ad\xDCV[\x90P_a&}\x86\x83aB\xF8V[\x90Pa&\x8D`\x10\x87\x87\x87_aC^V[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xD4\x7F=Y\x82\x86\x89\x89\x88`@Q\x86c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a&\xE4\x95\x94\x93\x92\x91\x90aedV[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a&\xFBW_\x80\xFD[PZ\xF1\x15\x80\x15a'\rW=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xDE\xF2\xE7\x04\xA0w(J\x07\xF3\xD0\xB46\xDB\x88\xF5\xD9\x81\xB6\x9FX\xAB|\x1A\xE6#%'\x18\xA6\xDE\x01\x87\x87\x87\x87`@Qa']\x94\x93\x92\x91\x90ae\xB5V[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_\x80`\x08`S\x81\x11\x15a'\x84Wa'\x83ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x07`S\x81\x11\x15a'\x9FWa'\x9Ead\x82V[[`\xFF\x16`\x01\x90\x1B`\x06`S\x81\x11\x15a'\xBAWa'\xB9ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a'\xD5Wa'\xD4ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a'\xF0Wa'\xEFad\x82V[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a(\x0BWa(\nad\x82V[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a(&Wa(%ad\x82V[[`\xFF\x16`\x01\x90\x1B_`S\x81\x11\x15a(@Wa(?ad\x82V[[`\xFF\x16`\x01\x90\x1Ba(Q\x91\x90ad\xDCV[a([\x91\x90ad\xDCV[a(e\x91\x90ad\xDCV[a(o\x91\x90ad\xDCV[a(y\x91\x90ad\xDCV[a(\x83\x91\x90ad\xDCV[a(\x8D\x91\x90ad\xDCV[\x90P_a(\x9A\x85\x83aB\xF8V[\x90Pa(\xA9`\x19\x87\x87\x87aO\x84V[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16cNrgi\x82\x88\x88\x88\x88`@Q\x86c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a)\0\x95\x94\x93\x92\x91\x90ak\xEEV[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a)\x17W_\x80\xFD[PZ\xF1\x15\x80\x15a))W=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F`\xBE\x9Da\xAA\xD8I\xFA\xCC(\xC3\x8B\x04\x8C\xB5\xC4\xBE4 \xB8\xFA\"3\xE0\x8C\xFA\x06\xBE\x1Bm\x1C>\x87\x87\x87\x87`@Qa)y\x94\x93\x92\x91\x90al?V[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_\x90V[_\x80`\x06`S\x81\x11\x15a)\xA4Wa)\xA3ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a)\xBFWa)\xBEad\x82V[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a)\xDAWa)\xD9ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a)\xF5Wa)\xF4ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a*\x10Wa*\x0Fad\x82V[[`\xFF\x16`\x01\x90\x1Ba*!\x91\x90ad\xDCV[a*+\x91\x90ad\xDCV[a*5\x91\x90ad\xDCV[a*?\x91\x90ad\xDCV[\x90P_a*L\x86\x83aB\xF8V[\x90Pa*\\`\x0F\x87\x87\x87_aC^V[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x85\x9A\x1Bp\x82\x86\x89\x89\x88`@Q\x86c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a*\xB3\x95\x94\x93\x92\x91\x90aedV[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a*\xCAW_\x80\xFD[PZ\xF1\x15\x80\x15a*\xDCW=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xC9\xFF\x8F\r\x18\xA3\xF7f\xCE]\xE3\xDE!`v\x05\x01@\xE4\xFC&R\xF5\xE0\xE7E\xF6\xFC\x83l\xDA\x8B\x87\x87\x87\x87`@Qa+,\x94\x93\x92\x91\x90ae\xB5V[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_\x80`\x08`S\x81\x11\x15a+SWa+Rad\x82V[[`\xFF\x16`\x01\x90\x1B`\x06`S\x81\x11\x15a+nWa+mad\x82V[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a+\x89Wa+\x88ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a+\xA4Wa+\xA3ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a+\xBFWa+\xBEad\x82V[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a+\xDAWa+\xD9ad\x82V[[`\xFF\x16`\x01\x90\x1B_`S\x81\x11\x15a+\xF4Wa+\xF3ad\x82V[[`\xFF\x16`\x01\x90\x1Ba,\x05\x91\x90ad\xDCV[a,\x0F\x91\x90ad\xDCV[a,\x19\x91\x90ad\xDCV[a,#\x91\x90ad\xDCV[a,-\x91\x90ad\xDCV[a,7\x91\x90ad\xDCV[\x90P_a,D\x86\x83aB\xF8V[\x90Pa,T`\x07\x87\x87\x87\x85aC^V[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x144\xBAM\x82\x86\x89\x89\x88`@Q\x86c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a,\xAB\x95\x94\x93\x92\x91\x90aedV[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a,\xC2W_\x80\xFD[PZ\xF1\x15\x80\x15a,\xD4W=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7FM2(K\xD3\x19>\xCA\xA4N\x1C\xEC\xA3/A\xC5\xD6\xC3(\x03\xA9.\x07\x96}\xD3\xEEB)r\x15\x82\x87\x87\x87\x87`@Qa-$\x94\x93\x92\x91\x90ae\xB5V[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_\x80`\x08`S\x81\x11\x15a-KWa-Jad\x82V[[`\xFF\x16`\x01\x90\x1B`\x06`S\x81\x11\x15a-fWa-ead\x82V[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a-\x81Wa-\x80ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a-\x9CWa-\x9Bad\x82V[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a-\xB7Wa-\xB6ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a-\xD2Wa-\xD1ad\x82V[[`\xFF\x16`\x01\x90\x1Ba-\xE3\x91\x90ad\xDCV[a-\xED\x91\x90ad\xDCV[a-\xF7\x91\x90ad\xDCV[a.\x01\x91\x90ad\xDCV[a.\x0B\x91\x90ad\xDCV[\x90P_a.\x18\x86\x83aB\xF8V[\x90Pa.(`\t\x87\x87\x87\x85aC^V[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x1E\xD9\x1F\xF6\x82\x86\x89\x89\x88`@Q\x86c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a.\x7F\x95\x94\x93\x92\x91\x90aedV[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a.\x96W_\x80\xFD[PZ\xF1\x15\x80\x15a.\xA8W=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F2B \xBF\xC9\xCB\x15\x8BI)\x91\xC0<0\x9C\xD8nSE\xCA\xC4Z\xAC\xAE \x92\xDD\xAB\xE3\x1F\xA3\xD8\x87\x87\x87\x87`@Qa.\xF8\x94\x93\x92\x91\x90ae\xB5V[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_\x80`\x08`S\x81\x11\x15a/\x1FWa/\x1Ead\x82V[[`\xFF\x16`\x01\x90\x1B`\x07`S\x81\x11\x15a/:Wa/9ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x06`S\x81\x11\x15a/UWa/Tad\x82V[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a/pWa/oad\x82V[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a/\x8BWa/\x8Aad\x82V[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a/\xA6Wa/\xA5ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a/\xC1Wa/\xC0ad\x82V[[`\xFF\x16`\x01\x90\x1B_`S\x81\x11\x15a/\xDBWa/\xDAad\x82V[[`\xFF\x16`\x01\x90\x1Ba/\xEC\x91\x90ad\xDCV[a/\xF6\x91\x90ad\xDCV[a0\0\x91\x90ad\xDCV[a0\n\x91\x90ad\xDCV[a0\x14\x91\x90ad\xDCV[a0\x1E\x91\x90ad\xDCV[a0(\x91\x90ad\xDCV[\x90P_\x81\x84`S\x81\x11\x15a0?Wa0>ad\x82V[[`\xFF\x16`\x01\x90\x1B\x16\x03a0~W`@Q\x7F\xC6\xDEFj\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x18\x84\x84sP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]F`@Q` \x01a0\xAC\x95\x94\x93\x92\x91\x90al\x82V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x91Pa0\xCE\x82\x84aG\x90V[\x91Pa0\xD8aH\tV[s#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c4\x8C1\x85\x84\x84`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a1'\x92\x91\x90al\xE0V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a1>W_\x80\xFD[PZ\xF1\x15\x80\x15a1PW=_\x80>=_\xFD[PPPPsP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c>9\\\xEC\x833`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a1\xA3\x92\x91\x90ag\x01V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a1\xBAW_\x80\xFD[PZ\xF1\x15\x80\x15a1\xCCW=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\x06<\xCD\x1B\xBAE\x15\x1D\x91\xF6\xA4\x18\x06PG\xA3\xD0H\xD0X\xA9\"SWG\xBB+WZ\x01\xD26\x85\x85\x85`@Qa2\x1A\x93\x92\x91\x90am\x07V[`@Q\x80\x91\x03\x90\xA2P\x92\x91PPV[_s6w!B\xB7Hq\xF2U\xCB\xD7\xA3\xE8\x9B@\x1D>E\x82_\x90P\x90V[`@Q\x80`@\x01`@R\x80`\x05\x81R` \x01\x7F5.0.0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81RP\x81V[_\x80`\x08`S\x81\x11\x15a2\x93Wa2\x92ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x06`S\x81\x11\x15a2\xAEWa2\xADad\x82V[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a2\xC9Wa2\xC8ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a2\xE4Wa2\xE3ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a2\xFFWa2\xFEad\x82V[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a3\x1AWa3\x19ad\x82V[[`\xFF\x16`\x01\x90\x1Ba3+\x91\x90ad\xDCV[a35\x91\x90ad\xDCV[a3?\x91\x90ad\xDCV[a3I\x91\x90ad\xDCV[a3S\x91\x90ad\xDCV[\x90P_a3`\x86\x83aB\xF8V[\x90Pa3p`\x0B\x87\x87\x87\x85aC^V[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16cf\x91\x81\xC0\x82\x86\x89\x89\x88`@Q\x86c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a3\xC7\x95\x94\x93\x92\x91\x90aedV[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a3\xDEW_\x80\xFD[PZ\xF1\x15\x80\x15a3\xF0W=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xC1HgY\x05\xD0z\xD5Io\x8E\xF4\xD8\x19\\\x90u\x03\xF3\xEC\x12\xFD\x10\xED_!$\n\xBCi64\x87\x87\x87\x87`@Qa4@\x94\x93\x92\x91\x90ae\xB5V[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_\x80`\x08`S\x81\x11\x15a4gWa4fad\x82V[[`\xFF\x16`\x01\x90\x1B`\x06`S\x81\x11\x15a4\x82Wa4\x81ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a4\x9DWa4\x9Cad\x82V[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a4\xB8Wa4\xB7ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a4\xD3Wa4\xD2ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a4\xEEWa4\xEDad\x82V[[`\xFF\x16`\x01\x90\x1Ba4\xFF\x91\x90ad\xDCV[a5\t\x91\x90ad\xDCV[a5\x13\x91\x90ad\xDCV[a5\x1D\x91\x90ad\xDCV[a5'\x91\x90ad\xDCV[\x90P_a54\x86\x83aB\xF8V[\x90Pa5D`\x08\x87\x87\x87\x85aC^V[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x83\xE6\xA7 \x82\x86\x89\x89\x88`@Q\x86c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a5\x9B\x95\x94\x93\x92\x91\x90aedV[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a5\xB2W_\x80\xFD[PZ\xF1\x15\x80\x15a5\xC4W=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xE8B\x82\xAA\xEB\xCC\xA6\x98D>9\xA2\xA9H\xA3E\xD0\xD2\xEB\xC6T\xAF\\\xB6W\xA2\xD7\xE8\x05;\xF6\xCB\x87\x87\x87\x87`@Qa6\x14\x94\x93\x92\x91\x90ae\xB5V[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_`\x01`\xF8\x1B\x82~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x14a6\x85W`@Q\x7FO\"NS\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x80\x1B\x83\x03a6\xC0W`@Q\x7F#\xD3Y\xA3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\x06`S\x81\x11\x15a6\xD5Wa6\xD4ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a6\xF0Wa6\xEFad\x82V[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a7\x0BWa7\nad\x82V[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a7&Wa7%ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a7AWa7@ad\x82V[[`\xFF\x16`\x01\x90\x1Ba7R\x91\x90ad\xDCV[a7\\\x91\x90ad\xDCV[a7f\x91\x90ad\xDCV[a7p\x91\x90ad\xDCV[\x90P_a7}\x86\x83aB\xF8V[\x90Pa7\x8D`\x04\x87\x87\x87\x85aC^V[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xFA\x08\xE3\x8D\x82\x86\x89\x89\x88`@Q\x86c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a7\xE4\x95\x94\x93\x92\x91\x90aedV[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a7\xFBW_\x80\xFD[PZ\xF1\x15\x80\x15a8\rW=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\x0Ei\x1C\xD0\xBF\x8CN\x93\x08\xE4\xCE\xD1\xBB\x9C\x96A\x17\xDC\\[\xB9\xB9\xAB[\xDF\xEB\xF2\xC9\xB1:\x89|\x87\x87\x87\x87`@Qa8]\x94\x93\x92\x91\x90ae\xB5V[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_\x80`\x08`S\x81\x11\x15a8\x84Wa8\x83ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x06`S\x81\x11\x15a8\x9FWa8\x9Ead\x82V[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a8\xBAWa8\xB9ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a8\xD5Wa8\xD4ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a8\xF0Wa8\xEFad\x82V[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a9\x0BWa9\nad\x82V[[`\xFF\x16`\x01\x90\x1Ba9\x1C\x91\x90ad\xDCV[a9&\x91\x90ad\xDCV[a90\x91\x90ad\xDCV[a9:\x91\x90ad\xDCV[a9D\x91\x90ad\xDCV[\x90P_a9Q\x84\x83aB\xF8V[\x90Pa9^`\x14\x85aS\xB8V[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xA4\xC9\x8F>\x82\x86\x86`@Q\x84c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a9\xB1\x93\x92\x91\x90aj\xBDV[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a9\xC8W_\x80\xFD[PZ\xF1\x15\x80\x15a9\xDAW=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\x8CfM<<\xA5\x83\xFCX\x03\xB8\xA9\x1CIdK\xBD\x95P\xBF\xA8yg\xC7:\xD1\xDE\x83\x02wh\xC0\x85\x85`@Qa:&\x92\x91\x90am<V[`@Q\x80\x91\x03\x90\xA2PP\x91\x90PV[_\x80a:?aH\xD0V[\x90Pa:K\x83\x82aUpV[\x91P3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\x0C\x8A\xCA`\x17\x003&\x05\x1E\x19\x91>\xF0&1\xF2K\x80\x11%\xE1\xFA\x8A\x1D\x81.\x86\x83\x19\xFD\xA6\x84\x83\x85`@Qa:\x97\x93\x92\x91\x90amcV[`@Q\x80\x91\x03\x90\xA2P\x91\x90PV[_\x80`\x08`S\x81\x11\x15a:\xBBWa:\xBAad\x82V[[`\xFF\x16`\x01\x90\x1B`\x07`S\x81\x11\x15a:\xD6Wa:\xD5ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x06`S\x81\x11\x15a:\xF1Wa:\xF0ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a;\x0CWa;\x0Bad\x82V[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a;'Wa;&ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a;BWa;Aad\x82V[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a;]Wa;\\ad\x82V[[`\xFF\x16`\x01\x90\x1B_`S\x81\x11\x15a;wWa;vad\x82V[[`\xFF\x16`\x01\x90\x1Ba;\x88\x91\x90ad\xDCV[a;\x92\x91\x90ad\xDCV[a;\x9C\x91\x90ad\xDCV[a;\xA6\x91\x90ad\xDCV[a;\xB0\x91\x90ad\xDCV[a;\xBA\x91\x90ad\xDCV[a;\xC4\x91\x90ad\xDCV[\x90P_a;\xD1\x86\x83aB\xF8V[\x90Pa;\xE1`\r\x87\x87\x87_aC^V[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xFA]\xEF\xDB\x82\x86\x89\x89\x88`@Q\x86c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a<8\x95\x94\x93\x92\x91\x90aedV[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a<OW_\x80\xFD[PZ\xF1\x15\x80\x15a<aW=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7Fi`\xC1\xE8\x8Fa\xC3R\xDB\xA3M\x1B\xBFgS\xE3\x02yRd\xD5\xD8\xAE\x82\xF7\x98<p\x04e\x1E]\x87\x87\x87\x87`@Qa<\xB1\x94\x93\x92\x91\x90ae\xB5V[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_\x80`\x08`S\x81\x11\x15a<\xD8Wa<\xD7ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x06`S\x81\x11\x15a<\xF3Wa<\xF2ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a=\x0EWa=\rad\x82V[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a=)Wa=(ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a=DWa=Cad\x82V[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a=_Wa=^ad\x82V[[`\xFF\x16`\x01\x90\x1B_`S\x81\x11\x15a=yWa=xad\x82V[[`\xFF\x16`\x01\x90\x1Ba=\x8A\x91\x90ad\xDCV[a=\x94\x91\x90ad\xDCV[a=\x9E\x91\x90ad\xDCV[a=\xA8\x91\x90ad\xDCV[a=\xB2\x91\x90ad\xDCV[a=\xBC\x91\x90ad\xDCV[\x90P_a=\xC9\x86\x83aB\xF8V[\x90Pa=\xD9`\x05\x87\x87\x87\x85aC^V[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x18V\xD9\x1D\x82\x86\x89\x89\x88`@Q\x86c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a>0\x95\x94\x93\x92\x91\x90aedV[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a>GW_\x80\xFD[PZ\xF1\x15\x80\x15a>YW=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xE4$\x86\xB0\xCC\xDB\xEF\x81\xA2\x07\\H\xC8\xE5\x15\xC0y\xAE\xA7<\x8B\x82B\x99\x97\xC7*/\xE1\xBFO\xEF\x87\x87\x87\x87`@Qa>\xA9\x94\x93\x92\x91\x90ae\xB5V[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_s#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9\x90P\x90V[_\x80`\x08`S\x81\x11\x15a>\xEBWa>\xEAad\x82V[[`\xFF\x16`\x01\x90\x1B`\x06`S\x81\x11\x15a?\x06Wa?\x05ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15a?!Wa? ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15a?<Wa?;ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15a?WWa?Vad\x82V[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15a?rWa?qad\x82V[[`\xFF\x16`\x01\x90\x1B_`S\x81\x11\x15a?\x8CWa?\x8Bad\x82V[[`\xFF\x16`\x01\x90\x1Ba?\x9D\x91\x90ad\xDCV[a?\xA7\x91\x90ad\xDCV[a?\xB1\x91\x90ad\xDCV[a?\xBB\x91\x90ad\xDCV[a?\xC5\x91\x90ad\xDCV[a?\xCF\x91\x90ad\xDCV[\x90P_a?\xDC\x84\x83aB\xF8V[\x90Pa?\xE9`\x15\x85aS\xB8V[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xFC\x06<b\x82\x86\x86`@Q\x84c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a@<\x93\x92\x91\x90aj\xBDV[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a@SW_\x80\xFD[PZ\xF1\x15\x80\x15a@eW=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7FU\xAF\xF4\xCCz=\x16\x0C\x83\xF1\xF1[\x81\x80\x11\xED\xE8A\xA0\xB4Y\x7F\xB1M\xCD6\x03\xDF:\x11\xE5\xE0\x85\x85`@Qa@\xB1\x92\x91\x90am<V[`@Q\x80\x91\x03\x90\xA2PP\x91\x90PV[_sP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]\x90P\x90V[_\x80`\x08`S\x81\x11\x15a@\xF1Wa@\xF0ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x07`S\x81\x11\x15aA\x0CWaA\x0Bad\x82V[[`\xFF\x16`\x01\x90\x1B`\x06`S\x81\x11\x15aA'WaA&ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15aABWaAAad\x82V[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15aA]WaA\\ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15aAxWaAwad\x82V[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15aA\x93WaA\x92ad\x82V[[`\xFF\x16`\x01\x90\x1B_`S\x81\x11\x15aA\xADWaA\xACad\x82V[[`\xFF\x16`\x01\x90\x1BaA\xBE\x91\x90ad\xDCV[aA\xC8\x91\x90ad\xDCV[aA\xD2\x91\x90ad\xDCV[aA\xDC\x91\x90ad\xDCV[aA\xE6\x91\x90ad\xDCV[aA\xF0\x91\x90ad\xDCV[aA\xFA\x91\x90ad\xDCV[\x90P_aB\x07\x86\x83aB\xF8V[\x90PaB\x17`\x0C\x87\x87\x87_aC^V[\x92Ps#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x94\xE7\x0EO\x82\x86\x89\x89\x88`@Q\x86c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01aBn\x95\x94\x93\x92\x91\x90aedV[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15aB\x85W_\x80\xFD[PZ\xF1\x15\x80\x15aB\x97W=_\x80>=_\xFD[PPPP3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xB3\xD5\xC6d\xEC\x86WX\x18\xE8\xD7_\xF2\\_\x86rP\xDF\x89T\x08\x85I\xC4\x1C\x84\x8C\xD1\x0Ev\xCB\x87\x87\x87\x87`@QaB\xE7\x94\x93\x92\x91\x90ae\xB5V[`@Q\x80\x91\x03\x90\xA2PP\x93\x92PPPV[_aC\x02\x83aF\x8EV[\x90P_\x82\x82`S\x81\x11\x15aC\x19WaC\x18ad\x82V[[`\xFF\x16`\x01\x90\x1B\x16\x03aCXW`@Q\x7F\xC6\xDEFj\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x92\x91PPV[_aCgaH\tV[aCp\x83aX\x01V[sP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x82\x02{m\x863`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01aC\xBF\x92\x91\x90ag\x01V[` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15aC\xDAW=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90aC\xFE\x91\x90ah\xE1V[aDAW\x843`@Q\x7F\x9D\xE39,\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aD8\x92\x91\x90ag\x01V[`@Q\x80\x91\x03\x90\xFD[_`\xF8\x1B\x83~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x03aE\xB6WsP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x82\x02{m\x853`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01aD\xBC\x92\x91\x90ag\x01V[` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15aD\xD7W=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90aD\xFB\x91\x90ah\xE1V[aE>W\x833`@Q\x7F\x9D\xE39,\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aE5\x92\x91\x90ag\x01V[`@Q\x80\x91\x03\x90\xFD[_aEH\x85aF\x8EV[\x90P_aET\x87aF\x8EV[\x90P\x81`S\x81\x11\x15aEiWaEhad\x82V[[\x81`S\x81\x11\x15aE|WaE{ad\x82V[[\x14aE\xB3W`@Q\x7F\x1F1X\xC7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[PP[\x85\x85\x85\x85sP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]F`@Q` \x01aE\xE5\x96\x95\x94\x93\x92\x91\x90am\xB8V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x90PaF\x07\x81\x83aG\x90V[\x90PsP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c>9\\\xEC\x823`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01aFX\x92\x91\x90ag\x01V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15aFoW_\x80\xFD[PZ\xF1\x15\x80\x15aF\x81W=_\x80>=_\xFD[PPPP\x95\x94PPPPPV[_\x81`\x1E` \x81\x10aF\xA3WaF\xA2an'V[[\x1A`\xF8\x1B`\xF8\x1C`\xFF\x16`S\x81\x11\x15aF\xBFWaF\xBEad\x82V[[\x90P\x91\x90PV[``_`\x01aF\xD4\x84aXEV[\x01\x90P_\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15aF\xF2WaF\xF1a`\x16V[[`@Q\x90\x80\x82R\x80`\x1F\x01`\x1F\x19\x16` \x01\x82\x01`@R\x80\x15aG$W\x81` \x01`\x01\x82\x02\x806\x837\x80\x82\x01\x91PP\x90P[P\x90P_\x82` \x01\x82\x01\x90P[`\x01\x15aG\x85W\x80\x80`\x01\x90\x03\x91PP\x7F0123456789abcdef\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\n\x86\x06\x1A\x81S`\n\x85\x81aGzWaGyanTV[[\x04\x94P_\x85\x03aG1W[\x81\x93PPPP\x91\x90PV[_\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0_\x1B\x83\x16\x90P`P`\xFF_\x1B\x90\x1B\x81\x17\x90P`\x10Fg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16_\x1B\x90\x1B\x81\x17\x90P`\x08\x82`S\x81\x11\x15aG\xEEWaG\xEDad\x82V[[`\xFF\x16_\x1B\x90\x1B\x81\x17\x90P_`\xFF\x16_\x1B\x81\x17\x90P\x92\x91PPV[s#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16cg\xA7E{3`@Q\x82c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01aHV\x91\x90ad\x13V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15aHmW_\x80\xFD[PZ\xF1\x15\x80\x15aH\x7FW=_\x80>=_\xFD[PPPPV[_aH\x8EaH\xA9V[_\x01_\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P\x90V[_\x7F\xF0\xC5~\x16\x84\r\xF0@\xF1P\x88\xDC/\x81\xFE9\x1C9#\xBE\xC7>#\xA9f.\xFC\x9C\"\x9Cj\0\x90P\x90V[_\x80aH\xDAaY\x96V[\x90P\x80_\x01TsP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]F`\x01CaI\x03\x91\x90an\x81V[@B`@Q` \x01aI\x19\x95\x94\x93\x92\x91\x90an\xB4V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x91P\x80_\x01_\x81T\x80\x92\x91\x90aID\x90ao\x12V[\x91\x90PUPP\x90V[_\x80`\x08`S\x81\x11\x15aIcWaIbad\x82V[[`\xFF\x16`\x01\x90\x1B`\x06`S\x81\x11\x15aI~WaI}ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15aI\x99WaI\x98ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15aI\xB4WaI\xB3ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15aI\xCFWaI\xCEad\x82V[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15aI\xEAWaI\xE9ad\x82V[[`\xFF\x16`\x01\x90\x1BaI\xFB\x91\x90ad\xDCV[aJ\x05\x91\x90ad\xDCV[aJ\x0F\x91\x90ad\xDCV[aJ\x19\x91\x90ad\xDCV[aJ#\x91\x90ad\xDCV[\x90P_\x81\x85`S\x81\x11\x15aJ:WaJ9ad\x82V[[`\xFF\x16`\x01\x90\x1B\x16\x03aJyW`@Q\x7F\xC6\xDEFj\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[aJ\x82\x85aY\xBDV[aJ\xB8W`@Q\x7F$\xE8\xE7B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[aJ\xC2\x85\x85aY\xE1V[`\x1B\x85\x85\x85`@Q` \x01aJ\xDA\x94\x93\x92\x91\x90aoyV[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x91PaJ\xFC\x82\x85aG\x90V[\x91PaK\x06aH\tV[s#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xCC\x86g\x82\x85\x84`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01aKU\x92\x91\x90al\xE0V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15aKlW_\x80\xFD[PZ\xF1\x15\x80\x15aK~W=_\x80>=_\xFD[PPPPsP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c>9\\\xEC\x833`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01aK\xD1\x92\x91\x90ag\x01V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15aK\xE8W_\x80\xFD[PZ\xF1\x15\x80\x15aK\xFAW=_\x80>=_\xFD[PPPPP\x93\x92PPPV[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x160s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14\x80aL\xB3WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16aL\x9Aa[1V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14\x15[\x15aL\xEAW`@Q\x7F\xE0|\x8D\xBA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[V[sP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x8D\xA5\xCB[`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15aMIW=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90aMm\x91\x90ao\xDAV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14aM\xDCW3`@Q\x7F!\xBF\xDA\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aM\xD3\x91\x90ad\x13V[`@Q\x80\x91\x03\x90\xFD[PV[\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16cR\xD1\x90-`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x92PPP\x80\x15aNGWP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90aND\x91\x90af\xD6V[`\x01[aN\x88W\x81`@Q\x7FL\x9C\x8C\xE3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aN\x7F\x91\x90ad\x13V[`@Q\x80\x91\x03\x90\xFD[\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC_\x1B\x81\x14aN\xEEW\x80`@Q\x7F\xAA\x1DI\xA4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aN\xE5\x91\x90a_\x8BV[`@Q\x80\x91\x03\x90\xFD[aN\xF8\x83\x83a[\x84V[PPPV[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x160s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14aO\x82W`@Q\x7F\xE0|\x8D\xBA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[V[_aO\x8DaH\tV[sP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x82\x02{m\x853`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01aO\xDC\x92\x91\x90ag\x01V[` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15aO\xF7W=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90aP\x1B\x91\x90ah\xE1V[aP^W\x833`@Q\x7F\x9D\xE39,\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aPU\x92\x91\x90ag\x01V[`@Q\x80\x91\x03\x90\xFD[sP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x82\x02{m\x843`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01aP\xAD\x92\x91\x90ag\x01V[` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15aP\xC8W=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90aP\xEC\x91\x90ah\xE1V[aQ/W\x823`@Q\x7F\x9D\xE39,\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aQ&\x92\x91\x90ag\x01V[`@Q\x80\x91\x03\x90\xFD[sP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x82\x02{m\x833`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01aQ~\x92\x91\x90ag\x01V[` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15aQ\x99W=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90aQ\xBD\x91\x90ah\xE1V[aR\0W\x813`@Q\x7F\x9D\xE39,\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aQ\xF7\x92\x91\x90ag\x01V[`@Q\x80\x91\x03\x90\xFD[_aR\n\x85aF\x8EV[\x90P_aR\x16\x85aF\x8EV[\x90P_aR\"\x85aF\x8EV[\x90P_`S\x81\x11\x15aR7WaR6ad\x82V[[\x83`S\x81\x11\x15aRJWaRIad\x82V[[\x14aR\x81W`@Q\x7F\xC6\xDEFj\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x80`S\x81\x11\x15aR\x94WaR\x93ad\x82V[[\x82`S\x81\x11\x15aR\xA7WaR\xA6ad\x82V[[\x14aR\xDEW`@Q\x7F\x1F1X\xC7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x87\x87\x87\x87sP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]F`@Q` \x01aS\r\x96\x95\x94\x93\x92\x91\x90ap\x05V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x93PaS/\x84\x83aG\x90V[\x93PsP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c>9\\\xEC\x853`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01aS\x80\x92\x91\x90ag\x01V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15aS\x97W_\x80\xFD[PZ\xF1\x15\x80\x15aS\xA9W=_\x80>=_\xFD[PPPPPPP\x94\x93PPPPV[_aS\xC1aH\tV[sP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x82\x02{m\x833`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01aT\x10\x92\x91\x90ag\x01V[` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15aT+W=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90aTO\x91\x90ah\xE1V[aT\x92W\x813`@Q\x7F\x9D\xE39,\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aT\x89\x92\x91\x90ag\x01V[`@Q\x80\x91\x03\x90\xFD[\x82\x82sP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]F`@Q` \x01aT\xBD\x94\x93\x92\x91\x90aptV[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x90P_aT\xDF\x83aF\x8EV[\x90PaT\xEB\x82\x82aG\x90V[\x91PsP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c>9\\\xEC\x833`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01aU<\x92\x91\x90ag\x01V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15aUSW_\x80\xFD[PZ\xF1\x15\x80\x15aUeW=_\x80>=_\xFD[PPPPP\x92\x91PPV[_\x80`\x08`S\x81\x11\x15aU\x86WaU\x85ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x06`S\x81\x11\x15aU\xA1WaU\xA0ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x05`S\x81\x11\x15aU\xBCWaU\xBBad\x82V[[`\xFF\x16`\x01\x90\x1B`\x04`S\x81\x11\x15aU\xD7WaU\xD6ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x03`S\x81\x11\x15aU\xF2WaU\xF1ad\x82V[[`\xFF\x16`\x01\x90\x1B`\x02`S\x81\x11\x15aV\rWaV\x0Cad\x82V[[`\xFF\x16`\x01\x90\x1B_`S\x81\x11\x15aV'WaV&ad\x82V[[`\xFF\x16`\x01\x90\x1BaV8\x91\x90ad\xDCV[aVB\x91\x90ad\xDCV[aVL\x91\x90ad\xDCV[aVV\x91\x90ad\xDCV[aV`\x91\x90ad\xDCV[aVj\x91\x90ad\xDCV[\x90P_\x81\x85`S\x81\x11\x15aV\x81WaV\x80ad\x82V[[`\xFF\x16`\x01\x90\x1B\x16\x03aV\xC0W`@Q\x7F\xC6\xDEFj\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x1A\x84\x84`@Q` \x01aV\xD6\x93\x92\x91\x90ap\xC1V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x91PaV\xF8\x82\x85aG\x90V[\x91PaW\x02aH\tV[s#?\xF8\x8AH\xC1r\xD2\x9FgT\x03\xE6\xA8\xE3\x02\xB0\xF02\xD9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\t\xB0N\x8F\x85\x84`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01aWQ\x92\x91\x90al\xE0V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15aWhW_\x80\xFD[PZ\xF1\x15\x80\x15aWzW=_\x80>=_\xFD[PPPPsP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c>9\\\xEC\x833`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01aW\xCD\x92\x91\x90ag\x01V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15aW\xE4W_\x80\xFD[PZ\xF1\x15\x80\x15aW\xF6W=_\x80>=_\xFD[PPPPP\x92\x91PPV[`\x01\x81`\xF8\x1C`\xFF\x16\x11\x15aXBW`@Q\x7F\xDF{\xF3%\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[PV[_\x80_\x90Pz\x18O\x03\xE9?\xF9\xF4\xDA\xA7\x97\xEDn8\xEDd\xBFj\x1F\x01\0\0\0\0\0\0\0\0\x83\x10aX\xA1Wz\x18O\x03\xE9?\xF9\xF4\xDA\xA7\x97\xEDn8\xEDd\xBFj\x1F\x01\0\0\0\0\0\0\0\0\x83\x81aX\x97WaX\x96anTV[[\x04\x92P`@\x81\x01\x90P[m\x04\xEE-mA[\x85\xAC\xEF\x81\0\0\0\0\x83\x10aX\xDEWm\x04\xEE-mA[\x85\xAC\xEF\x81\0\0\0\0\x83\x81aX\xD4WaX\xD3anTV[[\x04\x92P` \x81\x01\x90P[f#\x86\xF2o\xC1\0\0\x83\x10aY\rWf#\x86\xF2o\xC1\0\0\x83\x81aY\x03WaY\x02anTV[[\x04\x92P`\x10\x81\x01\x90P[c\x05\xF5\xE1\0\x83\x10aY6Wc\x05\xF5\xE1\0\x83\x81aY,WaY+anTV[[\x04\x92P`\x08\x81\x01\x90P[a'\x10\x83\x10aY[Wa'\x10\x83\x81aYQWaYPanTV[[\x04\x92P`\x04\x81\x01\x90P[`d\x83\x10aY~W`d\x83\x81aYtWaYsanTV[[\x04\x92P`\x02\x81\x01\x90P[`\n\x83\x10aY\x8DW`\x01\x81\x01\x90P[\x80\x91PP\x91\x90PV[_\x7FF\x13\xE1w\x1Fku]$>So\xB5\xA2<[\x15\xE2\x82eu\xFE\xE9!\xE8\xFEz\"\xA7`\xC8\0\x90P\x90V[_\x80\x82\x11\x80\x15aY\xDAWP_`\x01\x83aY\xD6\x91\x90an\x81V[\x83\x16\x14[\x90P\x91\x90PV[`\x02`S\x81\x11\x15aY\xF5WaY\xF4ad\x82V[[\x81`S\x81\x11\x15aZ\x08WaZ\x07ad\x82V[[\x03aZ\x1EWaZ\x19\x82a\x01\0a[\xF6V[a[-V[`\x03`S\x81\x11\x15aZ2WaZ1ad\x82V[[\x81`S\x81\x11\x15aZEWaZDad\x82V[[\x03aZ\\WaZW\x82b\x01\0\0a[\xF6V[a[-V[`\x04`S\x81\x11\x15aZpWaZoad\x82V[[\x81`S\x81\x11\x15aZ\x83WaZ\x82ad\x82V[[\x03aZ\x9CWaZ\x97\x82d\x01\0\0\0\0a[\xF6V[a[-V[`\x05`S\x81\x11\x15aZ\xB0WaZ\xAFad\x82V[[\x81`S\x81\x11\x15aZ\xC3WaZ\xC2ad\x82V[[\x03aZ\xE0WaZ\xDB\x82h\x01\0\0\0\0\0\0\0\0a[\xF6V[a[-V[`\x06`S\x81\x11\x15aZ\xF4WaZ\xF3ad\x82V[[\x81`S\x81\x11\x15a[\x07Wa[\x06ad\x82V[[\x03a[,Wa['\x82p\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a[\xF6V[a[-V[[PPV[_a[]\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC_\x1Ba\\4V[_\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P\x90V[a[\x8D\x82a\\=V[\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xBC|\xD7Z \xEE'\xFD\x9A\xDE\xBA\xB3 A\xF7U!M\xBCk\xFF\xA9\x0C\xC0\"[9\xDA.\\-;`@Q`@Q\x80\x91\x03\x90\xA2_\x81Q\x11\x15a[\xE9Wa[\xE3\x82\x82a]\x06V[Pa[\xF2V[a[\xF1a]\x86V[[PPV[\x80\x82\x11\x15a\\0W`@Q\x7F\xC7\xDA\xDFE\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[PPV[_\x81\x90P\x91\x90PV[_\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16;\x03a\\\x98W\x80`@Q\x7FL\x9C\x8C\xE3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\\\x8F\x91\x90ad\x13V[`@Q\x80\x91\x03\x90\xFD[\x80a\\\xC4\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC_\x1Ba\\4V[_\x01_a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UPPV[``_\x80\x84s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x84`@Qa]/\x91\x90aq7V[_`@Q\x80\x83\x03\x81\x85Z\xF4\x91PP=\x80_\x81\x14a]gW`@Q\x91P`\x1F\x19`?=\x01\x16\x82\x01`@R=\x82R=_` \x84\x01>a]lV[``\x91P[P\x91P\x91Pa]|\x85\x83\x83a]\xC2V[\x92PPP\x92\x91PPV[_4\x11\x15a]\xC0W`@Q\x7F\xB3\x98\x97\x9F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[V[``\x82a]\xD7Wa]\xD2\x82a^OV[a^GV[_\x82Q\x14\x80\x15a]\xFDWP_\x84s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16;\x14[\x15a^?W\x83`@Q\x7F\x99\x96\xB3\x15\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a^6\x91\x90ad\x13V[`@Q\x80\x91\x03\x90\xFD[\x81\x90Pa^HV[[\x93\x92PPPV[_\x81Q\x11\x15a^aW\x80Q\x80\x82` \x01\xFD[`@Q\x7F\xD6\xBD\xA2u\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`@Q\x90P\x90V[_\x80\xFD[_\x80\xFD[_\x81\x90P\x91\x90PV[a^\xB6\x81a^\xA4V[\x81\x14a^\xC0W_\x80\xFD[PV[_\x815\x90Pa^\xD1\x81a^\xADV[\x92\x91PPV[_\x7F\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\x16\x90P\x91\x90PV[a_\x0B\x81a^\xD7V[\x81\x14a_\x15W_\x80\xFD[PV[_\x815\x90Pa_&\x81a_\x02V[\x92\x91PPV[_\x80_``\x84\x86\x03\x12\x15a_CWa_Ba^\x9CV[[_a_P\x86\x82\x87\x01a^\xC3V[\x93PP` a_a\x86\x82\x87\x01a^\xC3V[\x92PP`@a_r\x86\x82\x87\x01a_\x18V[\x91PP\x92P\x92P\x92V[a_\x85\x81a^\xA4V[\x82RPPV[_` \x82\x01\x90Pa_\x9E_\x83\x01\x84a_|V[\x92\x91PPV[_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[_a_\xCD\x82a_\xA4V[\x90P\x91\x90PV[a_\xDD\x81a_\xC3V[\x81\x14a_\xE7W_\x80\xFD[PV[_\x815\x90Pa_\xF8\x81a_\xD4V[\x92\x91PPV[_\x80\xFD[_\x80\xFD[_`\x1F\x19`\x1F\x83\x01\x16\x90P\x91\x90PV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`A`\x04R`$_\xFD[a`L\x82a`\x06V[\x81\x01\x81\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17\x15a`kWa`ja`\x16V[[\x80`@RPPPV[_a`}a^\x93V[\x90Pa`\x89\x82\x82a`CV[\x91\x90PV[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15a`\xA8Wa`\xA7a`\x16V[[a`\xB1\x82a`\x06V[\x90P` \x81\x01\x90P\x91\x90PV[\x82\x81\x837_\x83\x83\x01RPPPV[_a`\xDEa`\xD9\x84a`\x8EV[a`tV[\x90P\x82\x81R` \x81\x01\x84\x84\x84\x01\x11\x15a`\xFAWa`\xF9a`\x02V[[aa\x05\x84\x82\x85a`\xBEV[P\x93\x92PPPV[_\x82`\x1F\x83\x01\x12aa!Waa a_\xFEV[[\x815aa1\x84\x82` \x86\x01a`\xCCV[\x91PP\x92\x91PPV[`T\x81\x10aaFW_\x80\xFD[PV[_\x815\x90PaaW\x81aa:V[\x92\x91PPV[_\x80_\x80`\x80\x85\x87\x03\x12\x15aauWaata^\x9CV[[_aa\x82\x87\x82\x88\x01a^\xC3V[\x94PP` aa\x93\x87\x82\x88\x01a_\xEAV[\x93PP`@\x85\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15aa\xB4Waa\xB3a^\xA0V[[aa\xC0\x87\x82\x88\x01aa\rV[\x92PP``aa\xD1\x87\x82\x88\x01aaIV[\x91PP\x92\x95\x91\x94P\x92PV[_\x81Q\x90P\x91\x90PV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[_[\x83\x81\x10\x15ab\x14W\x80\x82\x01Q\x81\x84\x01R` \x81\x01\x90Paa\xF9V[_\x84\x84\x01RPPPPV[_ab)\x82aa\xDDV[ab3\x81\x85aa\xE7V[\x93PabC\x81\x85` \x86\x01aa\xF7V[abL\x81a`\x06V[\x84\x01\x91PP\x92\x91PPV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Rabo\x81\x84ab\x1FV[\x90P\x92\x91PPV[_\x80`@\x83\x85\x03\x12\x15ab\x8DWab\x8Ca^\x9CV[[_ab\x9A\x85\x82\x86\x01a^\xC3V[\x92PP` ab\xAB\x85\x82\x86\x01aaIV[\x91PP\x92P\x92\x90PV[_\x81\x90P\x91\x90PV[ab\xC7\x81ab\xB5V[\x81\x14ab\xD1W_\x80\xFD[PV[_\x815\x90Pab\xE2\x81ab\xBEV[\x92\x91PPV[_\x80`@\x83\x85\x03\x12\x15ab\xFEWab\xFDa^\x9CV[[_ac\x0B\x85\x82\x86\x01ab\xD4V[\x92PP` ac\x1C\x85\x82\x86\x01aaIV[\x91PP\x92P\x92\x90PV[_\x80`@\x83\x85\x03\x12\x15ac<Wac;a^\x9CV[[_acI\x85\x82\x86\x01a_\xEAV[\x92PP` \x83\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15acjWacia^\xA0V[[acv\x85\x82\x86\x01aa\rV[\x91PP\x92P\x92\x90PV[_\x80_``\x84\x86\x03\x12\x15ac\x97Wac\x96a^\x9CV[[_ac\xA4\x86\x82\x87\x01a^\xC3V[\x93PP` ac\xB5\x86\x82\x87\x01a^\xC3V[\x92PP`@ac\xC6\x86\x82\x87\x01a^\xC3V[\x91PP\x92P\x92P\x92V[_`\xFF\x82\x16\x90P\x91\x90PV[ac\xE5\x81ac\xD0V[\x82RPPV[_` \x82\x01\x90Pac\xFE_\x83\x01\x84ac\xDCV[\x92\x91PPV[ad\r\x81a_\xC3V[\x82RPPV[_` \x82\x01\x90Pad&_\x83\x01\x84ad\x04V[\x92\x91PPV[_` \x82\x84\x03\x12\x15adAWad@a^\x9CV[[_adN\x84\x82\x85\x01a^\xC3V[\x91PP\x92\x91PPV[_` \x82\x84\x03\x12\x15adlWadka^\x9CV[[_ady\x84\x82\x85\x01aaIV[\x91PP\x92\x91PPV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`!`\x04R`$_\xFD[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x11`\x04R`$_\xFD[_ad\xE6\x82ab\xB5V[\x91Pad\xF1\x83ab\xB5V[\x92P\x82\x82\x01\x90P\x80\x82\x11\x15ae\tWae\x08ad\xAFV[[\x92\x91PPV[`T\x81\x10ae Wae\x1Fad\x82V[[PV[_\x81\x90Pae0\x82ae\x0FV[\x91\x90PV[_ae?\x82ae#V[\x90P\x91\x90PV[aeO\x81ae5V[\x82RPPV[ae^\x81a^\xD7V[\x82RPPV[_`\xA0\x82\x01\x90Paew_\x83\x01\x88aeFV[ae\x84` \x83\x01\x87aeUV[ae\x91`@\x83\x01\x86a_|V[ae\x9E``\x83\x01\x85a_|V[ae\xAB`\x80\x83\x01\x84a_|V[\x96\x95PPPPPPV[_`\x80\x82\x01\x90Pae\xC8_\x83\x01\x87a_|V[ae\xD5` \x83\x01\x86a_|V[ae\xE2`@\x83\x01\x85aeUV[ae\xEF``\x83\x01\x84a_|V[\x95\x94PPPPPV[af\x01\x81a_\xC3V[\x82RPPV[`@\x82\x01_\x82\x01Qaf\x1B_\x85\x01\x82ae\xF8V[P` \x82\x01Qaf.` \x85\x01\x82ae\xF8V[PPPPV[_\x81Q\x90P\x91\x90PV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[_afX\x82af4V[afb\x81\x85af>V[\x93Pafr\x81\x85` \x86\x01aa\xF7V[af{\x81a`\x06V[\x84\x01\x91PP\x92\x91PPV[_`\x80\x82\x01\x90Paf\x99_\x83\x01\x86af\x07V[af\xA6`@\x83\x01\x85a_|V[\x81\x81\x03``\x83\x01Raf\xB8\x81\x84afNV[\x90P\x94\x93PPPPV[_\x81Q\x90Paf\xD0\x81a^\xADV[\x92\x91PPV[_` \x82\x84\x03\x12\x15af\xEBWaf\xEAa^\x9CV[[_af\xF8\x84\x82\x85\x01af\xC2V[\x91PP\x92\x91PPV[_`@\x82\x01\x90Pag\x14_\x83\x01\x85a_|V[ag!` \x83\x01\x84ad\x04V[\x93\x92PPPV[_`\xA0\x82\x01\x90Pag;_\x83\x01\x88a_|V[agH` \x83\x01\x87ad\x04V[\x81\x81\x03`@\x83\x01RagZ\x81\x86afNV[\x90Pagi``\x83\x01\x85aeFV[agv`\x80\x83\x01\x84a_|V[\x96\x95PPPPPPV[_\x81\x90P\x92\x91PPV[_ag\x94\x82aa\xDDV[ag\x9E\x81\x85ag\x80V[\x93Pag\xAE\x81\x85` \x86\x01aa\xF7V[\x80\x84\x01\x91PP\x92\x91PPV[\x7F v\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_ag\xEE`\x02\x83ag\x80V[\x91Pag\xF9\x82ag\xBAV[`\x02\x82\x01\x90P\x91\x90PV[\x7F.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_ah8`\x01\x83ag\x80V[\x91PahC\x82ah\x04V[`\x01\x82\x01\x90P\x91\x90PV[_ahY\x82\x87ag\x8AV[\x91Pahd\x82ag\xE2V[\x91Pahp\x82\x86ag\x8AV[\x91Pah{\x82ah,V[\x91Pah\x87\x82\x85ag\x8AV[\x91Pah\x92\x82ah,V[\x91Pah\x9E\x82\x84ag\x8AV[\x91P\x81\x90P\x95\x94PPPPPV[_\x81\x15\x15\x90P\x91\x90PV[ah\xC0\x81ah\xACV[\x81\x14ah\xCAW_\x80\xFD[PV[_\x81Q\x90Pah\xDB\x81ah\xB7V[\x92\x91PPV[_` \x82\x84\x03\x12\x15ah\xF6Wah\xF5a^\x9CV[[_ai\x03\x84\x82\x85\x01ah\xCDV[\x91PP\x92\x91PPV[`\x1C\x81\x10ai\x1DWai\x1Cad\x82V[[PV[_\x81\x90Pai-\x82ai\x0CV[\x91\x90PV[_ai<\x82ai V[\x90P\x91\x90PV[_\x81`\xF8\x1B\x90P\x91\x90PV[_aiY\x82aiCV[\x90P\x91\x90PV[aiqail\x82ai2V[aiOV[\x82RPPV[_\x81\x90P\x91\x90PV[ai\x91ai\x8C\x82a^\xA4V[aiwV[\x82RPPV[ai\xA8ai\xA3\x82ae5V[aiOV[\x82RPPV[_\x81\x90P\x91\x90PV[_ai\xD1ai\xCCai\xC7\x84a_\xA4V[ai\xAEV[a_\xA4V[\x90P\x91\x90PV[_ai\xE2\x82ai\xB7V[\x90P\x91\x90PV[_ai\xF3\x82ai\xD8V[\x90P\x91\x90PV[_\x81``\x1B\x90P\x91\x90PV[_aj\x10\x82ai\xFAV[\x90P\x91\x90PV[_aj!\x82aj\x06V[\x90P\x91\x90PV[aj9aj4\x82ai\xE9V[aj\x17V[\x82RPPV[_\x81\x90P\x91\x90PV[ajYajT\x82ab\xB5V[aj?V[\x82RPPV[_ajj\x82\x88ai`V[`\x01\x82\x01\x91Pajz\x82\x87ai\x80V[` \x82\x01\x91Paj\x8A\x82\x86ai\x97V[`\x01\x82\x01\x91Paj\x9A\x82\x85aj(V[`\x14\x82\x01\x91Paj\xAA\x82\x84ajHV[` \x82\x01\x91P\x81\x90P\x96\x95PPPPPPV[_``\x82\x01\x90Paj\xD0_\x83\x01\x86aeFV[aj\xDD` \x83\x01\x85a_|V[aj\xEA`@\x83\x01\x84a_|V[\x94\x93PPPPV[_``\x82\x01\x90Pak\x05_\x83\x01\x86a_|V[ak\x12` \x83\x01\x85aeFV[ak\x1F`@\x83\x01\x84a_|V[\x94\x93PPPPV[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[akC\x81ak'V[\x82RPPV[_` \x82\x01\x90Pak\\_\x83\x01\x84ak:V[\x92\x91PPV[akk\x81ab\xB5V[\x82RPPV[_\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\x16\x90P\x91\x90PV[ak\xA5\x81akqV[\x82RPPV[_`\x80\x82\x01\x90Pak\xBE_\x83\x01\x87akbV[ak\xCB` \x83\x01\x86aeFV[ak\xD8`@\x83\x01\x85ak\x9CV[ak\xE5``\x83\x01\x84a_|V[\x95\x94PPPPPV[_`\xA0\x82\x01\x90Pal\x01_\x83\x01\x88aeFV[al\x0E` \x83\x01\x87a_|V[al\x1B`@\x83\x01\x86a_|V[al(``\x83\x01\x85a_|V[al5`\x80\x83\x01\x84a_|V[\x96\x95PPPPPPV[_`\x80\x82\x01\x90PalR_\x83\x01\x87a_|V[al_` \x83\x01\x86a_|V[all`@\x83\x01\x85a_|V[aly``\x83\x01\x84a_|V[\x95\x94PPPPPV[_al\x8D\x82\x88ai`V[`\x01\x82\x01\x91Pal\x9D\x82\x87ajHV[` \x82\x01\x91Pal\xAD\x82\x86ai\x97V[`\x01\x82\x01\x91Pal\xBD\x82\x85aj(V[`\x14\x82\x01\x91Pal\xCD\x82\x84ajHV[` \x82\x01\x91P\x81\x90P\x96\x95PPPPPPV[_`@\x82\x01\x90Pal\xF3_\x83\x01\x85aeFV[am\0` \x83\x01\x84a_|V[\x93\x92PPPV[_``\x82\x01\x90Pam\x1A_\x83\x01\x86akbV[am'` \x83\x01\x85aeFV[am4`@\x83\x01\x84a_|V[\x94\x93PPPPV[_`@\x82\x01\x90PamO_\x83\x01\x85a_|V[am\\` \x83\x01\x84a_|V[\x93\x92PPPV[_``\x82\x01\x90Pamv_\x83\x01\x86aeFV[am\x83` \x83\x01\x85ak\x9CV[am\x90`@\x83\x01\x84a_|V[\x94\x93PPPPV[_\x81\x90P\x91\x90PV[am\xB2am\xAD\x82a^\xD7V[am\x98V[\x82RPPV[_am\xC3\x82\x89ai`V[`\x01\x82\x01\x91Pam\xD3\x82\x88ai\x80V[` \x82\x01\x91Pam\xE3\x82\x87ai\x80V[` \x82\x01\x91Pam\xF3\x82\x86am\xA1V[`\x01\x82\x01\x91Pan\x03\x82\x85aj(V[`\x14\x82\x01\x91Pan\x13\x82\x84ajHV[` \x82\x01\x91P\x81\x90P\x97\x96PPPPPPPV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`2`\x04R`$_\xFD[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x12`\x04R`$_\xFD[_an\x8B\x82ab\xB5V[\x91Pan\x96\x83ab\xB5V[\x92P\x82\x82\x03\x90P\x81\x81\x11\x15an\xAEWan\xADad\xAFV[[\x92\x91PPV[_an\xBF\x82\x88ajHV[` \x82\x01\x91Pan\xCF\x82\x87aj(V[`\x14\x82\x01\x91Pan\xDF\x82\x86ajHV[` \x82\x01\x91Pan\xEF\x82\x85ai\x80V[` \x82\x01\x91Pan\xFF\x82\x84ajHV[` \x82\x01\x91P\x81\x90P\x96\x95PPPPPPV[_ao\x1C\x82ab\xB5V[\x91P\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x03aoNWaoMad\xAFV[[`\x01\x82\x01\x90P\x91\x90PV[_\x81\x90P\x91\x90PV[aosaon\x82akqV[aoYV[\x82RPPV[_ao\x84\x82\x87ai`V[`\x01\x82\x01\x91Pao\x94\x82\x86ajHV[` \x82\x01\x91Pao\xA4\x82\x85ai\x97V[`\x01\x82\x01\x91Pao\xB4\x82\x84aobV[`\x10\x82\x01\x91P\x81\x90P\x95\x94PPPPPV[_\x81Q\x90Pao\xD4\x81a_\xD4V[\x92\x91PPV[_` \x82\x84\x03\x12\x15ao\xEFWao\xEEa^\x9CV[[_ao\xFC\x84\x82\x85\x01ao\xC6V[\x91PP\x92\x91PPV[_ap\x10\x82\x89ai`V[`\x01\x82\x01\x91Pap \x82\x88ai\x80V[` \x82\x01\x91Pap0\x82\x87ai\x80V[` \x82\x01\x91Pap@\x82\x86ai\x80V[` \x82\x01\x91PapP\x82\x85aj(V[`\x14\x82\x01\x91Pap`\x82\x84ajHV[` \x82\x01\x91P\x81\x90P\x97\x96PPPPPPPV[_ap\x7F\x82\x87ai`V[`\x01\x82\x01\x91Pap\x8F\x82\x86ai\x80V[` \x82\x01\x91Pap\x9F\x82\x85aj(V[`\x14\x82\x01\x91Pap\xAF\x82\x84ajHV[` \x82\x01\x91P\x81\x90P\x95\x94PPPPPV[_ap\xCC\x82\x86ai`V[`\x01\x82\x01\x91Pap\xDC\x82\x85ai\x97V[`\x01\x82\x01\x91Pap\xEC\x82\x84aobV[`\x10\x82\x01\x91P\x81\x90P\x94\x93PPPPV[_\x81\x90P\x92\x91PPV[_aq\x11\x82af4V[aq\x1B\x81\x85ap\xFDV[\x93Paq+\x81\x85` \x86\x01aa\xF7V[\x80\x84\x01\x91PP\x92\x91PPV[_aqB\x82\x84aq\x07V[\x91P\x81\x90P\x92\x91PPV",
    );
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct FheType(u8);
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<FheType> for u8 {
            #[inline]
            fn stv_to_tokens(
                &self,
            ) -> <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::Token<'_> {
                alloy_sol_types::private::SolTypeValue::<
                    alloy::sol_types::sol_data::Uint<8>,
                >::stv_to_tokens(self)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::tokenize(self)
                    .0
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(self, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::abi_encoded_size(self)
            }
        }
        #[automatically_derived]
        impl FheType {
            /// The Solidity type name.
            pub const NAME: &'static str = stringify!(@ name);
            /// Convert from the underlying value type.
            #[inline]
            pub const fn from_underlying(value: u8) -> Self {
                Self(value)
            }
            /// Return the underlying value.
            #[inline]
            pub const fn into_underlying(self) -> u8 {
                self.0
            }
            /// Return the single encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode(&self.0)
            }
            /// Return the packed encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode_packed(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode_packed(&self.0)
            }
        }
        #[automatically_derived]
        impl From<u8> for FheType {
            fn from(value: u8) -> Self {
                Self::from_underlying(value)
            }
        }
        #[automatically_derived]
        impl From<FheType> for u8 {
            fn from(value: FheType) -> Self {
                value.into_underlying()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for FheType {
            type RustType = u8;
            type Token<'a> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = Self::NAME;
            const ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                Self::type_check(token).is_ok()
            }
            #[inline]
            fn type_check(token: &Self::Token<'_>) -> alloy_sol_types::Result<()> {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::type_check(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::detokenize(token)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for FheType {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::topic_preimage_length(rust)
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(rust, out)
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic(rust)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `ACLNotAllowed(bytes32,address)` and selector `0x9de3392c`.
```solidity
error ACLNotAllowed(bytes32 handle, address account);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ACLNotAllowed {
        #[allow(missing_docs)]
        pub handle: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::Address,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::Address,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ACLNotAllowed> for UnderlyingRustTuple<'_> {
            fn from(value: ACLNotAllowed) -> Self {
                (value.handle, value.account)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ACLNotAllowed {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    handle: tuple.0,
                    account: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ACLNotAllowed {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ACLNotAllowed(bytes32,address)";
            const SELECTOR: [u8; 4] = [157u8, 227u8, 57u8, 44u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.handle),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `AddressEmptyCode(address)` and selector `0x9996b315`.
```solidity
error AddressEmptyCode(address target);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AddressEmptyCode {
        #[allow(missing_docs)]
        pub target: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AddressEmptyCode> for UnderlyingRustTuple<'_> {
            fn from(value: AddressEmptyCode) -> Self {
                (value.target,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for AddressEmptyCode {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { target: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AddressEmptyCode {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AddressEmptyCode(address)";
            const SELECTOR: [u8; 4] = [153u8, 150u8, 179u8, 21u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.target,
                    ),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `DivisionByZero()` and selector `0x23d359a3`.
```solidity
error DivisionByZero();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DivisionByZero;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<DivisionByZero> for UnderlyingRustTuple<'_> {
            fn from(value: DivisionByZero) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for DivisionByZero {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for DivisionByZero {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "DivisionByZero()";
            const SELECTOR: [u8; 4] = [35u8, 211u8, 89u8, 163u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `ERC1967InvalidImplementation(address)` and selector `0x4c9c8ce3`.
```solidity
error ERC1967InvalidImplementation(address implementation);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC1967InvalidImplementation {
        #[allow(missing_docs)]
        pub implementation: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC1967InvalidImplementation>
        for UnderlyingRustTuple<'_> {
            fn from(value: ERC1967InvalidImplementation) -> Self {
                (value.implementation,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ERC1967InvalidImplementation {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { implementation: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC1967InvalidImplementation {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC1967InvalidImplementation(address)";
            const SELECTOR: [u8; 4] = [76u8, 156u8, 140u8, 227u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.implementation,
                    ),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `ERC1967NonPayable()` and selector `0xb398979f`.
```solidity
error ERC1967NonPayable();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC1967NonPayable;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC1967NonPayable> for UnderlyingRustTuple<'_> {
            fn from(value: ERC1967NonPayable) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ERC1967NonPayable {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC1967NonPayable {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC1967NonPayable()";
            const SELECTOR: [u8; 4] = [179u8, 152u8, 151u8, 159u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `FailedCall()` and selector `0xd6bda275`.
```solidity
error FailedCall();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct FailedCall;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<FailedCall> for UnderlyingRustTuple<'_> {
            fn from(value: FailedCall) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for FailedCall {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for FailedCall {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "FailedCall()";
            const SELECTOR: [u8; 4] = [214u8, 189u8, 162u8, 117u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `IncompatibleTypes()` and selector `0x1f3158c7`.
```solidity
error IncompatibleTypes();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct IncompatibleTypes;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<IncompatibleTypes> for UnderlyingRustTuple<'_> {
            fn from(value: IncompatibleTypes) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for IncompatibleTypes {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for IncompatibleTypes {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "IncompatibleTypes()";
            const SELECTOR: [u8; 4] = [31u8, 49u8, 88u8, 199u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidByteLength(uint8,uint256)` and selector `0xb30c0c57`.
```solidity
error InvalidByteLength(FheType typeOf, uint256 length);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidByteLength {
        #[allow(missing_docs)]
        pub typeOf: <FheType as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub length: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (FheType, alloy::sol_types::sol_data::Uint<256>);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            <FheType as alloy::sol_types::SolType>::RustType,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidByteLength> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidByteLength) -> Self {
                (value.typeOf, value.length)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidByteLength {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    typeOf: tuple.0,
                    length: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidByteLength {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidByteLength(uint8,uint256)";
            const SELECTOR: [u8; 4] = [179u8, 12u8, 12u8, 87u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <FheType as alloy_sol_types::SolType>::tokenize(&self.typeOf),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.length),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidInitialization()` and selector `0xf92ee8a9`.
```solidity
error InvalidInitialization();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidInitialization;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidInitialization> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidInitialization) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidInitialization {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidInitialization {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidInitialization()";
            const SELECTOR: [u8; 4] = [249u8, 46u8, 232u8, 169u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidType()` and selector `0xb9688461`.
```solidity
error InvalidType();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidType;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidType> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidType) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidType {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidType {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidType()";
            const SELECTOR: [u8; 4] = [185u8, 104u8, 132u8, 97u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `IsNotScalar()` and selector `0x4f224e53`.
```solidity
error IsNotScalar();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct IsNotScalar;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<IsNotScalar> for UnderlyingRustTuple<'_> {
            fn from(value: IsNotScalar) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for IsNotScalar {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for IsNotScalar {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "IsNotScalar()";
            const SELECTOR: [u8; 4] = [79u8, 34u8, 78u8, 83u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `NotHostOwner(address)` and selector `0x21bfda10`.
```solidity
error NotHostOwner(address sender);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NotHostOwner {
        #[allow(missing_docs)]
        pub sender: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NotHostOwner> for UnderlyingRustTuple<'_> {
            fn from(value: NotHostOwner) -> Self {
                (value.sender,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NotHostOwner {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { sender: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NotHostOwner {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NotHostOwner(address)";
            const SELECTOR: [u8; 4] = [33u8, 191u8, 218u8, 16u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sender,
                    ),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `NotInitializing()` and selector `0xd7e6bcf8`.
```solidity
error NotInitializing();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NotInitializing;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NotInitializing> for UnderlyingRustTuple<'_> {
            fn from(value: NotInitializing) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NotInitializing {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NotInitializing {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NotInitializing()";
            const SELECTOR: [u8; 4] = [215u8, 230u8, 188u8, 248u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `NotInitializingFromEmptyProxy()` and selector `0x6f4f731f`.
```solidity
error NotInitializingFromEmptyProxy();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NotInitializingFromEmptyProxy;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NotInitializingFromEmptyProxy>
        for UnderlyingRustTuple<'_> {
            fn from(value: NotInitializingFromEmptyProxy) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for NotInitializingFromEmptyProxy {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NotInitializingFromEmptyProxy {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NotInitializingFromEmptyProxy()";
            const SELECTOR: [u8; 4] = [111u8, 79u8, 115u8, 31u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `NotPowerOfTwo()` and selector `0x24e8e742`.
```solidity
error NotPowerOfTwo();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NotPowerOfTwo;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NotPowerOfTwo> for UnderlyingRustTuple<'_> {
            fn from(value: NotPowerOfTwo) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NotPowerOfTwo {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NotPowerOfTwo {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NotPowerOfTwo()";
            const SELECTOR: [u8; 4] = [36u8, 232u8, 231u8, 66u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `ScalarByteIsNotBoolean()` and selector `0xdf7bf325`.
```solidity
error ScalarByteIsNotBoolean();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ScalarByteIsNotBoolean;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ScalarByteIsNotBoolean> for UnderlyingRustTuple<'_> {
            fn from(value: ScalarByteIsNotBoolean) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ScalarByteIsNotBoolean {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ScalarByteIsNotBoolean {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ScalarByteIsNotBoolean()";
            const SELECTOR: [u8; 4] = [223u8, 123u8, 243u8, 37u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `SecondOperandIsNotScalar()` and selector `0x4dde0d98`.
```solidity
error SecondOperandIsNotScalar();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SecondOperandIsNotScalar;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<SecondOperandIsNotScalar>
        for UnderlyingRustTuple<'_> {
            fn from(value: SecondOperandIsNotScalar) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for SecondOperandIsNotScalar {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for SecondOperandIsNotScalar {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "SecondOperandIsNotScalar()";
            const SELECTOR: [u8; 4] = [77u8, 222u8, 13u8, 152u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `UUPSUnauthorizedCallContext()` and selector `0xe07c8dba`.
```solidity
error UUPSUnauthorizedCallContext();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct UUPSUnauthorizedCallContext;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UUPSUnauthorizedCallContext>
        for UnderlyingRustTuple<'_> {
            fn from(value: UUPSUnauthorizedCallContext) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for UUPSUnauthorizedCallContext {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for UUPSUnauthorizedCallContext {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "UUPSUnauthorizedCallContext()";
            const SELECTOR: [u8; 4] = [224u8, 124u8, 141u8, 186u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `UUPSUnsupportedProxiableUUID(bytes32)` and selector `0xaa1d49a4`.
```solidity
error UUPSUnsupportedProxiableUUID(bytes32 slot);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct UUPSUnsupportedProxiableUUID {
        #[allow(missing_docs)]
        pub slot: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UUPSUnsupportedProxiableUUID>
        for UnderlyingRustTuple<'_> {
            fn from(value: UUPSUnsupportedProxiableUUID) -> Self {
                (value.slot,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for UUPSUnsupportedProxiableUUID {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { slot: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for UUPSUnsupportedProxiableUUID {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "UUPSUnsupportedProxiableUUID(bytes32)";
            const SELECTOR: [u8; 4] = [170u8, 29u8, 73u8, 164u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.slot),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `UnsupportedType()` and selector `0xc6de466a`.
```solidity
error UnsupportedType();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct UnsupportedType;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnsupportedType> for UnderlyingRustTuple<'_> {
            fn from(value: UnsupportedType) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for UnsupportedType {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for UnsupportedType {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "UnsupportedType()";
            const SELECTOR: [u8; 4] = [198u8, 222u8, 70u8, 106u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `UpperBoundAboveMaxTypeValue()` and selector `0xc7dadf45`.
```solidity
error UpperBoundAboveMaxTypeValue();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct UpperBoundAboveMaxTypeValue;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UpperBoundAboveMaxTypeValue>
        for UnderlyingRustTuple<'_> {
            fn from(value: UpperBoundAboveMaxTypeValue) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for UpperBoundAboveMaxTypeValue {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for UpperBoundAboveMaxTypeValue {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "UpperBoundAboveMaxTypeValue()";
            const SELECTOR: [u8; 4] = [199u8, 218u8, 223u8, 69u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `Cast(address,bytes32,uint8,bytes32)` and selector `0x31ccae6a2f8e3ced1692f77c8f668133e4afdaaa35afe844ff4659a6c27e627f`.
```solidity
event Cast(address indexed caller, bytes32 ct, FheType toType, bytes32 result);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Cast {
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub ct: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub toType: <FheType as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Cast {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                FheType,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "Cast(address,bytes32,uint8,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                49u8, 204u8, 174u8, 106u8, 47u8, 142u8, 60u8, 237u8, 22u8, 146u8, 247u8,
                124u8, 143u8, 102u8, 129u8, 51u8, 228u8, 175u8, 218u8, 170u8, 53u8,
                175u8, 232u8, 68u8, 255u8, 70u8, 89u8, 166u8, 194u8, 126u8, 98u8, 127u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    caller: topics.1,
                    ct: data.0,
                    toType: data.1,
                    result: data.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.ct),
                    <FheType as alloy_sol_types::SolType>::tokenize(&self.toType),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.caller.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.caller,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Cast {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Cast> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Cast) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `FheAdd(address,bytes32,bytes32,bytes1,bytes32)` and selector `0xdb9050d65240431621d61d6f94b970e63f53a67a5766614ee6e5c5bbd41c8e2e`.
```solidity
event FheAdd(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct FheAdd {
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for FheAdd {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "FheAdd(address,bytes32,bytes32,bytes1,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                219u8, 144u8, 80u8, 214u8, 82u8, 64u8, 67u8, 22u8, 33u8, 214u8, 29u8,
                111u8, 148u8, 185u8, 112u8, 230u8, 63u8, 83u8, 166u8, 122u8, 87u8, 102u8,
                97u8, 78u8, 230u8, 229u8, 197u8, 187u8, 212u8, 28u8, 142u8, 46u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    caller: topics.1,
                    lhs: data.0,
                    rhs: data.1,
                    scalarByte: data.2,
                    result: data.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.caller.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.caller,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for FheAdd {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&FheAdd> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &FheAdd) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `FheBitAnd(address,bytes32,bytes32,bytes1,bytes32)` and selector `0xe42486b0ccdbef81a2075c48c8e515c079aea73c8b82429997c72a2fe1bf4fef`.
```solidity
event FheBitAnd(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct FheBitAnd {
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for FheBitAnd {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "FheBitAnd(address,bytes32,bytes32,bytes1,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                228u8, 36u8, 134u8, 176u8, 204u8, 219u8, 239u8, 129u8, 162u8, 7u8, 92u8,
                72u8, 200u8, 229u8, 21u8, 192u8, 121u8, 174u8, 167u8, 60u8, 139u8, 130u8,
                66u8, 153u8, 151u8, 199u8, 42u8, 47u8, 225u8, 191u8, 79u8, 239u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    caller: topics.1,
                    lhs: data.0,
                    rhs: data.1,
                    scalarByte: data.2,
                    result: data.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.caller.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.caller,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for FheBitAnd {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&FheBitAnd> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &FheBitAnd) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `FheBitOr(address,bytes32,bytes32,bytes1,bytes32)` and selector `0x56df279bbfb03d9ed097bbe2f28d520ca0c1161206327926e98664d70d2c24c4`.
```solidity
event FheBitOr(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct FheBitOr {
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for FheBitOr {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "FheBitOr(address,bytes32,bytes32,bytes1,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                86u8, 223u8, 39u8, 155u8, 191u8, 176u8, 61u8, 158u8, 208u8, 151u8, 187u8,
                226u8, 242u8, 141u8, 82u8, 12u8, 160u8, 193u8, 22u8, 18u8, 6u8, 50u8,
                121u8, 38u8, 233u8, 134u8, 100u8, 215u8, 13u8, 44u8, 36u8, 196u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    caller: topics.1,
                    lhs: data.0,
                    rhs: data.1,
                    scalarByte: data.2,
                    result: data.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.caller.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.caller,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for FheBitOr {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&FheBitOr> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &FheBitOr) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `FheBitXor(address,bytes32,bytes32,bytes1,bytes32)` and selector `0x4d32284bd3193ecaa44e1ceca32f41c5d6c32803a92e07967dd3ee4229721582`.
```solidity
event FheBitXor(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct FheBitXor {
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for FheBitXor {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "FheBitXor(address,bytes32,bytes32,bytes1,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                77u8, 50u8, 40u8, 75u8, 211u8, 25u8, 62u8, 202u8, 164u8, 78u8, 28u8,
                236u8, 163u8, 47u8, 65u8, 197u8, 214u8, 195u8, 40u8, 3u8, 169u8, 46u8,
                7u8, 150u8, 125u8, 211u8, 238u8, 66u8, 41u8, 114u8, 21u8, 130u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    caller: topics.1,
                    lhs: data.0,
                    rhs: data.1,
                    scalarByte: data.2,
                    result: data.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.caller.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.caller,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for FheBitXor {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&FheBitXor> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &FheBitXor) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `FheDiv(address,bytes32,bytes32,bytes1,bytes32)` and selector `0x3bab2ee0e2f90f4690c6a87bf63cf1a6b626086e95f231860b152966e8dabbf7`.
```solidity
event FheDiv(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct FheDiv {
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for FheDiv {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "FheDiv(address,bytes32,bytes32,bytes1,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                59u8, 171u8, 46u8, 224u8, 226u8, 249u8, 15u8, 70u8, 144u8, 198u8, 168u8,
                123u8, 246u8, 60u8, 241u8, 166u8, 182u8, 38u8, 8u8, 110u8, 149u8, 242u8,
                49u8, 134u8, 11u8, 21u8, 41u8, 102u8, 232u8, 218u8, 187u8, 247u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    caller: topics.1,
                    lhs: data.0,
                    rhs: data.1,
                    scalarByte: data.2,
                    result: data.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.caller.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.caller,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for FheDiv {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&FheDiv> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &FheDiv) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `FheEq(address,bytes32,bytes32,bytes1,bytes32)` and selector `0xb3d5c664ec86575818e8d75ff25c5f867250df8954088549c41c848cd10e76cb`.
```solidity
event FheEq(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct FheEq {
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for FheEq {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "FheEq(address,bytes32,bytes32,bytes1,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                179u8, 213u8, 198u8, 100u8, 236u8, 134u8, 87u8, 88u8, 24u8, 232u8, 215u8,
                95u8, 242u8, 92u8, 95u8, 134u8, 114u8, 80u8, 223u8, 137u8, 84u8, 8u8,
                133u8, 73u8, 196u8, 28u8, 132u8, 140u8, 209u8, 14u8, 118u8, 203u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    caller: topics.1,
                    lhs: data.0,
                    rhs: data.1,
                    scalarByte: data.2,
                    result: data.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.caller.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.caller,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for FheEq {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&FheEq> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &FheEq) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `FheGe(address,bytes32,bytes32,bytes1,bytes32)` and selector `0x38c3a63c4230de5b741f494ffb54e3087104030279bc7bccee8ad9ad31712b21`.
```solidity
event FheGe(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct FheGe {
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for FheGe {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "FheGe(address,bytes32,bytes32,bytes1,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                56u8, 195u8, 166u8, 60u8, 66u8, 48u8, 222u8, 91u8, 116u8, 31u8, 73u8,
                79u8, 251u8, 84u8, 227u8, 8u8, 113u8, 4u8, 3u8, 2u8, 121u8, 188u8, 123u8,
                204u8, 238u8, 138u8, 217u8, 173u8, 49u8, 113u8, 43u8, 33u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    caller: topics.1,
                    lhs: data.0,
                    rhs: data.1,
                    scalarByte: data.2,
                    result: data.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.caller.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.caller,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for FheGe {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&FheGe> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &FheGe) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `FheGt(address,bytes32,bytes32,bytes1,bytes32)` and selector `0xc9ff8f0d18a3f766ce5de3de216076050140e4fc2652f5e0e745f6fc836cda8b`.
```solidity
event FheGt(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct FheGt {
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for FheGt {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "FheGt(address,bytes32,bytes32,bytes1,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                201u8, 255u8, 143u8, 13u8, 24u8, 163u8, 247u8, 102u8, 206u8, 93u8, 227u8,
                222u8, 33u8, 96u8, 118u8, 5u8, 1u8, 64u8, 228u8, 252u8, 38u8, 82u8,
                245u8, 224u8, 231u8, 69u8, 246u8, 252u8, 131u8, 108u8, 218u8, 139u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    caller: topics.1,
                    lhs: data.0,
                    rhs: data.1,
                    scalarByte: data.2,
                    result: data.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.caller.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.caller,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for FheGt {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&FheGt> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &FheGt) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `FheIfThenElse(address,bytes32,bytes32,bytes32,bytes32)` and selector `0x60be9d61aad849facc28c38b048cb5c4be3420b8fa2233e08cfa06be1b6d1c3e`.
```solidity
event FheIfThenElse(address indexed caller, bytes32 control, bytes32 ifTrue, bytes32 ifFalse, bytes32 result);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct FheIfThenElse {
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub control: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub ifTrue: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub ifFalse: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for FheIfThenElse {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "FheIfThenElse(address,bytes32,bytes32,bytes32,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                96u8, 190u8, 157u8, 97u8, 170u8, 216u8, 73u8, 250u8, 204u8, 40u8, 195u8,
                139u8, 4u8, 140u8, 181u8, 196u8, 190u8, 52u8, 32u8, 184u8, 250u8, 34u8,
                51u8, 224u8, 140u8, 250u8, 6u8, 190u8, 27u8, 109u8, 28u8, 62u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    caller: topics.1,
                    control: data.0,
                    ifTrue: data.1,
                    ifFalse: data.2,
                    result: data.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.control),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.ifTrue),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.ifFalse),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.caller.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.caller,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for FheIfThenElse {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&FheIfThenElse> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &FheIfThenElse) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `FheLe(address,bytes32,bytes32,bytes1,bytes32)` and selector `0xdef2e704a077284a07f3d0b436db88f5d981b69f58ab7c1ae623252718a6de01`.
```solidity
event FheLe(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct FheLe {
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for FheLe {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "FheLe(address,bytes32,bytes32,bytes1,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                222u8, 242u8, 231u8, 4u8, 160u8, 119u8, 40u8, 74u8, 7u8, 243u8, 208u8,
                180u8, 54u8, 219u8, 136u8, 245u8, 217u8, 129u8, 182u8, 159u8, 88u8,
                171u8, 124u8, 26u8, 230u8, 35u8, 37u8, 39u8, 24u8, 166u8, 222u8, 1u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    caller: topics.1,
                    lhs: data.0,
                    rhs: data.1,
                    scalarByte: data.2,
                    result: data.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.caller.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.caller,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for FheLe {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&FheLe> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &FheLe) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `FheLt(address,bytes32,bytes32,bytes1,bytes32)` and selector `0x0d483b100d8c73b208984ec697caa3091521ee5525ce69edcf97d7e395d3d059`.
```solidity
event FheLt(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct FheLt {
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for FheLt {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "FheLt(address,bytes32,bytes32,bytes1,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                13u8, 72u8, 59u8, 16u8, 13u8, 140u8, 115u8, 178u8, 8u8, 152u8, 78u8,
                198u8, 151u8, 202u8, 163u8, 9u8, 21u8, 33u8, 238u8, 85u8, 37u8, 206u8,
                105u8, 237u8, 207u8, 151u8, 215u8, 227u8, 149u8, 211u8, 208u8, 89u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    caller: topics.1,
                    lhs: data.0,
                    rhs: data.1,
                    scalarByte: data.2,
                    result: data.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.caller.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.caller,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for FheLt {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&FheLt> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &FheLt) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `FheMax(address,bytes32,bytes32,bytes1,bytes32)` and selector `0xfd7c9208f956bf0c6ab76a667f04361245ad3e0a2d0eff92eb827acfcca68ea9`.
```solidity
event FheMax(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct FheMax {
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for FheMax {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "FheMax(address,bytes32,bytes32,bytes1,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                253u8, 124u8, 146u8, 8u8, 249u8, 86u8, 191u8, 12u8, 106u8, 183u8, 106u8,
                102u8, 127u8, 4u8, 54u8, 18u8, 69u8, 173u8, 62u8, 10u8, 45u8, 14u8,
                255u8, 146u8, 235u8, 130u8, 122u8, 207u8, 204u8, 166u8, 142u8, 169u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    caller: topics.1,
                    lhs: data.0,
                    rhs: data.1,
                    scalarByte: data.2,
                    result: data.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.caller.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.caller,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for FheMax {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&FheMax> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &FheMax) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `FheMin(address,bytes32,bytes32,bytes1,bytes32)` and selector `0xc11d62b13c360a83082487064be1ec0878b2f0be4f012bf59f89e128063d47ff`.
```solidity
event FheMin(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct FheMin {
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for FheMin {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "FheMin(address,bytes32,bytes32,bytes1,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                193u8, 29u8, 98u8, 177u8, 60u8, 54u8, 10u8, 131u8, 8u8, 36u8, 135u8, 6u8,
                75u8, 225u8, 236u8, 8u8, 120u8, 178u8, 240u8, 190u8, 79u8, 1u8, 43u8,
                245u8, 159u8, 137u8, 225u8, 40u8, 6u8, 61u8, 71u8, 255u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    caller: topics.1,
                    lhs: data.0,
                    rhs: data.1,
                    scalarByte: data.2,
                    result: data.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.caller.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.caller,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for FheMin {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&FheMin> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &FheMin) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `FheMul(address,bytes32,bytes32,bytes1,bytes32)` and selector `0x215346a4f9f975e6d5484e290bd4e53ca14453a9d282ebd3ccedb2a0f171753d`.
```solidity
event FheMul(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct FheMul {
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for FheMul {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "FheMul(address,bytes32,bytes32,bytes1,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                33u8, 83u8, 70u8, 164u8, 249u8, 249u8, 117u8, 230u8, 213u8, 72u8, 78u8,
                41u8, 11u8, 212u8, 229u8, 60u8, 161u8, 68u8, 83u8, 169u8, 210u8, 130u8,
                235u8, 211u8, 204u8, 237u8, 178u8, 160u8, 241u8, 113u8, 117u8, 61u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    caller: topics.1,
                    lhs: data.0,
                    rhs: data.1,
                    scalarByte: data.2,
                    result: data.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.caller.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.caller,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for FheMul {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&FheMul> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &FheMul) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `FheNe(address,bytes32,bytes32,bytes1,bytes32)` and selector `0x6960c1e88f61c352dba34d1bbf6753e302795264d5d8ae82f7983c7004651e5d`.
```solidity
event FheNe(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct FheNe {
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for FheNe {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "FheNe(address,bytes32,bytes32,bytes1,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                105u8, 96u8, 193u8, 232u8, 143u8, 97u8, 195u8, 82u8, 219u8, 163u8, 77u8,
                27u8, 191u8, 103u8, 83u8, 227u8, 2u8, 121u8, 82u8, 100u8, 213u8, 216u8,
                174u8, 130u8, 247u8, 152u8, 60u8, 112u8, 4u8, 101u8, 30u8, 93u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    caller: topics.1,
                    lhs: data.0,
                    rhs: data.1,
                    scalarByte: data.2,
                    result: data.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.caller.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.caller,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for FheNe {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&FheNe> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &FheNe) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `FheNeg(address,bytes32,bytes32)` and selector `0x8c664d3c3ca583fc5803b8a91c49644bbd9550bfa87967c73ad1de83027768c0`.
```solidity
event FheNeg(address indexed caller, bytes32 ct, bytes32 result);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct FheNeg {
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub ct: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for FheNeg {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "FheNeg(address,bytes32,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                140u8, 102u8, 77u8, 60u8, 60u8, 165u8, 131u8, 252u8, 88u8, 3u8, 184u8,
                169u8, 28u8, 73u8, 100u8, 75u8, 189u8, 149u8, 80u8, 191u8, 168u8, 121u8,
                103u8, 199u8, 58u8, 209u8, 222u8, 131u8, 2u8, 119u8, 104u8, 192u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    caller: topics.1,
                    ct: data.0,
                    result: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.ct),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.caller.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.caller,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for FheNeg {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&FheNeg> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &FheNeg) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `FheNot(address,bytes32,bytes32)` and selector `0x55aff4cc7a3d160c83f1f15b818011ede841a0b4597fb14dcd3603df3a11e5e0`.
```solidity
event FheNot(address indexed caller, bytes32 ct, bytes32 result);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct FheNot {
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub ct: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for FheNot {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "FheNot(address,bytes32,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                85u8, 175u8, 244u8, 204u8, 122u8, 61u8, 22u8, 12u8, 131u8, 241u8, 241u8,
                91u8, 129u8, 128u8, 17u8, 237u8, 232u8, 65u8, 160u8, 180u8, 89u8, 127u8,
                177u8, 77u8, 205u8, 54u8, 3u8, 223u8, 58u8, 17u8, 229u8, 224u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    caller: topics.1,
                    ct: data.0,
                    result: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.ct),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.caller.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.caller,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for FheNot {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&FheNot> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &FheNot) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `FheRand(address,uint8,bytes16,bytes32)` and selector `0x0c8aca6017003326051e19913ef02631f24b801125e1fa8a1d812e868319fda6`.
```solidity
event FheRand(address indexed caller, FheType randType, bytes16 seed, bytes32 result);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct FheRand {
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub randType: <FheType as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub seed: alloy::sol_types::private::FixedBytes<16>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for FheRand {
            type DataTuple<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<16>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "FheRand(address,uint8,bytes16,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                12u8, 138u8, 202u8, 96u8, 23u8, 0u8, 51u8, 38u8, 5u8, 30u8, 25u8, 145u8,
                62u8, 240u8, 38u8, 49u8, 242u8, 75u8, 128u8, 17u8, 37u8, 225u8, 250u8,
                138u8, 29u8, 129u8, 46u8, 134u8, 131u8, 25u8, 253u8, 166u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    caller: topics.1,
                    randType: data.0,
                    seed: data.1,
                    result: data.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <FheType as alloy_sol_types::SolType>::tokenize(&self.randType),
                    <alloy::sol_types::sol_data::FixedBytes<
                        16,
                    > as alloy_sol_types::SolType>::tokenize(&self.seed),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.caller.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.caller,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for FheRand {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&FheRand> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &FheRand) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `FheRandBounded(address,uint256,uint8,bytes16,bytes32)` and selector `0x5222d96b836727a1d6fe1ee9aef27f9bb507bd41794defa376ff6c648aaf8ff1`.
```solidity
event FheRandBounded(address indexed caller, uint256 upperBound, FheType randType, bytes16 seed, bytes32 result);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct FheRandBounded {
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub upperBound: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub randType: <FheType as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub seed: alloy::sol_types::private::FixedBytes<16>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for FheRandBounded {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                FheType,
                alloy::sol_types::sol_data::FixedBytes<16>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "FheRandBounded(address,uint256,uint8,bytes16,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                82u8, 34u8, 217u8, 107u8, 131u8, 103u8, 39u8, 161u8, 214u8, 254u8, 30u8,
                233u8, 174u8, 242u8, 127u8, 155u8, 181u8, 7u8, 189u8, 65u8, 121u8, 77u8,
                239u8, 163u8, 118u8, 255u8, 108u8, 100u8, 138u8, 175u8, 143u8, 241u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    caller: topics.1,
                    upperBound: data.0,
                    randType: data.1,
                    seed: data.2,
                    result: data.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.upperBound),
                    <FheType as alloy_sol_types::SolType>::tokenize(&self.randType),
                    <alloy::sol_types::sol_data::FixedBytes<
                        16,
                    > as alloy_sol_types::SolType>::tokenize(&self.seed),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.caller.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.caller,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for FheRandBounded {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&FheRandBounded> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &FheRandBounded) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `FheRem(address,bytes32,bytes32,bytes1,bytes32)` and selector `0x0e691cd0bf8c4e9308e4ced1bb9c964117dc5c5bb9b9ab5bdfebf2c9b13a897c`.
```solidity
event FheRem(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct FheRem {
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for FheRem {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "FheRem(address,bytes32,bytes32,bytes1,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                14u8, 105u8, 28u8, 208u8, 191u8, 140u8, 78u8, 147u8, 8u8, 228u8, 206u8,
                209u8, 187u8, 156u8, 150u8, 65u8, 23u8, 220u8, 92u8, 91u8, 185u8, 185u8,
                171u8, 91u8, 223u8, 235u8, 242u8, 201u8, 177u8, 58u8, 137u8, 124u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    caller: topics.1,
                    lhs: data.0,
                    rhs: data.1,
                    scalarByte: data.2,
                    result: data.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.caller.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.caller,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for FheRem {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&FheRem> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &FheRem) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `FheRotl(address,bytes32,bytes32,bytes1,bytes32)` and selector `0xeb0e4f8dc74058194d0602425fe602f955c222200f7f10c6fe67992f7b24c7e9`.
```solidity
event FheRotl(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct FheRotl {
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for FheRotl {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "FheRotl(address,bytes32,bytes32,bytes1,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                235u8, 14u8, 79u8, 141u8, 199u8, 64u8, 88u8, 25u8, 77u8, 6u8, 2u8, 66u8,
                95u8, 230u8, 2u8, 249u8, 85u8, 194u8, 34u8, 32u8, 15u8, 127u8, 16u8,
                198u8, 254u8, 103u8, 153u8, 47u8, 123u8, 36u8, 199u8, 233u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    caller: topics.1,
                    lhs: data.0,
                    rhs: data.1,
                    scalarByte: data.2,
                    result: data.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.caller.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.caller,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for FheRotl {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&FheRotl> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &FheRotl) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `FheRotr(address,bytes32,bytes32,bytes1,bytes32)` and selector `0xc148675905d07ad5496f8ef4d8195c907503f3ec12fd10ed5f21240abc693634`.
```solidity
event FheRotr(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct FheRotr {
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for FheRotr {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "FheRotr(address,bytes32,bytes32,bytes1,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                193u8, 72u8, 103u8, 89u8, 5u8, 208u8, 122u8, 213u8, 73u8, 111u8, 142u8,
                244u8, 216u8, 25u8, 92u8, 144u8, 117u8, 3u8, 243u8, 236u8, 18u8, 253u8,
                16u8, 237u8, 95u8, 33u8, 36u8, 10u8, 188u8, 105u8, 54u8, 52u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    caller: topics.1,
                    lhs: data.0,
                    rhs: data.1,
                    scalarByte: data.2,
                    result: data.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.caller.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.caller,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for FheRotr {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&FheRotr> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &FheRotr) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `FheShl(address,bytes32,bytes32,bytes1,bytes32)` and selector `0xe84282aaebcca698443e39a2a948a345d0d2ebc654af5cb657a2d7e8053bf6cb`.
```solidity
event FheShl(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct FheShl {
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for FheShl {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "FheShl(address,bytes32,bytes32,bytes1,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                232u8, 66u8, 130u8, 170u8, 235u8, 204u8, 166u8, 152u8, 68u8, 62u8, 57u8,
                162u8, 169u8, 72u8, 163u8, 69u8, 208u8, 210u8, 235u8, 198u8, 84u8, 175u8,
                92u8, 182u8, 87u8, 162u8, 215u8, 232u8, 5u8, 59u8, 246u8, 203u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    caller: topics.1,
                    lhs: data.0,
                    rhs: data.1,
                    scalarByte: data.2,
                    result: data.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.caller.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.caller,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for FheShl {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&FheShl> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &FheShl) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `FheShr(address,bytes32,bytes32,bytes1,bytes32)` and selector `0x324220bfc9cb158b492991c03c309cd86e5345cac45aacae2092ddabe31fa3d8`.
```solidity
event FheShr(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct FheShr {
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for FheShr {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "FheShr(address,bytes32,bytes32,bytes1,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                50u8, 66u8, 32u8, 191u8, 201u8, 203u8, 21u8, 139u8, 73u8, 41u8, 145u8,
                192u8, 60u8, 48u8, 156u8, 216u8, 110u8, 83u8, 69u8, 202u8, 196u8, 90u8,
                172u8, 174u8, 32u8, 146u8, 221u8, 171u8, 227u8, 31u8, 163u8, 216u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    caller: topics.1,
                    lhs: data.0,
                    rhs: data.1,
                    scalarByte: data.2,
                    result: data.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.caller.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.caller,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for FheShr {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&FheShr> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &FheShr) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `FheSub(address,bytes32,bytes32,bytes1,bytes32)` and selector `0xeb6d37bd271abe1395b21d6d78f3487d6584862872c29ffd3f90736ee99b7393`.
```solidity
event FheSub(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct FheSub {
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for FheSub {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "FheSub(address,bytes32,bytes32,bytes1,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                235u8, 109u8, 55u8, 189u8, 39u8, 26u8, 190u8, 19u8, 149u8, 178u8, 29u8,
                109u8, 120u8, 243u8, 72u8, 125u8, 101u8, 132u8, 134u8, 40u8, 114u8,
                194u8, 159u8, 253u8, 63u8, 144u8, 115u8, 110u8, 233u8, 155u8, 115u8,
                147u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    caller: topics.1,
                    lhs: data.0,
                    rhs: data.1,
                    scalarByte: data.2,
                    result: data.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.caller.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.caller,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for FheSub {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&FheSub> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &FheSub) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `Initialized(uint64)` and selector `0xc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d2`.
```solidity
event Initialized(uint64 version);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Initialized {
        #[allow(missing_docs)]
        pub version: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Initialized {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "Initialized(uint64)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                199u8, 245u8, 5u8, 178u8, 243u8, 113u8, 174u8, 33u8, 117u8, 238u8, 73u8,
                19u8, 244u8, 73u8, 158u8, 31u8, 38u8, 51u8, 167u8, 181u8, 147u8, 99u8,
                33u8, 238u8, 209u8, 205u8, 174u8, 182u8, 17u8, 81u8, 129u8, 210u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { version: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.version),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Initialized {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Initialized> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Initialized) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `TrivialEncrypt(address,uint256,uint8,bytes32)` and selector `0x063ccd1bba45151d91f6a418065047a3d048d058a922535747bb2b575a01d236`.
```solidity
event TrivialEncrypt(address indexed caller, uint256 pt, FheType toType, bytes32 result);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct TrivialEncrypt {
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub pt: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub toType: <FheType as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for TrivialEncrypt {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                FheType,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "TrivialEncrypt(address,uint256,uint8,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                6u8, 60u8, 205u8, 27u8, 186u8, 69u8, 21u8, 29u8, 145u8, 246u8, 164u8,
                24u8, 6u8, 80u8, 71u8, 163u8, 208u8, 72u8, 208u8, 88u8, 169u8, 34u8,
                83u8, 87u8, 71u8, 187u8, 43u8, 87u8, 90u8, 1u8, 210u8, 54u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    caller: topics.1,
                    pt: data.0,
                    toType: data.1,
                    result: data.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.pt),
                    <FheType as alloy_sol_types::SolType>::tokenize(&self.toType),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.caller.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.caller,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for TrivialEncrypt {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&TrivialEncrypt> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &TrivialEncrypt) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `Upgraded(address)` and selector `0xbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b`.
```solidity
event Upgraded(address indexed implementation);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Upgraded {
        #[allow(missing_docs)]
        pub implementation: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Upgraded {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "Upgraded(address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                188u8, 124u8, 215u8, 90u8, 32u8, 238u8, 39u8, 253u8, 154u8, 222u8, 186u8,
                179u8, 32u8, 65u8, 247u8, 85u8, 33u8, 77u8, 188u8, 107u8, 255u8, 169u8,
                12u8, 192u8, 34u8, 91u8, 57u8, 218u8, 46u8, 92u8, 45u8, 59u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { implementation: topics.1 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.implementation.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.implementation,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Upgraded {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Upgraded> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Upgraded) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `VerifyInput(address,bytes32,address,bytes,uint8,bytes32)` and selector `0xdc370db33589e73371dc3ee42c789c003d336eefcb7c3f56fe0f51ae5b1d9702`.
```solidity
event VerifyInput(address indexed caller, bytes32 inputHandle, address userAddress, bytes inputProof, FheType inputType, bytes32 result);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct VerifyInput {
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub inputHandle: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub userAddress: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub inputProof: alloy::sol_types::private::Bytes,
        #[allow(missing_docs)]
        pub inputType: <FheType as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for VerifyInput {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bytes,
                FheType,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "VerifyInput(address,bytes32,address,bytes,uint8,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                220u8, 55u8, 13u8, 179u8, 53u8, 137u8, 231u8, 51u8, 113u8, 220u8, 62u8,
                228u8, 44u8, 120u8, 156u8, 0u8, 61u8, 51u8, 110u8, 239u8, 203u8, 124u8,
                63u8, 86u8, 254u8, 15u8, 81u8, 174u8, 91u8, 29u8, 151u8, 2u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    caller: topics.1,
                    inputHandle: data.0,
                    userAddress: data.1,
                    inputProof: data.2,
                    inputType: data.3,
                    result: data.4,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.inputHandle),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.userAddress,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.inputProof,
                    ),
                    <FheType as alloy_sol_types::SolType>::tokenize(&self.inputType),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.caller.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.caller,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for VerifyInput {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&VerifyInput> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &VerifyInput) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Constructor`.
```solidity
constructor();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct constructorCall {}
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<constructorCall> for UnderlyingRustTuple<'_> {
                fn from(value: constructorCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for constructorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolConstructor for constructorCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `UPGRADE_INTERFACE_VERSION()` and selector `0xad3cb1cc`.
```solidity
function UPGRADE_INTERFACE_VERSION() external view returns (string memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct UPGRADE_INTERFACE_VERSIONCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`UPGRADE_INTERFACE_VERSION()`](UPGRADE_INTERFACE_VERSIONCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct UPGRADE_INTERFACE_VERSIONReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UPGRADE_INTERFACE_VERSIONCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: UPGRADE_INTERFACE_VERSIONCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for UPGRADE_INTERFACE_VERSIONCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UPGRADE_INTERFACE_VERSIONReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: UPGRADE_INTERFACE_VERSIONReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for UPGRADE_INTERFACE_VERSIONReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for UPGRADE_INTERFACE_VERSIONCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::String;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "UPGRADE_INTERFACE_VERSION()";
            const SELECTOR: [u8; 4] = [173u8, 60u8, 177u8, 204u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: UPGRADE_INTERFACE_VERSIONReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: UPGRADE_INTERFACE_VERSIONReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `cast(bytes32,uint8)` and selector `0x1c89ee44`.
```solidity
function cast(bytes32 ct, FheType toType) external returns (bytes32 result);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct castCall {
        #[allow(missing_docs)]
        pub ct: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub toType: <FheType as alloy::sol_types::SolType>::RustType,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`cast(bytes32,uint8)`](castCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct castReturn {
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                FheType,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                <FheType as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<castCall> for UnderlyingRustTuple<'_> {
                fn from(value: castCall) -> Self {
                    (value.ct, value.toType)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for castCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        ct: tuple.0,
                        toType: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<castReturn> for UnderlyingRustTuple<'_> {
                fn from(value: castReturn) -> Self {
                    (value.result,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for castReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { result: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for castCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>, FheType);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "cast(bytes32,uint8)";
            const SELECTOR: [u8; 4] = [28u8, 137u8, 238u8, 68u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.ct),
                    <FheType as alloy_sol_types::SolType>::tokenize(&self.toType),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: castReturn = r.into();
                        r.result
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: castReturn = r.into();
                        r.result
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `fheAdd(bytes32,bytes32,bytes1)` and selector `0x117b2f38`.
```solidity
function fheAdd(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheAddCall {
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`fheAdd(bytes32,bytes32,bytes1)`](fheAddCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheAddReturn {
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<1>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheAddCall> for UnderlyingRustTuple<'_> {
                fn from(value: fheAddCall) -> Self {
                    (value.lhs, value.rhs, value.scalarByte)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheAddCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        lhs: tuple.0,
                        rhs: tuple.1,
                        scalarByte: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheAddReturn> for UnderlyingRustTuple<'_> {
                fn from(value: fheAddReturn) -> Self {
                    (value.result,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheAddReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { result: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for fheAddCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "fheAdd(bytes32,bytes32,bytes1)";
            const SELECTOR: [u8; 4] = [17u8, 123u8, 47u8, 56u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: fheAddReturn = r.into();
                        r.result
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: fheAddReturn = r.into();
                        r.result
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `fheBitAnd(bytes32,bytes32,bytes1)` and selector `0xd99882d5`.
```solidity
function fheBitAnd(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheBitAndCall {
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`fheBitAnd(bytes32,bytes32,bytes1)`](fheBitAndCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheBitAndReturn {
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<1>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheBitAndCall> for UnderlyingRustTuple<'_> {
                fn from(value: fheBitAndCall) -> Self {
                    (value.lhs, value.rhs, value.scalarByte)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheBitAndCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        lhs: tuple.0,
                        rhs: tuple.1,
                        scalarByte: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheBitAndReturn> for UnderlyingRustTuple<'_> {
                fn from(value: fheBitAndReturn) -> Self {
                    (value.result,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheBitAndReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { result: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for fheBitAndCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "fheBitAnd(bytes32,bytes32,bytes1)";
            const SELECTOR: [u8; 4] = [217u8, 152u8, 130u8, 213u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: fheBitAndReturn = r.into();
                        r.result
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: fheBitAndReturn = r.into();
                        r.result
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `fheBitOr(bytes32,bytes32,bytes1)` and selector `0x63a2db29`.
```solidity
function fheBitOr(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheBitOrCall {
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`fheBitOr(bytes32,bytes32,bytes1)`](fheBitOrCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheBitOrReturn {
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<1>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheBitOrCall> for UnderlyingRustTuple<'_> {
                fn from(value: fheBitOrCall) -> Self {
                    (value.lhs, value.rhs, value.scalarByte)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheBitOrCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        lhs: tuple.0,
                        rhs: tuple.1,
                        scalarByte: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheBitOrReturn> for UnderlyingRustTuple<'_> {
                fn from(value: fheBitOrReturn) -> Self {
                    (value.result,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheBitOrReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { result: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for fheBitOrCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "fheBitOr(bytes32,bytes32,bytes1)";
            const SELECTOR: [u8; 4] = [99u8, 162u8, 219u8, 41u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: fheBitOrReturn = r.into();
                        r.result
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: fheBitOrReturn = r.into();
                        r.result
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `fheBitXor(bytes32,bytes32,bytes1)` and selector `0x8b49ceb4`.
```solidity
function fheBitXor(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheBitXorCall {
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`fheBitXor(bytes32,bytes32,bytes1)`](fheBitXorCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheBitXorReturn {
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<1>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheBitXorCall> for UnderlyingRustTuple<'_> {
                fn from(value: fheBitXorCall) -> Self {
                    (value.lhs, value.rhs, value.scalarByte)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheBitXorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        lhs: tuple.0,
                        rhs: tuple.1,
                        scalarByte: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheBitXorReturn> for UnderlyingRustTuple<'_> {
                fn from(value: fheBitXorReturn) -> Self {
                    (value.result,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheBitXorReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { result: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for fheBitXorCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "fheBitXor(bytes32,bytes32,bytes1)";
            const SELECTOR: [u8; 4] = [139u8, 73u8, 206u8, 180u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: fheBitXorReturn = r.into();
                        r.result
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: fheBitXorReturn = r.into();
                        r.result
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `fheDiv(bytes32,bytes32,bytes1)` and selector `0x5a53accb`.
```solidity
function fheDiv(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheDivCall {
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`fheDiv(bytes32,bytes32,bytes1)`](fheDivCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheDivReturn {
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<1>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheDivCall> for UnderlyingRustTuple<'_> {
                fn from(value: fheDivCall) -> Self {
                    (value.lhs, value.rhs, value.scalarByte)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheDivCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        lhs: tuple.0,
                        rhs: tuple.1,
                        scalarByte: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheDivReturn> for UnderlyingRustTuple<'_> {
                fn from(value: fheDivReturn) -> Self {
                    (value.result,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheDivReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { result: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for fheDivCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "fheDiv(bytes32,bytes32,bytes1)";
            const SELECTOR: [u8; 4] = [90u8, 83u8, 172u8, 203u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: fheDivReturn = r.into();
                        r.result
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: fheDivReturn = r.into();
                        r.result
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `fheEq(bytes32,bytes32,bytes1)` and selector `0xf77f3f1d`.
```solidity
function fheEq(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheEqCall {
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`fheEq(bytes32,bytes32,bytes1)`](fheEqCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheEqReturn {
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<1>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheEqCall> for UnderlyingRustTuple<'_> {
                fn from(value: fheEqCall) -> Self {
                    (value.lhs, value.rhs, value.scalarByte)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheEqCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        lhs: tuple.0,
                        rhs: tuple.1,
                        scalarByte: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheEqReturn> for UnderlyingRustTuple<'_> {
                fn from(value: fheEqReturn) -> Self {
                    (value.result,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheEqReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { result: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for fheEqCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "fheEq(bytes32,bytes32,bytes1)";
            const SELECTOR: [u8; 4] = [247u8, 127u8, 63u8, 29u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: fheEqReturn = r.into();
                        r.result
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: fheEqReturn = r.into();
                        r.result
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `fheGe(bytes32,bytes32,bytes1)` and selector `0x1391547f`.
```solidity
function fheGe(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheGeCall {
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`fheGe(bytes32,bytes32,bytes1)`](fheGeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheGeReturn {
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<1>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheGeCall> for UnderlyingRustTuple<'_> {
                fn from(value: fheGeCall) -> Self {
                    (value.lhs, value.rhs, value.scalarByte)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheGeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        lhs: tuple.0,
                        rhs: tuple.1,
                        scalarByte: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheGeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: fheGeReturn) -> Self {
                    (value.result,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheGeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { result: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for fheGeCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "fheGe(bytes32,bytes32,bytes1)";
            const SELECTOR: [u8; 4] = [19u8, 145u8, 84u8, 127u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: fheGeReturn = r.into();
                        r.result
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: fheGeReturn = r.into();
                        r.result
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `fheGt(bytes32,bytes32,bytes1)` and selector `0x85362ee7`.
```solidity
function fheGt(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheGtCall {
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`fheGt(bytes32,bytes32,bytes1)`](fheGtCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheGtReturn {
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<1>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheGtCall> for UnderlyingRustTuple<'_> {
                fn from(value: fheGtCall) -> Self {
                    (value.lhs, value.rhs, value.scalarByte)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheGtCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        lhs: tuple.0,
                        rhs: tuple.1,
                        scalarByte: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheGtReturn> for UnderlyingRustTuple<'_> {
                fn from(value: fheGtReturn) -> Self {
                    (value.result,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheGtReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { result: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for fheGtCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "fheGt(bytes32,bytes32,bytes1)";
            const SELECTOR: [u8; 4] = [133u8, 54u8, 46u8, 231u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: fheGtReturn = r.into();
                        r.result
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: fheGtReturn = r.into();
                        r.result
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `fheIfThenElse(bytes32,bytes32,bytes32)` and selector `0x7702dcff`.
```solidity
function fheIfThenElse(bytes32 control, bytes32 ifTrue, bytes32 ifFalse) external returns (bytes32 result);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheIfThenElseCall {
        #[allow(missing_docs)]
        pub control: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub ifTrue: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub ifFalse: alloy::sol_types::private::FixedBytes<32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`fheIfThenElse(bytes32,bytes32,bytes32)`](fheIfThenElseCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheIfThenElseReturn {
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheIfThenElseCall> for UnderlyingRustTuple<'_> {
                fn from(value: fheIfThenElseCall) -> Self {
                    (value.control, value.ifTrue, value.ifFalse)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheIfThenElseCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        control: tuple.0,
                        ifTrue: tuple.1,
                        ifFalse: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheIfThenElseReturn> for UnderlyingRustTuple<'_> {
                fn from(value: fheIfThenElseReturn) -> Self {
                    (value.result,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheIfThenElseReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { result: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for fheIfThenElseCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "fheIfThenElse(bytes32,bytes32,bytes32)";
            const SELECTOR: [u8; 4] = [119u8, 2u8, 220u8, 255u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.control),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.ifTrue),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.ifFalse),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: fheIfThenElseReturn = r.into();
                        r.result
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: fheIfThenElseReturn = r.into();
                        r.result
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `fheLe(bytes32,bytes32,bytes1)` and selector `0x7513a404`.
```solidity
function fheLe(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheLeCall {
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`fheLe(bytes32,bytes32,bytes1)`](fheLeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheLeReturn {
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<1>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheLeCall> for UnderlyingRustTuple<'_> {
                fn from(value: fheLeCall) -> Self {
                    (value.lhs, value.rhs, value.scalarByte)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheLeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        lhs: tuple.0,
                        rhs: tuple.1,
                        scalarByte: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheLeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: fheLeReturn) -> Self {
                    (value.result,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheLeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { result: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for fheLeCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "fheLe(bytes32,bytes32,bytes1)";
            const SELECTOR: [u8; 4] = [117u8, 19u8, 164u8, 4u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: fheLeReturn = r.into();
                        r.result
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: fheLeReturn = r.into();
                        r.result
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `fheLt(bytes32,bytes32,bytes1)` and selector `0x72107681`.
```solidity
function fheLt(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheLtCall {
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`fheLt(bytes32,bytes32,bytes1)`](fheLtCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheLtReturn {
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<1>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheLtCall> for UnderlyingRustTuple<'_> {
                fn from(value: fheLtCall) -> Self {
                    (value.lhs, value.rhs, value.scalarByte)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheLtCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        lhs: tuple.0,
                        rhs: tuple.1,
                        scalarByte: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheLtReturn> for UnderlyingRustTuple<'_> {
                fn from(value: fheLtReturn) -> Self {
                    (value.result,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheLtReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { result: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for fheLtCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "fheLt(bytes32,bytes32,bytes1)";
            const SELECTOR: [u8; 4] = [114u8, 16u8, 118u8, 129u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: fheLtReturn = r.into();
                        r.result
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: fheLtReturn = r.into();
                        r.result
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `fheMax(bytes32,bytes32,bytes1)` and selector `0x36318d64`.
```solidity
function fheMax(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheMaxCall {
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`fheMax(bytes32,bytes32,bytes1)`](fheMaxCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheMaxReturn {
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<1>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheMaxCall> for UnderlyingRustTuple<'_> {
                fn from(value: fheMaxCall) -> Self {
                    (value.lhs, value.rhs, value.scalarByte)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheMaxCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        lhs: tuple.0,
                        rhs: tuple.1,
                        scalarByte: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheMaxReturn> for UnderlyingRustTuple<'_> {
                fn from(value: fheMaxReturn) -> Self {
                    (value.result,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheMaxReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { result: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for fheMaxCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "fheMax(bytes32,bytes32,bytes1)";
            const SELECTOR: [u8; 4] = [54u8, 49u8, 141u8, 100u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: fheMaxReturn = r.into();
                        r.result
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: fheMaxReturn = r.into();
                        r.result
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `fheMin(bytes32,bytes32,bytes1)` and selector `0x04559f71`.
```solidity
function fheMin(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheMinCall {
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`fheMin(bytes32,bytes32,bytes1)`](fheMinCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheMinReturn {
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<1>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheMinCall> for UnderlyingRustTuple<'_> {
                fn from(value: fheMinCall) -> Self {
                    (value.lhs, value.rhs, value.scalarByte)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheMinCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        lhs: tuple.0,
                        rhs: tuple.1,
                        scalarByte: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheMinReturn> for UnderlyingRustTuple<'_> {
                fn from(value: fheMinReturn) -> Self {
                    (value.result,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheMinReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { result: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for fheMinCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "fheMin(bytes32,bytes32,bytes1)";
            const SELECTOR: [u8; 4] = [4u8, 85u8, 159u8, 113u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: fheMinReturn = r.into();
                        r.result
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: fheMinReturn = r.into();
                        r.result
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `fheMul(bytes32,bytes32,bytes1)` and selector `0x57f0a568`.
```solidity
function fheMul(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheMulCall {
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`fheMul(bytes32,bytes32,bytes1)`](fheMulCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheMulReturn {
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<1>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheMulCall> for UnderlyingRustTuple<'_> {
                fn from(value: fheMulCall) -> Self {
                    (value.lhs, value.rhs, value.scalarByte)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheMulCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        lhs: tuple.0,
                        rhs: tuple.1,
                        scalarByte: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheMulReturn> for UnderlyingRustTuple<'_> {
                fn from(value: fheMulReturn) -> Self {
                    (value.result,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheMulReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { result: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for fheMulCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "fheMul(bytes32,bytes32,bytes1)";
            const SELECTOR: [u8; 4] = [87u8, 240u8, 165u8, 104u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: fheMulReturn = r.into();
                        r.result
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: fheMulReturn = r.into();
                        r.result
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `fheNe(bytes32,bytes32,bytes1)` and selector `0xd8092cbc`.
```solidity
function fheNe(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheNeCall {
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`fheNe(bytes32,bytes32,bytes1)`](fheNeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheNeReturn {
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<1>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheNeCall> for UnderlyingRustTuple<'_> {
                fn from(value: fheNeCall) -> Self {
                    (value.lhs, value.rhs, value.scalarByte)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheNeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        lhs: tuple.0,
                        rhs: tuple.1,
                        scalarByte: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheNeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: fheNeReturn) -> Self {
                    (value.result,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheNeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { result: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for fheNeCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "fheNe(bytes32,bytes32,bytes1)";
            const SELECTOR: [u8; 4] = [216u8, 9u8, 44u8, 188u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: fheNeReturn = r.into();
                        r.result
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: fheNeReturn = r.into();
                        r.result
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `fheNeg(bytes32)` and selector `0xd580c063`.
```solidity
function fheNeg(bytes32 ct) external returns (bytes32 result);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheNegCall {
        #[allow(missing_docs)]
        pub ct: alloy::sol_types::private::FixedBytes<32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`fheNeg(bytes32)`](fheNegCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheNegReturn {
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheNegCall> for UnderlyingRustTuple<'_> {
                fn from(value: fheNegCall) -> Self {
                    (value.ct,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheNegCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { ct: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheNegReturn> for UnderlyingRustTuple<'_> {
                fn from(value: fheNegReturn) -> Self {
                    (value.result,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheNegReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { result: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for fheNegCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "fheNeg(bytes32)";
            const SELECTOR: [u8; 4] = [213u8, 128u8, 192u8, 99u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.ct),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: fheNegReturn = r.into();
                        r.result
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: fheNegReturn = r.into();
                        r.result
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `fheNot(bytes32)` and selector `0xf51ccfb0`.
```solidity
function fheNot(bytes32 ct) external returns (bytes32 result);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheNotCall {
        #[allow(missing_docs)]
        pub ct: alloy::sol_types::private::FixedBytes<32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`fheNot(bytes32)`](fheNotCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheNotReturn {
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheNotCall> for UnderlyingRustTuple<'_> {
                fn from(value: fheNotCall) -> Self {
                    (value.ct,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheNotCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { ct: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheNotReturn> for UnderlyingRustTuple<'_> {
                fn from(value: fheNotReturn) -> Self {
                    (value.result,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheNotReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { result: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for fheNotCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "fheNot(bytes32)";
            const SELECTOR: [u8; 4] = [245u8, 28u8, 207u8, 176u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.ct),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: fheNotReturn = r.into();
                        r.result
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: fheNotReturn = r.into();
                        r.result
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `fheRand(uint8)` and selector `0xd75d6e8a`.
```solidity
function fheRand(FheType randType) external returns (bytes32 result);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheRandCall {
        #[allow(missing_docs)]
        pub randType: <FheType as alloy::sol_types::SolType>::RustType,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`fheRand(uint8)`](fheRandCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheRandReturn {
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (FheType,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <FheType as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheRandCall> for UnderlyingRustTuple<'_> {
                fn from(value: fheRandCall) -> Self {
                    (value.randType,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheRandCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { randType: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheRandReturn> for UnderlyingRustTuple<'_> {
                fn from(value: fheRandReturn) -> Self {
                    (value.result,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheRandReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { result: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for fheRandCall {
            type Parameters<'a> = (FheType,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "fheRand(uint8)";
            const SELECTOR: [u8; 4] = [215u8, 93u8, 110u8, 138u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<FheType as alloy_sol_types::SolType>::tokenize(&self.randType),)
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: fheRandReturn = r.into();
                        r.result
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: fheRandReturn = r.into();
                        r.result
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `fheRandBounded(uint256,uint8)` and selector `0x48eef47e`.
```solidity
function fheRandBounded(uint256 upperBound, FheType randType) external returns (bytes32 result);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheRandBoundedCall {
        #[allow(missing_docs)]
        pub upperBound: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub randType: <FheType as alloy::sol_types::SolType>::RustType,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`fheRandBounded(uint256,uint8)`](fheRandBoundedCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheRandBoundedReturn {
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                FheType,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                <FheType as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheRandBoundedCall> for UnderlyingRustTuple<'_> {
                fn from(value: fheRandBoundedCall) -> Self {
                    (value.upperBound, value.randType)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheRandBoundedCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        upperBound: tuple.0,
                        randType: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheRandBoundedReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: fheRandBoundedReturn) -> Self {
                    (value.result,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for fheRandBoundedReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { result: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for fheRandBoundedCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>, FheType);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "fheRandBounded(uint256,uint8)";
            const SELECTOR: [u8; 4] = [72u8, 238u8, 244u8, 126u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.upperBound),
                    <FheType as alloy_sol_types::SolType>::tokenize(&self.randType),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: fheRandBoundedReturn = r.into();
                        r.result
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: fheRandBoundedReturn = r.into();
                        r.result
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `fheRem(bytes32,bytes32,bytes1)` and selector `0xcf4d18aa`.
```solidity
function fheRem(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheRemCall {
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`fheRem(bytes32,bytes32,bytes1)`](fheRemCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheRemReturn {
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<1>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheRemCall> for UnderlyingRustTuple<'_> {
                fn from(value: fheRemCall) -> Self {
                    (value.lhs, value.rhs, value.scalarByte)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheRemCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        lhs: tuple.0,
                        rhs: tuple.1,
                        scalarByte: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheRemReturn> for UnderlyingRustTuple<'_> {
                fn from(value: fheRemReturn) -> Self {
                    (value.result,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheRemReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { result: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for fheRemCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "fheRem(bytes32,bytes32,bytes1)";
            const SELECTOR: [u8; 4] = [207u8, 77u8, 24u8, 170u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: fheRemReturn = r.into();
                        r.result
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: fheRemReturn = r.into();
                        r.result
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `fheRotl(bytes32,bytes32,bytes1)` and selector `0x6754b360`.
```solidity
function fheRotl(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheRotlCall {
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`fheRotl(bytes32,bytes32,bytes1)`](fheRotlCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheRotlReturn {
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<1>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheRotlCall> for UnderlyingRustTuple<'_> {
                fn from(value: fheRotlCall) -> Self {
                    (value.lhs, value.rhs, value.scalarByte)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheRotlCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        lhs: tuple.0,
                        rhs: tuple.1,
                        scalarByte: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheRotlReturn> for UnderlyingRustTuple<'_> {
                fn from(value: fheRotlReturn) -> Self {
                    (value.result,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheRotlReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { result: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for fheRotlCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "fheRotl(bytes32,bytes32,bytes1)";
            const SELECTOR: [u8; 4] = [103u8, 84u8, 179u8, 96u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: fheRotlReturn = r.into();
                        r.result
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: fheRotlReturn = r.into();
                        r.result
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `fheRotr(bytes32,bytes32,bytes1)` and selector `0xc021329e`.
```solidity
function fheRotr(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheRotrCall {
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`fheRotr(bytes32,bytes32,bytes1)`](fheRotrCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheRotrReturn {
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<1>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheRotrCall> for UnderlyingRustTuple<'_> {
                fn from(value: fheRotrCall) -> Self {
                    (value.lhs, value.rhs, value.scalarByte)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheRotrCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        lhs: tuple.0,
                        rhs: tuple.1,
                        scalarByte: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheRotrReturn> for UnderlyingRustTuple<'_> {
                fn from(value: fheRotrReturn) -> Self {
                    (value.result,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheRotrReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { result: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for fheRotrCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "fheRotr(bytes32,bytes32,bytes1)";
            const SELECTOR: [u8; 4] = [192u8, 33u8, 50u8, 158u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: fheRotrReturn = r.into();
                        r.result
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: fheRotrReturn = r.into();
                        r.result
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `fheShl(bytes32,bytes32,bytes1)` and selector `0xccc480a1`.
```solidity
function fheShl(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheShlCall {
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`fheShl(bytes32,bytes32,bytes1)`](fheShlCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheShlReturn {
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<1>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheShlCall> for UnderlyingRustTuple<'_> {
                fn from(value: fheShlCall) -> Self {
                    (value.lhs, value.rhs, value.scalarByte)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheShlCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        lhs: tuple.0,
                        rhs: tuple.1,
                        scalarByte: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheShlReturn> for UnderlyingRustTuple<'_> {
                fn from(value: fheShlReturn) -> Self {
                    (value.result,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheShlReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { result: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for fheShlCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "fheShl(bytes32,bytes32,bytes1)";
            const SELECTOR: [u8; 4] = [204u8, 196u8, 128u8, 161u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: fheShlReturn = r.into();
                        r.result
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: fheShlReturn = r.into();
                        r.result
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `fheShr(bytes32,bytes32,bytes1)` and selector `0x91f98ffe`.
```solidity
function fheShr(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheShrCall {
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`fheShr(bytes32,bytes32,bytes1)`](fheShrCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheShrReturn {
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<1>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheShrCall> for UnderlyingRustTuple<'_> {
                fn from(value: fheShrCall) -> Self {
                    (value.lhs, value.rhs, value.scalarByte)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheShrCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        lhs: tuple.0,
                        rhs: tuple.1,
                        scalarByte: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheShrReturn> for UnderlyingRustTuple<'_> {
                fn from(value: fheShrReturn) -> Self {
                    (value.result,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheShrReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { result: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for fheShrCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "fheShr(bytes32,bytes32,bytes1)";
            const SELECTOR: [u8; 4] = [145u8, 249u8, 143u8, 254u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: fheShrReturn = r.into();
                        r.result
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: fheShrReturn = r.into();
                        r.result
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `fheSub(bytes32,bytes32,bytes1)` and selector `0x182b6d98`.
```solidity
function fheSub(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheSubCall {
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`fheSub(bytes32,bytes32,bytes1)`](fheSubCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fheSubReturn {
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<1>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheSubCall> for UnderlyingRustTuple<'_> {
                fn from(value: fheSubCall) -> Self {
                    (value.lhs, value.rhs, value.scalarByte)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheSubCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        lhs: tuple.0,
                        rhs: tuple.1,
                        scalarByte: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fheSubReturn> for UnderlyingRustTuple<'_> {
                fn from(value: fheSubReturn) -> Self {
                    (value.result,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fheSubReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { result: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for fheSubCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<1>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "fheSub(bytes32,bytes32,bytes1)";
            const SELECTOR: [u8; 4] = [24u8, 43u8, 109u8, 152u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: fheSubReturn = r.into();
                        r.result
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: fheSubReturn = r.into();
                        r.result
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getACLAddress()` and selector `0xf6859bdc`.
```solidity
function getACLAddress() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getACLAddressCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getACLAddress()`](getACLAddressCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getACLAddressReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getACLAddressCall> for UnderlyingRustTuple<'_> {
                fn from(value: getACLAddressCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getACLAddressCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getACLAddressReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getACLAddressReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getACLAddressReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getACLAddressCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getACLAddress()";
            const SELECTOR: [u8; 4] = [246u8, 133u8, 155u8, 220u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getACLAddressReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getACLAddressReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getHCULimitAddress()` and selector `0xe0786972`.
```solidity
function getHCULimitAddress() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getHCULimitAddressCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getHCULimitAddress()`](getHCULimitAddressCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getHCULimitAddressReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getHCULimitAddressCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getHCULimitAddressCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getHCULimitAddressCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getHCULimitAddressReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getHCULimitAddressReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getHCULimitAddressReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getHCULimitAddressCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getHCULimitAddress()";
            const SELECTOR: [u8; 4] = [224u8, 120u8, 105u8, 114u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getHCULimitAddressReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getHCULimitAddressReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getHandleVersion()` and selector `0x7a297f4b`.
```solidity
function getHandleVersion() external pure returns (uint8);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getHandleVersionCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getHandleVersion()`](getHandleVersionCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getHandleVersionReturn {
        #[allow(missing_docs)]
        pub _0: u8,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getHandleVersionCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getHandleVersionCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getHandleVersionCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<8>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u8,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getHandleVersionReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getHandleVersionReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getHandleVersionReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getHandleVersionCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = u8;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<8>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getHandleVersion()";
            const SELECTOR: [u8; 4] = [122u8, 41u8, 127u8, 75u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getHandleVersionReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getHandleVersionReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getInputVerifierAddress()` and selector `0xa8c7c2c1`.
```solidity
function getInputVerifierAddress() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getInputVerifierAddressCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getInputVerifierAddress()`](getInputVerifierAddressCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getInputVerifierAddressReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getInputVerifierAddressCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getInputVerifierAddressCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getInputVerifierAddressCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getInputVerifierAddressReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getInputVerifierAddressReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getInputVerifierAddressReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getInputVerifierAddressCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getInputVerifierAddress()";
            const SELECTOR: [u8; 4] = [168u8, 199u8, 194u8, 193u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getInputVerifierAddressReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getInputVerifierAddressReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getVersion()` and selector `0x0d8e6e2c`.
```solidity
function getVersion() external pure returns (string memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getVersionCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getVersion()`](getVersionCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getVersionReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getVersionCall> for UnderlyingRustTuple<'_> {
                fn from(value: getVersionCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getVersionCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getVersionReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getVersionReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getVersionReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getVersionCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::String;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getVersion()";
            const SELECTOR: [u8; 4] = [13u8, 142u8, 110u8, 44u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getVersionReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getVersionReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `initializeFromEmptyProxy()` and selector `0x39f73810`.
```solidity
function initializeFromEmptyProxy() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct initializeFromEmptyProxyCall;
    ///Container type for the return parameters of the [`initializeFromEmptyProxy()`](initializeFromEmptyProxyCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct initializeFromEmptyProxyReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<initializeFromEmptyProxyCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: initializeFromEmptyProxyCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for initializeFromEmptyProxyCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<initializeFromEmptyProxyReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: initializeFromEmptyProxyReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for initializeFromEmptyProxyReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl initializeFromEmptyProxyReturn {
            fn _tokenize(
                &self,
            ) -> <initializeFromEmptyProxyCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for initializeFromEmptyProxyCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = initializeFromEmptyProxyReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "initializeFromEmptyProxy()";
            const SELECTOR: [u8; 4] = [57u8, 247u8, 56u8, 16u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                initializeFromEmptyProxyReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `proxiableUUID()` and selector `0x52d1902d`.
```solidity
function proxiableUUID() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct proxiableUUIDCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`proxiableUUID()`](proxiableUUIDCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct proxiableUUIDReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<proxiableUUIDCall> for UnderlyingRustTuple<'_> {
                fn from(value: proxiableUUIDCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for proxiableUUIDCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<proxiableUUIDReturn> for UnderlyingRustTuple<'_> {
                fn from(value: proxiableUUIDReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for proxiableUUIDReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for proxiableUUIDCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "proxiableUUID()";
            const SELECTOR: [u8; 4] = [82u8, 209u8, 144u8, 45u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: proxiableUUIDReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: proxiableUUIDReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `trivialEncrypt(uint256,uint8)` and selector `0x9cd07acb`.
```solidity
function trivialEncrypt(uint256 pt, FheType toType) external returns (bytes32 result);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct trivialEncryptCall {
        #[allow(missing_docs)]
        pub pt: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub toType: <FheType as alloy::sol_types::SolType>::RustType,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`trivialEncrypt(uint256,uint8)`](trivialEncryptCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct trivialEncryptReturn {
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                FheType,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                <FheType as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<trivialEncryptCall> for UnderlyingRustTuple<'_> {
                fn from(value: trivialEncryptCall) -> Self {
                    (value.pt, value.toType)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for trivialEncryptCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        pt: tuple.0,
                        toType: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<trivialEncryptReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: trivialEncryptReturn) -> Self {
                    (value.result,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for trivialEncryptReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { result: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for trivialEncryptCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>, FheType);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "trivialEncrypt(uint256,uint8)";
            const SELECTOR: [u8; 4] = [156u8, 208u8, 122u8, 203u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.pt),
                    <FheType as alloy_sol_types::SolType>::tokenize(&self.toType),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: trivialEncryptReturn = r.into();
                        r.result
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: trivialEncryptReturn = r.into();
                        r.result
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `upgradeToAndCall(address,bytes)` and selector `0x4f1ef286`.
```solidity
function upgradeToAndCall(address newImplementation, bytes memory data) external payable;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct upgradeToAndCallCall {
        #[allow(missing_docs)]
        pub newImplementation: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub data: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`upgradeToAndCall(address,bytes)`](upgradeToAndCallCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct upgradeToAndCallReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<upgradeToAndCallCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: upgradeToAndCallCall) -> Self {
                    (value.newImplementation, value.data)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for upgradeToAndCallCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        newImplementation: tuple.0,
                        data: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<upgradeToAndCallReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: upgradeToAndCallReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for upgradeToAndCallReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl upgradeToAndCallReturn {
            fn _tokenize(
                &self,
            ) -> <upgradeToAndCallCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for upgradeToAndCallCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = upgradeToAndCallReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "upgradeToAndCall(address,bytes)";
            const SELECTOR: [u8; 4] = [79u8, 30u8, 242u8, 134u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.newImplementation,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.data,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                upgradeToAndCallReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `verifyInput(bytes32,address,bytes,uint8)` and selector `0x08bf832a`.
```solidity
function verifyInput(bytes32 inputHandle, address userAddress, bytes memory inputProof, FheType inputType) external returns (bytes32 result);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct verifyInputCall {
        #[allow(missing_docs)]
        pub inputHandle: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub userAddress: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub inputProof: alloy::sol_types::private::Bytes,
        #[allow(missing_docs)]
        pub inputType: <FheType as alloy::sol_types::SolType>::RustType,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`verifyInput(bytes32,address,bytes,uint8)`](verifyInputCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct verifyInputReturn {
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bytes,
                FheType,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Bytes,
                <FheType as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<verifyInputCall> for UnderlyingRustTuple<'_> {
                fn from(value: verifyInputCall) -> Self {
                    (
                        value.inputHandle,
                        value.userAddress,
                        value.inputProof,
                        value.inputType,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for verifyInputCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        inputHandle: tuple.0,
                        userAddress: tuple.1,
                        inputProof: tuple.2,
                        inputType: tuple.3,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<verifyInputReturn> for UnderlyingRustTuple<'_> {
                fn from(value: verifyInputReturn) -> Self {
                    (value.result,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for verifyInputReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { result: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for verifyInputCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bytes,
                FheType,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "verifyInput(bytes32,address,bytes,uint8)";
            const SELECTOR: [u8; 4] = [8u8, 191u8, 131u8, 42u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.inputHandle),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.userAddress,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.inputProof,
                    ),
                    <FheType as alloy_sol_types::SolType>::tokenize(&self.inputType),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: verifyInputReturn = r.into();
                        r.result
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: verifyInputReturn = r.into();
                        r.result
                    })
            }
        }
    };
    ///Container for all the [`FHEVMExecutor`](self) function calls.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive()]
    pub enum FHEVMExecutorCalls {
        #[allow(missing_docs)]
        UPGRADE_INTERFACE_VERSION(UPGRADE_INTERFACE_VERSIONCall),
        #[allow(missing_docs)]
        cast(castCall),
        #[allow(missing_docs)]
        fheAdd(fheAddCall),
        #[allow(missing_docs)]
        fheBitAnd(fheBitAndCall),
        #[allow(missing_docs)]
        fheBitOr(fheBitOrCall),
        #[allow(missing_docs)]
        fheBitXor(fheBitXorCall),
        #[allow(missing_docs)]
        fheDiv(fheDivCall),
        #[allow(missing_docs)]
        fheEq(fheEqCall),
        #[allow(missing_docs)]
        fheGe(fheGeCall),
        #[allow(missing_docs)]
        fheGt(fheGtCall),
        #[allow(missing_docs)]
        fheIfThenElse(fheIfThenElseCall),
        #[allow(missing_docs)]
        fheLe(fheLeCall),
        #[allow(missing_docs)]
        fheLt(fheLtCall),
        #[allow(missing_docs)]
        fheMax(fheMaxCall),
        #[allow(missing_docs)]
        fheMin(fheMinCall),
        #[allow(missing_docs)]
        fheMul(fheMulCall),
        #[allow(missing_docs)]
        fheNe(fheNeCall),
        #[allow(missing_docs)]
        fheNeg(fheNegCall),
        #[allow(missing_docs)]
        fheNot(fheNotCall),
        #[allow(missing_docs)]
        fheRand(fheRandCall),
        #[allow(missing_docs)]
        fheRandBounded(fheRandBoundedCall),
        #[allow(missing_docs)]
        fheRem(fheRemCall),
        #[allow(missing_docs)]
        fheRotl(fheRotlCall),
        #[allow(missing_docs)]
        fheRotr(fheRotrCall),
        #[allow(missing_docs)]
        fheShl(fheShlCall),
        #[allow(missing_docs)]
        fheShr(fheShrCall),
        #[allow(missing_docs)]
        fheSub(fheSubCall),
        #[allow(missing_docs)]
        getACLAddress(getACLAddressCall),
        #[allow(missing_docs)]
        getHCULimitAddress(getHCULimitAddressCall),
        #[allow(missing_docs)]
        getHandleVersion(getHandleVersionCall),
        #[allow(missing_docs)]
        getInputVerifierAddress(getInputVerifierAddressCall),
        #[allow(missing_docs)]
        getVersion(getVersionCall),
        #[allow(missing_docs)]
        initializeFromEmptyProxy(initializeFromEmptyProxyCall),
        #[allow(missing_docs)]
        proxiableUUID(proxiableUUIDCall),
        #[allow(missing_docs)]
        trivialEncrypt(trivialEncryptCall),
        #[allow(missing_docs)]
        upgradeToAndCall(upgradeToAndCallCall),
        #[allow(missing_docs)]
        verifyInput(verifyInputCall),
    }
    #[automatically_derived]
    impl FHEVMExecutorCalls {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [4u8, 85u8, 159u8, 113u8],
            [8u8, 191u8, 131u8, 42u8],
            [13u8, 142u8, 110u8, 44u8],
            [17u8, 123u8, 47u8, 56u8],
            [19u8, 145u8, 84u8, 127u8],
            [24u8, 43u8, 109u8, 152u8],
            [28u8, 137u8, 238u8, 68u8],
            [54u8, 49u8, 141u8, 100u8],
            [57u8, 247u8, 56u8, 16u8],
            [72u8, 238u8, 244u8, 126u8],
            [79u8, 30u8, 242u8, 134u8],
            [82u8, 209u8, 144u8, 45u8],
            [87u8, 240u8, 165u8, 104u8],
            [90u8, 83u8, 172u8, 203u8],
            [99u8, 162u8, 219u8, 41u8],
            [103u8, 84u8, 179u8, 96u8],
            [114u8, 16u8, 118u8, 129u8],
            [117u8, 19u8, 164u8, 4u8],
            [119u8, 2u8, 220u8, 255u8],
            [122u8, 41u8, 127u8, 75u8],
            [133u8, 54u8, 46u8, 231u8],
            [139u8, 73u8, 206u8, 180u8],
            [145u8, 249u8, 143u8, 254u8],
            [156u8, 208u8, 122u8, 203u8],
            [168u8, 199u8, 194u8, 193u8],
            [173u8, 60u8, 177u8, 204u8],
            [192u8, 33u8, 50u8, 158u8],
            [204u8, 196u8, 128u8, 161u8],
            [207u8, 77u8, 24u8, 170u8],
            [213u8, 128u8, 192u8, 99u8],
            [215u8, 93u8, 110u8, 138u8],
            [216u8, 9u8, 44u8, 188u8],
            [217u8, 152u8, 130u8, 213u8],
            [224u8, 120u8, 105u8, 114u8],
            [245u8, 28u8, 207u8, 176u8],
            [246u8, 133u8, 155u8, 220u8],
            [247u8, 127u8, 63u8, 29u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for FHEVMExecutorCalls {
        const NAME: &'static str = "FHEVMExecutorCalls";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 37usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::UPGRADE_INTERFACE_VERSION(_) => {
                    <UPGRADE_INTERFACE_VERSIONCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::cast(_) => <castCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::fheAdd(_) => <fheAddCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::fheBitAnd(_) => {
                    <fheBitAndCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::fheBitOr(_) => <fheBitOrCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::fheBitXor(_) => {
                    <fheBitXorCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::fheDiv(_) => <fheDivCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::fheEq(_) => <fheEqCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::fheGe(_) => <fheGeCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::fheGt(_) => <fheGtCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::fheIfThenElse(_) => {
                    <fheIfThenElseCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::fheLe(_) => <fheLeCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::fheLt(_) => <fheLtCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::fheMax(_) => <fheMaxCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::fheMin(_) => <fheMinCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::fheMul(_) => <fheMulCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::fheNe(_) => <fheNeCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::fheNeg(_) => <fheNegCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::fheNot(_) => <fheNotCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::fheRand(_) => <fheRandCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::fheRandBounded(_) => {
                    <fheRandBoundedCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::fheRem(_) => <fheRemCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::fheRotl(_) => <fheRotlCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::fheRotr(_) => <fheRotrCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::fheShl(_) => <fheShlCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::fheShr(_) => <fheShrCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::fheSub(_) => <fheSubCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::getACLAddress(_) => {
                    <getACLAddressCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getHCULimitAddress(_) => {
                    <getHCULimitAddressCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getHandleVersion(_) => {
                    <getHandleVersionCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getInputVerifierAddress(_) => {
                    <getInputVerifierAddressCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getVersion(_) => {
                    <getVersionCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::initializeFromEmptyProxy(_) => {
                    <initializeFromEmptyProxyCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::proxiableUUID(_) => {
                    <proxiableUUIDCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::trivialEncrypt(_) => {
                    <trivialEncryptCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::upgradeToAndCall(_) => {
                    <upgradeToAndCallCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::verifyInput(_) => {
                    <verifyInputCall as alloy_sol_types::SolCall>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<FHEVMExecutorCalls>] = &[
                {
                    fn fheMin(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheMinCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(FHEVMExecutorCalls::fheMin)
                    }
                    fheMin
                },
                {
                    fn verifyInput(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <verifyInputCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(FHEVMExecutorCalls::verifyInput)
                    }
                    verifyInput
                },
                {
                    fn getVersion(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <getVersionCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(FHEVMExecutorCalls::getVersion)
                    }
                    getVersion
                },
                {
                    fn fheAdd(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheAddCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(FHEVMExecutorCalls::fheAdd)
                    }
                    fheAdd
                },
                {
                    fn fheGe(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheGeCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(FHEVMExecutorCalls::fheGe)
                    }
                    fheGe
                },
                {
                    fn fheSub(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheSubCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(FHEVMExecutorCalls::fheSub)
                    }
                    fheSub
                },
                {
                    fn cast(data: &[u8]) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <castCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(FHEVMExecutorCalls::cast)
                    }
                    cast
                },
                {
                    fn fheMax(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheMaxCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(FHEVMExecutorCalls::fheMax)
                    }
                    fheMax
                },
                {
                    fn initializeFromEmptyProxy(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <initializeFromEmptyProxyCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(FHEVMExecutorCalls::initializeFromEmptyProxy)
                    }
                    initializeFromEmptyProxy
                },
                {
                    fn fheRandBounded(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheRandBoundedCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(FHEVMExecutorCalls::fheRandBounded)
                    }
                    fheRandBounded
                },
                {
                    fn upgradeToAndCall(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <upgradeToAndCallCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(FHEVMExecutorCalls::upgradeToAndCall)
                    }
                    upgradeToAndCall
                },
                {
                    fn proxiableUUID(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <proxiableUUIDCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(FHEVMExecutorCalls::proxiableUUID)
                    }
                    proxiableUUID
                },
                {
                    fn fheMul(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheMulCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(FHEVMExecutorCalls::fheMul)
                    }
                    fheMul
                },
                {
                    fn fheDiv(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheDivCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(FHEVMExecutorCalls::fheDiv)
                    }
                    fheDiv
                },
                {
                    fn fheBitOr(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheBitOrCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(FHEVMExecutorCalls::fheBitOr)
                    }
                    fheBitOr
                },
                {
                    fn fheRotl(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheRotlCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(FHEVMExecutorCalls::fheRotl)
                    }
                    fheRotl
                },
                {
                    fn fheLt(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheLtCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(FHEVMExecutorCalls::fheLt)
                    }
                    fheLt
                },
                {
                    fn fheLe(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheLeCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(FHEVMExecutorCalls::fheLe)
                    }
                    fheLe
                },
                {
                    fn fheIfThenElse(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheIfThenElseCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(FHEVMExecutorCalls::fheIfThenElse)
                    }
                    fheIfThenElse
                },
                {
                    fn getHandleVersion(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <getHandleVersionCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(FHEVMExecutorCalls::getHandleVersion)
                    }
                    getHandleVersion
                },
                {
                    fn fheGt(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheGtCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(FHEVMExecutorCalls::fheGt)
                    }
                    fheGt
                },
                {
                    fn fheBitXor(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheBitXorCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(FHEVMExecutorCalls::fheBitXor)
                    }
                    fheBitXor
                },
                {
                    fn fheShr(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheShrCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(FHEVMExecutorCalls::fheShr)
                    }
                    fheShr
                },
                {
                    fn trivialEncrypt(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <trivialEncryptCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(FHEVMExecutorCalls::trivialEncrypt)
                    }
                    trivialEncrypt
                },
                {
                    fn getInputVerifierAddress(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <getInputVerifierAddressCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(FHEVMExecutorCalls::getInputVerifierAddress)
                    }
                    getInputVerifierAddress
                },
                {
                    fn UPGRADE_INTERFACE_VERSION(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <UPGRADE_INTERFACE_VERSIONCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(FHEVMExecutorCalls::UPGRADE_INTERFACE_VERSION)
                    }
                    UPGRADE_INTERFACE_VERSION
                },
                {
                    fn fheRotr(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheRotrCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(FHEVMExecutorCalls::fheRotr)
                    }
                    fheRotr
                },
                {
                    fn fheShl(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheShlCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(FHEVMExecutorCalls::fheShl)
                    }
                    fheShl
                },
                {
                    fn fheRem(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheRemCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(FHEVMExecutorCalls::fheRem)
                    }
                    fheRem
                },
                {
                    fn fheNeg(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheNegCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(FHEVMExecutorCalls::fheNeg)
                    }
                    fheNeg
                },
                {
                    fn fheRand(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheRandCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(FHEVMExecutorCalls::fheRand)
                    }
                    fheRand
                },
                {
                    fn fheNe(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheNeCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(FHEVMExecutorCalls::fheNe)
                    }
                    fheNe
                },
                {
                    fn fheBitAnd(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheBitAndCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(FHEVMExecutorCalls::fheBitAnd)
                    }
                    fheBitAnd
                },
                {
                    fn getHCULimitAddress(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <getHCULimitAddressCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(FHEVMExecutorCalls::getHCULimitAddress)
                    }
                    getHCULimitAddress
                },
                {
                    fn fheNot(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheNotCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(FHEVMExecutorCalls::fheNot)
                    }
                    fheNot
                },
                {
                    fn getACLAddress(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <getACLAddressCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(FHEVMExecutorCalls::getACLAddress)
                    }
                    getACLAddress
                },
                {
                    fn fheEq(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheEqCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(FHEVMExecutorCalls::fheEq)
                    }
                    fheEq
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data)
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw_validate(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_VALIDATE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<FHEVMExecutorCalls>] = &[
                {
                    fn fheMin(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheMinCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::fheMin)
                    }
                    fheMin
                },
                {
                    fn verifyInput(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <verifyInputCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::verifyInput)
                    }
                    verifyInput
                },
                {
                    fn getVersion(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <getVersionCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::getVersion)
                    }
                    getVersion
                },
                {
                    fn fheAdd(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheAddCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::fheAdd)
                    }
                    fheAdd
                },
                {
                    fn fheGe(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheGeCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::fheGe)
                    }
                    fheGe
                },
                {
                    fn fheSub(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheSubCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::fheSub)
                    }
                    fheSub
                },
                {
                    fn cast(data: &[u8]) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <castCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::cast)
                    }
                    cast
                },
                {
                    fn fheMax(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheMaxCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::fheMax)
                    }
                    fheMax
                },
                {
                    fn initializeFromEmptyProxy(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <initializeFromEmptyProxyCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::initializeFromEmptyProxy)
                    }
                    initializeFromEmptyProxy
                },
                {
                    fn fheRandBounded(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheRandBoundedCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::fheRandBounded)
                    }
                    fheRandBounded
                },
                {
                    fn upgradeToAndCall(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <upgradeToAndCallCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::upgradeToAndCall)
                    }
                    upgradeToAndCall
                },
                {
                    fn proxiableUUID(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <proxiableUUIDCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::proxiableUUID)
                    }
                    proxiableUUID
                },
                {
                    fn fheMul(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheMulCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::fheMul)
                    }
                    fheMul
                },
                {
                    fn fheDiv(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheDivCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::fheDiv)
                    }
                    fheDiv
                },
                {
                    fn fheBitOr(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheBitOrCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::fheBitOr)
                    }
                    fheBitOr
                },
                {
                    fn fheRotl(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheRotlCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::fheRotl)
                    }
                    fheRotl
                },
                {
                    fn fheLt(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheLtCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::fheLt)
                    }
                    fheLt
                },
                {
                    fn fheLe(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheLeCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::fheLe)
                    }
                    fheLe
                },
                {
                    fn fheIfThenElse(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheIfThenElseCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::fheIfThenElse)
                    }
                    fheIfThenElse
                },
                {
                    fn getHandleVersion(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <getHandleVersionCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::getHandleVersion)
                    }
                    getHandleVersion
                },
                {
                    fn fheGt(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheGtCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::fheGt)
                    }
                    fheGt
                },
                {
                    fn fheBitXor(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheBitXorCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::fheBitXor)
                    }
                    fheBitXor
                },
                {
                    fn fheShr(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheShrCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::fheShr)
                    }
                    fheShr
                },
                {
                    fn trivialEncrypt(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <trivialEncryptCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::trivialEncrypt)
                    }
                    trivialEncrypt
                },
                {
                    fn getInputVerifierAddress(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <getInputVerifierAddressCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::getInputVerifierAddress)
                    }
                    getInputVerifierAddress
                },
                {
                    fn UPGRADE_INTERFACE_VERSION(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <UPGRADE_INTERFACE_VERSIONCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::UPGRADE_INTERFACE_VERSION)
                    }
                    UPGRADE_INTERFACE_VERSION
                },
                {
                    fn fheRotr(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheRotrCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::fheRotr)
                    }
                    fheRotr
                },
                {
                    fn fheShl(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheShlCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::fheShl)
                    }
                    fheShl
                },
                {
                    fn fheRem(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheRemCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::fheRem)
                    }
                    fheRem
                },
                {
                    fn fheNeg(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheNegCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::fheNeg)
                    }
                    fheNeg
                },
                {
                    fn fheRand(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheRandCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::fheRand)
                    }
                    fheRand
                },
                {
                    fn fheNe(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheNeCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::fheNe)
                    }
                    fheNe
                },
                {
                    fn fheBitAnd(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheBitAndCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::fheBitAnd)
                    }
                    fheBitAnd
                },
                {
                    fn getHCULimitAddress(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <getHCULimitAddressCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::getHCULimitAddress)
                    }
                    getHCULimitAddress
                },
                {
                    fn fheNot(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheNotCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::fheNot)
                    }
                    fheNot
                },
                {
                    fn getACLAddress(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <getACLAddressCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::getACLAddress)
                    }
                    getACLAddress
                },
                {
                    fn fheEq(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorCalls> {
                        <fheEqCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorCalls::fheEq)
                    }
                    fheEq
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_VALIDATE_SHIMS[idx](data)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::UPGRADE_INTERFACE_VERSION(inner) => {
                    <UPGRADE_INTERFACE_VERSIONCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::cast(inner) => {
                    <castCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::fheAdd(inner) => {
                    <fheAddCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::fheBitAnd(inner) => {
                    <fheBitAndCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::fheBitOr(inner) => {
                    <fheBitOrCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::fheBitXor(inner) => {
                    <fheBitXorCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::fheDiv(inner) => {
                    <fheDivCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::fheEq(inner) => {
                    <fheEqCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::fheGe(inner) => {
                    <fheGeCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::fheGt(inner) => {
                    <fheGtCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::fheIfThenElse(inner) => {
                    <fheIfThenElseCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::fheLe(inner) => {
                    <fheLeCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::fheLt(inner) => {
                    <fheLtCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::fheMax(inner) => {
                    <fheMaxCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::fheMin(inner) => {
                    <fheMinCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::fheMul(inner) => {
                    <fheMulCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::fheNe(inner) => {
                    <fheNeCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::fheNeg(inner) => {
                    <fheNegCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::fheNot(inner) => {
                    <fheNotCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::fheRand(inner) => {
                    <fheRandCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::fheRandBounded(inner) => {
                    <fheRandBoundedCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::fheRem(inner) => {
                    <fheRemCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::fheRotl(inner) => {
                    <fheRotlCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::fheRotr(inner) => {
                    <fheRotrCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::fheShl(inner) => {
                    <fheShlCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::fheShr(inner) => {
                    <fheShrCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::fheSub(inner) => {
                    <fheSubCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::getACLAddress(inner) => {
                    <getACLAddressCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getHCULimitAddress(inner) => {
                    <getHCULimitAddressCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getHandleVersion(inner) => {
                    <getHandleVersionCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getInputVerifierAddress(inner) => {
                    <getInputVerifierAddressCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getVersion(inner) => {
                    <getVersionCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::initializeFromEmptyProxy(inner) => {
                    <initializeFromEmptyProxyCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::proxiableUUID(inner) => {
                    <proxiableUUIDCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::trivialEncrypt(inner) => {
                    <trivialEncryptCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::upgradeToAndCall(inner) => {
                    <upgradeToAndCallCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::verifyInput(inner) => {
                    <verifyInputCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::UPGRADE_INTERFACE_VERSION(inner) => {
                    <UPGRADE_INTERFACE_VERSIONCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::cast(inner) => {
                    <castCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::fheAdd(inner) => {
                    <fheAddCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::fheBitAnd(inner) => {
                    <fheBitAndCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::fheBitOr(inner) => {
                    <fheBitOrCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::fheBitXor(inner) => {
                    <fheBitXorCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::fheDiv(inner) => {
                    <fheDivCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::fheEq(inner) => {
                    <fheEqCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::fheGe(inner) => {
                    <fheGeCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::fheGt(inner) => {
                    <fheGtCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::fheIfThenElse(inner) => {
                    <fheIfThenElseCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::fheLe(inner) => {
                    <fheLeCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::fheLt(inner) => {
                    <fheLtCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::fheMax(inner) => {
                    <fheMaxCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::fheMin(inner) => {
                    <fheMinCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::fheMul(inner) => {
                    <fheMulCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::fheNe(inner) => {
                    <fheNeCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::fheNeg(inner) => {
                    <fheNegCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::fheNot(inner) => {
                    <fheNotCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::fheRand(inner) => {
                    <fheRandCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::fheRandBounded(inner) => {
                    <fheRandBoundedCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::fheRem(inner) => {
                    <fheRemCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::fheRotl(inner) => {
                    <fheRotlCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::fheRotr(inner) => {
                    <fheRotrCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::fheShl(inner) => {
                    <fheShlCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::fheShr(inner) => {
                    <fheShrCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::fheSub(inner) => {
                    <fheSubCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::getACLAddress(inner) => {
                    <getACLAddressCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getHCULimitAddress(inner) => {
                    <getHCULimitAddressCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getHandleVersion(inner) => {
                    <getHandleVersionCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getInputVerifierAddress(inner) => {
                    <getInputVerifierAddressCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getVersion(inner) => {
                    <getVersionCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::initializeFromEmptyProxy(inner) => {
                    <initializeFromEmptyProxyCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::proxiableUUID(inner) => {
                    <proxiableUUIDCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::trivialEncrypt(inner) => {
                    <trivialEncryptCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::upgradeToAndCall(inner) => {
                    <upgradeToAndCallCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::verifyInput(inner) => {
                    <verifyInputCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`FHEVMExecutor`](self) custom errors.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub enum FHEVMExecutorErrors {
        #[allow(missing_docs)]
        ACLNotAllowed(ACLNotAllowed),
        #[allow(missing_docs)]
        AddressEmptyCode(AddressEmptyCode),
        #[allow(missing_docs)]
        DivisionByZero(DivisionByZero),
        #[allow(missing_docs)]
        ERC1967InvalidImplementation(ERC1967InvalidImplementation),
        #[allow(missing_docs)]
        ERC1967NonPayable(ERC1967NonPayable),
        #[allow(missing_docs)]
        FailedCall(FailedCall),
        #[allow(missing_docs)]
        IncompatibleTypes(IncompatibleTypes),
        #[allow(missing_docs)]
        InvalidByteLength(InvalidByteLength),
        #[allow(missing_docs)]
        InvalidInitialization(InvalidInitialization),
        #[allow(missing_docs)]
        InvalidType(InvalidType),
        #[allow(missing_docs)]
        IsNotScalar(IsNotScalar),
        #[allow(missing_docs)]
        NotHostOwner(NotHostOwner),
        #[allow(missing_docs)]
        NotInitializing(NotInitializing),
        #[allow(missing_docs)]
        NotInitializingFromEmptyProxy(NotInitializingFromEmptyProxy),
        #[allow(missing_docs)]
        NotPowerOfTwo(NotPowerOfTwo),
        #[allow(missing_docs)]
        ScalarByteIsNotBoolean(ScalarByteIsNotBoolean),
        #[allow(missing_docs)]
        SecondOperandIsNotScalar(SecondOperandIsNotScalar),
        #[allow(missing_docs)]
        UUPSUnauthorizedCallContext(UUPSUnauthorizedCallContext),
        #[allow(missing_docs)]
        UUPSUnsupportedProxiableUUID(UUPSUnsupportedProxiableUUID),
        #[allow(missing_docs)]
        UnsupportedType(UnsupportedType),
        #[allow(missing_docs)]
        UpperBoundAboveMaxTypeValue(UpperBoundAboveMaxTypeValue),
    }
    #[automatically_derived]
    impl FHEVMExecutorErrors {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [31u8, 49u8, 88u8, 199u8],
            [33u8, 191u8, 218u8, 16u8],
            [35u8, 211u8, 89u8, 163u8],
            [36u8, 232u8, 231u8, 66u8],
            [76u8, 156u8, 140u8, 227u8],
            [77u8, 222u8, 13u8, 152u8],
            [79u8, 34u8, 78u8, 83u8],
            [111u8, 79u8, 115u8, 31u8],
            [153u8, 150u8, 179u8, 21u8],
            [157u8, 227u8, 57u8, 44u8],
            [170u8, 29u8, 73u8, 164u8],
            [179u8, 12u8, 12u8, 87u8],
            [179u8, 152u8, 151u8, 159u8],
            [185u8, 104u8, 132u8, 97u8],
            [198u8, 222u8, 70u8, 106u8],
            [199u8, 218u8, 223u8, 69u8],
            [214u8, 189u8, 162u8, 117u8],
            [215u8, 230u8, 188u8, 248u8],
            [223u8, 123u8, 243u8, 37u8],
            [224u8, 124u8, 141u8, 186u8],
            [249u8, 46u8, 232u8, 169u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for FHEVMExecutorErrors {
        const NAME: &'static str = "FHEVMExecutorErrors";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 21usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::ACLNotAllowed(_) => {
                    <ACLNotAllowed as alloy_sol_types::SolError>::SELECTOR
                }
                Self::AddressEmptyCode(_) => {
                    <AddressEmptyCode as alloy_sol_types::SolError>::SELECTOR
                }
                Self::DivisionByZero(_) => {
                    <DivisionByZero as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC1967InvalidImplementation(_) => {
                    <ERC1967InvalidImplementation as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC1967NonPayable(_) => {
                    <ERC1967NonPayable as alloy_sol_types::SolError>::SELECTOR
                }
                Self::FailedCall(_) => {
                    <FailedCall as alloy_sol_types::SolError>::SELECTOR
                }
                Self::IncompatibleTypes(_) => {
                    <IncompatibleTypes as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidByteLength(_) => {
                    <InvalidByteLength as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidInitialization(_) => {
                    <InvalidInitialization as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidType(_) => {
                    <InvalidType as alloy_sol_types::SolError>::SELECTOR
                }
                Self::IsNotScalar(_) => {
                    <IsNotScalar as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NotHostOwner(_) => {
                    <NotHostOwner as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NotInitializing(_) => {
                    <NotInitializing as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NotInitializingFromEmptyProxy(_) => {
                    <NotInitializingFromEmptyProxy as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NotPowerOfTwo(_) => {
                    <NotPowerOfTwo as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ScalarByteIsNotBoolean(_) => {
                    <ScalarByteIsNotBoolean as alloy_sol_types::SolError>::SELECTOR
                }
                Self::SecondOperandIsNotScalar(_) => {
                    <SecondOperandIsNotScalar as alloy_sol_types::SolError>::SELECTOR
                }
                Self::UUPSUnauthorizedCallContext(_) => {
                    <UUPSUnauthorizedCallContext as alloy_sol_types::SolError>::SELECTOR
                }
                Self::UUPSUnsupportedProxiableUUID(_) => {
                    <UUPSUnsupportedProxiableUUID as alloy_sol_types::SolError>::SELECTOR
                }
                Self::UnsupportedType(_) => {
                    <UnsupportedType as alloy_sol_types::SolError>::SELECTOR
                }
                Self::UpperBoundAboveMaxTypeValue(_) => {
                    <UpperBoundAboveMaxTypeValue as alloy_sol_types::SolError>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<FHEVMExecutorErrors>] = &[
                {
                    fn IncompatibleTypes(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <IncompatibleTypes as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(FHEVMExecutorErrors::IncompatibleTypes)
                    }
                    IncompatibleTypes
                },
                {
                    fn NotHostOwner(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <NotHostOwner as alloy_sol_types::SolError>::abi_decode_raw(data)
                            .map(FHEVMExecutorErrors::NotHostOwner)
                    }
                    NotHostOwner
                },
                {
                    fn DivisionByZero(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <DivisionByZero as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(FHEVMExecutorErrors::DivisionByZero)
                    }
                    DivisionByZero
                },
                {
                    fn NotPowerOfTwo(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <NotPowerOfTwo as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(FHEVMExecutorErrors::NotPowerOfTwo)
                    }
                    NotPowerOfTwo
                },
                {
                    fn ERC1967InvalidImplementation(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <ERC1967InvalidImplementation as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(FHEVMExecutorErrors::ERC1967InvalidImplementation)
                    }
                    ERC1967InvalidImplementation
                },
                {
                    fn SecondOperandIsNotScalar(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <SecondOperandIsNotScalar as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(FHEVMExecutorErrors::SecondOperandIsNotScalar)
                    }
                    SecondOperandIsNotScalar
                },
                {
                    fn IsNotScalar(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <IsNotScalar as alloy_sol_types::SolError>::abi_decode_raw(data)
                            .map(FHEVMExecutorErrors::IsNotScalar)
                    }
                    IsNotScalar
                },
                {
                    fn NotInitializingFromEmptyProxy(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <NotInitializingFromEmptyProxy as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(FHEVMExecutorErrors::NotInitializingFromEmptyProxy)
                    }
                    NotInitializingFromEmptyProxy
                },
                {
                    fn AddressEmptyCode(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <AddressEmptyCode as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(FHEVMExecutorErrors::AddressEmptyCode)
                    }
                    AddressEmptyCode
                },
                {
                    fn ACLNotAllowed(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <ACLNotAllowed as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(FHEVMExecutorErrors::ACLNotAllowed)
                    }
                    ACLNotAllowed
                },
                {
                    fn UUPSUnsupportedProxiableUUID(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <UUPSUnsupportedProxiableUUID as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(FHEVMExecutorErrors::UUPSUnsupportedProxiableUUID)
                    }
                    UUPSUnsupportedProxiableUUID
                },
                {
                    fn InvalidByteLength(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <InvalidByteLength as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(FHEVMExecutorErrors::InvalidByteLength)
                    }
                    InvalidByteLength
                },
                {
                    fn ERC1967NonPayable(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <ERC1967NonPayable as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(FHEVMExecutorErrors::ERC1967NonPayable)
                    }
                    ERC1967NonPayable
                },
                {
                    fn InvalidType(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <InvalidType as alloy_sol_types::SolError>::abi_decode_raw(data)
                            .map(FHEVMExecutorErrors::InvalidType)
                    }
                    InvalidType
                },
                {
                    fn UnsupportedType(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <UnsupportedType as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(FHEVMExecutorErrors::UnsupportedType)
                    }
                    UnsupportedType
                },
                {
                    fn UpperBoundAboveMaxTypeValue(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <UpperBoundAboveMaxTypeValue as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(FHEVMExecutorErrors::UpperBoundAboveMaxTypeValue)
                    }
                    UpperBoundAboveMaxTypeValue
                },
                {
                    fn FailedCall(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <FailedCall as alloy_sol_types::SolError>::abi_decode_raw(data)
                            .map(FHEVMExecutorErrors::FailedCall)
                    }
                    FailedCall
                },
                {
                    fn NotInitializing(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <NotInitializing as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(FHEVMExecutorErrors::NotInitializing)
                    }
                    NotInitializing
                },
                {
                    fn ScalarByteIsNotBoolean(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <ScalarByteIsNotBoolean as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(FHEVMExecutorErrors::ScalarByteIsNotBoolean)
                    }
                    ScalarByteIsNotBoolean
                },
                {
                    fn UUPSUnauthorizedCallContext(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <UUPSUnauthorizedCallContext as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(FHEVMExecutorErrors::UUPSUnauthorizedCallContext)
                    }
                    UUPSUnauthorizedCallContext
                },
                {
                    fn InvalidInitialization(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <InvalidInitialization as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(FHEVMExecutorErrors::InvalidInitialization)
                    }
                    InvalidInitialization
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data)
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw_validate(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_VALIDATE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<FHEVMExecutorErrors>] = &[
                {
                    fn IncompatibleTypes(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <IncompatibleTypes as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorErrors::IncompatibleTypes)
                    }
                    IncompatibleTypes
                },
                {
                    fn NotHostOwner(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <NotHostOwner as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorErrors::NotHostOwner)
                    }
                    NotHostOwner
                },
                {
                    fn DivisionByZero(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <DivisionByZero as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorErrors::DivisionByZero)
                    }
                    DivisionByZero
                },
                {
                    fn NotPowerOfTwo(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <NotPowerOfTwo as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorErrors::NotPowerOfTwo)
                    }
                    NotPowerOfTwo
                },
                {
                    fn ERC1967InvalidImplementation(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <ERC1967InvalidImplementation as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorErrors::ERC1967InvalidImplementation)
                    }
                    ERC1967InvalidImplementation
                },
                {
                    fn SecondOperandIsNotScalar(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <SecondOperandIsNotScalar as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorErrors::SecondOperandIsNotScalar)
                    }
                    SecondOperandIsNotScalar
                },
                {
                    fn IsNotScalar(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <IsNotScalar as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorErrors::IsNotScalar)
                    }
                    IsNotScalar
                },
                {
                    fn NotInitializingFromEmptyProxy(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <NotInitializingFromEmptyProxy as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorErrors::NotInitializingFromEmptyProxy)
                    }
                    NotInitializingFromEmptyProxy
                },
                {
                    fn AddressEmptyCode(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <AddressEmptyCode as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorErrors::AddressEmptyCode)
                    }
                    AddressEmptyCode
                },
                {
                    fn ACLNotAllowed(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <ACLNotAllowed as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorErrors::ACLNotAllowed)
                    }
                    ACLNotAllowed
                },
                {
                    fn UUPSUnsupportedProxiableUUID(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <UUPSUnsupportedProxiableUUID as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorErrors::UUPSUnsupportedProxiableUUID)
                    }
                    UUPSUnsupportedProxiableUUID
                },
                {
                    fn InvalidByteLength(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <InvalidByteLength as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorErrors::InvalidByteLength)
                    }
                    InvalidByteLength
                },
                {
                    fn ERC1967NonPayable(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <ERC1967NonPayable as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorErrors::ERC1967NonPayable)
                    }
                    ERC1967NonPayable
                },
                {
                    fn InvalidType(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <InvalidType as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorErrors::InvalidType)
                    }
                    InvalidType
                },
                {
                    fn UnsupportedType(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <UnsupportedType as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorErrors::UnsupportedType)
                    }
                    UnsupportedType
                },
                {
                    fn UpperBoundAboveMaxTypeValue(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <UpperBoundAboveMaxTypeValue as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorErrors::UpperBoundAboveMaxTypeValue)
                    }
                    UpperBoundAboveMaxTypeValue
                },
                {
                    fn FailedCall(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <FailedCall as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorErrors::FailedCall)
                    }
                    FailedCall
                },
                {
                    fn NotInitializing(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <NotInitializing as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorErrors::NotInitializing)
                    }
                    NotInitializing
                },
                {
                    fn ScalarByteIsNotBoolean(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <ScalarByteIsNotBoolean as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorErrors::ScalarByteIsNotBoolean)
                    }
                    ScalarByteIsNotBoolean
                },
                {
                    fn UUPSUnauthorizedCallContext(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <UUPSUnauthorizedCallContext as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorErrors::UUPSUnauthorizedCallContext)
                    }
                    UUPSUnauthorizedCallContext
                },
                {
                    fn InvalidInitialization(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<FHEVMExecutorErrors> {
                        <InvalidInitialization as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(FHEVMExecutorErrors::InvalidInitialization)
                    }
                    InvalidInitialization
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_VALIDATE_SHIMS[idx](data)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::ACLNotAllowed(inner) => {
                    <ACLNotAllowed as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::AddressEmptyCode(inner) => {
                    <AddressEmptyCode as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::DivisionByZero(inner) => {
                    <DivisionByZero as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC1967InvalidImplementation(inner) => {
                    <ERC1967InvalidImplementation as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC1967NonPayable(inner) => {
                    <ERC1967NonPayable as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::FailedCall(inner) => {
                    <FailedCall as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::IncompatibleTypes(inner) => {
                    <IncompatibleTypes as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidByteLength(inner) => {
                    <InvalidByteLength as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidInitialization(inner) => {
                    <InvalidInitialization as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidType(inner) => {
                    <InvalidType as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::IsNotScalar(inner) => {
                    <IsNotScalar as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::NotHostOwner(inner) => {
                    <NotHostOwner as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::NotInitializing(inner) => {
                    <NotInitializing as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NotInitializingFromEmptyProxy(inner) => {
                    <NotInitializingFromEmptyProxy as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NotPowerOfTwo(inner) => {
                    <NotPowerOfTwo as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::ScalarByteIsNotBoolean(inner) => {
                    <ScalarByteIsNotBoolean as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::SecondOperandIsNotScalar(inner) => {
                    <SecondOperandIsNotScalar as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::UUPSUnauthorizedCallContext(inner) => {
                    <UUPSUnauthorizedCallContext as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::UUPSUnsupportedProxiableUUID(inner) => {
                    <UUPSUnsupportedProxiableUUID as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::UnsupportedType(inner) => {
                    <UnsupportedType as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::UpperBoundAboveMaxTypeValue(inner) => {
                    <UpperBoundAboveMaxTypeValue as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::ACLNotAllowed(inner) => {
                    <ACLNotAllowed as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::AddressEmptyCode(inner) => {
                    <AddressEmptyCode as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::DivisionByZero(inner) => {
                    <DivisionByZero as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC1967InvalidImplementation(inner) => {
                    <ERC1967InvalidImplementation as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC1967NonPayable(inner) => {
                    <ERC1967NonPayable as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::FailedCall(inner) => {
                    <FailedCall as alloy_sol_types::SolError>::abi_encode_raw(inner, out)
                }
                Self::IncompatibleTypes(inner) => {
                    <IncompatibleTypes as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidByteLength(inner) => {
                    <InvalidByteLength as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidInitialization(inner) => {
                    <InvalidInitialization as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidType(inner) => {
                    <InvalidType as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::IsNotScalar(inner) => {
                    <IsNotScalar as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NotHostOwner(inner) => {
                    <NotHostOwner as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NotInitializing(inner) => {
                    <NotInitializing as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NotInitializingFromEmptyProxy(inner) => {
                    <NotInitializingFromEmptyProxy as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NotPowerOfTwo(inner) => {
                    <NotPowerOfTwo as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ScalarByteIsNotBoolean(inner) => {
                    <ScalarByteIsNotBoolean as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::SecondOperandIsNotScalar(inner) => {
                    <SecondOperandIsNotScalar as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::UUPSUnauthorizedCallContext(inner) => {
                    <UUPSUnauthorizedCallContext as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::UUPSUnsupportedProxiableUUID(inner) => {
                    <UUPSUnsupportedProxiableUUID as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::UnsupportedType(inner) => {
                    <UnsupportedType as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::UpperBoundAboveMaxTypeValue(inner) => {
                    <UpperBoundAboveMaxTypeValue as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`FHEVMExecutor`](self) events.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub enum FHEVMExecutorEvents {
        #[allow(missing_docs)]
        Cast(Cast),
        #[allow(missing_docs)]
        FheAdd(FheAdd),
        #[allow(missing_docs)]
        FheBitAnd(FheBitAnd),
        #[allow(missing_docs)]
        FheBitOr(FheBitOr),
        #[allow(missing_docs)]
        FheBitXor(FheBitXor),
        #[allow(missing_docs)]
        FheDiv(FheDiv),
        #[allow(missing_docs)]
        FheEq(FheEq),
        #[allow(missing_docs)]
        FheGe(FheGe),
        #[allow(missing_docs)]
        FheGt(FheGt),
        #[allow(missing_docs)]
        FheIfThenElse(FheIfThenElse),
        #[allow(missing_docs)]
        FheLe(FheLe),
        #[allow(missing_docs)]
        FheLt(FheLt),
        #[allow(missing_docs)]
        FheMax(FheMax),
        #[allow(missing_docs)]
        FheMin(FheMin),
        #[allow(missing_docs)]
        FheMul(FheMul),
        #[allow(missing_docs)]
        FheNe(FheNe),
        #[allow(missing_docs)]
        FheNeg(FheNeg),
        #[allow(missing_docs)]
        FheNot(FheNot),
        #[allow(missing_docs)]
        FheRand(FheRand),
        #[allow(missing_docs)]
        FheRandBounded(FheRandBounded),
        #[allow(missing_docs)]
        FheRem(FheRem),
        #[allow(missing_docs)]
        FheRotl(FheRotl),
        #[allow(missing_docs)]
        FheRotr(FheRotr),
        #[allow(missing_docs)]
        FheShl(FheShl),
        #[allow(missing_docs)]
        FheShr(FheShr),
        #[allow(missing_docs)]
        FheSub(FheSub),
        #[allow(missing_docs)]
        Initialized(Initialized),
        #[allow(missing_docs)]
        TrivialEncrypt(TrivialEncrypt),
        #[allow(missing_docs)]
        Upgraded(Upgraded),
        #[allow(missing_docs)]
        VerifyInput(VerifyInput),
    }
    #[automatically_derived]
    impl FHEVMExecutorEvents {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 32usize]] = &[
            [
                6u8, 60u8, 205u8, 27u8, 186u8, 69u8, 21u8, 29u8, 145u8, 246u8, 164u8,
                24u8, 6u8, 80u8, 71u8, 163u8, 208u8, 72u8, 208u8, 88u8, 169u8, 34u8,
                83u8, 87u8, 71u8, 187u8, 43u8, 87u8, 90u8, 1u8, 210u8, 54u8,
            ],
            [
                12u8, 138u8, 202u8, 96u8, 23u8, 0u8, 51u8, 38u8, 5u8, 30u8, 25u8, 145u8,
                62u8, 240u8, 38u8, 49u8, 242u8, 75u8, 128u8, 17u8, 37u8, 225u8, 250u8,
                138u8, 29u8, 129u8, 46u8, 134u8, 131u8, 25u8, 253u8, 166u8,
            ],
            [
                13u8, 72u8, 59u8, 16u8, 13u8, 140u8, 115u8, 178u8, 8u8, 152u8, 78u8,
                198u8, 151u8, 202u8, 163u8, 9u8, 21u8, 33u8, 238u8, 85u8, 37u8, 206u8,
                105u8, 237u8, 207u8, 151u8, 215u8, 227u8, 149u8, 211u8, 208u8, 89u8,
            ],
            [
                14u8, 105u8, 28u8, 208u8, 191u8, 140u8, 78u8, 147u8, 8u8, 228u8, 206u8,
                209u8, 187u8, 156u8, 150u8, 65u8, 23u8, 220u8, 92u8, 91u8, 185u8, 185u8,
                171u8, 91u8, 223u8, 235u8, 242u8, 201u8, 177u8, 58u8, 137u8, 124u8,
            ],
            [
                33u8, 83u8, 70u8, 164u8, 249u8, 249u8, 117u8, 230u8, 213u8, 72u8, 78u8,
                41u8, 11u8, 212u8, 229u8, 60u8, 161u8, 68u8, 83u8, 169u8, 210u8, 130u8,
                235u8, 211u8, 204u8, 237u8, 178u8, 160u8, 241u8, 113u8, 117u8, 61u8,
            ],
            [
                49u8, 204u8, 174u8, 106u8, 47u8, 142u8, 60u8, 237u8, 22u8, 146u8, 247u8,
                124u8, 143u8, 102u8, 129u8, 51u8, 228u8, 175u8, 218u8, 170u8, 53u8,
                175u8, 232u8, 68u8, 255u8, 70u8, 89u8, 166u8, 194u8, 126u8, 98u8, 127u8,
            ],
            [
                50u8, 66u8, 32u8, 191u8, 201u8, 203u8, 21u8, 139u8, 73u8, 41u8, 145u8,
                192u8, 60u8, 48u8, 156u8, 216u8, 110u8, 83u8, 69u8, 202u8, 196u8, 90u8,
                172u8, 174u8, 32u8, 146u8, 221u8, 171u8, 227u8, 31u8, 163u8, 216u8,
            ],
            [
                56u8, 195u8, 166u8, 60u8, 66u8, 48u8, 222u8, 91u8, 116u8, 31u8, 73u8,
                79u8, 251u8, 84u8, 227u8, 8u8, 113u8, 4u8, 3u8, 2u8, 121u8, 188u8, 123u8,
                204u8, 238u8, 138u8, 217u8, 173u8, 49u8, 113u8, 43u8, 33u8,
            ],
            [
                59u8, 171u8, 46u8, 224u8, 226u8, 249u8, 15u8, 70u8, 144u8, 198u8, 168u8,
                123u8, 246u8, 60u8, 241u8, 166u8, 182u8, 38u8, 8u8, 110u8, 149u8, 242u8,
                49u8, 134u8, 11u8, 21u8, 41u8, 102u8, 232u8, 218u8, 187u8, 247u8,
            ],
            [
                77u8, 50u8, 40u8, 75u8, 211u8, 25u8, 62u8, 202u8, 164u8, 78u8, 28u8,
                236u8, 163u8, 47u8, 65u8, 197u8, 214u8, 195u8, 40u8, 3u8, 169u8, 46u8,
                7u8, 150u8, 125u8, 211u8, 238u8, 66u8, 41u8, 114u8, 21u8, 130u8,
            ],
            [
                82u8, 34u8, 217u8, 107u8, 131u8, 103u8, 39u8, 161u8, 214u8, 254u8, 30u8,
                233u8, 174u8, 242u8, 127u8, 155u8, 181u8, 7u8, 189u8, 65u8, 121u8, 77u8,
                239u8, 163u8, 118u8, 255u8, 108u8, 100u8, 138u8, 175u8, 143u8, 241u8,
            ],
            [
                85u8, 175u8, 244u8, 204u8, 122u8, 61u8, 22u8, 12u8, 131u8, 241u8, 241u8,
                91u8, 129u8, 128u8, 17u8, 237u8, 232u8, 65u8, 160u8, 180u8, 89u8, 127u8,
                177u8, 77u8, 205u8, 54u8, 3u8, 223u8, 58u8, 17u8, 229u8, 224u8,
            ],
            [
                86u8, 223u8, 39u8, 155u8, 191u8, 176u8, 61u8, 158u8, 208u8, 151u8, 187u8,
                226u8, 242u8, 141u8, 82u8, 12u8, 160u8, 193u8, 22u8, 18u8, 6u8, 50u8,
                121u8, 38u8, 233u8, 134u8, 100u8, 215u8, 13u8, 44u8, 36u8, 196u8,
            ],
            [
                96u8, 190u8, 157u8, 97u8, 170u8, 216u8, 73u8, 250u8, 204u8, 40u8, 195u8,
                139u8, 4u8, 140u8, 181u8, 196u8, 190u8, 52u8, 32u8, 184u8, 250u8, 34u8,
                51u8, 224u8, 140u8, 250u8, 6u8, 190u8, 27u8, 109u8, 28u8, 62u8,
            ],
            [
                105u8, 96u8, 193u8, 232u8, 143u8, 97u8, 195u8, 82u8, 219u8, 163u8, 77u8,
                27u8, 191u8, 103u8, 83u8, 227u8, 2u8, 121u8, 82u8, 100u8, 213u8, 216u8,
                174u8, 130u8, 247u8, 152u8, 60u8, 112u8, 4u8, 101u8, 30u8, 93u8,
            ],
            [
                140u8, 102u8, 77u8, 60u8, 60u8, 165u8, 131u8, 252u8, 88u8, 3u8, 184u8,
                169u8, 28u8, 73u8, 100u8, 75u8, 189u8, 149u8, 80u8, 191u8, 168u8, 121u8,
                103u8, 199u8, 58u8, 209u8, 222u8, 131u8, 2u8, 119u8, 104u8, 192u8,
            ],
            [
                179u8, 213u8, 198u8, 100u8, 236u8, 134u8, 87u8, 88u8, 24u8, 232u8, 215u8,
                95u8, 242u8, 92u8, 95u8, 134u8, 114u8, 80u8, 223u8, 137u8, 84u8, 8u8,
                133u8, 73u8, 196u8, 28u8, 132u8, 140u8, 209u8, 14u8, 118u8, 203u8,
            ],
            [
                188u8, 124u8, 215u8, 90u8, 32u8, 238u8, 39u8, 253u8, 154u8, 222u8, 186u8,
                179u8, 32u8, 65u8, 247u8, 85u8, 33u8, 77u8, 188u8, 107u8, 255u8, 169u8,
                12u8, 192u8, 34u8, 91u8, 57u8, 218u8, 46u8, 92u8, 45u8, 59u8,
            ],
            [
                193u8, 29u8, 98u8, 177u8, 60u8, 54u8, 10u8, 131u8, 8u8, 36u8, 135u8, 6u8,
                75u8, 225u8, 236u8, 8u8, 120u8, 178u8, 240u8, 190u8, 79u8, 1u8, 43u8,
                245u8, 159u8, 137u8, 225u8, 40u8, 6u8, 61u8, 71u8, 255u8,
            ],
            [
                193u8, 72u8, 103u8, 89u8, 5u8, 208u8, 122u8, 213u8, 73u8, 111u8, 142u8,
                244u8, 216u8, 25u8, 92u8, 144u8, 117u8, 3u8, 243u8, 236u8, 18u8, 253u8,
                16u8, 237u8, 95u8, 33u8, 36u8, 10u8, 188u8, 105u8, 54u8, 52u8,
            ],
            [
                199u8, 245u8, 5u8, 178u8, 243u8, 113u8, 174u8, 33u8, 117u8, 238u8, 73u8,
                19u8, 244u8, 73u8, 158u8, 31u8, 38u8, 51u8, 167u8, 181u8, 147u8, 99u8,
                33u8, 238u8, 209u8, 205u8, 174u8, 182u8, 17u8, 81u8, 129u8, 210u8,
            ],
            [
                201u8, 255u8, 143u8, 13u8, 24u8, 163u8, 247u8, 102u8, 206u8, 93u8, 227u8,
                222u8, 33u8, 96u8, 118u8, 5u8, 1u8, 64u8, 228u8, 252u8, 38u8, 82u8,
                245u8, 224u8, 231u8, 69u8, 246u8, 252u8, 131u8, 108u8, 218u8, 139u8,
            ],
            [
                219u8, 144u8, 80u8, 214u8, 82u8, 64u8, 67u8, 22u8, 33u8, 214u8, 29u8,
                111u8, 148u8, 185u8, 112u8, 230u8, 63u8, 83u8, 166u8, 122u8, 87u8, 102u8,
                97u8, 78u8, 230u8, 229u8, 197u8, 187u8, 212u8, 28u8, 142u8, 46u8,
            ],
            [
                220u8, 55u8, 13u8, 179u8, 53u8, 137u8, 231u8, 51u8, 113u8, 220u8, 62u8,
                228u8, 44u8, 120u8, 156u8, 0u8, 61u8, 51u8, 110u8, 239u8, 203u8, 124u8,
                63u8, 86u8, 254u8, 15u8, 81u8, 174u8, 91u8, 29u8, 151u8, 2u8,
            ],
            [
                222u8, 242u8, 231u8, 4u8, 160u8, 119u8, 40u8, 74u8, 7u8, 243u8, 208u8,
                180u8, 54u8, 219u8, 136u8, 245u8, 217u8, 129u8, 182u8, 159u8, 88u8,
                171u8, 124u8, 26u8, 230u8, 35u8, 37u8, 39u8, 24u8, 166u8, 222u8, 1u8,
            ],
            [
                228u8, 36u8, 134u8, 176u8, 204u8, 219u8, 239u8, 129u8, 162u8, 7u8, 92u8,
                72u8, 200u8, 229u8, 21u8, 192u8, 121u8, 174u8, 167u8, 60u8, 139u8, 130u8,
                66u8, 153u8, 151u8, 199u8, 42u8, 47u8, 225u8, 191u8, 79u8, 239u8,
            ],
            [
                232u8, 66u8, 130u8, 170u8, 235u8, 204u8, 166u8, 152u8, 68u8, 62u8, 57u8,
                162u8, 169u8, 72u8, 163u8, 69u8, 208u8, 210u8, 235u8, 198u8, 84u8, 175u8,
                92u8, 182u8, 87u8, 162u8, 215u8, 232u8, 5u8, 59u8, 246u8, 203u8,
            ],
            [
                235u8, 14u8, 79u8, 141u8, 199u8, 64u8, 88u8, 25u8, 77u8, 6u8, 2u8, 66u8,
                95u8, 230u8, 2u8, 249u8, 85u8, 194u8, 34u8, 32u8, 15u8, 127u8, 16u8,
                198u8, 254u8, 103u8, 153u8, 47u8, 123u8, 36u8, 199u8, 233u8,
            ],
            [
                235u8, 109u8, 55u8, 189u8, 39u8, 26u8, 190u8, 19u8, 149u8, 178u8, 29u8,
                109u8, 120u8, 243u8, 72u8, 125u8, 101u8, 132u8, 134u8, 40u8, 114u8,
                194u8, 159u8, 253u8, 63u8, 144u8, 115u8, 110u8, 233u8, 155u8, 115u8,
                147u8,
            ],
            [
                253u8, 124u8, 146u8, 8u8, 249u8, 86u8, 191u8, 12u8, 106u8, 183u8, 106u8,
                102u8, 127u8, 4u8, 54u8, 18u8, 69u8, 173u8, 62u8, 10u8, 45u8, 14u8,
                255u8, 146u8, 235u8, 130u8, 122u8, 207u8, 204u8, 166u8, 142u8, 169u8,
            ],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolEventInterface for FHEVMExecutorEvents {
        const NAME: &'static str = "FHEVMExecutorEvents";
        const COUNT: usize = 30usize;
        fn decode_raw_log(
            topics: &[alloy_sol_types::Word],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            match topics.first().copied() {
                Some(<Cast as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Cast as alloy_sol_types::SolEvent>::decode_raw_log(topics, data)
                        .map(Self::Cast)
                }
                Some(<FheAdd as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <FheAdd as alloy_sol_types::SolEvent>::decode_raw_log(topics, data)
                        .map(Self::FheAdd)
                }
                Some(<FheBitAnd as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <FheBitAnd as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::FheBitAnd)
                }
                Some(<FheBitOr as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <FheBitOr as alloy_sol_types::SolEvent>::decode_raw_log(topics, data)
                        .map(Self::FheBitOr)
                }
                Some(<FheBitXor as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <FheBitXor as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::FheBitXor)
                }
                Some(<FheDiv as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <FheDiv as alloy_sol_types::SolEvent>::decode_raw_log(topics, data)
                        .map(Self::FheDiv)
                }
                Some(<FheEq as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <FheEq as alloy_sol_types::SolEvent>::decode_raw_log(topics, data)
                        .map(Self::FheEq)
                }
                Some(<FheGe as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <FheGe as alloy_sol_types::SolEvent>::decode_raw_log(topics, data)
                        .map(Self::FheGe)
                }
                Some(<FheGt as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <FheGt as alloy_sol_types::SolEvent>::decode_raw_log(topics, data)
                        .map(Self::FheGt)
                }
                Some(<FheIfThenElse as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <FheIfThenElse as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::FheIfThenElse)
                }
                Some(<FheLe as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <FheLe as alloy_sol_types::SolEvent>::decode_raw_log(topics, data)
                        .map(Self::FheLe)
                }
                Some(<FheLt as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <FheLt as alloy_sol_types::SolEvent>::decode_raw_log(topics, data)
                        .map(Self::FheLt)
                }
                Some(<FheMax as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <FheMax as alloy_sol_types::SolEvent>::decode_raw_log(topics, data)
                        .map(Self::FheMax)
                }
                Some(<FheMin as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <FheMin as alloy_sol_types::SolEvent>::decode_raw_log(topics, data)
                        .map(Self::FheMin)
                }
                Some(<FheMul as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <FheMul as alloy_sol_types::SolEvent>::decode_raw_log(topics, data)
                        .map(Self::FheMul)
                }
                Some(<FheNe as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <FheNe as alloy_sol_types::SolEvent>::decode_raw_log(topics, data)
                        .map(Self::FheNe)
                }
                Some(<FheNeg as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <FheNeg as alloy_sol_types::SolEvent>::decode_raw_log(topics, data)
                        .map(Self::FheNeg)
                }
                Some(<FheNot as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <FheNot as alloy_sol_types::SolEvent>::decode_raw_log(topics, data)
                        .map(Self::FheNot)
                }
                Some(<FheRand as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <FheRand as alloy_sol_types::SolEvent>::decode_raw_log(topics, data)
                        .map(Self::FheRand)
                }
                Some(<FheRandBounded as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <FheRandBounded as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::FheRandBounded)
                }
                Some(<FheRem as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <FheRem as alloy_sol_types::SolEvent>::decode_raw_log(topics, data)
                        .map(Self::FheRem)
                }
                Some(<FheRotl as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <FheRotl as alloy_sol_types::SolEvent>::decode_raw_log(topics, data)
                        .map(Self::FheRotl)
                }
                Some(<FheRotr as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <FheRotr as alloy_sol_types::SolEvent>::decode_raw_log(topics, data)
                        .map(Self::FheRotr)
                }
                Some(<FheShl as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <FheShl as alloy_sol_types::SolEvent>::decode_raw_log(topics, data)
                        .map(Self::FheShl)
                }
                Some(<FheShr as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <FheShr as alloy_sol_types::SolEvent>::decode_raw_log(topics, data)
                        .map(Self::FheShr)
                }
                Some(<FheSub as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <FheSub as alloy_sol_types::SolEvent>::decode_raw_log(topics, data)
                        .map(Self::FheSub)
                }
                Some(<Initialized as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Initialized as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::Initialized)
                }
                Some(<TrivialEncrypt as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <TrivialEncrypt as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::TrivialEncrypt)
                }
                Some(<Upgraded as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Upgraded as alloy_sol_types::SolEvent>::decode_raw_log(topics, data)
                        .map(Self::Upgraded)
                }
                Some(<VerifyInput as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <VerifyInput as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::VerifyInput)
                }
                _ => {
                    alloy_sol_types::private::Err(alloy_sol_types::Error::InvalidLog {
                        name: <Self as alloy_sol_types::SolEventInterface>::NAME,
                        log: alloy_sol_types::private::Box::new(
                            alloy_sol_types::private::LogData::new_unchecked(
                                topics.to_vec(),
                                data.to_vec().into(),
                            ),
                        ),
                    })
                }
            }
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::private::IntoLogData for FHEVMExecutorEvents {
        fn to_log_data(&self) -> alloy_sol_types::private::LogData {
            match self {
                Self::Cast(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::FheAdd(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::FheBitAnd(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::FheBitOr(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::FheBitXor(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::FheDiv(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::FheEq(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::FheGe(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::FheGt(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::FheIfThenElse(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::FheLe(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::FheLt(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::FheMax(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::FheMin(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::FheMul(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::FheNe(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::FheNeg(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::FheNot(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::FheRand(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::FheRandBounded(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::FheRem(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::FheRotl(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::FheRotr(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::FheShl(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::FheShr(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::FheSub(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Initialized(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::TrivialEncrypt(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Upgraded(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::VerifyInput(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
            }
        }
        fn into_log_data(self) -> alloy_sol_types::private::LogData {
            match self {
                Self::Cast(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::FheAdd(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::FheBitAnd(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::FheBitOr(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::FheBitXor(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::FheDiv(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::FheEq(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::FheGe(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::FheGt(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::FheIfThenElse(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::FheLe(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::FheLt(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::FheMax(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::FheMin(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::FheMul(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::FheNe(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::FheNeg(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::FheNot(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::FheRand(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::FheRandBounded(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::FheRem(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::FheRotl(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::FheRotr(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::FheShl(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::FheShr(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::FheSub(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Initialized(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::TrivialEncrypt(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Upgraded(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::VerifyInput(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`FHEVMExecutor`](self) contract instance.

See the [wrapper's documentation](`FHEVMExecutorInstance`) for more details.*/
    #[inline]
    pub const fn new<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> FHEVMExecutorInstance<P, N> {
        FHEVMExecutorInstance::<P, N>::new(address, provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
    ) -> impl ::core::future::Future<
        Output = alloy_contract::Result<FHEVMExecutorInstance<P, N>>,
    > {
        FHEVMExecutorInstance::<P, N>::deploy(provider)
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(provider: P) -> alloy_contract::RawCallBuilder<P, N> {
        FHEVMExecutorInstance::<P, N>::deploy_builder(provider)
    }
    /**A [`FHEVMExecutor`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`FHEVMExecutor`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct FHEVMExecutorInstance<P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network: ::core::marker::PhantomData<N>,
    }
    #[automatically_derived]
    impl<P, N> ::core::fmt::Debug for FHEVMExecutorInstance<P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("FHEVMExecutorInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > FHEVMExecutorInstance<P, N> {
        /**Creates a new wrapper around an on-chain [`FHEVMExecutor`](self) contract instance.

See the [wrapper's documentation](`FHEVMExecutorInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            provider: P,
        ) -> Self {
            Self {
                address,
                provider,
                _network: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            provider: P,
        ) -> alloy_contract::Result<FHEVMExecutorInstance<P, N>> {
            let call_builder = Self::deploy_builder(provider);
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(provider: P) -> alloy_contract::RawCallBuilder<P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                provider,
                ::core::clone::Clone::clone(&BYTECODE),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<P: ::core::clone::Clone, N> FHEVMExecutorInstance<&P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> FHEVMExecutorInstance<P, N> {
            FHEVMExecutorInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > FHEVMExecutorInstance<P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<&P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        ///Creates a new call builder for the [`UPGRADE_INTERFACE_VERSION`] function.
        pub fn UPGRADE_INTERFACE_VERSION(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, UPGRADE_INTERFACE_VERSIONCall, N> {
            self.call_builder(&UPGRADE_INTERFACE_VERSIONCall)
        }
        ///Creates a new call builder for the [`cast`] function.
        pub fn cast(
            &self,
            ct: alloy::sol_types::private::FixedBytes<32>,
            toType: <FheType as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<&P, castCall, N> {
            self.call_builder(&castCall { ct, toType })
        }
        ///Creates a new call builder for the [`fheAdd`] function.
        pub fn fheAdd(
            &self,
            lhs: alloy::sol_types::private::FixedBytes<32>,
            rhs: alloy::sol_types::private::FixedBytes<32>,
            scalarByte: alloy::sol_types::private::FixedBytes<1>,
        ) -> alloy_contract::SolCallBuilder<&P, fheAddCall, N> {
            self.call_builder(&fheAddCall { lhs, rhs, scalarByte })
        }
        ///Creates a new call builder for the [`fheBitAnd`] function.
        pub fn fheBitAnd(
            &self,
            lhs: alloy::sol_types::private::FixedBytes<32>,
            rhs: alloy::sol_types::private::FixedBytes<32>,
            scalarByte: alloy::sol_types::private::FixedBytes<1>,
        ) -> alloy_contract::SolCallBuilder<&P, fheBitAndCall, N> {
            self.call_builder(
                &fheBitAndCall {
                    lhs,
                    rhs,
                    scalarByte,
                },
            )
        }
        ///Creates a new call builder for the [`fheBitOr`] function.
        pub fn fheBitOr(
            &self,
            lhs: alloy::sol_types::private::FixedBytes<32>,
            rhs: alloy::sol_types::private::FixedBytes<32>,
            scalarByte: alloy::sol_types::private::FixedBytes<1>,
        ) -> alloy_contract::SolCallBuilder<&P, fheBitOrCall, N> {
            self.call_builder(
                &fheBitOrCall {
                    lhs,
                    rhs,
                    scalarByte,
                },
            )
        }
        ///Creates a new call builder for the [`fheBitXor`] function.
        pub fn fheBitXor(
            &self,
            lhs: alloy::sol_types::private::FixedBytes<32>,
            rhs: alloy::sol_types::private::FixedBytes<32>,
            scalarByte: alloy::sol_types::private::FixedBytes<1>,
        ) -> alloy_contract::SolCallBuilder<&P, fheBitXorCall, N> {
            self.call_builder(
                &fheBitXorCall {
                    lhs,
                    rhs,
                    scalarByte,
                },
            )
        }
        ///Creates a new call builder for the [`fheDiv`] function.
        pub fn fheDiv(
            &self,
            lhs: alloy::sol_types::private::FixedBytes<32>,
            rhs: alloy::sol_types::private::FixedBytes<32>,
            scalarByte: alloy::sol_types::private::FixedBytes<1>,
        ) -> alloy_contract::SolCallBuilder<&P, fheDivCall, N> {
            self.call_builder(&fheDivCall { lhs, rhs, scalarByte })
        }
        ///Creates a new call builder for the [`fheEq`] function.
        pub fn fheEq(
            &self,
            lhs: alloy::sol_types::private::FixedBytes<32>,
            rhs: alloy::sol_types::private::FixedBytes<32>,
            scalarByte: alloy::sol_types::private::FixedBytes<1>,
        ) -> alloy_contract::SolCallBuilder<&P, fheEqCall, N> {
            self.call_builder(&fheEqCall { lhs, rhs, scalarByte })
        }
        ///Creates a new call builder for the [`fheGe`] function.
        pub fn fheGe(
            &self,
            lhs: alloy::sol_types::private::FixedBytes<32>,
            rhs: alloy::sol_types::private::FixedBytes<32>,
            scalarByte: alloy::sol_types::private::FixedBytes<1>,
        ) -> alloy_contract::SolCallBuilder<&P, fheGeCall, N> {
            self.call_builder(&fheGeCall { lhs, rhs, scalarByte })
        }
        ///Creates a new call builder for the [`fheGt`] function.
        pub fn fheGt(
            &self,
            lhs: alloy::sol_types::private::FixedBytes<32>,
            rhs: alloy::sol_types::private::FixedBytes<32>,
            scalarByte: alloy::sol_types::private::FixedBytes<1>,
        ) -> alloy_contract::SolCallBuilder<&P, fheGtCall, N> {
            self.call_builder(&fheGtCall { lhs, rhs, scalarByte })
        }
        ///Creates a new call builder for the [`fheIfThenElse`] function.
        pub fn fheIfThenElse(
            &self,
            control: alloy::sol_types::private::FixedBytes<32>,
            ifTrue: alloy::sol_types::private::FixedBytes<32>,
            ifFalse: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<&P, fheIfThenElseCall, N> {
            self.call_builder(
                &fheIfThenElseCall {
                    control,
                    ifTrue,
                    ifFalse,
                },
            )
        }
        ///Creates a new call builder for the [`fheLe`] function.
        pub fn fheLe(
            &self,
            lhs: alloy::sol_types::private::FixedBytes<32>,
            rhs: alloy::sol_types::private::FixedBytes<32>,
            scalarByte: alloy::sol_types::private::FixedBytes<1>,
        ) -> alloy_contract::SolCallBuilder<&P, fheLeCall, N> {
            self.call_builder(&fheLeCall { lhs, rhs, scalarByte })
        }
        ///Creates a new call builder for the [`fheLt`] function.
        pub fn fheLt(
            &self,
            lhs: alloy::sol_types::private::FixedBytes<32>,
            rhs: alloy::sol_types::private::FixedBytes<32>,
            scalarByte: alloy::sol_types::private::FixedBytes<1>,
        ) -> alloy_contract::SolCallBuilder<&P, fheLtCall, N> {
            self.call_builder(&fheLtCall { lhs, rhs, scalarByte })
        }
        ///Creates a new call builder for the [`fheMax`] function.
        pub fn fheMax(
            &self,
            lhs: alloy::sol_types::private::FixedBytes<32>,
            rhs: alloy::sol_types::private::FixedBytes<32>,
            scalarByte: alloy::sol_types::private::FixedBytes<1>,
        ) -> alloy_contract::SolCallBuilder<&P, fheMaxCall, N> {
            self.call_builder(&fheMaxCall { lhs, rhs, scalarByte })
        }
        ///Creates a new call builder for the [`fheMin`] function.
        pub fn fheMin(
            &self,
            lhs: alloy::sol_types::private::FixedBytes<32>,
            rhs: alloy::sol_types::private::FixedBytes<32>,
            scalarByte: alloy::sol_types::private::FixedBytes<1>,
        ) -> alloy_contract::SolCallBuilder<&P, fheMinCall, N> {
            self.call_builder(&fheMinCall { lhs, rhs, scalarByte })
        }
        ///Creates a new call builder for the [`fheMul`] function.
        pub fn fheMul(
            &self,
            lhs: alloy::sol_types::private::FixedBytes<32>,
            rhs: alloy::sol_types::private::FixedBytes<32>,
            scalarByte: alloy::sol_types::private::FixedBytes<1>,
        ) -> alloy_contract::SolCallBuilder<&P, fheMulCall, N> {
            self.call_builder(&fheMulCall { lhs, rhs, scalarByte })
        }
        ///Creates a new call builder for the [`fheNe`] function.
        pub fn fheNe(
            &self,
            lhs: alloy::sol_types::private::FixedBytes<32>,
            rhs: alloy::sol_types::private::FixedBytes<32>,
            scalarByte: alloy::sol_types::private::FixedBytes<1>,
        ) -> alloy_contract::SolCallBuilder<&P, fheNeCall, N> {
            self.call_builder(&fheNeCall { lhs, rhs, scalarByte })
        }
        ///Creates a new call builder for the [`fheNeg`] function.
        pub fn fheNeg(
            &self,
            ct: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<&P, fheNegCall, N> {
            self.call_builder(&fheNegCall { ct })
        }
        ///Creates a new call builder for the [`fheNot`] function.
        pub fn fheNot(
            &self,
            ct: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<&P, fheNotCall, N> {
            self.call_builder(&fheNotCall { ct })
        }
        ///Creates a new call builder for the [`fheRand`] function.
        pub fn fheRand(
            &self,
            randType: <FheType as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<&P, fheRandCall, N> {
            self.call_builder(&fheRandCall { randType })
        }
        ///Creates a new call builder for the [`fheRandBounded`] function.
        pub fn fheRandBounded(
            &self,
            upperBound: alloy::sol_types::private::primitives::aliases::U256,
            randType: <FheType as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<&P, fheRandBoundedCall, N> {
            self.call_builder(
                &fheRandBoundedCall {
                    upperBound,
                    randType,
                },
            )
        }
        ///Creates a new call builder for the [`fheRem`] function.
        pub fn fheRem(
            &self,
            lhs: alloy::sol_types::private::FixedBytes<32>,
            rhs: alloy::sol_types::private::FixedBytes<32>,
            scalarByte: alloy::sol_types::private::FixedBytes<1>,
        ) -> alloy_contract::SolCallBuilder<&P, fheRemCall, N> {
            self.call_builder(&fheRemCall { lhs, rhs, scalarByte })
        }
        ///Creates a new call builder for the [`fheRotl`] function.
        pub fn fheRotl(
            &self,
            lhs: alloy::sol_types::private::FixedBytes<32>,
            rhs: alloy::sol_types::private::FixedBytes<32>,
            scalarByte: alloy::sol_types::private::FixedBytes<1>,
        ) -> alloy_contract::SolCallBuilder<&P, fheRotlCall, N> {
            self.call_builder(
                &fheRotlCall {
                    lhs,
                    rhs,
                    scalarByte,
                },
            )
        }
        ///Creates a new call builder for the [`fheRotr`] function.
        pub fn fheRotr(
            &self,
            lhs: alloy::sol_types::private::FixedBytes<32>,
            rhs: alloy::sol_types::private::FixedBytes<32>,
            scalarByte: alloy::sol_types::private::FixedBytes<1>,
        ) -> alloy_contract::SolCallBuilder<&P, fheRotrCall, N> {
            self.call_builder(
                &fheRotrCall {
                    lhs,
                    rhs,
                    scalarByte,
                },
            )
        }
        ///Creates a new call builder for the [`fheShl`] function.
        pub fn fheShl(
            &self,
            lhs: alloy::sol_types::private::FixedBytes<32>,
            rhs: alloy::sol_types::private::FixedBytes<32>,
            scalarByte: alloy::sol_types::private::FixedBytes<1>,
        ) -> alloy_contract::SolCallBuilder<&P, fheShlCall, N> {
            self.call_builder(&fheShlCall { lhs, rhs, scalarByte })
        }
        ///Creates a new call builder for the [`fheShr`] function.
        pub fn fheShr(
            &self,
            lhs: alloy::sol_types::private::FixedBytes<32>,
            rhs: alloy::sol_types::private::FixedBytes<32>,
            scalarByte: alloy::sol_types::private::FixedBytes<1>,
        ) -> alloy_contract::SolCallBuilder<&P, fheShrCall, N> {
            self.call_builder(&fheShrCall { lhs, rhs, scalarByte })
        }
        ///Creates a new call builder for the [`fheSub`] function.
        pub fn fheSub(
            &self,
            lhs: alloy::sol_types::private::FixedBytes<32>,
            rhs: alloy::sol_types::private::FixedBytes<32>,
            scalarByte: alloy::sol_types::private::FixedBytes<1>,
        ) -> alloy_contract::SolCallBuilder<&P, fheSubCall, N> {
            self.call_builder(&fheSubCall { lhs, rhs, scalarByte })
        }
        ///Creates a new call builder for the [`getACLAddress`] function.
        pub fn getACLAddress(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, getACLAddressCall, N> {
            self.call_builder(&getACLAddressCall)
        }
        ///Creates a new call builder for the [`getHCULimitAddress`] function.
        pub fn getHCULimitAddress(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, getHCULimitAddressCall, N> {
            self.call_builder(&getHCULimitAddressCall)
        }
        ///Creates a new call builder for the [`getHandleVersion`] function.
        pub fn getHandleVersion(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, getHandleVersionCall, N> {
            self.call_builder(&getHandleVersionCall)
        }
        ///Creates a new call builder for the [`getInputVerifierAddress`] function.
        pub fn getInputVerifierAddress(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, getInputVerifierAddressCall, N> {
            self.call_builder(&getInputVerifierAddressCall)
        }
        ///Creates a new call builder for the [`getVersion`] function.
        pub fn getVersion(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, getVersionCall, N> {
            self.call_builder(&getVersionCall)
        }
        ///Creates a new call builder for the [`initializeFromEmptyProxy`] function.
        pub fn initializeFromEmptyProxy(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, initializeFromEmptyProxyCall, N> {
            self.call_builder(&initializeFromEmptyProxyCall)
        }
        ///Creates a new call builder for the [`proxiableUUID`] function.
        pub fn proxiableUUID(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, proxiableUUIDCall, N> {
            self.call_builder(&proxiableUUIDCall)
        }
        ///Creates a new call builder for the [`trivialEncrypt`] function.
        pub fn trivialEncrypt(
            &self,
            pt: alloy::sol_types::private::primitives::aliases::U256,
            toType: <FheType as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<&P, trivialEncryptCall, N> {
            self.call_builder(&trivialEncryptCall { pt, toType })
        }
        ///Creates a new call builder for the [`upgradeToAndCall`] function.
        pub fn upgradeToAndCall(
            &self,
            newImplementation: alloy::sol_types::private::Address,
            data: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<&P, upgradeToAndCallCall, N> {
            self.call_builder(
                &upgradeToAndCallCall {
                    newImplementation,
                    data,
                },
            )
        }
        ///Creates a new call builder for the [`verifyInput`] function.
        pub fn verifyInput(
            &self,
            inputHandle: alloy::sol_types::private::FixedBytes<32>,
            userAddress: alloy::sol_types::private::Address,
            inputProof: alloy::sol_types::private::Bytes,
            inputType: <FheType as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<&P, verifyInputCall, N> {
            self.call_builder(
                &verifyInputCall {
                    inputHandle,
                    userAddress,
                    inputProof,
                    inputType,
                },
            )
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > FHEVMExecutorInstance<P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<&P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
        ///Creates a new event filter for the [`Cast`] event.
        pub fn Cast_filter(&self) -> alloy_contract::Event<&P, Cast, N> {
            self.event_filter::<Cast>()
        }
        ///Creates a new event filter for the [`FheAdd`] event.
        pub fn FheAdd_filter(&self) -> alloy_contract::Event<&P, FheAdd, N> {
            self.event_filter::<FheAdd>()
        }
        ///Creates a new event filter for the [`FheBitAnd`] event.
        pub fn FheBitAnd_filter(&self) -> alloy_contract::Event<&P, FheBitAnd, N> {
            self.event_filter::<FheBitAnd>()
        }
        ///Creates a new event filter for the [`FheBitOr`] event.
        pub fn FheBitOr_filter(&self) -> alloy_contract::Event<&P, FheBitOr, N> {
            self.event_filter::<FheBitOr>()
        }
        ///Creates a new event filter for the [`FheBitXor`] event.
        pub fn FheBitXor_filter(&self) -> alloy_contract::Event<&P, FheBitXor, N> {
            self.event_filter::<FheBitXor>()
        }
        ///Creates a new event filter for the [`FheDiv`] event.
        pub fn FheDiv_filter(&self) -> alloy_contract::Event<&P, FheDiv, N> {
            self.event_filter::<FheDiv>()
        }
        ///Creates a new event filter for the [`FheEq`] event.
        pub fn FheEq_filter(&self) -> alloy_contract::Event<&P, FheEq, N> {
            self.event_filter::<FheEq>()
        }
        ///Creates a new event filter for the [`FheGe`] event.
        pub fn FheGe_filter(&self) -> alloy_contract::Event<&P, FheGe, N> {
            self.event_filter::<FheGe>()
        }
        ///Creates a new event filter for the [`FheGt`] event.
        pub fn FheGt_filter(&self) -> alloy_contract::Event<&P, FheGt, N> {
            self.event_filter::<FheGt>()
        }
        ///Creates a new event filter for the [`FheIfThenElse`] event.
        pub fn FheIfThenElse_filter(
            &self,
        ) -> alloy_contract::Event<&P, FheIfThenElse, N> {
            self.event_filter::<FheIfThenElse>()
        }
        ///Creates a new event filter for the [`FheLe`] event.
        pub fn FheLe_filter(&self) -> alloy_contract::Event<&P, FheLe, N> {
            self.event_filter::<FheLe>()
        }
        ///Creates a new event filter for the [`FheLt`] event.
        pub fn FheLt_filter(&self) -> alloy_contract::Event<&P, FheLt, N> {
            self.event_filter::<FheLt>()
        }
        ///Creates a new event filter for the [`FheMax`] event.
        pub fn FheMax_filter(&self) -> alloy_contract::Event<&P, FheMax, N> {
            self.event_filter::<FheMax>()
        }
        ///Creates a new event filter for the [`FheMin`] event.
        pub fn FheMin_filter(&self) -> alloy_contract::Event<&P, FheMin, N> {
            self.event_filter::<FheMin>()
        }
        ///Creates a new event filter for the [`FheMul`] event.
        pub fn FheMul_filter(&self) -> alloy_contract::Event<&P, FheMul, N> {
            self.event_filter::<FheMul>()
        }
        ///Creates a new event filter for the [`FheNe`] event.
        pub fn FheNe_filter(&self) -> alloy_contract::Event<&P, FheNe, N> {
            self.event_filter::<FheNe>()
        }
        ///Creates a new event filter for the [`FheNeg`] event.
        pub fn FheNeg_filter(&self) -> alloy_contract::Event<&P, FheNeg, N> {
            self.event_filter::<FheNeg>()
        }
        ///Creates a new event filter for the [`FheNot`] event.
        pub fn FheNot_filter(&self) -> alloy_contract::Event<&P, FheNot, N> {
            self.event_filter::<FheNot>()
        }
        ///Creates a new event filter for the [`FheRand`] event.
        pub fn FheRand_filter(&self) -> alloy_contract::Event<&P, FheRand, N> {
            self.event_filter::<FheRand>()
        }
        ///Creates a new event filter for the [`FheRandBounded`] event.
        pub fn FheRandBounded_filter(
            &self,
        ) -> alloy_contract::Event<&P, FheRandBounded, N> {
            self.event_filter::<FheRandBounded>()
        }
        ///Creates a new event filter for the [`FheRem`] event.
        pub fn FheRem_filter(&self) -> alloy_contract::Event<&P, FheRem, N> {
            self.event_filter::<FheRem>()
        }
        ///Creates a new event filter for the [`FheRotl`] event.
        pub fn FheRotl_filter(&self) -> alloy_contract::Event<&P, FheRotl, N> {
            self.event_filter::<FheRotl>()
        }
        ///Creates a new event filter for the [`FheRotr`] event.
        pub fn FheRotr_filter(&self) -> alloy_contract::Event<&P, FheRotr, N> {
            self.event_filter::<FheRotr>()
        }
        ///Creates a new event filter for the [`FheShl`] event.
        pub fn FheShl_filter(&self) -> alloy_contract::Event<&P, FheShl, N> {
            self.event_filter::<FheShl>()
        }
        ///Creates a new event filter for the [`FheShr`] event.
        pub fn FheShr_filter(&self) -> alloy_contract::Event<&P, FheShr, N> {
            self.event_filter::<FheShr>()
        }
        ///Creates a new event filter for the [`FheSub`] event.
        pub fn FheSub_filter(&self) -> alloy_contract::Event<&P, FheSub, N> {
            self.event_filter::<FheSub>()
        }
        ///Creates a new event filter for the [`Initialized`] event.
        pub fn Initialized_filter(&self) -> alloy_contract::Event<&P, Initialized, N> {
            self.event_filter::<Initialized>()
        }
        ///Creates a new event filter for the [`TrivialEncrypt`] event.
        pub fn TrivialEncrypt_filter(
            &self,
        ) -> alloy_contract::Event<&P, TrivialEncrypt, N> {
            self.event_filter::<TrivialEncrypt>()
        }
        ///Creates a new event filter for the [`Upgraded`] event.
        pub fn Upgraded_filter(&self) -> alloy_contract::Event<&P, Upgraded, N> {
            self.event_filter::<Upgraded>()
        }
        ///Creates a new event filter for the [`VerifyInput`] event.
        pub fn VerifyInput_filter(&self) -> alloy_contract::Event<&P, VerifyInput, N> {
            self.event_filter::<VerifyInput>()
        }
    }
}
