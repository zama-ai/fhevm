/**

Generated by the following Solidity interface...
```solidity
interface HCULimit {
    type FheType is uint8;

    error AddressEmptyCode(address target);
    error CallerMustBeFHEVMExecutorContract();
    error ERC1967InvalidImplementation(address implementation);
    error ERC1967NonPayable();
    error FailedCall();
    error HCUTransactionDepthLimitExceeded();
    error HCUTransactionLimitExceeded();
    error InvalidInitialization();
    error NotHostOwner(address sender);
    error NotInitializing();
    error NotInitializingFromEmptyProxy();
    error OnlyScalarOperationsAreSupported();
    error UUPSUnauthorizedCallContext();
    error UUPSUnsupportedProxiableUUID(bytes32 slot);
    error UnsupportedOperation();

    event Initialized(uint64 version);
    event Upgraded(address indexed implementation);

    constructor();

    function UPGRADE_INTERFACE_VERSION() external view returns (string memory);
    function checkHCUForCast(FheType resultType, bytes32 ct, bytes32 result) external;
    function checkHCUForFheAdd(FheType resultType, bytes1 scalarByte, bytes32 lhs, bytes32 rhs, bytes32 result) external;
    function checkHCUForFheBitAnd(FheType resultType, bytes1 scalarByte, bytes32 lhs, bytes32 rhs, bytes32 result) external;
    function checkHCUForFheBitOr(FheType resultType, bytes1 scalarByte, bytes32 lhs, bytes32 rhs, bytes32 result) external;
    function checkHCUForFheBitXor(FheType resultType, bytes1 scalarByte, bytes32 lhs, bytes32 rhs, bytes32 result) external;
    function checkHCUForFheDiv(FheType resultType, bytes1 scalarByte, bytes32 lhs, bytes32, bytes32 result) external;
    function checkHCUForFheEq(FheType resultType, bytes1 scalarByte, bytes32 lhs, bytes32 rhs, bytes32 result) external;
    function checkHCUForFheGe(FheType resultType, bytes1 scalarByte, bytes32 lhs, bytes32 rhs, bytes32 result) external;
    function checkHCUForFheGt(FheType resultType, bytes1 scalarByte, bytes32 lhs, bytes32 rhs, bytes32 result) external;
    function checkHCUForFheLe(FheType resultType, bytes1 scalarByte, bytes32 lhs, bytes32 rhs, bytes32 result) external;
    function checkHCUForFheLt(FheType resultType, bytes1 scalarByte, bytes32 lhs, bytes32 rhs, bytes32 result) external;
    function checkHCUForFheMax(FheType resultType, bytes1 scalarByte, bytes32 lhs, bytes32 rhs, bytes32 result) external;
    function checkHCUForFheMin(FheType resultType, bytes1 scalarByte, bytes32 lhs, bytes32 rhs, bytes32 result) external;
    function checkHCUForFheMul(FheType resultType, bytes1 scalarByte, bytes32 lhs, bytes32 rhs, bytes32 result) external;
    function checkHCUForFheNe(FheType resultType, bytes1 scalarByte, bytes32 lhs, bytes32 rhs, bytes32 result) external;
    function checkHCUForFheNeg(FheType resultType, bytes32 ct, bytes32 result) external;
    function checkHCUForFheNot(FheType resultType, bytes32 ct, bytes32 result) external;
    function checkHCUForFheRand(FheType resultType, bytes32 result) external;
    function checkHCUForFheRandBounded(FheType resultType, bytes32 result) external;
    function checkHCUForFheRem(FheType resultType, bytes1 scalarByte, bytes32 lhs, bytes32, bytes32 result) external;
    function checkHCUForFheRotl(FheType resultType, bytes1 scalarByte, bytes32 lhs, bytes32 rhs, bytes32 result) external;
    function checkHCUForFheRotr(FheType resultType, bytes1 scalarByte, bytes32 lhs, bytes32 rhs, bytes32 result) external;
    function checkHCUForFheShl(FheType resultType, bytes1 scalarByte, bytes32 lhs, bytes32 rhs, bytes32 result) external;
    function checkHCUForFheShr(FheType resultType, bytes1 scalarByte, bytes32 lhs, bytes32 rhs, bytes32 result) external;
    function checkHCUForFheSub(FheType resultType, bytes1 scalarByte, bytes32 lhs, bytes32 rhs, bytes32 result) external;
    function checkHCUForIfThenElse(FheType resultType, bytes32 lhs, bytes32 middle, bytes32 rhs, bytes32 result) external;
    function checkHCUForTrivialEncrypt(FheType resultType, bytes32 result) external;
    function getFHEVMExecutorAddress() external view returns (address);
    function getVersion() external pure returns (string memory);
    function initializeFromEmptyProxy() external;
    function proxiableUUID() external view returns (bytes32);
    function upgradeToAndCall(address newImplementation, bytes memory data) external payable;
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "constructor",
    "inputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "UPGRADE_INTERFACE_VERSION",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "checkHCUForCast",
    "inputs": [
      {
        "name": "resultType",
        "type": "uint8",
        "internalType": "enum FheType"
      },
      {
        "name": "ct",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "checkHCUForFheAdd",
    "inputs": [
      {
        "name": "resultType",
        "type": "uint8",
        "internalType": "enum FheType"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "internalType": "bytes1"
      },
      {
        "name": "lhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "checkHCUForFheBitAnd",
    "inputs": [
      {
        "name": "resultType",
        "type": "uint8",
        "internalType": "enum FheType"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "internalType": "bytes1"
      },
      {
        "name": "lhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "checkHCUForFheBitOr",
    "inputs": [
      {
        "name": "resultType",
        "type": "uint8",
        "internalType": "enum FheType"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "internalType": "bytes1"
      },
      {
        "name": "lhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "checkHCUForFheBitXor",
    "inputs": [
      {
        "name": "resultType",
        "type": "uint8",
        "internalType": "enum FheType"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "internalType": "bytes1"
      },
      {
        "name": "lhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "checkHCUForFheDiv",
    "inputs": [
      {
        "name": "resultType",
        "type": "uint8",
        "internalType": "enum FheType"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "internalType": "bytes1"
      },
      {
        "name": "lhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "checkHCUForFheEq",
    "inputs": [
      {
        "name": "resultType",
        "type": "uint8",
        "internalType": "enum FheType"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "internalType": "bytes1"
      },
      {
        "name": "lhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "checkHCUForFheGe",
    "inputs": [
      {
        "name": "resultType",
        "type": "uint8",
        "internalType": "enum FheType"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "internalType": "bytes1"
      },
      {
        "name": "lhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "checkHCUForFheGt",
    "inputs": [
      {
        "name": "resultType",
        "type": "uint8",
        "internalType": "enum FheType"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "internalType": "bytes1"
      },
      {
        "name": "lhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "checkHCUForFheLe",
    "inputs": [
      {
        "name": "resultType",
        "type": "uint8",
        "internalType": "enum FheType"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "internalType": "bytes1"
      },
      {
        "name": "lhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "checkHCUForFheLt",
    "inputs": [
      {
        "name": "resultType",
        "type": "uint8",
        "internalType": "enum FheType"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "internalType": "bytes1"
      },
      {
        "name": "lhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "checkHCUForFheMax",
    "inputs": [
      {
        "name": "resultType",
        "type": "uint8",
        "internalType": "enum FheType"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "internalType": "bytes1"
      },
      {
        "name": "lhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "checkHCUForFheMin",
    "inputs": [
      {
        "name": "resultType",
        "type": "uint8",
        "internalType": "enum FheType"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "internalType": "bytes1"
      },
      {
        "name": "lhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "checkHCUForFheMul",
    "inputs": [
      {
        "name": "resultType",
        "type": "uint8",
        "internalType": "enum FheType"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "internalType": "bytes1"
      },
      {
        "name": "lhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "checkHCUForFheNe",
    "inputs": [
      {
        "name": "resultType",
        "type": "uint8",
        "internalType": "enum FheType"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "internalType": "bytes1"
      },
      {
        "name": "lhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "checkHCUForFheNeg",
    "inputs": [
      {
        "name": "resultType",
        "type": "uint8",
        "internalType": "enum FheType"
      },
      {
        "name": "ct",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "checkHCUForFheNot",
    "inputs": [
      {
        "name": "resultType",
        "type": "uint8",
        "internalType": "enum FheType"
      },
      {
        "name": "ct",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "checkHCUForFheRand",
    "inputs": [
      {
        "name": "resultType",
        "type": "uint8",
        "internalType": "enum FheType"
      },
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "checkHCUForFheRandBounded",
    "inputs": [
      {
        "name": "resultType",
        "type": "uint8",
        "internalType": "enum FheType"
      },
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "checkHCUForFheRem",
    "inputs": [
      {
        "name": "resultType",
        "type": "uint8",
        "internalType": "enum FheType"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "internalType": "bytes1"
      },
      {
        "name": "lhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "checkHCUForFheRotl",
    "inputs": [
      {
        "name": "resultType",
        "type": "uint8",
        "internalType": "enum FheType"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "internalType": "bytes1"
      },
      {
        "name": "lhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "checkHCUForFheRotr",
    "inputs": [
      {
        "name": "resultType",
        "type": "uint8",
        "internalType": "enum FheType"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "internalType": "bytes1"
      },
      {
        "name": "lhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "checkHCUForFheShl",
    "inputs": [
      {
        "name": "resultType",
        "type": "uint8",
        "internalType": "enum FheType"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "internalType": "bytes1"
      },
      {
        "name": "lhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "checkHCUForFheShr",
    "inputs": [
      {
        "name": "resultType",
        "type": "uint8",
        "internalType": "enum FheType"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "internalType": "bytes1"
      },
      {
        "name": "lhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "checkHCUForFheSub",
    "inputs": [
      {
        "name": "resultType",
        "type": "uint8",
        "internalType": "enum FheType"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "internalType": "bytes1"
      },
      {
        "name": "lhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "checkHCUForIfThenElse",
    "inputs": [
      {
        "name": "resultType",
        "type": "uint8",
        "internalType": "enum FheType"
      },
      {
        "name": "lhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "middle",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "checkHCUForTrivialEncrypt",
    "inputs": [
      {
        "name": "resultType",
        "type": "uint8",
        "internalType": "enum FheType"
      },
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "getFHEVMExecutorAddress",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getVersion",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "initializeFromEmptyProxy",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "proxiableUUID",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "upgradeToAndCall",
    "inputs": [
      {
        "name": "newImplementation",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "data",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [],
    "stateMutability": "payable"
  },
  {
    "type": "event",
    "name": "Initialized",
    "inputs": [
      {
        "name": "version",
        "type": "uint64",
        "indexed": false,
        "internalType": "uint64"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Upgraded",
    "inputs": [
      {
        "name": "implementation",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "error",
    "name": "AddressEmptyCode",
    "inputs": [
      {
        "name": "target",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "CallerMustBeFHEVMExecutorContract",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ERC1967InvalidImplementation",
    "inputs": [
      {
        "name": "implementation",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "ERC1967NonPayable",
    "inputs": []
  },
  {
    "type": "error",
    "name": "FailedCall",
    "inputs": []
  },
  {
    "type": "error",
    "name": "HCUTransactionDepthLimitExceeded",
    "inputs": []
  },
  {
    "type": "error",
    "name": "HCUTransactionLimitExceeded",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidInitialization",
    "inputs": []
  },
  {
    "type": "error",
    "name": "NotHostOwner",
    "inputs": [
      {
        "name": "sender",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "NotInitializing",
    "inputs": []
  },
  {
    "type": "error",
    "name": "NotInitializingFromEmptyProxy",
    "inputs": []
  },
  {
    "type": "error",
    "name": "OnlyScalarOperationsAreSupported",
    "inputs": []
  },
  {
    "type": "error",
    "name": "UUPSUnauthorizedCallContext",
    "inputs": []
  },
  {
    "type": "error",
    "name": "UUPSUnsupportedProxiableUUID",
    "inputs": [
      {
        "name": "slot",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ]
  },
  {
    "type": "error",
    "name": "UnsupportedOperation",
    "inputs": []
  }
]
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod HCULimit {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x60a06040523073ffffffffffffffffffffffffffffffffffffffff1660809073ffffffffffffffffffffffffffffffffffffffff1681525034801562000043575f80fd5b50620000546200005a60201b60201c565b620001c4565b5f6200006b6200015e60201b60201c565b9050805f0160089054906101000a900460ff1615620000b6576040517ff92ee8a900000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b67ffffffffffffffff8016815f015f9054906101000a900467ffffffffffffffff1667ffffffffffffffff16146200015b5767ffffffffffffffff815f015f6101000a81548167ffffffffffffffff021916908367ffffffffffffffff1602179055507fc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d267ffffffffffffffff604051620001529190620001a9565b60405180910390a15b50565b5f7ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00905090565b5f67ffffffffffffffff82169050919050565b620001a38162000185565b82525050565b5f602082019050620001be5f83018462000198565b92915050565b608051617415620001eb5f395f81816163df0152818161643401526166d601526174155ff3fe6080604052600436106101ed575f3560e01c8063642b14901161010c578063acb5f3881161009f578063e8e399ad1161006e578063e8e399ad1461063b578063fa08e38d14610663578063fa5defdb1461068b578063fc063c62146106b3578063fdad4c96146106db576101ed565b8063acb5f38814610599578063ad3cb1cc146105c1578063cc866782146105eb578063d47f3d5914610613576101ed565b8063859a1b70116100db578063859a1b70146104f9578063907531081461052157806394e70e4f14610549578063a4c98f3e14610571576101ed565b8063642b149014610459578063669181c0146104815780636bb3c611146104a957806383e6a720146104d1576101ed565b8063268d6d3111610184578063406b451311610153578063406b4513146103c35780634e726769146103eb5780634f1ef2861461041357806352d1902d1461042f576101ed565b8063268d6d3114610333578063348c31851461035d57806339f73810146103855780633c16ff0d1461039b576101ed565b80631434ba4d116101c05780631434ba4d1461029357806314526e87146102bb5780631856d91d146102e35780631ed91ff61461030b576101ed565b806302dd6276146101f157806309b04e8f146102195780630d8e6e2c146102415780631339c5ee1461026b575b5f80fd5b3480156101fc575f80fd5b5061021760048036038101906102129190616c68565b610703565b005b348015610224575f80fd5b5061023f600480360381019061023a9190616cb8565b610938565b005b34801561024c575f80fd5b50610255610b7b565b6040516102629190616d80565b60405180910390f35b348015610276575f80fd5b50610291600480360381019061028c9190616df5565b610bf6565b005b34801561029e575f80fd5b506102b960048036038101906102b49190616df5565b610f51565b005b3480156102c6575f80fd5b506102e160048036038101906102dc9190616df5565b61137f565b005b3480156102ee575f80fd5b5061030960048036038101906103049190616df5565b611747565b005b348015610316575f80fd5b50610331600480360381019061032c9190616df5565b611b75565b005b34801561033e575f80fd5b50610347611f3d565b6040516103549190616eab565b60405180910390f35b348015610368575f80fd5b50610383600480360381019061037e9190616cb8565b611f58565b005b348015610390575f80fd5b506103996121ca565b005b3480156103a6575f80fd5b506103c160048036038101906103bc9190616df5565b61233a565b005b3480156103ce575f80fd5b506103e960048036038101906103e49190616df5565b612698565b005b3480156103f6575f80fd5b50610411600480360381019061040c9190616ec4565b6128cd565b005b61042d60048036038101906104289190617091565b612b46565b005b34801561043a575f80fd5b50610443612b65565b60405161045091906170fa565b60405180910390f35b348015610464575f80fd5b5061047f600480360381019061047a9190616df5565b612b96565b005b34801561048c575f80fd5b506104a760048036038101906104a29190616df5565b612ef4565b005b3480156104b4575f80fd5b506104cf60048036038101906104ca9190616df5565b6132bc565b005b3480156104dc575f80fd5b506104f760048036038101906104f29190616df5565b613617565b005b348015610504575f80fd5b5061051f600480360381019061051a9190616df5565b6139df565b005b34801561052c575f80fd5b5061054760048036038101906105429190616df5565b613d3a565b005b348015610554575f80fd5b5061056f600480360381019061056a9190616df5565b614098565b005b34801561057c575f80fd5b5061059760048036038101906105929190616c68565b61453f565b005b3480156105a4575f80fd5b506105bf60048036038101906105ba9190616df5565b61474b565b005b3480156105cc575f80fd5b506105d5614aa9565b6040516105e29190616d80565b60405180910390f35b3480156105f6575f80fd5b50610611600480360381019061060c9190616cb8565b614ae2565b005b34801561061e575f80fd5b5061063960048036038101906106349190616df5565b614cef565b005b348015610646575f80fd5b50610661600480360381019061065c9190616df5565b61504a565b005b34801561066e575f80fd5b5061068960048036038101906106849190616df5565b615478565b005b348015610696575f80fd5b506106b160048036038101906106ac9190616df5565b6156ad565b005b3480156106be575f80fd5b506106d960048036038101906106d49190616c68565b615b54565b005b3480156106e6575f80fd5b5061070160048036038101906106fc9190616df5565b615d89565b005b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161461077c576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f8060538111156107905761078f617113565b5b8460538111156107a3576107a2617113565b5b036107b15760209050610927565b600260538111156107c5576107c4617113565b5b8460538111156107d8576107d7617113565b5b036107e65760209050610926565b600360538111156107fa576107f9617113565b5b84605381111561080d5761080c617113565b5b0361081b5760209050610925565b6004605381111561082f5761082e617113565b5b84605381111561084257610841617113565b5b036108505760209050610924565b6005605381111561086457610863617113565b5b84605381111561087757610876617113565b5b036108855760209050610923565b6006605381111561089957610898617113565b5b8460538111156108ac576108ab617113565b5b036108ba5760209050610922565b600860538111156108ce576108cd617113565b5b8460538111156108e1576108e0617113565b5b036108ef5760209050610921565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b5b5b6109328184846160e7565b50505050565b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16146109b1576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f8060538111156109c5576109c4617113565b5b8360538111156109d8576109d7617113565b5b036109e757614a389050610b63565b600260538111156109fb576109fa617113565b5b836053811115610a0e57610a0d617113565b5b03610a1d576159d89050610b62565b60036053811115610a3157610a30617113565b5b836053811115610a4457610a43617113565b5b03610a53576159d89050610b61565b60046053811115610a6757610a66617113565b5b836053811115610a7a57610a79617113565b5b03610a8957615dc09050610b60565b60056053811115610a9d57610a9c617113565b5b836053811115610ab057610aaf617113565b5b03610abf57615dc09050610b5f565b60066053811115610ad357610ad2617113565b5b836053811115610ae657610ae5617113565b5b03610af5576161a89050610b5e565b60086053811115610b0957610b08617113565b5b836053811115610b1c57610b1b617113565b5b03610b2b576175309050610b5d565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b5b5b610b6c81616153565b610b7682826161b3565b505050565b60606040518060400160405280600881526020017f4843554c696d6974000000000000000000000000000000000000000000000000815250610bbc5f6161ba565b610bc660016161ba565b610bcf5f6161ba565b604051602001610be2949392919061720e565b604051602081830303815290604052905090565b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614610c6f576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f600160f81b857effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191603610df45760026053811115610cb157610cb0617113565b5b866053811115610cc457610cc3617113565b5b03610cd35761cb209050610de4565b60036053811115610ce757610ce6617113565b5b866053811115610cfa57610cf9617113565b5b03610d095761e2909050610de3565b60046053811115610d1d57610d1c617113565b5b866053811115610d3057610d2f617113565b5b03610d4057620144389050610de2565b60056053811115610d5457610d53617113565b5b866053811115610d6757610d66617113565b5b03610d77576201ccf09050610de1565b60066053811115610d8b57610d8a617113565b5b866053811115610d9e57610d9d617113565b5b03610dae57620246089050610de0565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b610def8185846160e7565b610f49565b60026053811115610e0857610e07617113565b5b866053811115610e1b57610e1a617113565b5b03610e2a5761e6789050610f3c565b60036053811115610e3e57610e3d617113565b5b866053811115610e5157610e50617113565b5b03610e6157620148209050610f3b565b60046053811115610e7557610e74617113565b5b866053811115610e8857610e87617113565b5b03610e98576201c9089050610f3a565b60056053811115610eac57610eab617113565b5b866053811115610ebf57610ebe617113565b5b03610ecf5762023a509050610f39565b60066053811115610ee357610ee2617113565b5b866053811115610ef657610ef5617113565b5b03610f0657620347d89050610f38565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b610f4881858585616284565b5b505050505050565b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614610fca576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f600160f81b857effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916036111b9575f605381111561100b5761100a617113565b5b86605381111561101e5761101d617113565b5b0361102d576155f090506111a9565b6002605381111561104157611040617113565b5b86605381111561105457611053617113565b5b036110635761791890506111a8565b6003605381111561107757611076617113565b5b86605381111561108a57611089617113565b5b036110995761791890506111a7565b600460538111156110ad576110ac617113565b5b8660538111156110c0576110bf617113565b5b036110cf57617d0090506111a6565b600560538111156110e3576110e2617113565b5b8660538111156110f6576110f5617113565b5b03611105576184d090506111a5565b6006605381111561111957611118617113565b5b86605381111561112c5761112b617113565b5b0361113b5761908890506111a4565b6008605381111561114f5761114e617113565b5b86605381111561116257611161617113565b5b036111715761985890506111a3565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b5b5b6111b48185846160e7565b611377565b5f60538111156111cc576111cb617113565b5b8660538111156111df576111de617113565b5b036111ee576155f0905061136a565b6002605381111561120257611201617113565b5b86605381111561121557611214617113565b5b03611224576179189050611369565b6003605381111561123857611237617113565b5b86605381111561124b5761124a617113565b5b0361125a576179189050611368565b6004605381111561126e5761126d617113565b5b86605381111561128157611280617113565b5b0361129057617d009050611367565b600560538111156112a4576112a3617113565b5b8660538111156112b7576112b6617113565b5b036112c6576184d09050611366565b600660538111156112da576112d9617113565b5b8660538111156112ed576112ec617113565b5b036112fc576190889050611365565b600860538111156113105761130f617113565b5b86605381111561132357611322617113565b5b03611332576198589050611364565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b5b5b61137681858585616284565b5b505050505050565b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16146113f8576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f600160f81b857effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916036115b1576002605381111561143a57611439617113565b5b86605381111561144d5761144c617113565b5b0361145c5761791890506115a1565b600360538111156114705761146f617113565b5b86605381111561148357611482617113565b5b036114925761791890506115a0565b600460538111156114a6576114a5617113565b5b8660538111156114b9576114b8617113565b5b036114c857617d00905061159f565b600560538111156114dc576114db617113565b5b8660538111156114ef576114ee617113565b5b036114fe576184d0905061159e565b6006605381111561151257611511617113565b5b86605381111561152557611524617113565b5b0361153457619088905061159d565b6008605381111561154857611547617113565b5b86605381111561155b5761155a617113565b5b0361156a57619470905061159c565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b5b6115ac8185846160e7565b61173f565b600260538111156115c5576115c4617113565b5b8660538111156115d8576115d7617113565b5b036115e857620163789050611732565b600360538111156115fc576115fb617113565b5b86605381111561160f5761160e617113565b5b0361161f576201e8489050611731565b6004605381111561163357611632617113565b5b86605381111561164657611645617113565b5b036116565762027cb89050611730565b6005605381111561166a57611669617113565b5b86605381111561167d5761167c617113565b5b0361168d5762033068905061172f565b600660538111156116a1576116a0617113565b5b8660538111156116b4576116b3617113565b5b036116c45762043df0905061172e565b600860538111156116d8576116d7617113565b5b8660538111156116eb576116ea617113565b5b036116fb576205c490905061172d565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b5b61173e81858585616284565b5b505050505050565b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16146117c0576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f600160f81b857effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916036119af575f605381111561180157611800617113565b5b86605381111561181457611813617113565b5b03611823576155f0905061199f565b6002605381111561183757611836617113565b5b86605381111561184a57611849617113565b5b0361185957617918905061199e565b6003605381111561186d5761186c617113565b5b8660538111156118805761187f617113565b5b0361188f57617918905061199d565b600460538111156118a3576118a2617113565b5b8660538111156118b6576118b5617113565b5b036118c557617d00905061199c565b600560538111156118d9576118d8617113565b5b8660538111156118ec576118eb617113565b5b036118fb576184d0905061199b565b6006605381111561190f5761190e617113565b5b86605381111561192257611921617113565b5b0361193157619088905061199a565b6008605381111561194557611944617113565b5b86605381111561195857611957617113565b5b03611967576194709050611999565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b5b5b6119aa8185846160e7565b611b6d565b5f60538111156119c2576119c1617113565b5b8660538111156119d5576119d4617113565b5b036119e4576161a89050611b60565b600260538111156119f8576119f7617113565b5b866053811115611a0b57611a0a617113565b5b03611a1a576179189050611b5f565b60036053811115611a2e57611a2d617113565b5b866053811115611a4157611a40617113565b5b03611a50576179189050611b5e565b60046053811115611a6457611a63617113565b5b866053811115611a7757611a76617113565b5b03611a8657617d009050611b5d565b60056053811115611a9a57611a99617113565b5b866053811115611aad57611aac617113565b5b03611abc576184d09050611b5c565b60066053811115611ad057611acf617113565b5b866053811115611ae357611ae2617113565b5b03611af2576190889050611b5b565b60086053811115611b0657611b05617113565b5b866053811115611b1957611b18617113565b5b03611b28576194709050611b5a565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b5b5b611b6c81858585616284565b5b505050505050565b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614611bee576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f600160f81b857effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191603611da75760026053811115611c3057611c2f617113565b5b866053811115611c4357611c42617113565b5b03611c5257617d009050611d97565b60036053811115611c6657611c65617113565b5b866053811115611c7957611c78617113565b5b03611c8857617d009050611d96565b60046053811115611c9c57611c9b617113565b5b866053811115611caf57611cae617113565b5b03611cbe57617d009050611d95565b60056053811115611cd257611cd1617113565b5b866053811115611ce557611ce4617113565b5b03611cf4576184d09050611d94565b60066053811115611d0857611d07617113565b5b866053811115611d1b57611d1a617113565b5b03611d2a576190889050611d93565b60086053811115611d3e57611d3d617113565b5b866053811115611d5157611d50617113565b5b03611d60576194709050611d92565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b5b611da28185846160e7565b611f35565b60026053811115611dbb57611dba617113565b5b866053811115611dce57611dcd617113565b5b03611dde57620163789050611f28565b60036053811115611df257611df1617113565b5b866053811115611e0557611e04617113565b5b03611e15576201e0789050611f27565b60046053811115611e2957611e28617113565b5b866053811115611e3c57611e3b617113565b5b03611e4c5762027cb89050611f26565b60056053811115611e6057611e5f617113565b5b866053811115611e7357611e72617113565b5b03611e8357620330689050611f25565b60066053811115611e9757611e96617113565b5b866053811115611eaa57611ea9617113565b5b03611eba57620426809050611f24565b60086053811115611ece57611ecd617113565b5b866053811115611ee157611ee0617113565b5b03611ef1576205a1689050611f23565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b5b611f3481858585616284565b5b505050505050565b5f73e3a9105a3a932253a70f126eb1e3b589c643dd24905090565b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614611fd1576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f806053811115611fe557611fe4617113565b5b836053811115611ff857611ff7617113565b5b0361200657602090506121b2565b6002605381111561201a57612019617113565b5b83605381111561202d5761202c617113565b5b0361203b57602090506121b1565b6003605381111561204f5761204e617113565b5b83605381111561206257612061617113565b5b0361207057602090506121b0565b6004605381111561208457612083617113565b5b83605381111561209757612096617113565b5b036120a557602090506121af565b600560538111156120b9576120b8617113565b5b8360538111156120cc576120cb617113565b5b036120da57602090506121ae565b600660538111156120ee576120ed617113565b5b83605381111561210157612100617113565b5b0361210f57602090506121ad565b6007605381111561212357612122617113565b5b83605381111561213657612135617113565b5b0361214457602090506121ac565b6008605381111561215857612157617113565b5b83605381111561216b5761216a617113565b5b0361217957602090506121ab565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b5b5b5b6121bb81616153565b6121c582826161b3565b505050565b60016121d4616302565b67ffffffffffffffff1614612215576040517f6f4f731f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60025f612220616326565b9050805f0160089054906101000a900460ff168061226857508167ffffffffffffffff16815f015f9054906101000a900467ffffffffffffffff1667ffffffffffffffff1610155b1561229f576040517ff92ee8a900000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b81815f015f6101000a81548167ffffffffffffffff021916908367ffffffffffffffff1602179055506001815f0160086101000a81548160ff0219169083151502179055505f815f0160086101000a81548160ff0219169083151502179055507fc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d28260405161232e919061728e565b60405180910390a15050565b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16146123b3576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f600160f81b857effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff19160361253a57600260538111156123f5576123f4617113565b5b86605381111561240857612407617113565b5b03612418576201dc90905061252a565b6003605381111561242c5761242b617113565b5b86605381111561243f5761243e617113565b5b0361244f576202f1e89050612529565b6004605381111561246357612462617113565b5b86605381111561247657612475617113565b5b036124865762040b289050612528565b6005605381111561249a57612499617113565b5b8660538111156124ad576124ac617113565b5b036124bd57620591c89050612527565b600660538111156124d1576124d0617113565b5b8660538111156124e4576124e3617113565b5b036124f457620a9ec09050612526565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b6125358185846160e7565b612690565b6002605381111561254e5761254d617113565b5b86605381111561256157612560617113565b5b0361257157620249f09050612683565b6003605381111561258557612584617113565b5b86605381111561259857612597617113565b5b036125a857620363309050612682565b600460538111156125bc576125bb617113565b5b8660538111156125cf576125ce617113565b5b036125df57620501409050612681565b600560538111156125f3576125f2617113565b5b86605381111561260657612605617113565b5b0361261657620918209050612680565b6006605381111561262a57612629617113565b5b86605381111561263d5761263c617113565b5b0361264d576219b9f0905061267f565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b61268f81858585616284565b5b505050505050565b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614612711576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f600160f81b857effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191614612771576040517f6aa9eb0500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6002605381111561278557612784617113565b5b86605381111561279857612797617113565b5b036127a8576203345090506128ba565b600360538111156127bc576127bb617113565b5b8660538111156127cf576127ce617113565b5b036127df5762049bb090506128b9565b600460538111156127f3576127f2617113565b5b86605381111561280657612805617113565b5b03612816576206aef090506128b8565b6005605381111561282a57612829617113565b5b86605381111561283d5761283c617113565b5b0361284d57620ae8f890506128b7565b6006605381111561286157612860617113565b5b86605381111561287457612873617113565b5b03612884576212b12890506128b6565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b6128c58185846160e7565b505050505050565b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614612946576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f80605381111561295a57612959617113565b5b86605381111561296d5761296c617113565b5b0361297c5761d6d89050612b31565b600260538111156129905761298f617113565b5b8660538111156129a3576129a2617113565b5b036129b25761d6d89050612b30565b600360538111156129c6576129c5617113565b5b8660538111156129d9576129d8617113565b5b036129e85761d6d89050612b2f565b600460538111156129fc576129fb617113565b5b866053811115612a0f57612a0e617113565b5b03612a1e5761d6d89050612b2e565b60056053811115612a3257612a31617113565b5b866053811115612a4557612a44617113565b5b03612a545761d6d89050612b2d565b60066053811115612a6857612a67617113565b5b866053811115612a7b57612a7a617113565b5b03612a8a5761dea89050612b2c565b60076053811115612a9e57612a9d617113565b5b866053811115612ab157612ab0617113565b5b03612ac157620144389050612b2b565b60086053811115612ad557612ad4617113565b5b866053811115612ae857612ae7617113565b5b03612af8576201a5e09050612b2a565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b5b5b5b612b3e818686868661634d565b505050505050565b612b4e6163dd565b612b57826164c3565b612b6182826165b6565b5050565b5f612b6e6166d4565b7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5f1b905090565b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614612c0f576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f600160f81b857effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191603612d965760026053811115612c5157612c50617113565b5b866053811115612c6457612c63617113565b5b03612c7457620148209050612d86565b60036053811115612c8857612c87617113565b5b866053811115612c9b57612c9a617113565b5b03612cab57620157c09050612d85565b60046053811115612cbf57612cbe617113565b5b866053811115612cd257612cd1617113565b5b03612ce2576201c9089050612d84565b60056053811115612cf657612cf5617113565b5b866053811115612d0957612d08617113565b5b03612d1957620249f09050612d83565b60066053811115612d2d57612d2c617113565b5b866053811115612d4057612d3f617113565b5b03612d50576202d6909050612d82565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b612d918185846160e7565b612eec565b60026053811115612daa57612da9617113565b5b866053811115612dbd57612dbc617113565b5b03612dcd576201d0d89050612edf565b60036053811115612de157612de0617113565b5b866053811115612df457612df3617113565b5b03612e045762023a509050612ede565b60046053811115612e1857612e17617113565b5b866053811115612e2b57612e2a617113565b5b03612e3b576202c6f09050612edd565b60056053811115612e4f57612e4e617113565b5b866053811115612e6257612e61617113565b5b03612e7257620357789050612edc565b60066053811115612e8657612e85617113565b5b866053811115612e9957612e98617113565b5b03612ea957620468e89050612edb565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b612eeb81858585616284565b5b505050505050565b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614612f6d576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f600160f81b857effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916036131265760026053811115612faf57612fae617113565b5b866053811115612fc257612fc1617113565b5b03612fd1576179189050613116565b60036053811115612fe557612fe4617113565b5b866053811115612ff857612ff7617113565b5b03613007576179189050613115565b6004605381111561301b5761301a617113565b5b86605381111561302e5761302d617113565b5b0361303d57617d009050613114565b6005605381111561305157613050617113565b5b86605381111561306457613063617113565b5b03613073576184d09050613113565b6006605381111561308757613086617113565b5b86605381111561309a57613099617113565b5b036130a9576190889050613112565b600860538111156130bd576130bc617113565b5b8660538111156130d0576130cf617113565b5b036130df57619c409050613111565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b5b6131218185846160e7565b6132b4565b6002605381111561313a57613139617113565b5b86605381111561314d5761314c617113565b5b0361315d5762016b4890506132a7565b6003605381111561317157613170617113565b5b86605381111561318457613183617113565b5b03613194576201e84890506132a6565b600460538111156131a8576131a7617113565b5b8660538111156131bb576131ba617113565b5b036131cb576202710090506132a5565b600560538111156131df576131de617113565b5b8660538111156131f2576131f1617113565b5b03613202576203306890506132a4565b6006605381111561321657613215617113565b5b86605381111561322957613228617113565b5b03613239576204517890506132a3565b6008605381111561324d5761324c617113565b5b8660538111156132605761325f617113565b5b03613270576205b8d890506132a2565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b5b6132b381858585616284565b5b505050505050565b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614613335576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f600160f81b857effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916036134ba576002605381111561337757613376617113565b5b86605381111561338a57613389617113565b5b036133995761cb2090506134aa565b600360538111156133ad576133ac617113565b5b8660538111156133c0576133bf617113565b5b036133cf5761d6d890506134a9565b600460538111156133e3576133e2617113565b5b8660538111156133f6576133f5617113565b5b03613406576201482090506134a8565b6005605381111561341a57613419617113565b5b86605381111561342d5761342c617113565b5b0361343d576201c52090506134a7565b6006605381111561345157613450617113565b5b86605381111561346457613463617113565b5b03613474576202460890506134a6565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b6134b58185846160e7565b61360f565b600260538111156134ce576134cd617113565b5b8660538111156134e1576134e0617113565b5b036134f05761f6189050613602565b6003605381111561350457613503617113565b5b86605381111561351757613516617113565b5b0361352757620148209050613601565b6004605381111561353b5761353a617113565b5b86605381111561354e5761354d617113565b5b0361355e576201ccf09050613600565b6005605381111561357257613571617113565b5b86605381111561358557613584617113565b5b0361359557620251c090506135ff565b600660538111156135a9576135a8617113565b5b8660538111156135bc576135bb617113565b5b036135cc576203345090506135fe565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b61360e81858585616284565b5b505050505050565b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614613690576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f600160f81b857effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff19160361384957600260538111156136d2576136d1617113565b5b8660538111156136e5576136e4617113565b5b036136f457617d009050613839565b6003605381111561370857613707617113565b5b86605381111561371b5761371a617113565b5b0361372a57617d009050613838565b6004605381111561373e5761373d617113565b5b86605381111561375157613750617113565b5b0361376057617d009050613837565b6005605381111561377457613773617113565b5b86605381111561378757613786617113565b5b03613796576184d09050613836565b600660538111156137aa576137a9617113565b5b8660538111156137bd576137bc617113565b5b036137cc576190889050613835565b600860538111156137e0576137df617113565b5b8660538111156137f3576137f2617113565b5b03613802576198589050613834565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b5b6138448185846160e7565b6139d7565b6002605381111561385d5761385c617113565b5b8660538111156138705761386f617113565b5b03613880576201676090506139ca565b6003605381111561389457613893617113565b5b8660538111156138a7576138a6617113565b5b036138b7576201e84890506139c9565b600460538111156138cb576138ca617113565b5b8660538111156138de576138dd617113565b5b036138ee57620278d090506139c8565b6005605381111561390257613901617113565b5b86605381111561391557613914617113565b5b036139255762032c8090506139c7565b6006605381111561393957613938617113565b5b86605381111561394c5761394b617113565b5b0361395c576204268090506139c6565b600860538111156139705761396f617113565b5b86605381111561398357613982617113565b5b03613993576205c49090506139c5565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b5b6139d681858585616284565b5b505050505050565b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614613a58576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f600160f81b857effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191603613bdd5760026053811115613a9a57613a99617113565b5b866053811115613aad57613aac617113565b5b03613abc5761cb209050613bcd565b60036053811115613ad057613acf617113565b5b866053811115613ae357613ae2617113565b5b03613af25761d6d89050613bcc565b60046053811115613b0657613b05617113565b5b866053811115613b1957613b18617113565b5b03613b2957620148209050613bcb565b60056053811115613b3d57613b3c617113565b5b866053811115613b5057613b4f617113565b5b03613b60576201c9089050613bca565b60066053811115613b7457613b73617113565b5b866053811115613b8757613b86617113565b5b03613b9757620249f09050613bc9565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b613bd88185846160e7565b613d32565b60026053811115613bf157613bf0617113565b5b866053811115613c0457613c03617113565b5b03613c135761e6789050613d25565b60036053811115613c2757613c26617113565b5b866053811115613c3a57613c39617113565b5b03613c4a57620148209050613d24565b60046053811115613c5e57613c5d617113565b5b866053811115613c7157613c70617113565b5b03613c81576201ccf09050613d23565b60056053811115613c9557613c94617113565b5b866053811115613ca857613ca7617113565b5b03613cb857620251c09050613d22565b60066053811115613ccc57613ccb617113565b5b866053811115613cdf57613cde617113565b5b03613cef57620353909050613d21565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b613d3181858585616284565b5b505050505050565b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614613db3576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f600160f81b857effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191603613f3a5760026053811115613df557613df4617113565b5b866053811115613e0857613e07617113565b5b03613e1857620148209050613f2a565b60036053811115613e2c57613e2b617113565b5b866053811115613e3f57613e3e617113565b5b03613e4f5762016b489050613f29565b60046053811115613e6357613e62617113565b5b866053811115613e7657613e75617113565b5b03613e8657620173189050613f28565b60056053811115613e9a57613e99617113565b5b866053811115613ead57613eac617113565b5b03613ebd57620207889050613f27565b60066053811115613ed157613ed0617113565b5b866053811115613ee457613ee3617113565b5b03613ef45762029fe09050613f26565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b613f358185846160e7565b614090565b60026053811115613f4e57613f4d617113565b5b866053811115613f6157613f60617113565b5b03613f7157620163789050614083565b60036053811115613f8557613f84617113565b5b866053811115613f9857613f97617113565b5b03613fa85762016b489050614082565b60046053811115613fbc57613fbb617113565b5b866053811115613fcf57613fce617113565b5b03613fdf576201e8489050614081565b60056053811115613ff357613ff2617113565b5b86605381111561400657614005617113565b5b0361401657620278d09050614080565b6006605381111561402a57614029617113565b5b86605381111561403d5761403c617113565b5b0361404d576203f7a0905061407f565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b61408f81858585616284565b5b505050505050565b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614614111576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f600160f81b857effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff19160361433c575f605381111561415257614151617113565b5b86605381111561416557614164617113565b5b03614174576161a8905061432c565b6002605381111561418857614187617113565b5b86605381111561419b5761419a617113565b5b036141aa5761d6d8905061432b565b600360538111156141be576141bd617113565b5b8660538111156141d1576141d0617113565b5b036141e05761d6d8905061432a565b600460538111156141f4576141f3617113565b5b86605381111561420757614206617113565b5b0361421757620140509050614329565b6005605381111561422b5761422a617113565b5b86605381111561423e5761423d617113565b5b0361424e57620144389050614328565b6006605381111561426257614261617113565b5b86605381111561427557614274617113565b5b03614285576201c9089050614327565b6007605381111561429957614298617113565b5b8660538111156142ac576142ab617113565b5b036142bc576201c9089050614326565b600860538111156142d0576142cf617113565b5b8660538111156142e3576142e2617113565b5b036142f3576201ccf09050614325565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b5b5b5b6143378185846160e7565b614537565b5f605381111561434f5761434e617113565b5b86605381111561436257614361617113565b5b0361437157616590905061452a565b6002605381111561438557614384617113565b5b86605381111561439857614397617113565b5b036143a75761d6d89050614529565b600360538111156143bb576143ba617113565b5b8660538111156143ce576143cd617113565b5b036143de57620144389050614528565b600460538111156143f2576143f1617113565b5b86605381111561440557614404617113565b5b036144155762014ff09050614527565b6005605381111561442957614428617113565b5b86605381111561443c5761443b617113565b5b0361444c576201d4c09050614526565b600660538111156144605761445f617113565b5b86605381111561447357614472617113565b5b03614483576201dc909050614525565b6007605381111561449757614496617113565b5b8660538111156144aa576144a9617113565b5b036144ba57620217289050614524565b600860538111156144ce576144cd617113565b5b8660538111156144e1576144e0617113565b5b036144f157620251c09050614523565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b5b5b5b61453681858585616284565b5b505050505050565b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16146145b8576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f600260538111156145cd576145cc617113565b5b8460538111156145e0576145df617113565b5b036145f05762013498905061473a565b6003605381111561460457614603617113565b5b84605381111561461757614616617113565b5b036146275762016b489050614739565b6004605381111561463b5761463a617113565b5b84605381111561464e5761464d617113565b5b0361465e57620173189050614738565b6005605381111561467257614671617113565b5b84605381111561468557614684617113565b5b03614695576201ffb89050614737565b600660538111156146a9576146a8617113565b5b8460538111156146bc576146bb617113565b5b036146cc57620290409050614736565b600860538111156146e0576146df617113565b5b8460538111156146f3576146f2617113565b5b036147035762041ac89050614735565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b5b6147458184846160e7565b50505050565b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16146147c4576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f600160f81b857effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff19160361494b576002605381111561480657614805617113565b5b86605381111561481957614818617113565b5b036148295762015ba8905061493b565b6003605381111561483d5761483c617113565b5b8660538111156148505761484f617113565b5b036148605762015ba8905061493a565b6004605381111561487457614873617113565b5b86605381111561488757614886617113565b5b03614897576201c9089050614939565b600560538111156148ab576148aa617113565b5b8660538111156148be576148bd617113565b5b036148ce57620246089050614938565b600660538111156148e2576148e1617113565b5b8660538111156148f5576148f4617113565b5b03614905576202bf209050614937565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b6149468185846160e7565b614aa1565b6002605381111561495f5761495e617113565b5b86605381111561497257614971617113565b5b03614982576201d8a89050614a94565b6003605381111561499657614995617113565b5b8660538111156149a9576149a8617113565b5b036149b957620236689050614a93565b600460538111156149cd576149cc617113565b5b8660538111156149e0576149df617113565b5b036149f0576202bf209050614a92565b60056053811115614a0457614a03617113565b5b866053811115614a1757614a16617113565b5b03614a2757620353909050614a91565b60066053811115614a3b57614a3a617113565b5b866053811115614a4e57614a4d617113565b5b03614a5e5762046cd09050614a90565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b614aa081858585616284565b5b505050505050565b6040518060400160405280600581526020017f352e302e3000000000000000000000000000000000000000000000000000000081525081565b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614614b5b576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f60026053811115614b7057614b6f617113565b5b836053811115614b8357614b82617113565b5b03614b92576159d89050614cd7565b60036053811115614ba657614ba5617113565b5b836053811115614bb957614bb8617113565b5b03614bc8576159d89050614cd6565b60046053811115614bdc57614bdb617113565b5b836053811115614bef57614bee617113565b5b03614bfe57615dc09050614cd5565b60056053811115614c1257614c11617113565b5b836053811115614c2557614c24617113565b5b03614c3457615dc09050614cd4565b60066053811115614c4857614c47617113565b5b836053811115614c5b57614c5a617113565b5b03614c6a576161a89050614cd3565b60086053811115614c7e57614c7d617113565b5b836053811115614c9157614c90617113565b5b03614ca0576175309050614cd2565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b5b614ce081616153565b614cea82826161b3565b505050565b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614614d68576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f600160f81b857effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191603614eed5760026053811115614daa57614da9617113565b5b866053811115614dbd57614dbc617113565b5b03614dcc5761e2909050614edd565b60036053811115614de057614ddf617113565b5b866053811115614df357614df2617113565b5b03614e025761e2909050614edc565b60046053811115614e1657614e15617113565b5b866053811115614e2957614e28617113565b5b03614e3957620148209050614edb565b60056053811115614e4d57614e4c617113565b5b866053811115614e6057614e5f617113565b5b03614e70576201d0d89050614eda565b60066053811115614e8457614e83617113565b5b866053811115614e9757614e96617113565b5b03614ea757620249f09050614ed9565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b614ee88185846160e7565b615042565b60026053811115614f0157614f00617113565b5b866053811115614f1457614f13617113565b5b03614f235761e2909050615035565b60036053811115614f3757614f36617113565b5b866053811115614f4a57614f49617113565b5b03614f5a57620144389050615034565b60046053811115614f6e57614f6d617113565b5b866053811115614f8157614f80617113565b5b03614f91576201c9089050615033565b60056053811115614fa557614fa4617113565b5b866053811115614fb857614fb7617113565b5b03614fc857620246089050615032565b60066053811115614fdc57614fdb617113565b5b866053811115614fef57614fee617113565b5b03614fff57620353909050615031565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b61504181858585616284565b5b505050505050565b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16146150c3576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f600160f81b857effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916036152b2575f605381111561510457615103617113565b5b86605381111561511757615116617113565b5b03615126576155f090506152a2565b6002605381111561513a57615139617113565b5b86605381111561514d5761514c617113565b5b0361515c5761753090506152a1565b600360538111156151705761516f617113565b5b86605381111561518357615182617113565b5b036151925761753090506152a0565b600460538111156151a6576151a5617113565b5b8660538111156151b9576151b8617113565b5b036151c857617d00905061529f565b600560538111156151dc576151db617113565b5b8660538111156151ef576151ee617113565b5b036151fe576184d0905061529e565b6006605381111561521257615211617113565b5b86605381111561522557615224617113565b5b0361523457619088905061529d565b6008605381111561524857615247617113565b5b86605381111561525b5761525a617113565b5b0361526a57619470905061529c565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b5b5b6152ad8185846160e7565b615470565b5f60538111156152c5576152c4617113565b5b8660538111156152d8576152d7617113565b5b036152e757615dc09050615463565b600260538111156152fb576152fa617113565b5b86605381111561530e5761530d617113565b5b0361531d576175309050615462565b6003605381111561533157615330617113565b5b86605381111561534457615343617113565b5b03615353576179189050615461565b6004605381111561536757615366617113565b5b86605381111561537a57615379617113565b5b0361538957617d009050615460565b6005605381111561539d5761539c617113565b5b8660538111156153b0576153af617113565b5b036153bf576184d0905061545f565b600660538111156153d3576153d2617113565b5b8660538111156153e6576153e5617113565b5b036153f557619088905061545e565b6008605381111561540957615408617113565b5b86605381111561541c5761541b617113565b5b0361542b57619470905061545d565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b5b5b61546f81858585616284565b5b505050505050565b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16146154f1576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f600160f81b857effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191614615551576040517f6aa9eb0500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6002605381111561556557615564617113565b5b86605381111561557857615577617113565b5b03615588576206b6c0905061569a565b6003605381111561559c5761559b617113565b5b8660538111156155af576155ae617113565b5b036155bf576208d9a09050615699565b600460538111156155d3576155d2617113565b5b8660538111156155e6576155e5617113565b5b036155f657620c15c09050615698565b6005605381111561560a57615609617113565b5b86605381111561561d5761561c617113565b5b0361562d57621197e89050615697565b6006605381111561564157615640617113565b5b86605381111561565457615653617113565b5b0361566457621da5d89050615696565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b6156a58185846160e7565b505050505050565b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614615726576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f600160f81b857effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191603615951575f605381111561576757615766617113565b5b86605381111561577a57615779617113565b5b03615789576159d89050615941565b6002605381111561579d5761579c617113565b5b8660538111156157b0576157af617113565b5b036157bf5761d6d89050615940565b600360538111156157d3576157d2617113565b5b8660538111156157e6576157e5617113565b5b036157f55761d6d8905061593f565b6004605381111561580957615808617113565b5b86605381111561581c5761581b617113565b5b0361582c5762014438905061593e565b600560538111156158405761583f617113565b5b86605381111561585357615852617113565b5b036158635762014820905061593d565b6006605381111561587757615876617113565b5b86605381111561588a57615889617113565b5b0361589a576201c908905061593c565b600760538111156158ae576158ad617113565b5b8660538111156158c1576158c0617113565b5b036158d1576201c908905061593b565b600860538111156158e5576158e4617113565b5b8660538111156158f8576158f7617113565b5b03615908576201c908905061593a565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b5b5b5b61594c8185846160e7565b615b4c565b5f605381111561596457615963617113565b5b86605381111561597757615976617113565b5b03615986576159d89050615b3f565b6002605381111561599a57615999617113565b5b8660538111156159ad576159ac617113565b5b036159bc5761d6d89050615b3e565b600360538111156159d0576159cf617113565b5b8660538111156159e3576159e2617113565b5b036159f357620144389050615b3d565b60046053811115615a0757615a06617113565b5b866053811115615a1a57615a19617113565b5b03615a2a5762014c089050615b3c565b60056053811115615a3e57615a3d617113565b5b866053811115615a5157615a50617113565b5b03615a61576201ccf09050615b3b565b60066053811115615a7557615a74617113565b5b866053811115615a8857615a87617113565b5b03615a98576201dc909050615b3a565b60076053811115615aac57615aab617113565b5b866053811115615abf57615abe617113565b5b03615acf57620213409050615b39565b60086053811115615ae357615ae2617113565b5b866053811115615af657615af5617113565b5b03615b0657620249f09050615b38565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b5b5b5b615b4b81858585616284565b5b505050505050565b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614615bcd576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f806053811115615be157615be0617113565b5b846053811115615bf457615bf3617113565b5b03615c025760029050615d78565b60026053811115615c1657615c15617113565b5b846053811115615c2957615c28617113565b5b03615c375760099050615d77565b60036053811115615c4b57615c4a617113565b5b846053811115615c5e57615c5d617113565b5b03615c6c5760109050615d76565b60046053811115615c8057615c7f617113565b5b846053811115615c9357615c92617113565b5b03615ca15760209050615d75565b60056053811115615cb557615cb4617113565b5b846053811115615cc857615cc7617113565b5b03615cd657603f9050615d74565b60066053811115615cea57615ce9617113565b5b846053811115615cfd57615cfc617113565b5b03615d0b5760829050615d73565b60086053811115615d1f57615d1e617113565b5b846053811115615d3257615d31617113565b5b03615d405760829050615d72565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b5b5b615d838184846160e7565b50505050565b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614615e02576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f600160f81b857effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191603615f895760026053811115615e4457615e43617113565b5b866053811115615e5757615e56617113565b5b03615e6757620148209050615f79565b60036053811115615e7b57615e7a617113565b5b866053811115615e8e57615e8d617113565b5b03615e9e5762016b489050615f78565b60046053811115615eb257615eb1617113565b5b866053811115615ec557615ec4617113565b5b03615ed557620173189050615f77565b60056053811115615ee957615ee8617113565b5b866053811115615efc57615efb617113565b5b03615f0c57620207889050615f76565b60066053811115615f2057615f1f617113565b5b866053811115615f3357615f32617113565b5b03615f435762029fe09050615f75565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b615f848185846160e7565b6160df565b60026053811115615f9d57615f9c617113565b5b866053811115615fb057615faf617113565b5b03615fc057620157c090506160d2565b60036053811115615fd457615fd3617113565b5b866053811115615fe757615fe6617113565b5b03615ff75762016b4890506160d1565b6004605381111561600b5761600a617113565b5b86605381111561601e5761601d617113565b5b0361602e576201e84890506160d0565b6005605381111561604257616041617113565b5b86605381111561605557616054617113565b5b0361606557620278d090506160cf565b6006605381111561607957616078617113565b5b86605381111561608c5761608b617113565b5b0361609c576203f3b890506160ce565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b6160de81858585616284565b5b505050505050565b6160f083616153565b5f6160fa8361675b565b8461610591906172dd565b9050624c4b408110616143576040517ffc34487000000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b61614d82826161b3565b50505050565b5f61615c616765565b8261616791906172dd565b90506301312d0081106161a6576040517f77e3c29300000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6161af8161676d565b5050565b80825d5050565b60605f60016161c884616773565b0190505f8167ffffffffffffffff8111156161e6576161e5616f6d565b5b6040519080825280601f01601f1916602001820160405280156162185781602001600182028036833780820191505090505b5090505f82602001820190505b600115616279578080600190039150507f3031323334353637383961626364656600000000000000000000000000000000600a86061a8153600a858161626e5761626d617310565b5b0494505f8503616225575b819350505050919050565b61628d84616153565b5f6162a861629a8561675b565b6162a38561675b565b6168c4565b856162b391906172dd565b9050624c4b4081106162f1576040517ffc34487000000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6162fb82826161b3565b5050505050565b5f61630b616326565b5f015f9054906101000a900467ffffffffffffffff16905090565b5f7ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00905090565b61635685616153565b5f6163826163638661675b565b61637d61636f8761675b565b6163788761675b565b6168c4565b6168c4565b8661638d91906172dd565b9050624c4b4081106163cb576040517ffc34487000000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6163d582826161b3565b505050505050565b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff163073ffffffffffffffffffffffffffffffffffffffff16148061648a57507f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff166164716168dd565b73ffffffffffffffffffffffffffffffffffffffff1614155b156164c1576040517fe07c8dba00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b565b7350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff16638da5cb5b6040518163ffffffff1660e01b8152600401602060405180830381865afa158015616520573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906165449190617351565b73ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16146165b357336040517f21bfda100000000000000000000000000000000000000000000000000000000081526004016165aa9190616eab565b60405180910390fd5b50565b8173ffffffffffffffffffffffffffffffffffffffff166352d1902d6040518163ffffffff1660e01b8152600401602060405180830381865afa92505050801561661e57506040513d601f19601f8201168201806040525081019061661b9190617390565b60015b61665f57816040517f4c9c8ce30000000000000000000000000000000000000000000000000000000081526004016166569190616eab565b60405180910390fd5b7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5f1b81146166c557806040517faa1d49a40000000000000000000000000000000000000000000000000000000081526004016166bc91906170fa565b60405180910390fd5b6166cf8383616930565b505050565b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff163073ffffffffffffffffffffffffffffffffffffffff1614616759576040517fe07c8dba00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b565b5f815c9050919050565b5f805c905090565b805f5d50565b5f805f90507a184f03e93ff9f4daa797ed6e38ed64bf6a1f01000000000000000083106167cf577a184f03e93ff9f4daa797ed6e38ed64bf6a1f01000000000000000083816167c5576167c4617310565b5b0492506040810190505b6d04ee2d6d415b85acef8100000000831061680c576d04ee2d6d415b85acef8100000000838161680257616801617310565b5b0492506020810190505b662386f26fc10000831061683b57662386f26fc10000838161683157616830617310565b5b0492506010810190505b6305f5e1008310616864576305f5e100838161685a57616859617310565b5b0492506008810190505b612710831061688957612710838161687f5761687e617310565b5b0492506004810190505b606483106168ac57606483816168a2576168a1617310565b5b0492506002810190505b600a83106168bb576001810190505b80915050919050565b5f818310156168d357816168d5565b825b905092915050565b5f6169097f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5f1b6169a2565b5f015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905090565b616939826169ab565b8173ffffffffffffffffffffffffffffffffffffffff167fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b60405160405180910390a25f815111156169955761698f8282616a74565b5061699e565b61699d616af4565b5b5050565b5f819050919050565b5f8173ffffffffffffffffffffffffffffffffffffffff163b03616a0657806040517f4c9c8ce30000000000000000000000000000000000000000000000000000000081526004016169fd9190616eab565b60405180910390fd5b80616a327f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5f1b6169a2565b5f015f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555050565b60605f808473ffffffffffffffffffffffffffffffffffffffff1684604051616a9d91906173ff565b5f60405180830381855af49150503d805f8114616ad5576040519150601f19603f3d011682016040523d82523d5f602084013e616ada565b606091505b5091509150616aea858383616b30565b9250505092915050565b5f341115616b2e576040517fb398979f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b565b606082616b4557616b4082616bbd565b616bb5565b5f8251148015616b6b57505f8473ffffffffffffffffffffffffffffffffffffffff163b145b15616bad57836040517f9996b315000000000000000000000000000000000000000000000000000000008152600401616ba49190616eab565b60405180910390fd5b819050616bb6565b5b9392505050565b5f81511115616bcf5780518082602001fd5b6040517fd6bda27500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f604051905090565b5f80fd5b5f80fd5b60548110616c1e575f80fd5b50565b5f81359050616c2f81616c12565b92915050565b5f819050919050565b616c4781616c35565b8114616c51575f80fd5b50565b5f81359050616c6281616c3e565b92915050565b5f805f60608486031215616c7f57616c7e616c0a565b5b5f616c8c86828701616c21565b9350506020616c9d86828701616c54565b9250506040616cae86828701616c54565b9150509250925092565b5f8060408385031215616cce57616ccd616c0a565b5b5f616cdb85828601616c21565b9250506020616cec85828601616c54565b9150509250929050565b5f81519050919050565b5f82825260208201905092915050565b5f5b83811015616d2d578082015181840152602081019050616d12565b5f8484015250505050565b5f601f19601f8301169050919050565b5f616d5282616cf6565b616d5c8185616d00565b9350616d6c818560208601616d10565b616d7581616d38565b840191505092915050565b5f6020820190508181035f830152616d988184616d48565b905092915050565b5f7fff0000000000000000000000000000000000000000000000000000000000000082169050919050565b616dd481616da0565b8114616dde575f80fd5b50565b5f81359050616def81616dcb565b92915050565b5f805f805f60a08688031215616e0e57616e0d616c0a565b5b5f616e1b88828901616c21565b9550506020616e2c88828901616de1565b9450506040616e3d88828901616c54565b9350506060616e4e88828901616c54565b9250506080616e5f88828901616c54565b9150509295509295909350565b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f616e9582616e6c565b9050919050565b616ea581616e8b565b82525050565b5f602082019050616ebe5f830184616e9c565b92915050565b5f805f805f60a08688031215616edd57616edc616c0a565b5b5f616eea88828901616c21565b9550506020616efb88828901616c54565b9450506040616f0c88828901616c54565b9350506060616f1d88828901616c54565b9250506080616f2e88828901616c54565b9150509295509295909350565b616f4481616e8b565b8114616f4e575f80fd5b50565b5f81359050616f5f81616f3b565b92915050565b5f80fd5b5f80fd5b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b616fa382616d38565b810181811067ffffffffffffffff82111715616fc257616fc1616f6d565b5b80604052505050565b5f616fd4616c01565b9050616fe08282616f9a565b919050565b5f67ffffffffffffffff821115616fff57616ffe616f6d565b5b61700882616d38565b9050602081019050919050565b828183375f83830152505050565b5f61703561703084616fe5565b616fcb565b90508281526020810184848401111561705157617050616f69565b5b61705c848285617015565b509392505050565b5f82601f83011261707857617077616f65565b5b8135617088848260208601617023565b91505092915050565b5f80604083850312156170a7576170a6616c0a565b5b5f6170b485828601616f51565b925050602083013567ffffffffffffffff8111156170d5576170d4616c0e565b5b6170e185828601617064565b9150509250929050565b6170f481616c35565b82525050565b5f60208201905061710d5f8301846170eb565b92915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52602160045260245ffd5b5f81905092915050565b5f61715482616cf6565b61715e8185617140565b935061716e818560208601616d10565b80840191505092915050565b7f20760000000000000000000000000000000000000000000000000000000000005f82015250565b5f6171ae600283617140565b91506171b98261717a565b600282019050919050565b7f2e000000000000000000000000000000000000000000000000000000000000005f82015250565b5f6171f8600183617140565b9150617203826171c4565b600182019050919050565b5f617219828761714a565b9150617224826171a2565b9150617230828661714a565b915061723b826171ec565b9150617247828561714a565b9150617252826171ec565b915061725e828461714a565b915081905095945050505050565b5f67ffffffffffffffff82169050919050565b6172888161726c565b82525050565b5f6020820190506172a15f83018461727f565b92915050565b5f819050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5f6172e7826172a7565b91506172f2836172a7565b925082820190508082111561730a576173096172b0565b5b92915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601260045260245ffd5b5f8151905061734b81616f3b565b92915050565b5f6020828403121561736657617365616c0a565b5b5f6173738482850161733d565b91505092915050565b5f8151905061738a81616c3e565b92915050565b5f602082840312156173a5576173a4616c0a565b5b5f6173b28482850161737c565b91505092915050565b5f81519050919050565b5f81905092915050565b5f6173d9826173bb565b6173e381856173c5565b93506173f3818560208601616d10565b80840191505092915050565b5f61740a82846173cf565b91508190509291505056
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\xA0`@R0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`\x80\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81RP4\x80\x15b\0\0CW_\x80\xFD[Pb\0\0Tb\0\0Z` \x1B` \x1CV[b\0\x01\xC4V[_b\0\0kb\0\x01^` \x1B` \x1CV[\x90P\x80_\x01`\x08\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x15b\0\0\xB6W`@Q\x7F\xF9.\xE8\xA9\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\x16\x81_\x01_\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14b\0\x01[Wg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81_\x01_a\x01\0\n\x81T\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP\x7F\xC7\xF5\x05\xB2\xF3q\xAE!u\xEEI\x13\xF4I\x9E\x1F&3\xA7\xB5\x93c!\xEE\xD1\xCD\xAE\xB6\x11Q\x81\xD2g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@Qb\0\x01R\x91\x90b\0\x01\xA9V[`@Q\x80\x91\x03\x90\xA1[PV[_\x7F\xF0\xC5~\x16\x84\r\xF0@\xF1P\x88\xDC/\x81\xFE9\x1C9#\xBE\xC7>#\xA9f.\xFC\x9C\"\x9Cj\0\x90P\x90V[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[b\0\x01\xA3\x81b\0\x01\x85V[\x82RPPV[_` \x82\x01\x90Pb\0\x01\xBE_\x83\x01\x84b\0\x01\x98V[\x92\x91PPV[`\x80Qat\x15b\0\x01\xEB_9_\x81\x81ac\xDF\x01R\x81\x81ad4\x01Raf\xD6\x01Rat\x15_\xF3\xFE`\x80`@R`\x046\x10a\x01\xEDW_5`\xE0\x1C\x80cd+\x14\x90\x11a\x01\x0CW\x80c\xAC\xB5\xF3\x88\x11a\0\x9FW\x80c\xE8\xE3\x99\xAD\x11a\0nW\x80c\xE8\xE3\x99\xAD\x14a\x06;W\x80c\xFA\x08\xE3\x8D\x14a\x06cW\x80c\xFA]\xEF\xDB\x14a\x06\x8BW\x80c\xFC\x06<b\x14a\x06\xB3W\x80c\xFD\xADL\x96\x14a\x06\xDBWa\x01\xEDV[\x80c\xAC\xB5\xF3\x88\x14a\x05\x99W\x80c\xAD<\xB1\xCC\x14a\x05\xC1W\x80c\xCC\x86g\x82\x14a\x05\xEBW\x80c\xD4\x7F=Y\x14a\x06\x13Wa\x01\xEDV[\x80c\x85\x9A\x1Bp\x11a\0\xDBW\x80c\x85\x9A\x1Bp\x14a\x04\xF9W\x80c\x90u1\x08\x14a\x05!W\x80c\x94\xE7\x0EO\x14a\x05IW\x80c\xA4\xC9\x8F>\x14a\x05qWa\x01\xEDV[\x80cd+\x14\x90\x14a\x04YW\x80cf\x91\x81\xC0\x14a\x04\x81W\x80ck\xB3\xC6\x11\x14a\x04\xA9W\x80c\x83\xE6\xA7 \x14a\x04\xD1Wa\x01\xEDV[\x80c&\x8Dm1\x11a\x01\x84W\x80c@kE\x13\x11a\x01SW\x80c@kE\x13\x14a\x03\xC3W\x80cNrgi\x14a\x03\xEBW\x80cO\x1E\xF2\x86\x14a\x04\x13W\x80cR\xD1\x90-\x14a\x04/Wa\x01\xEDV[\x80c&\x8Dm1\x14a\x033W\x80c4\x8C1\x85\x14a\x03]W\x80c9\xF78\x10\x14a\x03\x85W\x80c<\x16\xFF\r\x14a\x03\x9BWa\x01\xEDV[\x80c\x144\xBAM\x11a\x01\xC0W\x80c\x144\xBAM\x14a\x02\x93W\x80c\x14Rn\x87\x14a\x02\xBBW\x80c\x18V\xD9\x1D\x14a\x02\xE3W\x80c\x1E\xD9\x1F\xF6\x14a\x03\x0BWa\x01\xEDV[\x80c\x02\xDDbv\x14a\x01\xF1W\x80c\t\xB0N\x8F\x14a\x02\x19W\x80c\r\x8En,\x14a\x02AW\x80c\x139\xC5\xEE\x14a\x02kW[_\x80\xFD[4\x80\x15a\x01\xFCW_\x80\xFD[Pa\x02\x17`\x04\x806\x03\x81\x01\x90a\x02\x12\x91\x90alhV[a\x07\x03V[\0[4\x80\x15a\x02$W_\x80\xFD[Pa\x02?`\x04\x806\x03\x81\x01\x90a\x02:\x91\x90al\xB8V[a\t8V[\0[4\x80\x15a\x02LW_\x80\xFD[Pa\x02Ua\x0B{V[`@Qa\x02b\x91\x90am\x80V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x02vW_\x80\xFD[Pa\x02\x91`\x04\x806\x03\x81\x01\x90a\x02\x8C\x91\x90am\xF5V[a\x0B\xF6V[\0[4\x80\x15a\x02\x9EW_\x80\xFD[Pa\x02\xB9`\x04\x806\x03\x81\x01\x90a\x02\xB4\x91\x90am\xF5V[a\x0FQV[\0[4\x80\x15a\x02\xC6W_\x80\xFD[Pa\x02\xE1`\x04\x806\x03\x81\x01\x90a\x02\xDC\x91\x90am\xF5V[a\x13\x7FV[\0[4\x80\x15a\x02\xEEW_\x80\xFD[Pa\x03\t`\x04\x806\x03\x81\x01\x90a\x03\x04\x91\x90am\xF5V[a\x17GV[\0[4\x80\x15a\x03\x16W_\x80\xFD[Pa\x031`\x04\x806\x03\x81\x01\x90a\x03,\x91\x90am\xF5V[a\x1BuV[\0[4\x80\x15a\x03>W_\x80\xFD[Pa\x03Ga\x1F=V[`@Qa\x03T\x91\x90an\xABV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x03hW_\x80\xFD[Pa\x03\x83`\x04\x806\x03\x81\x01\x90a\x03~\x91\x90al\xB8V[a\x1FXV[\0[4\x80\x15a\x03\x90W_\x80\xFD[Pa\x03\x99a!\xCAV[\0[4\x80\x15a\x03\xA6W_\x80\xFD[Pa\x03\xC1`\x04\x806\x03\x81\x01\x90a\x03\xBC\x91\x90am\xF5V[a#:V[\0[4\x80\x15a\x03\xCEW_\x80\xFD[Pa\x03\xE9`\x04\x806\x03\x81\x01\x90a\x03\xE4\x91\x90am\xF5V[a&\x98V[\0[4\x80\x15a\x03\xF6W_\x80\xFD[Pa\x04\x11`\x04\x806\x03\x81\x01\x90a\x04\x0C\x91\x90an\xC4V[a(\xCDV[\0[a\x04-`\x04\x806\x03\x81\x01\x90a\x04(\x91\x90ap\x91V[a+FV[\0[4\x80\x15a\x04:W_\x80\xFD[Pa\x04Ca+eV[`@Qa\x04P\x91\x90ap\xFAV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x04dW_\x80\xFD[Pa\x04\x7F`\x04\x806\x03\x81\x01\x90a\x04z\x91\x90am\xF5V[a+\x96V[\0[4\x80\x15a\x04\x8CW_\x80\xFD[Pa\x04\xA7`\x04\x806\x03\x81\x01\x90a\x04\xA2\x91\x90am\xF5V[a.\xF4V[\0[4\x80\x15a\x04\xB4W_\x80\xFD[Pa\x04\xCF`\x04\x806\x03\x81\x01\x90a\x04\xCA\x91\x90am\xF5V[a2\xBCV[\0[4\x80\x15a\x04\xDCW_\x80\xFD[Pa\x04\xF7`\x04\x806\x03\x81\x01\x90a\x04\xF2\x91\x90am\xF5V[a6\x17V[\0[4\x80\x15a\x05\x04W_\x80\xFD[Pa\x05\x1F`\x04\x806\x03\x81\x01\x90a\x05\x1A\x91\x90am\xF5V[a9\xDFV[\0[4\x80\x15a\x05,W_\x80\xFD[Pa\x05G`\x04\x806\x03\x81\x01\x90a\x05B\x91\x90am\xF5V[a=:V[\0[4\x80\x15a\x05TW_\x80\xFD[Pa\x05o`\x04\x806\x03\x81\x01\x90a\x05j\x91\x90am\xF5V[a@\x98V[\0[4\x80\x15a\x05|W_\x80\xFD[Pa\x05\x97`\x04\x806\x03\x81\x01\x90a\x05\x92\x91\x90alhV[aE?V[\0[4\x80\x15a\x05\xA4W_\x80\xFD[Pa\x05\xBF`\x04\x806\x03\x81\x01\x90a\x05\xBA\x91\x90am\xF5V[aGKV[\0[4\x80\x15a\x05\xCCW_\x80\xFD[Pa\x05\xD5aJ\xA9V[`@Qa\x05\xE2\x91\x90am\x80V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x05\xF6W_\x80\xFD[Pa\x06\x11`\x04\x806\x03\x81\x01\x90a\x06\x0C\x91\x90al\xB8V[aJ\xE2V[\0[4\x80\x15a\x06\x1EW_\x80\xFD[Pa\x069`\x04\x806\x03\x81\x01\x90a\x064\x91\x90am\xF5V[aL\xEFV[\0[4\x80\x15a\x06FW_\x80\xFD[Pa\x06a`\x04\x806\x03\x81\x01\x90a\x06\\\x91\x90am\xF5V[aPJV[\0[4\x80\x15a\x06nW_\x80\xFD[Pa\x06\x89`\x04\x806\x03\x81\x01\x90a\x06\x84\x91\x90am\xF5V[aTxV[\0[4\x80\x15a\x06\x96W_\x80\xFD[Pa\x06\xB1`\x04\x806\x03\x81\x01\x90a\x06\xAC\x91\x90am\xF5V[aV\xADV[\0[4\x80\x15a\x06\xBEW_\x80\xFD[Pa\x06\xD9`\x04\x806\x03\x81\x01\x90a\x06\xD4\x91\x90alhV[a[TV[\0[4\x80\x15a\x06\xE6W_\x80\xFD[Pa\x07\x01`\x04\x806\x03\x81\x01\x90a\x06\xFC\x91\x90am\xF5V[a]\x89V[\0[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x07|W`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x80`S\x81\x11\x15a\x07\x90Wa\x07\x8Faq\x13V[[\x84`S\x81\x11\x15a\x07\xA3Wa\x07\xA2aq\x13V[[\x03a\x07\xB1W` \x90Pa\t'V[`\x02`S\x81\x11\x15a\x07\xC5Wa\x07\xC4aq\x13V[[\x84`S\x81\x11\x15a\x07\xD8Wa\x07\xD7aq\x13V[[\x03a\x07\xE6W` \x90Pa\t&V[`\x03`S\x81\x11\x15a\x07\xFAWa\x07\xF9aq\x13V[[\x84`S\x81\x11\x15a\x08\rWa\x08\x0Caq\x13V[[\x03a\x08\x1BW` \x90Pa\t%V[`\x04`S\x81\x11\x15a\x08/Wa\x08.aq\x13V[[\x84`S\x81\x11\x15a\x08BWa\x08Aaq\x13V[[\x03a\x08PW` \x90Pa\t$V[`\x05`S\x81\x11\x15a\x08dWa\x08caq\x13V[[\x84`S\x81\x11\x15a\x08wWa\x08vaq\x13V[[\x03a\x08\x85W` \x90Pa\t#V[`\x06`S\x81\x11\x15a\x08\x99Wa\x08\x98aq\x13V[[\x84`S\x81\x11\x15a\x08\xACWa\x08\xABaq\x13V[[\x03a\x08\xBAW` \x90Pa\t\"V[`\x08`S\x81\x11\x15a\x08\xCEWa\x08\xCDaq\x13V[[\x84`S\x81\x11\x15a\x08\xE1Wa\x08\xE0aq\x13V[[\x03a\x08\xEFW` \x90Pa\t!V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[[[a\t2\x81\x84\x84a`\xE7V[PPPPV[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\t\xB1W`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x80`S\x81\x11\x15a\t\xC5Wa\t\xC4aq\x13V[[\x83`S\x81\x11\x15a\t\xD8Wa\t\xD7aq\x13V[[\x03a\t\xE7WaJ8\x90Pa\x0BcV[`\x02`S\x81\x11\x15a\t\xFBWa\t\xFAaq\x13V[[\x83`S\x81\x11\x15a\n\x0EWa\n\raq\x13V[[\x03a\n\x1DWaY\xD8\x90Pa\x0BbV[`\x03`S\x81\x11\x15a\n1Wa\n0aq\x13V[[\x83`S\x81\x11\x15a\nDWa\nCaq\x13V[[\x03a\nSWaY\xD8\x90Pa\x0BaV[`\x04`S\x81\x11\x15a\ngWa\nfaq\x13V[[\x83`S\x81\x11\x15a\nzWa\nyaq\x13V[[\x03a\n\x89Wa]\xC0\x90Pa\x0B`V[`\x05`S\x81\x11\x15a\n\x9DWa\n\x9Caq\x13V[[\x83`S\x81\x11\x15a\n\xB0Wa\n\xAFaq\x13V[[\x03a\n\xBFWa]\xC0\x90Pa\x0B_V[`\x06`S\x81\x11\x15a\n\xD3Wa\n\xD2aq\x13V[[\x83`S\x81\x11\x15a\n\xE6Wa\n\xE5aq\x13V[[\x03a\n\xF5Waa\xA8\x90Pa\x0B^V[`\x08`S\x81\x11\x15a\x0B\tWa\x0B\x08aq\x13V[[\x83`S\x81\x11\x15a\x0B\x1CWa\x0B\x1Baq\x13V[[\x03a\x0B+Wau0\x90Pa\x0B]V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[[[a\x0Bl\x81aaSV[a\x0Bv\x82\x82aa\xB3V[PPPV[```@Q\x80`@\x01`@R\x80`\x08\x81R` \x01\x7FHCULimit\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81RPa\x0B\xBC_aa\xBAV[a\x0B\xC6`\x01aa\xBAV[a\x0B\xCF_aa\xBAV[`@Q` \x01a\x0B\xE2\x94\x93\x92\x91\x90ar\x0EV[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x90P\x90V[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x0CoW`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\x01`\xF8\x1B\x85~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x03a\r\xF4W`\x02`S\x81\x11\x15a\x0C\xB1Wa\x0C\xB0aq\x13V[[\x86`S\x81\x11\x15a\x0C\xC4Wa\x0C\xC3aq\x13V[[\x03a\x0C\xD3Wa\xCB \x90Pa\r\xE4V[`\x03`S\x81\x11\x15a\x0C\xE7Wa\x0C\xE6aq\x13V[[\x86`S\x81\x11\x15a\x0C\xFAWa\x0C\xF9aq\x13V[[\x03a\r\tWa\xE2\x90\x90Pa\r\xE3V[`\x04`S\x81\x11\x15a\r\x1DWa\r\x1Caq\x13V[[\x86`S\x81\x11\x15a\r0Wa\r/aq\x13V[[\x03a\r@Wb\x01D8\x90Pa\r\xE2V[`\x05`S\x81\x11\x15a\rTWa\rSaq\x13V[[\x86`S\x81\x11\x15a\rgWa\rfaq\x13V[[\x03a\rwWb\x01\xCC\xF0\x90Pa\r\xE1V[`\x06`S\x81\x11\x15a\r\x8BWa\r\x8Aaq\x13V[[\x86`S\x81\x11\x15a\r\x9EWa\r\x9Daq\x13V[[\x03a\r\xAEWb\x02F\x08\x90Pa\r\xE0V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[a\r\xEF\x81\x85\x84a`\xE7V[a\x0FIV[`\x02`S\x81\x11\x15a\x0E\x08Wa\x0E\x07aq\x13V[[\x86`S\x81\x11\x15a\x0E\x1BWa\x0E\x1Aaq\x13V[[\x03a\x0E*Wa\xE6x\x90Pa\x0F<V[`\x03`S\x81\x11\x15a\x0E>Wa\x0E=aq\x13V[[\x86`S\x81\x11\x15a\x0EQWa\x0EPaq\x13V[[\x03a\x0EaWb\x01H \x90Pa\x0F;V[`\x04`S\x81\x11\x15a\x0EuWa\x0Etaq\x13V[[\x86`S\x81\x11\x15a\x0E\x88Wa\x0E\x87aq\x13V[[\x03a\x0E\x98Wb\x01\xC9\x08\x90Pa\x0F:V[`\x05`S\x81\x11\x15a\x0E\xACWa\x0E\xABaq\x13V[[\x86`S\x81\x11\x15a\x0E\xBFWa\x0E\xBEaq\x13V[[\x03a\x0E\xCFWb\x02:P\x90Pa\x0F9V[`\x06`S\x81\x11\x15a\x0E\xE3Wa\x0E\xE2aq\x13V[[\x86`S\x81\x11\x15a\x0E\xF6Wa\x0E\xF5aq\x13V[[\x03a\x0F\x06Wb\x03G\xD8\x90Pa\x0F8V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[a\x0FH\x81\x85\x85\x85ab\x84V[[PPPPPPV[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x0F\xCAW`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\x01`\xF8\x1B\x85~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x03a\x11\xB9W_`S\x81\x11\x15a\x10\x0BWa\x10\naq\x13V[[\x86`S\x81\x11\x15a\x10\x1EWa\x10\x1Daq\x13V[[\x03a\x10-WaU\xF0\x90Pa\x11\xA9V[`\x02`S\x81\x11\x15a\x10AWa\x10@aq\x13V[[\x86`S\x81\x11\x15a\x10TWa\x10Saq\x13V[[\x03a\x10cWay\x18\x90Pa\x11\xA8V[`\x03`S\x81\x11\x15a\x10wWa\x10vaq\x13V[[\x86`S\x81\x11\x15a\x10\x8AWa\x10\x89aq\x13V[[\x03a\x10\x99Way\x18\x90Pa\x11\xA7V[`\x04`S\x81\x11\x15a\x10\xADWa\x10\xACaq\x13V[[\x86`S\x81\x11\x15a\x10\xC0Wa\x10\xBFaq\x13V[[\x03a\x10\xCFWa}\0\x90Pa\x11\xA6V[`\x05`S\x81\x11\x15a\x10\xE3Wa\x10\xE2aq\x13V[[\x86`S\x81\x11\x15a\x10\xF6Wa\x10\xF5aq\x13V[[\x03a\x11\x05Wa\x84\xD0\x90Pa\x11\xA5V[`\x06`S\x81\x11\x15a\x11\x19Wa\x11\x18aq\x13V[[\x86`S\x81\x11\x15a\x11,Wa\x11+aq\x13V[[\x03a\x11;Wa\x90\x88\x90Pa\x11\xA4V[`\x08`S\x81\x11\x15a\x11OWa\x11Naq\x13V[[\x86`S\x81\x11\x15a\x11bWa\x11aaq\x13V[[\x03a\x11qWa\x98X\x90Pa\x11\xA3V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[[[a\x11\xB4\x81\x85\x84a`\xE7V[a\x13wV[_`S\x81\x11\x15a\x11\xCCWa\x11\xCBaq\x13V[[\x86`S\x81\x11\x15a\x11\xDFWa\x11\xDEaq\x13V[[\x03a\x11\xEEWaU\xF0\x90Pa\x13jV[`\x02`S\x81\x11\x15a\x12\x02Wa\x12\x01aq\x13V[[\x86`S\x81\x11\x15a\x12\x15Wa\x12\x14aq\x13V[[\x03a\x12$Way\x18\x90Pa\x13iV[`\x03`S\x81\x11\x15a\x128Wa\x127aq\x13V[[\x86`S\x81\x11\x15a\x12KWa\x12Jaq\x13V[[\x03a\x12ZWay\x18\x90Pa\x13hV[`\x04`S\x81\x11\x15a\x12nWa\x12maq\x13V[[\x86`S\x81\x11\x15a\x12\x81Wa\x12\x80aq\x13V[[\x03a\x12\x90Wa}\0\x90Pa\x13gV[`\x05`S\x81\x11\x15a\x12\xA4Wa\x12\xA3aq\x13V[[\x86`S\x81\x11\x15a\x12\xB7Wa\x12\xB6aq\x13V[[\x03a\x12\xC6Wa\x84\xD0\x90Pa\x13fV[`\x06`S\x81\x11\x15a\x12\xDAWa\x12\xD9aq\x13V[[\x86`S\x81\x11\x15a\x12\xEDWa\x12\xECaq\x13V[[\x03a\x12\xFCWa\x90\x88\x90Pa\x13eV[`\x08`S\x81\x11\x15a\x13\x10Wa\x13\x0Faq\x13V[[\x86`S\x81\x11\x15a\x13#Wa\x13\"aq\x13V[[\x03a\x132Wa\x98X\x90Pa\x13dV[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[[[a\x13v\x81\x85\x85\x85ab\x84V[[PPPPPPV[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x13\xF8W`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\x01`\xF8\x1B\x85~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x03a\x15\xB1W`\x02`S\x81\x11\x15a\x14:Wa\x149aq\x13V[[\x86`S\x81\x11\x15a\x14MWa\x14Laq\x13V[[\x03a\x14\\Way\x18\x90Pa\x15\xA1V[`\x03`S\x81\x11\x15a\x14pWa\x14oaq\x13V[[\x86`S\x81\x11\x15a\x14\x83Wa\x14\x82aq\x13V[[\x03a\x14\x92Way\x18\x90Pa\x15\xA0V[`\x04`S\x81\x11\x15a\x14\xA6Wa\x14\xA5aq\x13V[[\x86`S\x81\x11\x15a\x14\xB9Wa\x14\xB8aq\x13V[[\x03a\x14\xC8Wa}\0\x90Pa\x15\x9FV[`\x05`S\x81\x11\x15a\x14\xDCWa\x14\xDBaq\x13V[[\x86`S\x81\x11\x15a\x14\xEFWa\x14\xEEaq\x13V[[\x03a\x14\xFEWa\x84\xD0\x90Pa\x15\x9EV[`\x06`S\x81\x11\x15a\x15\x12Wa\x15\x11aq\x13V[[\x86`S\x81\x11\x15a\x15%Wa\x15$aq\x13V[[\x03a\x154Wa\x90\x88\x90Pa\x15\x9DV[`\x08`S\x81\x11\x15a\x15HWa\x15Gaq\x13V[[\x86`S\x81\x11\x15a\x15[Wa\x15Zaq\x13V[[\x03a\x15jWa\x94p\x90Pa\x15\x9CV[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[[a\x15\xAC\x81\x85\x84a`\xE7V[a\x17?V[`\x02`S\x81\x11\x15a\x15\xC5Wa\x15\xC4aq\x13V[[\x86`S\x81\x11\x15a\x15\xD8Wa\x15\xD7aq\x13V[[\x03a\x15\xE8Wb\x01cx\x90Pa\x172V[`\x03`S\x81\x11\x15a\x15\xFCWa\x15\xFBaq\x13V[[\x86`S\x81\x11\x15a\x16\x0FWa\x16\x0Eaq\x13V[[\x03a\x16\x1FWb\x01\xE8H\x90Pa\x171V[`\x04`S\x81\x11\x15a\x163Wa\x162aq\x13V[[\x86`S\x81\x11\x15a\x16FWa\x16Eaq\x13V[[\x03a\x16VWb\x02|\xB8\x90Pa\x170V[`\x05`S\x81\x11\x15a\x16jWa\x16iaq\x13V[[\x86`S\x81\x11\x15a\x16}Wa\x16|aq\x13V[[\x03a\x16\x8DWb\x030h\x90Pa\x17/V[`\x06`S\x81\x11\x15a\x16\xA1Wa\x16\xA0aq\x13V[[\x86`S\x81\x11\x15a\x16\xB4Wa\x16\xB3aq\x13V[[\x03a\x16\xC4Wb\x04=\xF0\x90Pa\x17.V[`\x08`S\x81\x11\x15a\x16\xD8Wa\x16\xD7aq\x13V[[\x86`S\x81\x11\x15a\x16\xEBWa\x16\xEAaq\x13V[[\x03a\x16\xFBWb\x05\xC4\x90\x90Pa\x17-V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[[a\x17>\x81\x85\x85\x85ab\x84V[[PPPPPPV[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x17\xC0W`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\x01`\xF8\x1B\x85~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x03a\x19\xAFW_`S\x81\x11\x15a\x18\x01Wa\x18\0aq\x13V[[\x86`S\x81\x11\x15a\x18\x14Wa\x18\x13aq\x13V[[\x03a\x18#WaU\xF0\x90Pa\x19\x9FV[`\x02`S\x81\x11\x15a\x187Wa\x186aq\x13V[[\x86`S\x81\x11\x15a\x18JWa\x18Iaq\x13V[[\x03a\x18YWay\x18\x90Pa\x19\x9EV[`\x03`S\x81\x11\x15a\x18mWa\x18laq\x13V[[\x86`S\x81\x11\x15a\x18\x80Wa\x18\x7Faq\x13V[[\x03a\x18\x8FWay\x18\x90Pa\x19\x9DV[`\x04`S\x81\x11\x15a\x18\xA3Wa\x18\xA2aq\x13V[[\x86`S\x81\x11\x15a\x18\xB6Wa\x18\xB5aq\x13V[[\x03a\x18\xC5Wa}\0\x90Pa\x19\x9CV[`\x05`S\x81\x11\x15a\x18\xD9Wa\x18\xD8aq\x13V[[\x86`S\x81\x11\x15a\x18\xECWa\x18\xEBaq\x13V[[\x03a\x18\xFBWa\x84\xD0\x90Pa\x19\x9BV[`\x06`S\x81\x11\x15a\x19\x0FWa\x19\x0Eaq\x13V[[\x86`S\x81\x11\x15a\x19\"Wa\x19!aq\x13V[[\x03a\x191Wa\x90\x88\x90Pa\x19\x9AV[`\x08`S\x81\x11\x15a\x19EWa\x19Daq\x13V[[\x86`S\x81\x11\x15a\x19XWa\x19Waq\x13V[[\x03a\x19gWa\x94p\x90Pa\x19\x99V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[[[a\x19\xAA\x81\x85\x84a`\xE7V[a\x1BmV[_`S\x81\x11\x15a\x19\xC2Wa\x19\xC1aq\x13V[[\x86`S\x81\x11\x15a\x19\xD5Wa\x19\xD4aq\x13V[[\x03a\x19\xE4Waa\xA8\x90Pa\x1B`V[`\x02`S\x81\x11\x15a\x19\xF8Wa\x19\xF7aq\x13V[[\x86`S\x81\x11\x15a\x1A\x0BWa\x1A\naq\x13V[[\x03a\x1A\x1AWay\x18\x90Pa\x1B_V[`\x03`S\x81\x11\x15a\x1A.Wa\x1A-aq\x13V[[\x86`S\x81\x11\x15a\x1AAWa\x1A@aq\x13V[[\x03a\x1APWay\x18\x90Pa\x1B^V[`\x04`S\x81\x11\x15a\x1AdWa\x1Acaq\x13V[[\x86`S\x81\x11\x15a\x1AwWa\x1Avaq\x13V[[\x03a\x1A\x86Wa}\0\x90Pa\x1B]V[`\x05`S\x81\x11\x15a\x1A\x9AWa\x1A\x99aq\x13V[[\x86`S\x81\x11\x15a\x1A\xADWa\x1A\xACaq\x13V[[\x03a\x1A\xBCWa\x84\xD0\x90Pa\x1B\\V[`\x06`S\x81\x11\x15a\x1A\xD0Wa\x1A\xCFaq\x13V[[\x86`S\x81\x11\x15a\x1A\xE3Wa\x1A\xE2aq\x13V[[\x03a\x1A\xF2Wa\x90\x88\x90Pa\x1B[V[`\x08`S\x81\x11\x15a\x1B\x06Wa\x1B\x05aq\x13V[[\x86`S\x81\x11\x15a\x1B\x19Wa\x1B\x18aq\x13V[[\x03a\x1B(Wa\x94p\x90Pa\x1BZV[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[[[a\x1Bl\x81\x85\x85\x85ab\x84V[[PPPPPPV[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x1B\xEEW`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\x01`\xF8\x1B\x85~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x03a\x1D\xA7W`\x02`S\x81\x11\x15a\x1C0Wa\x1C/aq\x13V[[\x86`S\x81\x11\x15a\x1CCWa\x1CBaq\x13V[[\x03a\x1CRWa}\0\x90Pa\x1D\x97V[`\x03`S\x81\x11\x15a\x1CfWa\x1Ceaq\x13V[[\x86`S\x81\x11\x15a\x1CyWa\x1Cxaq\x13V[[\x03a\x1C\x88Wa}\0\x90Pa\x1D\x96V[`\x04`S\x81\x11\x15a\x1C\x9CWa\x1C\x9Baq\x13V[[\x86`S\x81\x11\x15a\x1C\xAFWa\x1C\xAEaq\x13V[[\x03a\x1C\xBEWa}\0\x90Pa\x1D\x95V[`\x05`S\x81\x11\x15a\x1C\xD2Wa\x1C\xD1aq\x13V[[\x86`S\x81\x11\x15a\x1C\xE5Wa\x1C\xE4aq\x13V[[\x03a\x1C\xF4Wa\x84\xD0\x90Pa\x1D\x94V[`\x06`S\x81\x11\x15a\x1D\x08Wa\x1D\x07aq\x13V[[\x86`S\x81\x11\x15a\x1D\x1BWa\x1D\x1Aaq\x13V[[\x03a\x1D*Wa\x90\x88\x90Pa\x1D\x93V[`\x08`S\x81\x11\x15a\x1D>Wa\x1D=aq\x13V[[\x86`S\x81\x11\x15a\x1DQWa\x1DPaq\x13V[[\x03a\x1D`Wa\x94p\x90Pa\x1D\x92V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[[a\x1D\xA2\x81\x85\x84a`\xE7V[a\x1F5V[`\x02`S\x81\x11\x15a\x1D\xBBWa\x1D\xBAaq\x13V[[\x86`S\x81\x11\x15a\x1D\xCEWa\x1D\xCDaq\x13V[[\x03a\x1D\xDEWb\x01cx\x90Pa\x1F(V[`\x03`S\x81\x11\x15a\x1D\xF2Wa\x1D\xF1aq\x13V[[\x86`S\x81\x11\x15a\x1E\x05Wa\x1E\x04aq\x13V[[\x03a\x1E\x15Wb\x01\xE0x\x90Pa\x1F'V[`\x04`S\x81\x11\x15a\x1E)Wa\x1E(aq\x13V[[\x86`S\x81\x11\x15a\x1E<Wa\x1E;aq\x13V[[\x03a\x1ELWb\x02|\xB8\x90Pa\x1F&V[`\x05`S\x81\x11\x15a\x1E`Wa\x1E_aq\x13V[[\x86`S\x81\x11\x15a\x1EsWa\x1Eraq\x13V[[\x03a\x1E\x83Wb\x030h\x90Pa\x1F%V[`\x06`S\x81\x11\x15a\x1E\x97Wa\x1E\x96aq\x13V[[\x86`S\x81\x11\x15a\x1E\xAAWa\x1E\xA9aq\x13V[[\x03a\x1E\xBAWb\x04&\x80\x90Pa\x1F$V[`\x08`S\x81\x11\x15a\x1E\xCEWa\x1E\xCDaq\x13V[[\x86`S\x81\x11\x15a\x1E\xE1Wa\x1E\xE0aq\x13V[[\x03a\x1E\xF1Wb\x05\xA1h\x90Pa\x1F#V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[[a\x1F4\x81\x85\x85\x85ab\x84V[[PPPPPPV[_s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$\x90P\x90V[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x1F\xD1W`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x80`S\x81\x11\x15a\x1F\xE5Wa\x1F\xE4aq\x13V[[\x83`S\x81\x11\x15a\x1F\xF8Wa\x1F\xF7aq\x13V[[\x03a \x06W` \x90Pa!\xB2V[`\x02`S\x81\x11\x15a \x1AWa \x19aq\x13V[[\x83`S\x81\x11\x15a -Wa ,aq\x13V[[\x03a ;W` \x90Pa!\xB1V[`\x03`S\x81\x11\x15a OWa Naq\x13V[[\x83`S\x81\x11\x15a bWa aaq\x13V[[\x03a pW` \x90Pa!\xB0V[`\x04`S\x81\x11\x15a \x84Wa \x83aq\x13V[[\x83`S\x81\x11\x15a \x97Wa \x96aq\x13V[[\x03a \xA5W` \x90Pa!\xAFV[`\x05`S\x81\x11\x15a \xB9Wa \xB8aq\x13V[[\x83`S\x81\x11\x15a \xCCWa \xCBaq\x13V[[\x03a \xDAW` \x90Pa!\xAEV[`\x06`S\x81\x11\x15a \xEEWa \xEDaq\x13V[[\x83`S\x81\x11\x15a!\x01Wa!\0aq\x13V[[\x03a!\x0FW` \x90Pa!\xADV[`\x07`S\x81\x11\x15a!#Wa!\"aq\x13V[[\x83`S\x81\x11\x15a!6Wa!5aq\x13V[[\x03a!DW` \x90Pa!\xACV[`\x08`S\x81\x11\x15a!XWa!Waq\x13V[[\x83`S\x81\x11\x15a!kWa!jaq\x13V[[\x03a!yW` \x90Pa!\xABV[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[[[[a!\xBB\x81aaSV[a!\xC5\x82\x82aa\xB3V[PPPV[`\x01a!\xD4ac\x02V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\"\x15W`@Q\x7FoOs\x1F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x02_a\" ac&V[\x90P\x80_\x01`\x08\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x80a\"hWP\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81_\x01_\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x10\x15[\x15a\"\x9FW`@Q\x7F\xF9.\xE8\xA9\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x81\x81_\x01_a\x01\0\n\x81T\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP`\x01\x81_\x01`\x08a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP_\x81_\x01`\x08a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP\x7F\xC7\xF5\x05\xB2\xF3q\xAE!u\xEEI\x13\xF4I\x9E\x1F&3\xA7\xB5\x93c!\xEE\xD1\xCD\xAE\xB6\x11Q\x81\xD2\x82`@Qa#.\x91\x90ar\x8EV[`@Q\x80\x91\x03\x90\xA1PPV[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a#\xB3W`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\x01`\xF8\x1B\x85~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x03a%:W`\x02`S\x81\x11\x15a#\xF5Wa#\xF4aq\x13V[[\x86`S\x81\x11\x15a$\x08Wa$\x07aq\x13V[[\x03a$\x18Wb\x01\xDC\x90\x90Pa%*V[`\x03`S\x81\x11\x15a$,Wa$+aq\x13V[[\x86`S\x81\x11\x15a$?Wa$>aq\x13V[[\x03a$OWb\x02\xF1\xE8\x90Pa%)V[`\x04`S\x81\x11\x15a$cWa$baq\x13V[[\x86`S\x81\x11\x15a$vWa$uaq\x13V[[\x03a$\x86Wb\x04\x0B(\x90Pa%(V[`\x05`S\x81\x11\x15a$\x9AWa$\x99aq\x13V[[\x86`S\x81\x11\x15a$\xADWa$\xACaq\x13V[[\x03a$\xBDWb\x05\x91\xC8\x90Pa%'V[`\x06`S\x81\x11\x15a$\xD1Wa$\xD0aq\x13V[[\x86`S\x81\x11\x15a$\xE4Wa$\xE3aq\x13V[[\x03a$\xF4Wb\n\x9E\xC0\x90Pa%&V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[a%5\x81\x85\x84a`\xE7V[a&\x90V[`\x02`S\x81\x11\x15a%NWa%Maq\x13V[[\x86`S\x81\x11\x15a%aWa%`aq\x13V[[\x03a%qWb\x02I\xF0\x90Pa&\x83V[`\x03`S\x81\x11\x15a%\x85Wa%\x84aq\x13V[[\x86`S\x81\x11\x15a%\x98Wa%\x97aq\x13V[[\x03a%\xA8Wb\x03c0\x90Pa&\x82V[`\x04`S\x81\x11\x15a%\xBCWa%\xBBaq\x13V[[\x86`S\x81\x11\x15a%\xCFWa%\xCEaq\x13V[[\x03a%\xDFWb\x05\x01@\x90Pa&\x81V[`\x05`S\x81\x11\x15a%\xF3Wa%\xF2aq\x13V[[\x86`S\x81\x11\x15a&\x06Wa&\x05aq\x13V[[\x03a&\x16Wb\t\x18 \x90Pa&\x80V[`\x06`S\x81\x11\x15a&*Wa&)aq\x13V[[\x86`S\x81\x11\x15a&=Wa&<aq\x13V[[\x03a&MWb\x19\xB9\xF0\x90Pa&\x7FV[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[a&\x8F\x81\x85\x85\x85ab\x84V[[PPPPPPV[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a'\x11W`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\x01`\xF8\x1B\x85~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x14a'qW`@Q\x7Fj\xA9\xEB\x05\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x02`S\x81\x11\x15a'\x85Wa'\x84aq\x13V[[\x86`S\x81\x11\x15a'\x98Wa'\x97aq\x13V[[\x03a'\xA8Wb\x034P\x90Pa(\xBAV[`\x03`S\x81\x11\x15a'\xBCWa'\xBBaq\x13V[[\x86`S\x81\x11\x15a'\xCFWa'\xCEaq\x13V[[\x03a'\xDFWb\x04\x9B\xB0\x90Pa(\xB9V[`\x04`S\x81\x11\x15a'\xF3Wa'\xF2aq\x13V[[\x86`S\x81\x11\x15a(\x06Wa(\x05aq\x13V[[\x03a(\x16Wb\x06\xAE\xF0\x90Pa(\xB8V[`\x05`S\x81\x11\x15a(*Wa()aq\x13V[[\x86`S\x81\x11\x15a(=Wa(<aq\x13V[[\x03a(MWb\n\xE8\xF8\x90Pa(\xB7V[`\x06`S\x81\x11\x15a(aWa(`aq\x13V[[\x86`S\x81\x11\x15a(tWa(saq\x13V[[\x03a(\x84Wb\x12\xB1(\x90Pa(\xB6V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[a(\xC5\x81\x85\x84a`\xE7V[PPPPPPV[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a)FW`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x80`S\x81\x11\x15a)ZWa)Yaq\x13V[[\x86`S\x81\x11\x15a)mWa)laq\x13V[[\x03a)|Wa\xD6\xD8\x90Pa+1V[`\x02`S\x81\x11\x15a)\x90Wa)\x8Faq\x13V[[\x86`S\x81\x11\x15a)\xA3Wa)\xA2aq\x13V[[\x03a)\xB2Wa\xD6\xD8\x90Pa+0V[`\x03`S\x81\x11\x15a)\xC6Wa)\xC5aq\x13V[[\x86`S\x81\x11\x15a)\xD9Wa)\xD8aq\x13V[[\x03a)\xE8Wa\xD6\xD8\x90Pa+/V[`\x04`S\x81\x11\x15a)\xFCWa)\xFBaq\x13V[[\x86`S\x81\x11\x15a*\x0FWa*\x0Eaq\x13V[[\x03a*\x1EWa\xD6\xD8\x90Pa+.V[`\x05`S\x81\x11\x15a*2Wa*1aq\x13V[[\x86`S\x81\x11\x15a*EWa*Daq\x13V[[\x03a*TWa\xD6\xD8\x90Pa+-V[`\x06`S\x81\x11\x15a*hWa*gaq\x13V[[\x86`S\x81\x11\x15a*{Wa*zaq\x13V[[\x03a*\x8AWa\xDE\xA8\x90Pa+,V[`\x07`S\x81\x11\x15a*\x9EWa*\x9Daq\x13V[[\x86`S\x81\x11\x15a*\xB1Wa*\xB0aq\x13V[[\x03a*\xC1Wb\x01D8\x90Pa++V[`\x08`S\x81\x11\x15a*\xD5Wa*\xD4aq\x13V[[\x86`S\x81\x11\x15a*\xE8Wa*\xE7aq\x13V[[\x03a*\xF8Wb\x01\xA5\xE0\x90Pa+*V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[[[[a+>\x81\x86\x86\x86\x86acMV[PPPPPPV[a+Nac\xDDV[a+W\x82ad\xC3V[a+a\x82\x82ae\xB6V[PPV[_a+naf\xD4V[\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC_\x1B\x90P\x90V[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a,\x0FW`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\x01`\xF8\x1B\x85~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x03a-\x96W`\x02`S\x81\x11\x15a,QWa,Paq\x13V[[\x86`S\x81\x11\x15a,dWa,caq\x13V[[\x03a,tWb\x01H \x90Pa-\x86V[`\x03`S\x81\x11\x15a,\x88Wa,\x87aq\x13V[[\x86`S\x81\x11\x15a,\x9BWa,\x9Aaq\x13V[[\x03a,\xABWb\x01W\xC0\x90Pa-\x85V[`\x04`S\x81\x11\x15a,\xBFWa,\xBEaq\x13V[[\x86`S\x81\x11\x15a,\xD2Wa,\xD1aq\x13V[[\x03a,\xE2Wb\x01\xC9\x08\x90Pa-\x84V[`\x05`S\x81\x11\x15a,\xF6Wa,\xF5aq\x13V[[\x86`S\x81\x11\x15a-\tWa-\x08aq\x13V[[\x03a-\x19Wb\x02I\xF0\x90Pa-\x83V[`\x06`S\x81\x11\x15a--Wa-,aq\x13V[[\x86`S\x81\x11\x15a-@Wa-?aq\x13V[[\x03a-PWb\x02\xD6\x90\x90Pa-\x82V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[a-\x91\x81\x85\x84a`\xE7V[a.\xECV[`\x02`S\x81\x11\x15a-\xAAWa-\xA9aq\x13V[[\x86`S\x81\x11\x15a-\xBDWa-\xBCaq\x13V[[\x03a-\xCDWb\x01\xD0\xD8\x90Pa.\xDFV[`\x03`S\x81\x11\x15a-\xE1Wa-\xE0aq\x13V[[\x86`S\x81\x11\x15a-\xF4Wa-\xF3aq\x13V[[\x03a.\x04Wb\x02:P\x90Pa.\xDEV[`\x04`S\x81\x11\x15a.\x18Wa.\x17aq\x13V[[\x86`S\x81\x11\x15a.+Wa.*aq\x13V[[\x03a.;Wb\x02\xC6\xF0\x90Pa.\xDDV[`\x05`S\x81\x11\x15a.OWa.Naq\x13V[[\x86`S\x81\x11\x15a.bWa.aaq\x13V[[\x03a.rWb\x03Wx\x90Pa.\xDCV[`\x06`S\x81\x11\x15a.\x86Wa.\x85aq\x13V[[\x86`S\x81\x11\x15a.\x99Wa.\x98aq\x13V[[\x03a.\xA9Wb\x04h\xE8\x90Pa.\xDBV[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[a.\xEB\x81\x85\x85\x85ab\x84V[[PPPPPPV[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a/mW`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\x01`\xF8\x1B\x85~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x03a1&W`\x02`S\x81\x11\x15a/\xAFWa/\xAEaq\x13V[[\x86`S\x81\x11\x15a/\xC2Wa/\xC1aq\x13V[[\x03a/\xD1Way\x18\x90Pa1\x16V[`\x03`S\x81\x11\x15a/\xE5Wa/\xE4aq\x13V[[\x86`S\x81\x11\x15a/\xF8Wa/\xF7aq\x13V[[\x03a0\x07Way\x18\x90Pa1\x15V[`\x04`S\x81\x11\x15a0\x1BWa0\x1Aaq\x13V[[\x86`S\x81\x11\x15a0.Wa0-aq\x13V[[\x03a0=Wa}\0\x90Pa1\x14V[`\x05`S\x81\x11\x15a0QWa0Paq\x13V[[\x86`S\x81\x11\x15a0dWa0caq\x13V[[\x03a0sWa\x84\xD0\x90Pa1\x13V[`\x06`S\x81\x11\x15a0\x87Wa0\x86aq\x13V[[\x86`S\x81\x11\x15a0\x9AWa0\x99aq\x13V[[\x03a0\xA9Wa\x90\x88\x90Pa1\x12V[`\x08`S\x81\x11\x15a0\xBDWa0\xBCaq\x13V[[\x86`S\x81\x11\x15a0\xD0Wa0\xCFaq\x13V[[\x03a0\xDFWa\x9C@\x90Pa1\x11V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[[a1!\x81\x85\x84a`\xE7V[a2\xB4V[`\x02`S\x81\x11\x15a1:Wa19aq\x13V[[\x86`S\x81\x11\x15a1MWa1Laq\x13V[[\x03a1]Wb\x01kH\x90Pa2\xA7V[`\x03`S\x81\x11\x15a1qWa1paq\x13V[[\x86`S\x81\x11\x15a1\x84Wa1\x83aq\x13V[[\x03a1\x94Wb\x01\xE8H\x90Pa2\xA6V[`\x04`S\x81\x11\x15a1\xA8Wa1\xA7aq\x13V[[\x86`S\x81\x11\x15a1\xBBWa1\xBAaq\x13V[[\x03a1\xCBWb\x02q\0\x90Pa2\xA5V[`\x05`S\x81\x11\x15a1\xDFWa1\xDEaq\x13V[[\x86`S\x81\x11\x15a1\xF2Wa1\xF1aq\x13V[[\x03a2\x02Wb\x030h\x90Pa2\xA4V[`\x06`S\x81\x11\x15a2\x16Wa2\x15aq\x13V[[\x86`S\x81\x11\x15a2)Wa2(aq\x13V[[\x03a29Wb\x04Qx\x90Pa2\xA3V[`\x08`S\x81\x11\x15a2MWa2Laq\x13V[[\x86`S\x81\x11\x15a2`Wa2_aq\x13V[[\x03a2pWb\x05\xB8\xD8\x90Pa2\xA2V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[[a2\xB3\x81\x85\x85\x85ab\x84V[[PPPPPPV[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a35W`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\x01`\xF8\x1B\x85~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x03a4\xBAW`\x02`S\x81\x11\x15a3wWa3vaq\x13V[[\x86`S\x81\x11\x15a3\x8AWa3\x89aq\x13V[[\x03a3\x99Wa\xCB \x90Pa4\xAAV[`\x03`S\x81\x11\x15a3\xADWa3\xACaq\x13V[[\x86`S\x81\x11\x15a3\xC0Wa3\xBFaq\x13V[[\x03a3\xCFWa\xD6\xD8\x90Pa4\xA9V[`\x04`S\x81\x11\x15a3\xE3Wa3\xE2aq\x13V[[\x86`S\x81\x11\x15a3\xF6Wa3\xF5aq\x13V[[\x03a4\x06Wb\x01H \x90Pa4\xA8V[`\x05`S\x81\x11\x15a4\x1AWa4\x19aq\x13V[[\x86`S\x81\x11\x15a4-Wa4,aq\x13V[[\x03a4=Wb\x01\xC5 \x90Pa4\xA7V[`\x06`S\x81\x11\x15a4QWa4Paq\x13V[[\x86`S\x81\x11\x15a4dWa4caq\x13V[[\x03a4tWb\x02F\x08\x90Pa4\xA6V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[a4\xB5\x81\x85\x84a`\xE7V[a6\x0FV[`\x02`S\x81\x11\x15a4\xCEWa4\xCDaq\x13V[[\x86`S\x81\x11\x15a4\xE1Wa4\xE0aq\x13V[[\x03a4\xF0Wa\xF6\x18\x90Pa6\x02V[`\x03`S\x81\x11\x15a5\x04Wa5\x03aq\x13V[[\x86`S\x81\x11\x15a5\x17Wa5\x16aq\x13V[[\x03a5'Wb\x01H \x90Pa6\x01V[`\x04`S\x81\x11\x15a5;Wa5:aq\x13V[[\x86`S\x81\x11\x15a5NWa5Maq\x13V[[\x03a5^Wb\x01\xCC\xF0\x90Pa6\0V[`\x05`S\x81\x11\x15a5rWa5qaq\x13V[[\x86`S\x81\x11\x15a5\x85Wa5\x84aq\x13V[[\x03a5\x95Wb\x02Q\xC0\x90Pa5\xFFV[`\x06`S\x81\x11\x15a5\xA9Wa5\xA8aq\x13V[[\x86`S\x81\x11\x15a5\xBCWa5\xBBaq\x13V[[\x03a5\xCCWb\x034P\x90Pa5\xFEV[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[a6\x0E\x81\x85\x85\x85ab\x84V[[PPPPPPV[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a6\x90W`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\x01`\xF8\x1B\x85~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x03a8IW`\x02`S\x81\x11\x15a6\xD2Wa6\xD1aq\x13V[[\x86`S\x81\x11\x15a6\xE5Wa6\xE4aq\x13V[[\x03a6\xF4Wa}\0\x90Pa89V[`\x03`S\x81\x11\x15a7\x08Wa7\x07aq\x13V[[\x86`S\x81\x11\x15a7\x1BWa7\x1Aaq\x13V[[\x03a7*Wa}\0\x90Pa88V[`\x04`S\x81\x11\x15a7>Wa7=aq\x13V[[\x86`S\x81\x11\x15a7QWa7Paq\x13V[[\x03a7`Wa}\0\x90Pa87V[`\x05`S\x81\x11\x15a7tWa7saq\x13V[[\x86`S\x81\x11\x15a7\x87Wa7\x86aq\x13V[[\x03a7\x96Wa\x84\xD0\x90Pa86V[`\x06`S\x81\x11\x15a7\xAAWa7\xA9aq\x13V[[\x86`S\x81\x11\x15a7\xBDWa7\xBCaq\x13V[[\x03a7\xCCWa\x90\x88\x90Pa85V[`\x08`S\x81\x11\x15a7\xE0Wa7\xDFaq\x13V[[\x86`S\x81\x11\x15a7\xF3Wa7\xF2aq\x13V[[\x03a8\x02Wa\x98X\x90Pa84V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[[a8D\x81\x85\x84a`\xE7V[a9\xD7V[`\x02`S\x81\x11\x15a8]Wa8\\aq\x13V[[\x86`S\x81\x11\x15a8pWa8oaq\x13V[[\x03a8\x80Wb\x01g`\x90Pa9\xCAV[`\x03`S\x81\x11\x15a8\x94Wa8\x93aq\x13V[[\x86`S\x81\x11\x15a8\xA7Wa8\xA6aq\x13V[[\x03a8\xB7Wb\x01\xE8H\x90Pa9\xC9V[`\x04`S\x81\x11\x15a8\xCBWa8\xCAaq\x13V[[\x86`S\x81\x11\x15a8\xDEWa8\xDDaq\x13V[[\x03a8\xEEWb\x02x\xD0\x90Pa9\xC8V[`\x05`S\x81\x11\x15a9\x02Wa9\x01aq\x13V[[\x86`S\x81\x11\x15a9\x15Wa9\x14aq\x13V[[\x03a9%Wb\x03,\x80\x90Pa9\xC7V[`\x06`S\x81\x11\x15a99Wa98aq\x13V[[\x86`S\x81\x11\x15a9LWa9Kaq\x13V[[\x03a9\\Wb\x04&\x80\x90Pa9\xC6V[`\x08`S\x81\x11\x15a9pWa9oaq\x13V[[\x86`S\x81\x11\x15a9\x83Wa9\x82aq\x13V[[\x03a9\x93Wb\x05\xC4\x90\x90Pa9\xC5V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[[a9\xD6\x81\x85\x85\x85ab\x84V[[PPPPPPV[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a:XW`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\x01`\xF8\x1B\x85~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x03a;\xDDW`\x02`S\x81\x11\x15a:\x9AWa:\x99aq\x13V[[\x86`S\x81\x11\x15a:\xADWa:\xACaq\x13V[[\x03a:\xBCWa\xCB \x90Pa;\xCDV[`\x03`S\x81\x11\x15a:\xD0Wa:\xCFaq\x13V[[\x86`S\x81\x11\x15a:\xE3Wa:\xE2aq\x13V[[\x03a:\xF2Wa\xD6\xD8\x90Pa;\xCCV[`\x04`S\x81\x11\x15a;\x06Wa;\x05aq\x13V[[\x86`S\x81\x11\x15a;\x19Wa;\x18aq\x13V[[\x03a;)Wb\x01H \x90Pa;\xCBV[`\x05`S\x81\x11\x15a;=Wa;<aq\x13V[[\x86`S\x81\x11\x15a;PWa;Oaq\x13V[[\x03a;`Wb\x01\xC9\x08\x90Pa;\xCAV[`\x06`S\x81\x11\x15a;tWa;saq\x13V[[\x86`S\x81\x11\x15a;\x87Wa;\x86aq\x13V[[\x03a;\x97Wb\x02I\xF0\x90Pa;\xC9V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[a;\xD8\x81\x85\x84a`\xE7V[a=2V[`\x02`S\x81\x11\x15a;\xF1Wa;\xF0aq\x13V[[\x86`S\x81\x11\x15a<\x04Wa<\x03aq\x13V[[\x03a<\x13Wa\xE6x\x90Pa=%V[`\x03`S\x81\x11\x15a<'Wa<&aq\x13V[[\x86`S\x81\x11\x15a<:Wa<9aq\x13V[[\x03a<JWb\x01H \x90Pa=$V[`\x04`S\x81\x11\x15a<^Wa<]aq\x13V[[\x86`S\x81\x11\x15a<qWa<paq\x13V[[\x03a<\x81Wb\x01\xCC\xF0\x90Pa=#V[`\x05`S\x81\x11\x15a<\x95Wa<\x94aq\x13V[[\x86`S\x81\x11\x15a<\xA8Wa<\xA7aq\x13V[[\x03a<\xB8Wb\x02Q\xC0\x90Pa=\"V[`\x06`S\x81\x11\x15a<\xCCWa<\xCBaq\x13V[[\x86`S\x81\x11\x15a<\xDFWa<\xDEaq\x13V[[\x03a<\xEFWb\x03S\x90\x90Pa=!V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[a=1\x81\x85\x85\x85ab\x84V[[PPPPPPV[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a=\xB3W`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\x01`\xF8\x1B\x85~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x03a?:W`\x02`S\x81\x11\x15a=\xF5Wa=\xF4aq\x13V[[\x86`S\x81\x11\x15a>\x08Wa>\x07aq\x13V[[\x03a>\x18Wb\x01H \x90Pa?*V[`\x03`S\x81\x11\x15a>,Wa>+aq\x13V[[\x86`S\x81\x11\x15a>?Wa>>aq\x13V[[\x03a>OWb\x01kH\x90Pa?)V[`\x04`S\x81\x11\x15a>cWa>baq\x13V[[\x86`S\x81\x11\x15a>vWa>uaq\x13V[[\x03a>\x86Wb\x01s\x18\x90Pa?(V[`\x05`S\x81\x11\x15a>\x9AWa>\x99aq\x13V[[\x86`S\x81\x11\x15a>\xADWa>\xACaq\x13V[[\x03a>\xBDWb\x02\x07\x88\x90Pa?'V[`\x06`S\x81\x11\x15a>\xD1Wa>\xD0aq\x13V[[\x86`S\x81\x11\x15a>\xE4Wa>\xE3aq\x13V[[\x03a>\xF4Wb\x02\x9F\xE0\x90Pa?&V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[a?5\x81\x85\x84a`\xE7V[a@\x90V[`\x02`S\x81\x11\x15a?NWa?Maq\x13V[[\x86`S\x81\x11\x15a?aWa?`aq\x13V[[\x03a?qWb\x01cx\x90Pa@\x83V[`\x03`S\x81\x11\x15a?\x85Wa?\x84aq\x13V[[\x86`S\x81\x11\x15a?\x98Wa?\x97aq\x13V[[\x03a?\xA8Wb\x01kH\x90Pa@\x82V[`\x04`S\x81\x11\x15a?\xBCWa?\xBBaq\x13V[[\x86`S\x81\x11\x15a?\xCFWa?\xCEaq\x13V[[\x03a?\xDFWb\x01\xE8H\x90Pa@\x81V[`\x05`S\x81\x11\x15a?\xF3Wa?\xF2aq\x13V[[\x86`S\x81\x11\x15a@\x06Wa@\x05aq\x13V[[\x03a@\x16Wb\x02x\xD0\x90Pa@\x80V[`\x06`S\x81\x11\x15a@*Wa@)aq\x13V[[\x86`S\x81\x11\x15a@=Wa@<aq\x13V[[\x03a@MWb\x03\xF7\xA0\x90Pa@\x7FV[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[a@\x8F\x81\x85\x85\x85ab\x84V[[PPPPPPV[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14aA\x11W`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\x01`\xF8\x1B\x85~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x03aC<W_`S\x81\x11\x15aARWaAQaq\x13V[[\x86`S\x81\x11\x15aAeWaAdaq\x13V[[\x03aAtWaa\xA8\x90PaC,V[`\x02`S\x81\x11\x15aA\x88WaA\x87aq\x13V[[\x86`S\x81\x11\x15aA\x9BWaA\x9Aaq\x13V[[\x03aA\xAAWa\xD6\xD8\x90PaC+V[`\x03`S\x81\x11\x15aA\xBEWaA\xBDaq\x13V[[\x86`S\x81\x11\x15aA\xD1WaA\xD0aq\x13V[[\x03aA\xE0Wa\xD6\xD8\x90PaC*V[`\x04`S\x81\x11\x15aA\xF4WaA\xF3aq\x13V[[\x86`S\x81\x11\x15aB\x07WaB\x06aq\x13V[[\x03aB\x17Wb\x01@P\x90PaC)V[`\x05`S\x81\x11\x15aB+WaB*aq\x13V[[\x86`S\x81\x11\x15aB>WaB=aq\x13V[[\x03aBNWb\x01D8\x90PaC(V[`\x06`S\x81\x11\x15aBbWaBaaq\x13V[[\x86`S\x81\x11\x15aBuWaBtaq\x13V[[\x03aB\x85Wb\x01\xC9\x08\x90PaC'V[`\x07`S\x81\x11\x15aB\x99WaB\x98aq\x13V[[\x86`S\x81\x11\x15aB\xACWaB\xABaq\x13V[[\x03aB\xBCWb\x01\xC9\x08\x90PaC&V[`\x08`S\x81\x11\x15aB\xD0WaB\xCFaq\x13V[[\x86`S\x81\x11\x15aB\xE3WaB\xE2aq\x13V[[\x03aB\xF3Wb\x01\xCC\xF0\x90PaC%V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[[[[aC7\x81\x85\x84a`\xE7V[aE7V[_`S\x81\x11\x15aCOWaCNaq\x13V[[\x86`S\x81\x11\x15aCbWaCaaq\x13V[[\x03aCqWae\x90\x90PaE*V[`\x02`S\x81\x11\x15aC\x85WaC\x84aq\x13V[[\x86`S\x81\x11\x15aC\x98WaC\x97aq\x13V[[\x03aC\xA7Wa\xD6\xD8\x90PaE)V[`\x03`S\x81\x11\x15aC\xBBWaC\xBAaq\x13V[[\x86`S\x81\x11\x15aC\xCEWaC\xCDaq\x13V[[\x03aC\xDEWb\x01D8\x90PaE(V[`\x04`S\x81\x11\x15aC\xF2WaC\xF1aq\x13V[[\x86`S\x81\x11\x15aD\x05WaD\x04aq\x13V[[\x03aD\x15Wb\x01O\xF0\x90PaE'V[`\x05`S\x81\x11\x15aD)WaD(aq\x13V[[\x86`S\x81\x11\x15aD<WaD;aq\x13V[[\x03aDLWb\x01\xD4\xC0\x90PaE&V[`\x06`S\x81\x11\x15aD`WaD_aq\x13V[[\x86`S\x81\x11\x15aDsWaDraq\x13V[[\x03aD\x83Wb\x01\xDC\x90\x90PaE%V[`\x07`S\x81\x11\x15aD\x97WaD\x96aq\x13V[[\x86`S\x81\x11\x15aD\xAAWaD\xA9aq\x13V[[\x03aD\xBAWb\x02\x17(\x90PaE$V[`\x08`S\x81\x11\x15aD\xCEWaD\xCDaq\x13V[[\x86`S\x81\x11\x15aD\xE1WaD\xE0aq\x13V[[\x03aD\xF1Wb\x02Q\xC0\x90PaE#V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[[[[aE6\x81\x85\x85\x85ab\x84V[[PPPPPPV[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14aE\xB8W`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\x02`S\x81\x11\x15aE\xCDWaE\xCCaq\x13V[[\x84`S\x81\x11\x15aE\xE0WaE\xDFaq\x13V[[\x03aE\xF0Wb\x014\x98\x90PaG:V[`\x03`S\x81\x11\x15aF\x04WaF\x03aq\x13V[[\x84`S\x81\x11\x15aF\x17WaF\x16aq\x13V[[\x03aF'Wb\x01kH\x90PaG9V[`\x04`S\x81\x11\x15aF;WaF:aq\x13V[[\x84`S\x81\x11\x15aFNWaFMaq\x13V[[\x03aF^Wb\x01s\x18\x90PaG8V[`\x05`S\x81\x11\x15aFrWaFqaq\x13V[[\x84`S\x81\x11\x15aF\x85WaF\x84aq\x13V[[\x03aF\x95Wb\x01\xFF\xB8\x90PaG7V[`\x06`S\x81\x11\x15aF\xA9WaF\xA8aq\x13V[[\x84`S\x81\x11\x15aF\xBCWaF\xBBaq\x13V[[\x03aF\xCCWb\x02\x90@\x90PaG6V[`\x08`S\x81\x11\x15aF\xE0WaF\xDFaq\x13V[[\x84`S\x81\x11\x15aF\xF3WaF\xF2aq\x13V[[\x03aG\x03Wb\x04\x1A\xC8\x90PaG5V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[[aGE\x81\x84\x84a`\xE7V[PPPPV[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14aG\xC4W`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\x01`\xF8\x1B\x85~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x03aIKW`\x02`S\x81\x11\x15aH\x06WaH\x05aq\x13V[[\x86`S\x81\x11\x15aH\x19WaH\x18aq\x13V[[\x03aH)Wb\x01[\xA8\x90PaI;V[`\x03`S\x81\x11\x15aH=WaH<aq\x13V[[\x86`S\x81\x11\x15aHPWaHOaq\x13V[[\x03aH`Wb\x01[\xA8\x90PaI:V[`\x04`S\x81\x11\x15aHtWaHsaq\x13V[[\x86`S\x81\x11\x15aH\x87WaH\x86aq\x13V[[\x03aH\x97Wb\x01\xC9\x08\x90PaI9V[`\x05`S\x81\x11\x15aH\xABWaH\xAAaq\x13V[[\x86`S\x81\x11\x15aH\xBEWaH\xBDaq\x13V[[\x03aH\xCEWb\x02F\x08\x90PaI8V[`\x06`S\x81\x11\x15aH\xE2WaH\xE1aq\x13V[[\x86`S\x81\x11\x15aH\xF5WaH\xF4aq\x13V[[\x03aI\x05Wb\x02\xBF \x90PaI7V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[aIF\x81\x85\x84a`\xE7V[aJ\xA1V[`\x02`S\x81\x11\x15aI_WaI^aq\x13V[[\x86`S\x81\x11\x15aIrWaIqaq\x13V[[\x03aI\x82Wb\x01\xD8\xA8\x90PaJ\x94V[`\x03`S\x81\x11\x15aI\x96WaI\x95aq\x13V[[\x86`S\x81\x11\x15aI\xA9WaI\xA8aq\x13V[[\x03aI\xB9Wb\x026h\x90PaJ\x93V[`\x04`S\x81\x11\x15aI\xCDWaI\xCCaq\x13V[[\x86`S\x81\x11\x15aI\xE0WaI\xDFaq\x13V[[\x03aI\xF0Wb\x02\xBF \x90PaJ\x92V[`\x05`S\x81\x11\x15aJ\x04WaJ\x03aq\x13V[[\x86`S\x81\x11\x15aJ\x17WaJ\x16aq\x13V[[\x03aJ'Wb\x03S\x90\x90PaJ\x91V[`\x06`S\x81\x11\x15aJ;WaJ:aq\x13V[[\x86`S\x81\x11\x15aJNWaJMaq\x13V[[\x03aJ^Wb\x04l\xD0\x90PaJ\x90V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[aJ\xA0\x81\x85\x85\x85ab\x84V[[PPPPPPV[`@Q\x80`@\x01`@R\x80`\x05\x81R` \x01\x7F5.0.0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81RP\x81V[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14aK[W`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\x02`S\x81\x11\x15aKpWaKoaq\x13V[[\x83`S\x81\x11\x15aK\x83WaK\x82aq\x13V[[\x03aK\x92WaY\xD8\x90PaL\xD7V[`\x03`S\x81\x11\x15aK\xA6WaK\xA5aq\x13V[[\x83`S\x81\x11\x15aK\xB9WaK\xB8aq\x13V[[\x03aK\xC8WaY\xD8\x90PaL\xD6V[`\x04`S\x81\x11\x15aK\xDCWaK\xDBaq\x13V[[\x83`S\x81\x11\x15aK\xEFWaK\xEEaq\x13V[[\x03aK\xFEWa]\xC0\x90PaL\xD5V[`\x05`S\x81\x11\x15aL\x12WaL\x11aq\x13V[[\x83`S\x81\x11\x15aL%WaL$aq\x13V[[\x03aL4Wa]\xC0\x90PaL\xD4V[`\x06`S\x81\x11\x15aLHWaLGaq\x13V[[\x83`S\x81\x11\x15aL[WaLZaq\x13V[[\x03aLjWaa\xA8\x90PaL\xD3V[`\x08`S\x81\x11\x15aL~WaL}aq\x13V[[\x83`S\x81\x11\x15aL\x91WaL\x90aq\x13V[[\x03aL\xA0Wau0\x90PaL\xD2V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[[aL\xE0\x81aaSV[aL\xEA\x82\x82aa\xB3V[PPPV[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14aMhW`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\x01`\xF8\x1B\x85~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x03aN\xEDW`\x02`S\x81\x11\x15aM\xAAWaM\xA9aq\x13V[[\x86`S\x81\x11\x15aM\xBDWaM\xBCaq\x13V[[\x03aM\xCCWa\xE2\x90\x90PaN\xDDV[`\x03`S\x81\x11\x15aM\xE0WaM\xDFaq\x13V[[\x86`S\x81\x11\x15aM\xF3WaM\xF2aq\x13V[[\x03aN\x02Wa\xE2\x90\x90PaN\xDCV[`\x04`S\x81\x11\x15aN\x16WaN\x15aq\x13V[[\x86`S\x81\x11\x15aN)WaN(aq\x13V[[\x03aN9Wb\x01H \x90PaN\xDBV[`\x05`S\x81\x11\x15aNMWaNLaq\x13V[[\x86`S\x81\x11\x15aN`WaN_aq\x13V[[\x03aNpWb\x01\xD0\xD8\x90PaN\xDAV[`\x06`S\x81\x11\x15aN\x84WaN\x83aq\x13V[[\x86`S\x81\x11\x15aN\x97WaN\x96aq\x13V[[\x03aN\xA7Wb\x02I\xF0\x90PaN\xD9V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[aN\xE8\x81\x85\x84a`\xE7V[aPBV[`\x02`S\x81\x11\x15aO\x01WaO\0aq\x13V[[\x86`S\x81\x11\x15aO\x14WaO\x13aq\x13V[[\x03aO#Wa\xE2\x90\x90PaP5V[`\x03`S\x81\x11\x15aO7WaO6aq\x13V[[\x86`S\x81\x11\x15aOJWaOIaq\x13V[[\x03aOZWb\x01D8\x90PaP4V[`\x04`S\x81\x11\x15aOnWaOmaq\x13V[[\x86`S\x81\x11\x15aO\x81WaO\x80aq\x13V[[\x03aO\x91Wb\x01\xC9\x08\x90PaP3V[`\x05`S\x81\x11\x15aO\xA5WaO\xA4aq\x13V[[\x86`S\x81\x11\x15aO\xB8WaO\xB7aq\x13V[[\x03aO\xC8Wb\x02F\x08\x90PaP2V[`\x06`S\x81\x11\x15aO\xDCWaO\xDBaq\x13V[[\x86`S\x81\x11\x15aO\xEFWaO\xEEaq\x13V[[\x03aO\xFFWb\x03S\x90\x90PaP1V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[aPA\x81\x85\x85\x85ab\x84V[[PPPPPPV[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14aP\xC3W`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\x01`\xF8\x1B\x85~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x03aR\xB2W_`S\x81\x11\x15aQ\x04WaQ\x03aq\x13V[[\x86`S\x81\x11\x15aQ\x17WaQ\x16aq\x13V[[\x03aQ&WaU\xF0\x90PaR\xA2V[`\x02`S\x81\x11\x15aQ:WaQ9aq\x13V[[\x86`S\x81\x11\x15aQMWaQLaq\x13V[[\x03aQ\\Wau0\x90PaR\xA1V[`\x03`S\x81\x11\x15aQpWaQoaq\x13V[[\x86`S\x81\x11\x15aQ\x83WaQ\x82aq\x13V[[\x03aQ\x92Wau0\x90PaR\xA0V[`\x04`S\x81\x11\x15aQ\xA6WaQ\xA5aq\x13V[[\x86`S\x81\x11\x15aQ\xB9WaQ\xB8aq\x13V[[\x03aQ\xC8Wa}\0\x90PaR\x9FV[`\x05`S\x81\x11\x15aQ\xDCWaQ\xDBaq\x13V[[\x86`S\x81\x11\x15aQ\xEFWaQ\xEEaq\x13V[[\x03aQ\xFEWa\x84\xD0\x90PaR\x9EV[`\x06`S\x81\x11\x15aR\x12WaR\x11aq\x13V[[\x86`S\x81\x11\x15aR%WaR$aq\x13V[[\x03aR4Wa\x90\x88\x90PaR\x9DV[`\x08`S\x81\x11\x15aRHWaRGaq\x13V[[\x86`S\x81\x11\x15aR[WaRZaq\x13V[[\x03aRjWa\x94p\x90PaR\x9CV[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[[[aR\xAD\x81\x85\x84a`\xE7V[aTpV[_`S\x81\x11\x15aR\xC5WaR\xC4aq\x13V[[\x86`S\x81\x11\x15aR\xD8WaR\xD7aq\x13V[[\x03aR\xE7Wa]\xC0\x90PaTcV[`\x02`S\x81\x11\x15aR\xFBWaR\xFAaq\x13V[[\x86`S\x81\x11\x15aS\x0EWaS\raq\x13V[[\x03aS\x1DWau0\x90PaTbV[`\x03`S\x81\x11\x15aS1WaS0aq\x13V[[\x86`S\x81\x11\x15aSDWaSCaq\x13V[[\x03aSSWay\x18\x90PaTaV[`\x04`S\x81\x11\x15aSgWaSfaq\x13V[[\x86`S\x81\x11\x15aSzWaSyaq\x13V[[\x03aS\x89Wa}\0\x90PaT`V[`\x05`S\x81\x11\x15aS\x9DWaS\x9Caq\x13V[[\x86`S\x81\x11\x15aS\xB0WaS\xAFaq\x13V[[\x03aS\xBFWa\x84\xD0\x90PaT_V[`\x06`S\x81\x11\x15aS\xD3WaS\xD2aq\x13V[[\x86`S\x81\x11\x15aS\xE6WaS\xE5aq\x13V[[\x03aS\xF5Wa\x90\x88\x90PaT^V[`\x08`S\x81\x11\x15aT\tWaT\x08aq\x13V[[\x86`S\x81\x11\x15aT\x1CWaT\x1Baq\x13V[[\x03aT+Wa\x94p\x90PaT]V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[[[aTo\x81\x85\x85\x85ab\x84V[[PPPPPPV[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14aT\xF1W`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\x01`\xF8\x1B\x85~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x14aUQW`@Q\x7Fj\xA9\xEB\x05\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x02`S\x81\x11\x15aUeWaUdaq\x13V[[\x86`S\x81\x11\x15aUxWaUwaq\x13V[[\x03aU\x88Wb\x06\xB6\xC0\x90PaV\x9AV[`\x03`S\x81\x11\x15aU\x9CWaU\x9Baq\x13V[[\x86`S\x81\x11\x15aU\xAFWaU\xAEaq\x13V[[\x03aU\xBFWb\x08\xD9\xA0\x90PaV\x99V[`\x04`S\x81\x11\x15aU\xD3WaU\xD2aq\x13V[[\x86`S\x81\x11\x15aU\xE6WaU\xE5aq\x13V[[\x03aU\xF6Wb\x0C\x15\xC0\x90PaV\x98V[`\x05`S\x81\x11\x15aV\nWaV\taq\x13V[[\x86`S\x81\x11\x15aV\x1DWaV\x1Caq\x13V[[\x03aV-Wb\x11\x97\xE8\x90PaV\x97V[`\x06`S\x81\x11\x15aVAWaV@aq\x13V[[\x86`S\x81\x11\x15aVTWaVSaq\x13V[[\x03aVdWb\x1D\xA5\xD8\x90PaV\x96V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[aV\xA5\x81\x85\x84a`\xE7V[PPPPPPV[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14aW&W`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\x01`\xF8\x1B\x85~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x03aYQW_`S\x81\x11\x15aWgWaWfaq\x13V[[\x86`S\x81\x11\x15aWzWaWyaq\x13V[[\x03aW\x89WaY\xD8\x90PaYAV[`\x02`S\x81\x11\x15aW\x9DWaW\x9Caq\x13V[[\x86`S\x81\x11\x15aW\xB0WaW\xAFaq\x13V[[\x03aW\xBFWa\xD6\xD8\x90PaY@V[`\x03`S\x81\x11\x15aW\xD3WaW\xD2aq\x13V[[\x86`S\x81\x11\x15aW\xE6WaW\xE5aq\x13V[[\x03aW\xF5Wa\xD6\xD8\x90PaY?V[`\x04`S\x81\x11\x15aX\tWaX\x08aq\x13V[[\x86`S\x81\x11\x15aX\x1CWaX\x1Baq\x13V[[\x03aX,Wb\x01D8\x90PaY>V[`\x05`S\x81\x11\x15aX@WaX?aq\x13V[[\x86`S\x81\x11\x15aXSWaXRaq\x13V[[\x03aXcWb\x01H \x90PaY=V[`\x06`S\x81\x11\x15aXwWaXvaq\x13V[[\x86`S\x81\x11\x15aX\x8AWaX\x89aq\x13V[[\x03aX\x9AWb\x01\xC9\x08\x90PaY<V[`\x07`S\x81\x11\x15aX\xAEWaX\xADaq\x13V[[\x86`S\x81\x11\x15aX\xC1WaX\xC0aq\x13V[[\x03aX\xD1Wb\x01\xC9\x08\x90PaY;V[`\x08`S\x81\x11\x15aX\xE5WaX\xE4aq\x13V[[\x86`S\x81\x11\x15aX\xF8WaX\xF7aq\x13V[[\x03aY\x08Wb\x01\xC9\x08\x90PaY:V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[[[[aYL\x81\x85\x84a`\xE7V[a[LV[_`S\x81\x11\x15aYdWaYcaq\x13V[[\x86`S\x81\x11\x15aYwWaYvaq\x13V[[\x03aY\x86WaY\xD8\x90Pa[?V[`\x02`S\x81\x11\x15aY\x9AWaY\x99aq\x13V[[\x86`S\x81\x11\x15aY\xADWaY\xACaq\x13V[[\x03aY\xBCWa\xD6\xD8\x90Pa[>V[`\x03`S\x81\x11\x15aY\xD0WaY\xCFaq\x13V[[\x86`S\x81\x11\x15aY\xE3WaY\xE2aq\x13V[[\x03aY\xF3Wb\x01D8\x90Pa[=V[`\x04`S\x81\x11\x15aZ\x07WaZ\x06aq\x13V[[\x86`S\x81\x11\x15aZ\x1AWaZ\x19aq\x13V[[\x03aZ*Wb\x01L\x08\x90Pa[<V[`\x05`S\x81\x11\x15aZ>WaZ=aq\x13V[[\x86`S\x81\x11\x15aZQWaZPaq\x13V[[\x03aZaWb\x01\xCC\xF0\x90Pa[;V[`\x06`S\x81\x11\x15aZuWaZtaq\x13V[[\x86`S\x81\x11\x15aZ\x88WaZ\x87aq\x13V[[\x03aZ\x98Wb\x01\xDC\x90\x90Pa[:V[`\x07`S\x81\x11\x15aZ\xACWaZ\xABaq\x13V[[\x86`S\x81\x11\x15aZ\xBFWaZ\xBEaq\x13V[[\x03aZ\xCFWb\x02\x13@\x90Pa[9V[`\x08`S\x81\x11\x15aZ\xE3WaZ\xE2aq\x13V[[\x86`S\x81\x11\x15aZ\xF6WaZ\xF5aq\x13V[[\x03a[\x06Wb\x02I\xF0\x90Pa[8V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[[[[a[K\x81\x85\x85\x85ab\x84V[[PPPPPPV[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a[\xCDW`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x80`S\x81\x11\x15a[\xE1Wa[\xE0aq\x13V[[\x84`S\x81\x11\x15a[\xF4Wa[\xF3aq\x13V[[\x03a\\\x02W`\x02\x90Pa]xV[`\x02`S\x81\x11\x15a\\\x16Wa\\\x15aq\x13V[[\x84`S\x81\x11\x15a\\)Wa\\(aq\x13V[[\x03a\\7W`\t\x90Pa]wV[`\x03`S\x81\x11\x15a\\KWa\\Jaq\x13V[[\x84`S\x81\x11\x15a\\^Wa\\]aq\x13V[[\x03a\\lW`\x10\x90Pa]vV[`\x04`S\x81\x11\x15a\\\x80Wa\\\x7Faq\x13V[[\x84`S\x81\x11\x15a\\\x93Wa\\\x92aq\x13V[[\x03a\\\xA1W` \x90Pa]uV[`\x05`S\x81\x11\x15a\\\xB5Wa\\\xB4aq\x13V[[\x84`S\x81\x11\x15a\\\xC8Wa\\\xC7aq\x13V[[\x03a\\\xD6W`?\x90Pa]tV[`\x06`S\x81\x11\x15a\\\xEAWa\\\xE9aq\x13V[[\x84`S\x81\x11\x15a\\\xFDWa\\\xFCaq\x13V[[\x03a]\x0BW`\x82\x90Pa]sV[`\x08`S\x81\x11\x15a]\x1FWa]\x1Eaq\x13V[[\x84`S\x81\x11\x15a]2Wa]1aq\x13V[[\x03a]@W`\x82\x90Pa]rV[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[[[a]\x83\x81\x84\x84a`\xE7V[PPPPV[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a^\x02W`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\x01`\xF8\x1B\x85~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x03a_\x89W`\x02`S\x81\x11\x15a^DWa^Caq\x13V[[\x86`S\x81\x11\x15a^WWa^Vaq\x13V[[\x03a^gWb\x01H \x90Pa_yV[`\x03`S\x81\x11\x15a^{Wa^zaq\x13V[[\x86`S\x81\x11\x15a^\x8EWa^\x8Daq\x13V[[\x03a^\x9EWb\x01kH\x90Pa_xV[`\x04`S\x81\x11\x15a^\xB2Wa^\xB1aq\x13V[[\x86`S\x81\x11\x15a^\xC5Wa^\xC4aq\x13V[[\x03a^\xD5Wb\x01s\x18\x90Pa_wV[`\x05`S\x81\x11\x15a^\xE9Wa^\xE8aq\x13V[[\x86`S\x81\x11\x15a^\xFCWa^\xFBaq\x13V[[\x03a_\x0CWb\x02\x07\x88\x90Pa_vV[`\x06`S\x81\x11\x15a_ Wa_\x1Faq\x13V[[\x86`S\x81\x11\x15a_3Wa_2aq\x13V[[\x03a_CWb\x02\x9F\xE0\x90Pa_uV[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[a_\x84\x81\x85\x84a`\xE7V[a`\xDFV[`\x02`S\x81\x11\x15a_\x9DWa_\x9Caq\x13V[[\x86`S\x81\x11\x15a_\xB0Wa_\xAFaq\x13V[[\x03a_\xC0Wb\x01W\xC0\x90Pa`\xD2V[`\x03`S\x81\x11\x15a_\xD4Wa_\xD3aq\x13V[[\x86`S\x81\x11\x15a_\xE7Wa_\xE6aq\x13V[[\x03a_\xF7Wb\x01kH\x90Pa`\xD1V[`\x04`S\x81\x11\x15a`\x0BWa`\naq\x13V[[\x86`S\x81\x11\x15a`\x1EWa`\x1Daq\x13V[[\x03a`.Wb\x01\xE8H\x90Pa`\xD0V[`\x05`S\x81\x11\x15a`BWa`Aaq\x13V[[\x86`S\x81\x11\x15a`UWa`Taq\x13V[[\x03a`eWb\x02x\xD0\x90Pa`\xCFV[`\x06`S\x81\x11\x15a`yWa`xaq\x13V[[\x86`S\x81\x11\x15a`\x8CWa`\x8Baq\x13V[[\x03a`\x9CWb\x03\xF3\xB8\x90Pa`\xCEV[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[a`\xDE\x81\x85\x85\x85ab\x84V[[PPPPPPV[a`\xF0\x83aaSV[_a`\xFA\x83ag[V[\x84aa\x05\x91\x90ar\xDDV[\x90PbLK@\x81\x10aaCW`@Q\x7F\xFC4Hp\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[aaM\x82\x82aa\xB3V[PPPPV[_aa\\ageV[\x82aag\x91\x90ar\xDDV[\x90Pc\x011-\0\x81\x10aa\xA6W`@Q\x7Fw\xE3\xC2\x93\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[aa\xAF\x81agmV[PPV[\x80\x82]PPV[``_`\x01aa\xC8\x84agsV[\x01\x90P_\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15aa\xE6Waa\xE5aomV[[`@Q\x90\x80\x82R\x80`\x1F\x01`\x1F\x19\x16` \x01\x82\x01`@R\x80\x15ab\x18W\x81` \x01`\x01\x82\x02\x806\x837\x80\x82\x01\x91PP\x90P[P\x90P_\x82` \x01\x82\x01\x90P[`\x01\x15abyW\x80\x80`\x01\x90\x03\x91PP\x7F0123456789abcdef\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\n\x86\x06\x1A\x81S`\n\x85\x81abnWabmas\x10V[[\x04\x94P_\x85\x03ab%W[\x81\x93PPPP\x91\x90PV[ab\x8D\x84aaSV[_ab\xA8ab\x9A\x85ag[V[ab\xA3\x85ag[V[ah\xC4V[\x85ab\xB3\x91\x90ar\xDDV[\x90PbLK@\x81\x10ab\xF1W`@Q\x7F\xFC4Hp\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[ab\xFB\x82\x82aa\xB3V[PPPPPV[_ac\x0Bac&V[_\x01_\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P\x90V[_\x7F\xF0\xC5~\x16\x84\r\xF0@\xF1P\x88\xDC/\x81\xFE9\x1C9#\xBE\xC7>#\xA9f.\xFC\x9C\"\x9Cj\0\x90P\x90V[acV\x85aaSV[_ac\x82acc\x86ag[V[ac}aco\x87ag[V[acx\x87ag[V[ah\xC4V[ah\xC4V[\x86ac\x8D\x91\x90ar\xDDV[\x90PbLK@\x81\x10ac\xCBW`@Q\x7F\xFC4Hp\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[ac\xD5\x82\x82aa\xB3V[PPPPPPV[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x160s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14\x80ad\x8AWP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16adqah\xDDV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14\x15[\x15ad\xC1W`@Q\x7F\xE0|\x8D\xBA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[V[sP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x8D\xA5\xCB[`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15ae W=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90aeD\x91\x90asQV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14ae\xB3W3`@Q\x7F!\xBF\xDA\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01ae\xAA\x91\x90an\xABV[`@Q\x80\x91\x03\x90\xFD[PV[\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16cR\xD1\x90-`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x92PPP\x80\x15af\x1EWP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90af\x1B\x91\x90as\x90V[`\x01[af_W\x81`@Q\x7FL\x9C\x8C\xE3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01afV\x91\x90an\xABV[`@Q\x80\x91\x03\x90\xFD[\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC_\x1B\x81\x14af\xC5W\x80`@Q\x7F\xAA\x1DI\xA4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01af\xBC\x91\x90ap\xFAV[`@Q\x80\x91\x03\x90\xFD[af\xCF\x83\x83ai0V[PPPV[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x160s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14agYW`@Q\x7F\xE0|\x8D\xBA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[V[_\x81\\\x90P\x91\x90PV[_\x80\\\x90P\x90V[\x80_]PV[_\x80_\x90Pz\x18O\x03\xE9?\xF9\xF4\xDA\xA7\x97\xEDn8\xEDd\xBFj\x1F\x01\0\0\0\0\0\0\0\0\x83\x10ag\xCFWz\x18O\x03\xE9?\xF9\xF4\xDA\xA7\x97\xEDn8\xEDd\xBFj\x1F\x01\0\0\0\0\0\0\0\0\x83\x81ag\xC5Wag\xC4as\x10V[[\x04\x92P`@\x81\x01\x90P[m\x04\xEE-mA[\x85\xAC\xEF\x81\0\0\0\0\x83\x10ah\x0CWm\x04\xEE-mA[\x85\xAC\xEF\x81\0\0\0\0\x83\x81ah\x02Wah\x01as\x10V[[\x04\x92P` \x81\x01\x90P[f#\x86\xF2o\xC1\0\0\x83\x10ah;Wf#\x86\xF2o\xC1\0\0\x83\x81ah1Wah0as\x10V[[\x04\x92P`\x10\x81\x01\x90P[c\x05\xF5\xE1\0\x83\x10ahdWc\x05\xF5\xE1\0\x83\x81ahZWahYas\x10V[[\x04\x92P`\x08\x81\x01\x90P[a'\x10\x83\x10ah\x89Wa'\x10\x83\x81ah\x7FWah~as\x10V[[\x04\x92P`\x04\x81\x01\x90P[`d\x83\x10ah\xACW`d\x83\x81ah\xA2Wah\xA1as\x10V[[\x04\x92P`\x02\x81\x01\x90P[`\n\x83\x10ah\xBBW`\x01\x81\x01\x90P[\x80\x91PP\x91\x90PV[_\x81\x83\x10\x15ah\xD3W\x81ah\xD5V[\x82[\x90P\x92\x91PPV[_ai\t\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC_\x1Bai\xA2V[_\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P\x90V[ai9\x82ai\xABV[\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xBC|\xD7Z \xEE'\xFD\x9A\xDE\xBA\xB3 A\xF7U!M\xBCk\xFF\xA9\x0C\xC0\"[9\xDA.\\-;`@Q`@Q\x80\x91\x03\x90\xA2_\x81Q\x11\x15ai\x95Wai\x8F\x82\x82ajtV[Pai\x9EV[ai\x9Daj\xF4V[[PPV[_\x81\x90P\x91\x90PV[_\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16;\x03aj\x06W\x80`@Q\x7FL\x9C\x8C\xE3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01ai\xFD\x91\x90an\xABV[`@Q\x80\x91\x03\x90\xFD[\x80aj2\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC_\x1Bai\xA2V[_\x01_a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UPPV[``_\x80\x84s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x84`@Qaj\x9D\x91\x90as\xFFV[_`@Q\x80\x83\x03\x81\x85Z\xF4\x91PP=\x80_\x81\x14aj\xD5W`@Q\x91P`\x1F\x19`?=\x01\x16\x82\x01`@R=\x82R=_` \x84\x01>aj\xDAV[``\x91P[P\x91P\x91Paj\xEA\x85\x83\x83ak0V[\x92PPP\x92\x91PPV[_4\x11\x15ak.W`@Q\x7F\xB3\x98\x97\x9F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[V[``\x82akEWak@\x82ak\xBDV[ak\xB5V[_\x82Q\x14\x80\x15akkWP_\x84s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16;\x14[\x15ak\xADW\x83`@Q\x7F\x99\x96\xB3\x15\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01ak\xA4\x91\x90an\xABV[`@Q\x80\x91\x03\x90\xFD[\x81\x90Pak\xB6V[[\x93\x92PPPV[_\x81Q\x11\x15ak\xCFW\x80Q\x80\x82` \x01\xFD[`@Q\x7F\xD6\xBD\xA2u\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`@Q\x90P\x90V[_\x80\xFD[_\x80\xFD[`T\x81\x10al\x1EW_\x80\xFD[PV[_\x815\x90Pal/\x81al\x12V[\x92\x91PPV[_\x81\x90P\x91\x90PV[alG\x81al5V[\x81\x14alQW_\x80\xFD[PV[_\x815\x90Palb\x81al>V[\x92\x91PPV[_\x80_``\x84\x86\x03\x12\x15al\x7FWal~al\nV[[_al\x8C\x86\x82\x87\x01al!V[\x93PP` al\x9D\x86\x82\x87\x01alTV[\x92PP`@al\xAE\x86\x82\x87\x01alTV[\x91PP\x92P\x92P\x92V[_\x80`@\x83\x85\x03\x12\x15al\xCEWal\xCDal\nV[[_al\xDB\x85\x82\x86\x01al!V[\x92PP` al\xEC\x85\x82\x86\x01alTV[\x91PP\x92P\x92\x90PV[_\x81Q\x90P\x91\x90PV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[_[\x83\x81\x10\x15am-W\x80\x82\x01Q\x81\x84\x01R` \x81\x01\x90Pam\x12V[_\x84\x84\x01RPPPPV[_`\x1F\x19`\x1F\x83\x01\x16\x90P\x91\x90PV[_amR\x82al\xF6V[am\\\x81\x85am\0V[\x93Paml\x81\x85` \x86\x01am\x10V[amu\x81am8V[\x84\x01\x91PP\x92\x91PPV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ram\x98\x81\x84amHV[\x90P\x92\x91PPV[_\x7F\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\x16\x90P\x91\x90PV[am\xD4\x81am\xA0V[\x81\x14am\xDEW_\x80\xFD[PV[_\x815\x90Pam\xEF\x81am\xCBV[\x92\x91PPV[_\x80_\x80_`\xA0\x86\x88\x03\x12\x15an\x0EWan\ral\nV[[_an\x1B\x88\x82\x89\x01al!V[\x95PP` an,\x88\x82\x89\x01am\xE1V[\x94PP`@an=\x88\x82\x89\x01alTV[\x93PP``anN\x88\x82\x89\x01alTV[\x92PP`\x80an_\x88\x82\x89\x01alTV[\x91PP\x92\x95P\x92\x95\x90\x93PV[_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[_an\x95\x82anlV[\x90P\x91\x90PV[an\xA5\x81an\x8BV[\x82RPPV[_` \x82\x01\x90Pan\xBE_\x83\x01\x84an\x9CV[\x92\x91PPV[_\x80_\x80_`\xA0\x86\x88\x03\x12\x15an\xDDWan\xDCal\nV[[_an\xEA\x88\x82\x89\x01al!V[\x95PP` an\xFB\x88\x82\x89\x01alTV[\x94PP`@ao\x0C\x88\x82\x89\x01alTV[\x93PP``ao\x1D\x88\x82\x89\x01alTV[\x92PP`\x80ao.\x88\x82\x89\x01alTV[\x91PP\x92\x95P\x92\x95\x90\x93PV[aoD\x81an\x8BV[\x81\x14aoNW_\x80\xFD[PV[_\x815\x90Pao_\x81ao;V[\x92\x91PPV[_\x80\xFD[_\x80\xFD[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`A`\x04R`$_\xFD[ao\xA3\x82am8V[\x81\x01\x81\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17\x15ao\xC2Wao\xC1aomV[[\x80`@RPPPV[_ao\xD4al\x01V[\x90Pao\xE0\x82\x82ao\x9AV[\x91\x90PV[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15ao\xFFWao\xFEaomV[[ap\x08\x82am8V[\x90P` \x81\x01\x90P\x91\x90PV[\x82\x81\x837_\x83\x83\x01RPPPV[_ap5ap0\x84ao\xE5V[ao\xCBV[\x90P\x82\x81R` \x81\x01\x84\x84\x84\x01\x11\x15apQWapPaoiV[[ap\\\x84\x82\x85ap\x15V[P\x93\x92PPPV[_\x82`\x1F\x83\x01\x12apxWapwaoeV[[\x815ap\x88\x84\x82` \x86\x01ap#V[\x91PP\x92\x91PPV[_\x80`@\x83\x85\x03\x12\x15ap\xA7Wap\xA6al\nV[[_ap\xB4\x85\x82\x86\x01aoQV[\x92PP` \x83\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15ap\xD5Wap\xD4al\x0EV[[ap\xE1\x85\x82\x86\x01apdV[\x91PP\x92P\x92\x90PV[ap\xF4\x81al5V[\x82RPPV[_` \x82\x01\x90Paq\r_\x83\x01\x84ap\xEBV[\x92\x91PPV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`!`\x04R`$_\xFD[_\x81\x90P\x92\x91PPV[_aqT\x82al\xF6V[aq^\x81\x85aq@V[\x93Paqn\x81\x85` \x86\x01am\x10V[\x80\x84\x01\x91PP\x92\x91PPV[\x7F v\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_aq\xAE`\x02\x83aq@V[\x91Paq\xB9\x82aqzV[`\x02\x82\x01\x90P\x91\x90PV[\x7F.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_aq\xF8`\x01\x83aq@V[\x91Par\x03\x82aq\xC4V[`\x01\x82\x01\x90P\x91\x90PV[_ar\x19\x82\x87aqJV[\x91Par$\x82aq\xA2V[\x91Par0\x82\x86aqJV[\x91Par;\x82aq\xECV[\x91ParG\x82\x85aqJV[\x91ParR\x82aq\xECV[\x91Par^\x82\x84aqJV[\x91P\x81\x90P\x95\x94PPPPPV[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[ar\x88\x81arlV[\x82RPPV[_` \x82\x01\x90Par\xA1_\x83\x01\x84ar\x7FV[\x92\x91PPV[_\x81\x90P\x91\x90PV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x11`\x04R`$_\xFD[_ar\xE7\x82ar\xA7V[\x91Par\xF2\x83ar\xA7V[\x92P\x82\x82\x01\x90P\x80\x82\x11\x15as\nWas\tar\xB0V[[\x92\x91PPV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x12`\x04R`$_\xFD[_\x81Q\x90PasK\x81ao;V[\x92\x91PPV[_` \x82\x84\x03\x12\x15asfWaseal\nV[[_ass\x84\x82\x85\x01as=V[\x91PP\x92\x91PPV[_\x81Q\x90Pas\x8A\x81al>V[\x92\x91PPV[_` \x82\x84\x03\x12\x15as\xA5Was\xA4al\nV[[_as\xB2\x84\x82\x85\x01as|V[\x91PP\x92\x91PPV[_\x81Q\x90P\x91\x90PV[_\x81\x90P\x92\x91PPV[_as\xD9\x82as\xBBV[as\xE3\x81\x85as\xC5V[\x93Pas\xF3\x81\x85` \x86\x01am\x10V[\x80\x84\x01\x91PP\x92\x91PPV[_at\n\x82\x84as\xCFV[\x91P\x81\x90P\x92\x91PPV",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x6080604052600436106101ed575f3560e01c8063642b14901161010c578063acb5f3881161009f578063e8e399ad1161006e578063e8e399ad1461063b578063fa08e38d14610663578063fa5defdb1461068b578063fc063c62146106b3578063fdad4c96146106db576101ed565b8063acb5f38814610599578063ad3cb1cc146105c1578063cc866782146105eb578063d47f3d5914610613576101ed565b8063859a1b70116100db578063859a1b70146104f9578063907531081461052157806394e70e4f14610549578063a4c98f3e14610571576101ed565b8063642b149014610459578063669181c0146104815780636bb3c611146104a957806383e6a720146104d1576101ed565b8063268d6d3111610184578063406b451311610153578063406b4513146103c35780634e726769146103eb5780634f1ef2861461041357806352d1902d1461042f576101ed565b8063268d6d3114610333578063348c31851461035d57806339f73810146103855780633c16ff0d1461039b576101ed565b80631434ba4d116101c05780631434ba4d1461029357806314526e87146102bb5780631856d91d146102e35780631ed91ff61461030b576101ed565b806302dd6276146101f157806309b04e8f146102195780630d8e6e2c146102415780631339c5ee1461026b575b5f80fd5b3480156101fc575f80fd5b5061021760048036038101906102129190616c68565b610703565b005b348015610224575f80fd5b5061023f600480360381019061023a9190616cb8565b610938565b005b34801561024c575f80fd5b50610255610b7b565b6040516102629190616d80565b60405180910390f35b348015610276575f80fd5b50610291600480360381019061028c9190616df5565b610bf6565b005b34801561029e575f80fd5b506102b960048036038101906102b49190616df5565b610f51565b005b3480156102c6575f80fd5b506102e160048036038101906102dc9190616df5565b61137f565b005b3480156102ee575f80fd5b5061030960048036038101906103049190616df5565b611747565b005b348015610316575f80fd5b50610331600480360381019061032c9190616df5565b611b75565b005b34801561033e575f80fd5b50610347611f3d565b6040516103549190616eab565b60405180910390f35b348015610368575f80fd5b50610383600480360381019061037e9190616cb8565b611f58565b005b348015610390575f80fd5b506103996121ca565b005b3480156103a6575f80fd5b506103c160048036038101906103bc9190616df5565b61233a565b005b3480156103ce575f80fd5b506103e960048036038101906103e49190616df5565b612698565b005b3480156103f6575f80fd5b50610411600480360381019061040c9190616ec4565b6128cd565b005b61042d60048036038101906104289190617091565b612b46565b005b34801561043a575f80fd5b50610443612b65565b60405161045091906170fa565b60405180910390f35b348015610464575f80fd5b5061047f600480360381019061047a9190616df5565b612b96565b005b34801561048c575f80fd5b506104a760048036038101906104a29190616df5565b612ef4565b005b3480156104b4575f80fd5b506104cf60048036038101906104ca9190616df5565b6132bc565b005b3480156104dc575f80fd5b506104f760048036038101906104f29190616df5565b613617565b005b348015610504575f80fd5b5061051f600480360381019061051a9190616df5565b6139df565b005b34801561052c575f80fd5b5061054760048036038101906105429190616df5565b613d3a565b005b348015610554575f80fd5b5061056f600480360381019061056a9190616df5565b614098565b005b34801561057c575f80fd5b5061059760048036038101906105929190616c68565b61453f565b005b3480156105a4575f80fd5b506105bf60048036038101906105ba9190616df5565b61474b565b005b3480156105cc575f80fd5b506105d5614aa9565b6040516105e29190616d80565b60405180910390f35b3480156105f6575f80fd5b50610611600480360381019061060c9190616cb8565b614ae2565b005b34801561061e575f80fd5b5061063960048036038101906106349190616df5565b614cef565b005b348015610646575f80fd5b50610661600480360381019061065c9190616df5565b61504a565b005b34801561066e575f80fd5b5061068960048036038101906106849190616df5565b615478565b005b348015610696575f80fd5b506106b160048036038101906106ac9190616df5565b6156ad565b005b3480156106be575f80fd5b506106d960048036038101906106d49190616c68565b615b54565b005b3480156106e6575f80fd5b5061070160048036038101906106fc9190616df5565b615d89565b005b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161461077c576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f8060538111156107905761078f617113565b5b8460538111156107a3576107a2617113565b5b036107b15760209050610927565b600260538111156107c5576107c4617113565b5b8460538111156107d8576107d7617113565b5b036107e65760209050610926565b600360538111156107fa576107f9617113565b5b84605381111561080d5761080c617113565b5b0361081b5760209050610925565b6004605381111561082f5761082e617113565b5b84605381111561084257610841617113565b5b036108505760209050610924565b6005605381111561086457610863617113565b5b84605381111561087757610876617113565b5b036108855760209050610923565b6006605381111561089957610898617113565b5b8460538111156108ac576108ab617113565b5b036108ba5760209050610922565b600860538111156108ce576108cd617113565b5b8460538111156108e1576108e0617113565b5b036108ef5760209050610921565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b5b5b6109328184846160e7565b50505050565b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16146109b1576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f8060538111156109c5576109c4617113565b5b8360538111156109d8576109d7617113565b5b036109e757614a389050610b63565b600260538111156109fb576109fa617113565b5b836053811115610a0e57610a0d617113565b5b03610a1d576159d89050610b62565b60036053811115610a3157610a30617113565b5b836053811115610a4457610a43617113565b5b03610a53576159d89050610b61565b60046053811115610a6757610a66617113565b5b836053811115610a7a57610a79617113565b5b03610a8957615dc09050610b60565b60056053811115610a9d57610a9c617113565b5b836053811115610ab057610aaf617113565b5b03610abf57615dc09050610b5f565b60066053811115610ad357610ad2617113565b5b836053811115610ae657610ae5617113565b5b03610af5576161a89050610b5e565b60086053811115610b0957610b08617113565b5b836053811115610b1c57610b1b617113565b5b03610b2b576175309050610b5d565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b5b5b610b6c81616153565b610b7682826161b3565b505050565b60606040518060400160405280600881526020017f4843554c696d6974000000000000000000000000000000000000000000000000815250610bbc5f6161ba565b610bc660016161ba565b610bcf5f6161ba565b604051602001610be2949392919061720e565b604051602081830303815290604052905090565b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614610c6f576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f600160f81b857effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191603610df45760026053811115610cb157610cb0617113565b5b866053811115610cc457610cc3617113565b5b03610cd35761cb209050610de4565b60036053811115610ce757610ce6617113565b5b866053811115610cfa57610cf9617113565b5b03610d095761e2909050610de3565b60046053811115610d1d57610d1c617113565b5b866053811115610d3057610d2f617113565b5b03610d4057620144389050610de2565b60056053811115610d5457610d53617113565b5b866053811115610d6757610d66617113565b5b03610d77576201ccf09050610de1565b60066053811115610d8b57610d8a617113565b5b866053811115610d9e57610d9d617113565b5b03610dae57620246089050610de0565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b610def8185846160e7565b610f49565b60026053811115610e0857610e07617113565b5b866053811115610e1b57610e1a617113565b5b03610e2a5761e6789050610f3c565b60036053811115610e3e57610e3d617113565b5b866053811115610e5157610e50617113565b5b03610e6157620148209050610f3b565b60046053811115610e7557610e74617113565b5b866053811115610e8857610e87617113565b5b03610e98576201c9089050610f3a565b60056053811115610eac57610eab617113565b5b866053811115610ebf57610ebe617113565b5b03610ecf5762023a509050610f39565b60066053811115610ee357610ee2617113565b5b866053811115610ef657610ef5617113565b5b03610f0657620347d89050610f38565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b610f4881858585616284565b5b505050505050565b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614610fca576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f600160f81b857effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916036111b9575f605381111561100b5761100a617113565b5b86605381111561101e5761101d617113565b5b0361102d576155f090506111a9565b6002605381111561104157611040617113565b5b86605381111561105457611053617113565b5b036110635761791890506111a8565b6003605381111561107757611076617113565b5b86605381111561108a57611089617113565b5b036110995761791890506111a7565b600460538111156110ad576110ac617113565b5b8660538111156110c0576110bf617113565b5b036110cf57617d0090506111a6565b600560538111156110e3576110e2617113565b5b8660538111156110f6576110f5617113565b5b03611105576184d090506111a5565b6006605381111561111957611118617113565b5b86605381111561112c5761112b617113565b5b0361113b5761908890506111a4565b6008605381111561114f5761114e617113565b5b86605381111561116257611161617113565b5b036111715761985890506111a3565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b5b5b6111b48185846160e7565b611377565b5f60538111156111cc576111cb617113565b5b8660538111156111df576111de617113565b5b036111ee576155f0905061136a565b6002605381111561120257611201617113565b5b86605381111561121557611214617113565b5b03611224576179189050611369565b6003605381111561123857611237617113565b5b86605381111561124b5761124a617113565b5b0361125a576179189050611368565b6004605381111561126e5761126d617113565b5b86605381111561128157611280617113565b5b0361129057617d009050611367565b600560538111156112a4576112a3617113565b5b8660538111156112b7576112b6617113565b5b036112c6576184d09050611366565b600660538111156112da576112d9617113565b5b8660538111156112ed576112ec617113565b5b036112fc576190889050611365565b600860538111156113105761130f617113565b5b86605381111561132357611322617113565b5b03611332576198589050611364565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b5b5b61137681858585616284565b5b505050505050565b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16146113f8576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f600160f81b857effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916036115b1576002605381111561143a57611439617113565b5b86605381111561144d5761144c617113565b5b0361145c5761791890506115a1565b600360538111156114705761146f617113565b5b86605381111561148357611482617113565b5b036114925761791890506115a0565b600460538111156114a6576114a5617113565b5b8660538111156114b9576114b8617113565b5b036114c857617d00905061159f565b600560538111156114dc576114db617113565b5b8660538111156114ef576114ee617113565b5b036114fe576184d0905061159e565b6006605381111561151257611511617113565b5b86605381111561152557611524617113565b5b0361153457619088905061159d565b6008605381111561154857611547617113565b5b86605381111561155b5761155a617113565b5b0361156a57619470905061159c565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b5b6115ac8185846160e7565b61173f565b600260538111156115c5576115c4617113565b5b8660538111156115d8576115d7617113565b5b036115e857620163789050611732565b600360538111156115fc576115fb617113565b5b86605381111561160f5761160e617113565b5b0361161f576201e8489050611731565b6004605381111561163357611632617113565b5b86605381111561164657611645617113565b5b036116565762027cb89050611730565b6005605381111561166a57611669617113565b5b86605381111561167d5761167c617113565b5b0361168d5762033068905061172f565b600660538111156116a1576116a0617113565b5b8660538111156116b4576116b3617113565b5b036116c45762043df0905061172e565b600860538111156116d8576116d7617113565b5b8660538111156116eb576116ea617113565b5b036116fb576205c490905061172d565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b5b61173e81858585616284565b5b505050505050565b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16146117c0576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f600160f81b857effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916036119af575f605381111561180157611800617113565b5b86605381111561181457611813617113565b5b03611823576155f0905061199f565b6002605381111561183757611836617113565b5b86605381111561184a57611849617113565b5b0361185957617918905061199e565b6003605381111561186d5761186c617113565b5b8660538111156118805761187f617113565b5b0361188f57617918905061199d565b600460538111156118a3576118a2617113565b5b8660538111156118b6576118b5617113565b5b036118c557617d00905061199c565b600560538111156118d9576118d8617113565b5b8660538111156118ec576118eb617113565b5b036118fb576184d0905061199b565b6006605381111561190f5761190e617113565b5b86605381111561192257611921617113565b5b0361193157619088905061199a565b6008605381111561194557611944617113565b5b86605381111561195857611957617113565b5b03611967576194709050611999565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b5b5b6119aa8185846160e7565b611b6d565b5f60538111156119c2576119c1617113565b5b8660538111156119d5576119d4617113565b5b036119e4576161a89050611b60565b600260538111156119f8576119f7617113565b5b866053811115611a0b57611a0a617113565b5b03611a1a576179189050611b5f565b60036053811115611a2e57611a2d617113565b5b866053811115611a4157611a40617113565b5b03611a50576179189050611b5e565b60046053811115611a6457611a63617113565b5b866053811115611a7757611a76617113565b5b03611a8657617d009050611b5d565b60056053811115611a9a57611a99617113565b5b866053811115611aad57611aac617113565b5b03611abc576184d09050611b5c565b60066053811115611ad057611acf617113565b5b866053811115611ae357611ae2617113565b5b03611af2576190889050611b5b565b60086053811115611b0657611b05617113565b5b866053811115611b1957611b18617113565b5b03611b28576194709050611b5a565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b5b5b611b6c81858585616284565b5b505050505050565b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614611bee576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f600160f81b857effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191603611da75760026053811115611c3057611c2f617113565b5b866053811115611c4357611c42617113565b5b03611c5257617d009050611d97565b60036053811115611c6657611c65617113565b5b866053811115611c7957611c78617113565b5b03611c8857617d009050611d96565b60046053811115611c9c57611c9b617113565b5b866053811115611caf57611cae617113565b5b03611cbe57617d009050611d95565b60056053811115611cd257611cd1617113565b5b866053811115611ce557611ce4617113565b5b03611cf4576184d09050611d94565b60066053811115611d0857611d07617113565b5b866053811115611d1b57611d1a617113565b5b03611d2a576190889050611d93565b60086053811115611d3e57611d3d617113565b5b866053811115611d5157611d50617113565b5b03611d60576194709050611d92565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b5b611da28185846160e7565b611f35565b60026053811115611dbb57611dba617113565b5b866053811115611dce57611dcd617113565b5b03611dde57620163789050611f28565b60036053811115611df257611df1617113565b5b866053811115611e0557611e04617113565b5b03611e15576201e0789050611f27565b60046053811115611e2957611e28617113565b5b866053811115611e3c57611e3b617113565b5b03611e4c5762027cb89050611f26565b60056053811115611e6057611e5f617113565b5b866053811115611e7357611e72617113565b5b03611e8357620330689050611f25565b60066053811115611e9757611e96617113565b5b866053811115611eaa57611ea9617113565b5b03611eba57620426809050611f24565b60086053811115611ece57611ecd617113565b5b866053811115611ee157611ee0617113565b5b03611ef1576205a1689050611f23565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b5b611f3481858585616284565b5b505050505050565b5f73e3a9105a3a932253a70f126eb1e3b589c643dd24905090565b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614611fd1576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f806053811115611fe557611fe4617113565b5b836053811115611ff857611ff7617113565b5b0361200657602090506121b2565b6002605381111561201a57612019617113565b5b83605381111561202d5761202c617113565b5b0361203b57602090506121b1565b6003605381111561204f5761204e617113565b5b83605381111561206257612061617113565b5b0361207057602090506121b0565b6004605381111561208457612083617113565b5b83605381111561209757612096617113565b5b036120a557602090506121af565b600560538111156120b9576120b8617113565b5b8360538111156120cc576120cb617113565b5b036120da57602090506121ae565b600660538111156120ee576120ed617113565b5b83605381111561210157612100617113565b5b0361210f57602090506121ad565b6007605381111561212357612122617113565b5b83605381111561213657612135617113565b5b0361214457602090506121ac565b6008605381111561215857612157617113565b5b83605381111561216b5761216a617113565b5b0361217957602090506121ab565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b5b5b5b6121bb81616153565b6121c582826161b3565b505050565b60016121d4616302565b67ffffffffffffffff1614612215576040517f6f4f731f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60025f612220616326565b9050805f0160089054906101000a900460ff168061226857508167ffffffffffffffff16815f015f9054906101000a900467ffffffffffffffff1667ffffffffffffffff1610155b1561229f576040517ff92ee8a900000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b81815f015f6101000a81548167ffffffffffffffff021916908367ffffffffffffffff1602179055506001815f0160086101000a81548160ff0219169083151502179055505f815f0160086101000a81548160ff0219169083151502179055507fc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d28260405161232e919061728e565b60405180910390a15050565b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16146123b3576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f600160f81b857effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff19160361253a57600260538111156123f5576123f4617113565b5b86605381111561240857612407617113565b5b03612418576201dc90905061252a565b6003605381111561242c5761242b617113565b5b86605381111561243f5761243e617113565b5b0361244f576202f1e89050612529565b6004605381111561246357612462617113565b5b86605381111561247657612475617113565b5b036124865762040b289050612528565b6005605381111561249a57612499617113565b5b8660538111156124ad576124ac617113565b5b036124bd57620591c89050612527565b600660538111156124d1576124d0617113565b5b8660538111156124e4576124e3617113565b5b036124f457620a9ec09050612526565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b6125358185846160e7565b612690565b6002605381111561254e5761254d617113565b5b86605381111561256157612560617113565b5b0361257157620249f09050612683565b6003605381111561258557612584617113565b5b86605381111561259857612597617113565b5b036125a857620363309050612682565b600460538111156125bc576125bb617113565b5b8660538111156125cf576125ce617113565b5b036125df57620501409050612681565b600560538111156125f3576125f2617113565b5b86605381111561260657612605617113565b5b0361261657620918209050612680565b6006605381111561262a57612629617113565b5b86605381111561263d5761263c617113565b5b0361264d576219b9f0905061267f565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b61268f81858585616284565b5b505050505050565b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614612711576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f600160f81b857effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191614612771576040517f6aa9eb0500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6002605381111561278557612784617113565b5b86605381111561279857612797617113565b5b036127a8576203345090506128ba565b600360538111156127bc576127bb617113565b5b8660538111156127cf576127ce617113565b5b036127df5762049bb090506128b9565b600460538111156127f3576127f2617113565b5b86605381111561280657612805617113565b5b03612816576206aef090506128b8565b6005605381111561282a57612829617113565b5b86605381111561283d5761283c617113565b5b0361284d57620ae8f890506128b7565b6006605381111561286157612860617113565b5b86605381111561287457612873617113565b5b03612884576212b12890506128b6565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b6128c58185846160e7565b505050505050565b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614612946576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f80605381111561295a57612959617113565b5b86605381111561296d5761296c617113565b5b0361297c5761d6d89050612b31565b600260538111156129905761298f617113565b5b8660538111156129a3576129a2617113565b5b036129b25761d6d89050612b30565b600360538111156129c6576129c5617113565b5b8660538111156129d9576129d8617113565b5b036129e85761d6d89050612b2f565b600460538111156129fc576129fb617113565b5b866053811115612a0f57612a0e617113565b5b03612a1e5761d6d89050612b2e565b60056053811115612a3257612a31617113565b5b866053811115612a4557612a44617113565b5b03612a545761d6d89050612b2d565b60066053811115612a6857612a67617113565b5b866053811115612a7b57612a7a617113565b5b03612a8a5761dea89050612b2c565b60076053811115612a9e57612a9d617113565b5b866053811115612ab157612ab0617113565b5b03612ac157620144389050612b2b565b60086053811115612ad557612ad4617113565b5b866053811115612ae857612ae7617113565b5b03612af8576201a5e09050612b2a565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b5b5b5b612b3e818686868661634d565b505050505050565b612b4e6163dd565b612b57826164c3565b612b6182826165b6565b5050565b5f612b6e6166d4565b7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5f1b905090565b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614612c0f576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f600160f81b857effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191603612d965760026053811115612c5157612c50617113565b5b866053811115612c6457612c63617113565b5b03612c7457620148209050612d86565b60036053811115612c8857612c87617113565b5b866053811115612c9b57612c9a617113565b5b03612cab57620157c09050612d85565b60046053811115612cbf57612cbe617113565b5b866053811115612cd257612cd1617113565b5b03612ce2576201c9089050612d84565b60056053811115612cf657612cf5617113565b5b866053811115612d0957612d08617113565b5b03612d1957620249f09050612d83565b60066053811115612d2d57612d2c617113565b5b866053811115612d4057612d3f617113565b5b03612d50576202d6909050612d82565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b612d918185846160e7565b612eec565b60026053811115612daa57612da9617113565b5b866053811115612dbd57612dbc617113565b5b03612dcd576201d0d89050612edf565b60036053811115612de157612de0617113565b5b866053811115612df457612df3617113565b5b03612e045762023a509050612ede565b60046053811115612e1857612e17617113565b5b866053811115612e2b57612e2a617113565b5b03612e3b576202c6f09050612edd565b60056053811115612e4f57612e4e617113565b5b866053811115612e6257612e61617113565b5b03612e7257620357789050612edc565b60066053811115612e8657612e85617113565b5b866053811115612e9957612e98617113565b5b03612ea957620468e89050612edb565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b612eeb81858585616284565b5b505050505050565b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614612f6d576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f600160f81b857effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916036131265760026053811115612faf57612fae617113565b5b866053811115612fc257612fc1617113565b5b03612fd1576179189050613116565b60036053811115612fe557612fe4617113565b5b866053811115612ff857612ff7617113565b5b03613007576179189050613115565b6004605381111561301b5761301a617113565b5b86605381111561302e5761302d617113565b5b0361303d57617d009050613114565b6005605381111561305157613050617113565b5b86605381111561306457613063617113565b5b03613073576184d09050613113565b6006605381111561308757613086617113565b5b86605381111561309a57613099617113565b5b036130a9576190889050613112565b600860538111156130bd576130bc617113565b5b8660538111156130d0576130cf617113565b5b036130df57619c409050613111565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b5b6131218185846160e7565b6132b4565b6002605381111561313a57613139617113565b5b86605381111561314d5761314c617113565b5b0361315d5762016b4890506132a7565b6003605381111561317157613170617113565b5b86605381111561318457613183617113565b5b03613194576201e84890506132a6565b600460538111156131a8576131a7617113565b5b8660538111156131bb576131ba617113565b5b036131cb576202710090506132a5565b600560538111156131df576131de617113565b5b8660538111156131f2576131f1617113565b5b03613202576203306890506132a4565b6006605381111561321657613215617113565b5b86605381111561322957613228617113565b5b03613239576204517890506132a3565b6008605381111561324d5761324c617113565b5b8660538111156132605761325f617113565b5b03613270576205b8d890506132a2565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b5b6132b381858585616284565b5b505050505050565b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614613335576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f600160f81b857effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916036134ba576002605381111561337757613376617113565b5b86605381111561338a57613389617113565b5b036133995761cb2090506134aa565b600360538111156133ad576133ac617113565b5b8660538111156133c0576133bf617113565b5b036133cf5761d6d890506134a9565b600460538111156133e3576133e2617113565b5b8660538111156133f6576133f5617113565b5b03613406576201482090506134a8565b6005605381111561341a57613419617113565b5b86605381111561342d5761342c617113565b5b0361343d576201c52090506134a7565b6006605381111561345157613450617113565b5b86605381111561346457613463617113565b5b03613474576202460890506134a6565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b6134b58185846160e7565b61360f565b600260538111156134ce576134cd617113565b5b8660538111156134e1576134e0617113565b5b036134f05761f6189050613602565b6003605381111561350457613503617113565b5b86605381111561351757613516617113565b5b0361352757620148209050613601565b6004605381111561353b5761353a617113565b5b86605381111561354e5761354d617113565b5b0361355e576201ccf09050613600565b6005605381111561357257613571617113565b5b86605381111561358557613584617113565b5b0361359557620251c090506135ff565b600660538111156135a9576135a8617113565b5b8660538111156135bc576135bb617113565b5b036135cc576203345090506135fe565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b61360e81858585616284565b5b505050505050565b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614613690576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f600160f81b857effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff19160361384957600260538111156136d2576136d1617113565b5b8660538111156136e5576136e4617113565b5b036136f457617d009050613839565b6003605381111561370857613707617113565b5b86605381111561371b5761371a617113565b5b0361372a57617d009050613838565b6004605381111561373e5761373d617113565b5b86605381111561375157613750617113565b5b0361376057617d009050613837565b6005605381111561377457613773617113565b5b86605381111561378757613786617113565b5b03613796576184d09050613836565b600660538111156137aa576137a9617113565b5b8660538111156137bd576137bc617113565b5b036137cc576190889050613835565b600860538111156137e0576137df617113565b5b8660538111156137f3576137f2617113565b5b03613802576198589050613834565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b5b6138448185846160e7565b6139d7565b6002605381111561385d5761385c617113565b5b8660538111156138705761386f617113565b5b03613880576201676090506139ca565b6003605381111561389457613893617113565b5b8660538111156138a7576138a6617113565b5b036138b7576201e84890506139c9565b600460538111156138cb576138ca617113565b5b8660538111156138de576138dd617113565b5b036138ee57620278d090506139c8565b6005605381111561390257613901617113565b5b86605381111561391557613914617113565b5b036139255762032c8090506139c7565b6006605381111561393957613938617113565b5b86605381111561394c5761394b617113565b5b0361395c576204268090506139c6565b600860538111156139705761396f617113565b5b86605381111561398357613982617113565b5b03613993576205c49090506139c5565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b5b6139d681858585616284565b5b505050505050565b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614613a58576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f600160f81b857effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191603613bdd5760026053811115613a9a57613a99617113565b5b866053811115613aad57613aac617113565b5b03613abc5761cb209050613bcd565b60036053811115613ad057613acf617113565b5b866053811115613ae357613ae2617113565b5b03613af25761d6d89050613bcc565b60046053811115613b0657613b05617113565b5b866053811115613b1957613b18617113565b5b03613b2957620148209050613bcb565b60056053811115613b3d57613b3c617113565b5b866053811115613b5057613b4f617113565b5b03613b60576201c9089050613bca565b60066053811115613b7457613b73617113565b5b866053811115613b8757613b86617113565b5b03613b9757620249f09050613bc9565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b613bd88185846160e7565b613d32565b60026053811115613bf157613bf0617113565b5b866053811115613c0457613c03617113565b5b03613c135761e6789050613d25565b60036053811115613c2757613c26617113565b5b866053811115613c3a57613c39617113565b5b03613c4a57620148209050613d24565b60046053811115613c5e57613c5d617113565b5b866053811115613c7157613c70617113565b5b03613c81576201ccf09050613d23565b60056053811115613c9557613c94617113565b5b866053811115613ca857613ca7617113565b5b03613cb857620251c09050613d22565b60066053811115613ccc57613ccb617113565b5b866053811115613cdf57613cde617113565b5b03613cef57620353909050613d21565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b613d3181858585616284565b5b505050505050565b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614613db3576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f600160f81b857effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191603613f3a5760026053811115613df557613df4617113565b5b866053811115613e0857613e07617113565b5b03613e1857620148209050613f2a565b60036053811115613e2c57613e2b617113565b5b866053811115613e3f57613e3e617113565b5b03613e4f5762016b489050613f29565b60046053811115613e6357613e62617113565b5b866053811115613e7657613e75617113565b5b03613e8657620173189050613f28565b60056053811115613e9a57613e99617113565b5b866053811115613ead57613eac617113565b5b03613ebd57620207889050613f27565b60066053811115613ed157613ed0617113565b5b866053811115613ee457613ee3617113565b5b03613ef45762029fe09050613f26565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b613f358185846160e7565b614090565b60026053811115613f4e57613f4d617113565b5b866053811115613f6157613f60617113565b5b03613f7157620163789050614083565b60036053811115613f8557613f84617113565b5b866053811115613f9857613f97617113565b5b03613fa85762016b489050614082565b60046053811115613fbc57613fbb617113565b5b866053811115613fcf57613fce617113565b5b03613fdf576201e8489050614081565b60056053811115613ff357613ff2617113565b5b86605381111561400657614005617113565b5b0361401657620278d09050614080565b6006605381111561402a57614029617113565b5b86605381111561403d5761403c617113565b5b0361404d576203f7a0905061407f565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b61408f81858585616284565b5b505050505050565b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614614111576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f600160f81b857effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff19160361433c575f605381111561415257614151617113565b5b86605381111561416557614164617113565b5b03614174576161a8905061432c565b6002605381111561418857614187617113565b5b86605381111561419b5761419a617113565b5b036141aa5761d6d8905061432b565b600360538111156141be576141bd617113565b5b8660538111156141d1576141d0617113565b5b036141e05761d6d8905061432a565b600460538111156141f4576141f3617113565b5b86605381111561420757614206617113565b5b0361421757620140509050614329565b6005605381111561422b5761422a617113565b5b86605381111561423e5761423d617113565b5b0361424e57620144389050614328565b6006605381111561426257614261617113565b5b86605381111561427557614274617113565b5b03614285576201c9089050614327565b6007605381111561429957614298617113565b5b8660538111156142ac576142ab617113565b5b036142bc576201c9089050614326565b600860538111156142d0576142cf617113565b5b8660538111156142e3576142e2617113565b5b036142f3576201ccf09050614325565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b5b5b5b6143378185846160e7565b614537565b5f605381111561434f5761434e617113565b5b86605381111561436257614361617113565b5b0361437157616590905061452a565b6002605381111561438557614384617113565b5b86605381111561439857614397617113565b5b036143a75761d6d89050614529565b600360538111156143bb576143ba617113565b5b8660538111156143ce576143cd617113565b5b036143de57620144389050614528565b600460538111156143f2576143f1617113565b5b86605381111561440557614404617113565b5b036144155762014ff09050614527565b6005605381111561442957614428617113565b5b86605381111561443c5761443b617113565b5b0361444c576201d4c09050614526565b600660538111156144605761445f617113565b5b86605381111561447357614472617113565b5b03614483576201dc909050614525565b6007605381111561449757614496617113565b5b8660538111156144aa576144a9617113565b5b036144ba57620217289050614524565b600860538111156144ce576144cd617113565b5b8660538111156144e1576144e0617113565b5b036144f157620251c09050614523565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b5b5b5b61453681858585616284565b5b505050505050565b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16146145b8576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f600260538111156145cd576145cc617113565b5b8460538111156145e0576145df617113565b5b036145f05762013498905061473a565b6003605381111561460457614603617113565b5b84605381111561461757614616617113565b5b036146275762016b489050614739565b6004605381111561463b5761463a617113565b5b84605381111561464e5761464d617113565b5b0361465e57620173189050614738565b6005605381111561467257614671617113565b5b84605381111561468557614684617113565b5b03614695576201ffb89050614737565b600660538111156146a9576146a8617113565b5b8460538111156146bc576146bb617113565b5b036146cc57620290409050614736565b600860538111156146e0576146df617113565b5b8460538111156146f3576146f2617113565b5b036147035762041ac89050614735565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b5b6147458184846160e7565b50505050565b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16146147c4576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f600160f81b857effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff19160361494b576002605381111561480657614805617113565b5b86605381111561481957614818617113565b5b036148295762015ba8905061493b565b6003605381111561483d5761483c617113565b5b8660538111156148505761484f617113565b5b036148605762015ba8905061493a565b6004605381111561487457614873617113565b5b86605381111561488757614886617113565b5b03614897576201c9089050614939565b600560538111156148ab576148aa617113565b5b8660538111156148be576148bd617113565b5b036148ce57620246089050614938565b600660538111156148e2576148e1617113565b5b8660538111156148f5576148f4617113565b5b03614905576202bf209050614937565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b6149468185846160e7565b614aa1565b6002605381111561495f5761495e617113565b5b86605381111561497257614971617113565b5b03614982576201d8a89050614a94565b6003605381111561499657614995617113565b5b8660538111156149a9576149a8617113565b5b036149b957620236689050614a93565b600460538111156149cd576149cc617113565b5b8660538111156149e0576149df617113565b5b036149f0576202bf209050614a92565b60056053811115614a0457614a03617113565b5b866053811115614a1757614a16617113565b5b03614a2757620353909050614a91565b60066053811115614a3b57614a3a617113565b5b866053811115614a4e57614a4d617113565b5b03614a5e5762046cd09050614a90565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b614aa081858585616284565b5b505050505050565b6040518060400160405280600581526020017f352e302e3000000000000000000000000000000000000000000000000000000081525081565b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614614b5b576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f60026053811115614b7057614b6f617113565b5b836053811115614b8357614b82617113565b5b03614b92576159d89050614cd7565b60036053811115614ba657614ba5617113565b5b836053811115614bb957614bb8617113565b5b03614bc8576159d89050614cd6565b60046053811115614bdc57614bdb617113565b5b836053811115614bef57614bee617113565b5b03614bfe57615dc09050614cd5565b60056053811115614c1257614c11617113565b5b836053811115614c2557614c24617113565b5b03614c3457615dc09050614cd4565b60066053811115614c4857614c47617113565b5b836053811115614c5b57614c5a617113565b5b03614c6a576161a89050614cd3565b60086053811115614c7e57614c7d617113565b5b836053811115614c9157614c90617113565b5b03614ca0576175309050614cd2565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b5b614ce081616153565b614cea82826161b3565b505050565b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614614d68576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f600160f81b857effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191603614eed5760026053811115614daa57614da9617113565b5b866053811115614dbd57614dbc617113565b5b03614dcc5761e2909050614edd565b60036053811115614de057614ddf617113565b5b866053811115614df357614df2617113565b5b03614e025761e2909050614edc565b60046053811115614e1657614e15617113565b5b866053811115614e2957614e28617113565b5b03614e3957620148209050614edb565b60056053811115614e4d57614e4c617113565b5b866053811115614e6057614e5f617113565b5b03614e70576201d0d89050614eda565b60066053811115614e8457614e83617113565b5b866053811115614e9757614e96617113565b5b03614ea757620249f09050614ed9565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b614ee88185846160e7565b615042565b60026053811115614f0157614f00617113565b5b866053811115614f1457614f13617113565b5b03614f235761e2909050615035565b60036053811115614f3757614f36617113565b5b866053811115614f4a57614f49617113565b5b03614f5a57620144389050615034565b60046053811115614f6e57614f6d617113565b5b866053811115614f8157614f80617113565b5b03614f91576201c9089050615033565b60056053811115614fa557614fa4617113565b5b866053811115614fb857614fb7617113565b5b03614fc857620246089050615032565b60066053811115614fdc57614fdb617113565b5b866053811115614fef57614fee617113565b5b03614fff57620353909050615031565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b61504181858585616284565b5b505050505050565b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16146150c3576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f600160f81b857effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916036152b2575f605381111561510457615103617113565b5b86605381111561511757615116617113565b5b03615126576155f090506152a2565b6002605381111561513a57615139617113565b5b86605381111561514d5761514c617113565b5b0361515c5761753090506152a1565b600360538111156151705761516f617113565b5b86605381111561518357615182617113565b5b036151925761753090506152a0565b600460538111156151a6576151a5617113565b5b8660538111156151b9576151b8617113565b5b036151c857617d00905061529f565b600560538111156151dc576151db617113565b5b8660538111156151ef576151ee617113565b5b036151fe576184d0905061529e565b6006605381111561521257615211617113565b5b86605381111561522557615224617113565b5b0361523457619088905061529d565b6008605381111561524857615247617113565b5b86605381111561525b5761525a617113565b5b0361526a57619470905061529c565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b5b5b6152ad8185846160e7565b615470565b5f60538111156152c5576152c4617113565b5b8660538111156152d8576152d7617113565b5b036152e757615dc09050615463565b600260538111156152fb576152fa617113565b5b86605381111561530e5761530d617113565b5b0361531d576175309050615462565b6003605381111561533157615330617113565b5b86605381111561534457615343617113565b5b03615353576179189050615461565b6004605381111561536757615366617113565b5b86605381111561537a57615379617113565b5b0361538957617d009050615460565b6005605381111561539d5761539c617113565b5b8660538111156153b0576153af617113565b5b036153bf576184d0905061545f565b600660538111156153d3576153d2617113565b5b8660538111156153e6576153e5617113565b5b036153f557619088905061545e565b6008605381111561540957615408617113565b5b86605381111561541c5761541b617113565b5b0361542b57619470905061545d565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b5b5b61546f81858585616284565b5b505050505050565b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16146154f1576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f600160f81b857effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191614615551576040517f6aa9eb0500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6002605381111561556557615564617113565b5b86605381111561557857615577617113565b5b03615588576206b6c0905061569a565b6003605381111561559c5761559b617113565b5b8660538111156155af576155ae617113565b5b036155bf576208d9a09050615699565b600460538111156155d3576155d2617113565b5b8660538111156155e6576155e5617113565b5b036155f657620c15c09050615698565b6005605381111561560a57615609617113565b5b86605381111561561d5761561c617113565b5b0361562d57621197e89050615697565b6006605381111561564157615640617113565b5b86605381111561565457615653617113565b5b0361566457621da5d89050615696565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b6156a58185846160e7565b505050505050565b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614615726576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f600160f81b857effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191603615951575f605381111561576757615766617113565b5b86605381111561577a57615779617113565b5b03615789576159d89050615941565b6002605381111561579d5761579c617113565b5b8660538111156157b0576157af617113565b5b036157bf5761d6d89050615940565b600360538111156157d3576157d2617113565b5b8660538111156157e6576157e5617113565b5b036157f55761d6d8905061593f565b6004605381111561580957615808617113565b5b86605381111561581c5761581b617113565b5b0361582c5762014438905061593e565b600560538111156158405761583f617113565b5b86605381111561585357615852617113565b5b036158635762014820905061593d565b6006605381111561587757615876617113565b5b86605381111561588a57615889617113565b5b0361589a576201c908905061593c565b600760538111156158ae576158ad617113565b5b8660538111156158c1576158c0617113565b5b036158d1576201c908905061593b565b600860538111156158e5576158e4617113565b5b8660538111156158f8576158f7617113565b5b03615908576201c908905061593a565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b5b5b5b61594c8185846160e7565b615b4c565b5f605381111561596457615963617113565b5b86605381111561597757615976617113565b5b03615986576159d89050615b3f565b6002605381111561599a57615999617113565b5b8660538111156159ad576159ac617113565b5b036159bc5761d6d89050615b3e565b600360538111156159d0576159cf617113565b5b8660538111156159e3576159e2617113565b5b036159f357620144389050615b3d565b60046053811115615a0757615a06617113565b5b866053811115615a1a57615a19617113565b5b03615a2a5762014c089050615b3c565b60056053811115615a3e57615a3d617113565b5b866053811115615a5157615a50617113565b5b03615a61576201ccf09050615b3b565b60066053811115615a7557615a74617113565b5b866053811115615a8857615a87617113565b5b03615a98576201dc909050615b3a565b60076053811115615aac57615aab617113565b5b866053811115615abf57615abe617113565b5b03615acf57620213409050615b39565b60086053811115615ae357615ae2617113565b5b866053811115615af657615af5617113565b5b03615b0657620249f09050615b38565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b5b5b5b615b4b81858585616284565b5b505050505050565b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614615bcd576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f806053811115615be157615be0617113565b5b846053811115615bf457615bf3617113565b5b03615c025760029050615d78565b60026053811115615c1657615c15617113565b5b846053811115615c2957615c28617113565b5b03615c375760099050615d77565b60036053811115615c4b57615c4a617113565b5b846053811115615c5e57615c5d617113565b5b03615c6c5760109050615d76565b60046053811115615c8057615c7f617113565b5b846053811115615c9357615c92617113565b5b03615ca15760209050615d75565b60056053811115615cb557615cb4617113565b5b846053811115615cc857615cc7617113565b5b03615cd657603f9050615d74565b60066053811115615cea57615ce9617113565b5b846053811115615cfd57615cfc617113565b5b03615d0b5760829050615d73565b60086053811115615d1f57615d1e617113565b5b846053811115615d3257615d31617113565b5b03615d405760829050615d72565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b5b5b615d838184846160e7565b50505050565b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614615e02576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f600160f81b857effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191603615f895760026053811115615e4457615e43617113565b5b866053811115615e5757615e56617113565b5b03615e6757620148209050615f79565b60036053811115615e7b57615e7a617113565b5b866053811115615e8e57615e8d617113565b5b03615e9e5762016b489050615f78565b60046053811115615eb257615eb1617113565b5b866053811115615ec557615ec4617113565b5b03615ed557620173189050615f77565b60056053811115615ee957615ee8617113565b5b866053811115615efc57615efb617113565b5b03615f0c57620207889050615f76565b60066053811115615f2057615f1f617113565b5b866053811115615f3357615f32617113565b5b03615f435762029fe09050615f75565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b615f848185846160e7565b6160df565b60026053811115615f9d57615f9c617113565b5b866053811115615fb057615faf617113565b5b03615fc057620157c090506160d2565b60036053811115615fd457615fd3617113565b5b866053811115615fe757615fe6617113565b5b03615ff75762016b4890506160d1565b6004605381111561600b5761600a617113565b5b86605381111561601e5761601d617113565b5b0361602e576201e84890506160d0565b6005605381111561604257616041617113565b5b86605381111561605557616054617113565b5b0361606557620278d090506160cf565b6006605381111561607957616078617113565b5b86605381111561608c5761608b617113565b5b0361609c576203f3b890506160ce565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b6160de81858585616284565b5b505050505050565b6160f083616153565b5f6160fa8361675b565b8461610591906172dd565b9050624c4b408110616143576040517ffc34487000000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b61614d82826161b3565b50505050565b5f61615c616765565b8261616791906172dd565b90506301312d0081106161a6576040517f77e3c29300000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6161af8161676d565b5050565b80825d5050565b60605f60016161c884616773565b0190505f8167ffffffffffffffff8111156161e6576161e5616f6d565b5b6040519080825280601f01601f1916602001820160405280156162185781602001600182028036833780820191505090505b5090505f82602001820190505b600115616279578080600190039150507f3031323334353637383961626364656600000000000000000000000000000000600a86061a8153600a858161626e5761626d617310565b5b0494505f8503616225575b819350505050919050565b61628d84616153565b5f6162a861629a8561675b565b6162a38561675b565b6168c4565b856162b391906172dd565b9050624c4b4081106162f1576040517ffc34487000000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6162fb82826161b3565b5050505050565b5f61630b616326565b5f015f9054906101000a900467ffffffffffffffff16905090565b5f7ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00905090565b61635685616153565b5f6163826163638661675b565b61637d61636f8761675b565b6163788761675b565b6168c4565b6168c4565b8661638d91906172dd565b9050624c4b4081106163cb576040517ffc34487000000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6163d582826161b3565b505050505050565b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff163073ffffffffffffffffffffffffffffffffffffffff16148061648a57507f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff166164716168dd565b73ffffffffffffffffffffffffffffffffffffffff1614155b156164c1576040517fe07c8dba00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b565b7350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff16638da5cb5b6040518163ffffffff1660e01b8152600401602060405180830381865afa158015616520573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906165449190617351565b73ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16146165b357336040517f21bfda100000000000000000000000000000000000000000000000000000000081526004016165aa9190616eab565b60405180910390fd5b50565b8173ffffffffffffffffffffffffffffffffffffffff166352d1902d6040518163ffffffff1660e01b8152600401602060405180830381865afa92505050801561661e57506040513d601f19601f8201168201806040525081019061661b9190617390565b60015b61665f57816040517f4c9c8ce30000000000000000000000000000000000000000000000000000000081526004016166569190616eab565b60405180910390fd5b7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5f1b81146166c557806040517faa1d49a40000000000000000000000000000000000000000000000000000000081526004016166bc91906170fa565b60405180910390fd5b6166cf8383616930565b505050565b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff163073ffffffffffffffffffffffffffffffffffffffff1614616759576040517fe07c8dba00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b565b5f815c9050919050565b5f805c905090565b805f5d50565b5f805f90507a184f03e93ff9f4daa797ed6e38ed64bf6a1f01000000000000000083106167cf577a184f03e93ff9f4daa797ed6e38ed64bf6a1f01000000000000000083816167c5576167c4617310565b5b0492506040810190505b6d04ee2d6d415b85acef8100000000831061680c576d04ee2d6d415b85acef8100000000838161680257616801617310565b5b0492506020810190505b662386f26fc10000831061683b57662386f26fc10000838161683157616830617310565b5b0492506010810190505b6305f5e1008310616864576305f5e100838161685a57616859617310565b5b0492506008810190505b612710831061688957612710838161687f5761687e617310565b5b0492506004810190505b606483106168ac57606483816168a2576168a1617310565b5b0492506002810190505b600a83106168bb576001810190505b80915050919050565b5f818310156168d357816168d5565b825b905092915050565b5f6169097f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5f1b6169a2565b5f015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905090565b616939826169ab565b8173ffffffffffffffffffffffffffffffffffffffff167fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b60405160405180910390a25f815111156169955761698f8282616a74565b5061699e565b61699d616af4565b5b5050565b5f819050919050565b5f8173ffffffffffffffffffffffffffffffffffffffff163b03616a0657806040517f4c9c8ce30000000000000000000000000000000000000000000000000000000081526004016169fd9190616eab565b60405180910390fd5b80616a327f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5f1b6169a2565b5f015f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555050565b60605f808473ffffffffffffffffffffffffffffffffffffffff1684604051616a9d91906173ff565b5f60405180830381855af49150503d805f8114616ad5576040519150601f19603f3d011682016040523d82523d5f602084013e616ada565b606091505b5091509150616aea858383616b30565b9250505092915050565b5f341115616b2e576040517fb398979f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b565b606082616b4557616b4082616bbd565b616bb5565b5f8251148015616b6b57505f8473ffffffffffffffffffffffffffffffffffffffff163b145b15616bad57836040517f9996b315000000000000000000000000000000000000000000000000000000008152600401616ba49190616eab565b60405180910390fd5b819050616bb6565b5b9392505050565b5f81511115616bcf5780518082602001fd5b6040517fd6bda27500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f604051905090565b5f80fd5b5f80fd5b60548110616c1e575f80fd5b50565b5f81359050616c2f81616c12565b92915050565b5f819050919050565b616c4781616c35565b8114616c51575f80fd5b50565b5f81359050616c6281616c3e565b92915050565b5f805f60608486031215616c7f57616c7e616c0a565b5b5f616c8c86828701616c21565b9350506020616c9d86828701616c54565b9250506040616cae86828701616c54565b9150509250925092565b5f8060408385031215616cce57616ccd616c0a565b5b5f616cdb85828601616c21565b9250506020616cec85828601616c54565b9150509250929050565b5f81519050919050565b5f82825260208201905092915050565b5f5b83811015616d2d578082015181840152602081019050616d12565b5f8484015250505050565b5f601f19601f8301169050919050565b5f616d5282616cf6565b616d5c8185616d00565b9350616d6c818560208601616d10565b616d7581616d38565b840191505092915050565b5f6020820190508181035f830152616d988184616d48565b905092915050565b5f7fff0000000000000000000000000000000000000000000000000000000000000082169050919050565b616dd481616da0565b8114616dde575f80fd5b50565b5f81359050616def81616dcb565b92915050565b5f805f805f60a08688031215616e0e57616e0d616c0a565b5b5f616e1b88828901616c21565b9550506020616e2c88828901616de1565b9450506040616e3d88828901616c54565b9350506060616e4e88828901616c54565b9250506080616e5f88828901616c54565b9150509295509295909350565b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f616e9582616e6c565b9050919050565b616ea581616e8b565b82525050565b5f602082019050616ebe5f830184616e9c565b92915050565b5f805f805f60a08688031215616edd57616edc616c0a565b5b5f616eea88828901616c21565b9550506020616efb88828901616c54565b9450506040616f0c88828901616c54565b9350506060616f1d88828901616c54565b9250506080616f2e88828901616c54565b9150509295509295909350565b616f4481616e8b565b8114616f4e575f80fd5b50565b5f81359050616f5f81616f3b565b92915050565b5f80fd5b5f80fd5b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b616fa382616d38565b810181811067ffffffffffffffff82111715616fc257616fc1616f6d565b5b80604052505050565b5f616fd4616c01565b9050616fe08282616f9a565b919050565b5f67ffffffffffffffff821115616fff57616ffe616f6d565b5b61700882616d38565b9050602081019050919050565b828183375f83830152505050565b5f61703561703084616fe5565b616fcb565b90508281526020810184848401111561705157617050616f69565b5b61705c848285617015565b509392505050565b5f82601f83011261707857617077616f65565b5b8135617088848260208601617023565b91505092915050565b5f80604083850312156170a7576170a6616c0a565b5b5f6170b485828601616f51565b925050602083013567ffffffffffffffff8111156170d5576170d4616c0e565b5b6170e185828601617064565b9150509250929050565b6170f481616c35565b82525050565b5f60208201905061710d5f8301846170eb565b92915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52602160045260245ffd5b5f81905092915050565b5f61715482616cf6565b61715e8185617140565b935061716e818560208601616d10565b80840191505092915050565b7f20760000000000000000000000000000000000000000000000000000000000005f82015250565b5f6171ae600283617140565b91506171b98261717a565b600282019050919050565b7f2e000000000000000000000000000000000000000000000000000000000000005f82015250565b5f6171f8600183617140565b9150617203826171c4565b600182019050919050565b5f617219828761714a565b9150617224826171a2565b9150617230828661714a565b915061723b826171ec565b9150617247828561714a565b9150617252826171ec565b915061725e828461714a565b915081905095945050505050565b5f67ffffffffffffffff82169050919050565b6172888161726c565b82525050565b5f6020820190506172a15f83018461727f565b92915050565b5f819050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5f6172e7826172a7565b91506172f2836172a7565b925082820190508082111561730a576173096172b0565b5b92915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601260045260245ffd5b5f8151905061734b81616f3b565b92915050565b5f6020828403121561736657617365616c0a565b5b5f6173738482850161733d565b91505092915050565b5f8151905061738a81616c3e565b92915050565b5f602082840312156173a5576173a4616c0a565b5b5f6173b28482850161737c565b91505092915050565b5f81519050919050565b5f81905092915050565b5f6173d9826173bb565b6173e381856173c5565b93506173f3818560208601616d10565b80840191505092915050565b5f61740a82846173cf565b91508190509291505056
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R`\x046\x10a\x01\xEDW_5`\xE0\x1C\x80cd+\x14\x90\x11a\x01\x0CW\x80c\xAC\xB5\xF3\x88\x11a\0\x9FW\x80c\xE8\xE3\x99\xAD\x11a\0nW\x80c\xE8\xE3\x99\xAD\x14a\x06;W\x80c\xFA\x08\xE3\x8D\x14a\x06cW\x80c\xFA]\xEF\xDB\x14a\x06\x8BW\x80c\xFC\x06<b\x14a\x06\xB3W\x80c\xFD\xADL\x96\x14a\x06\xDBWa\x01\xEDV[\x80c\xAC\xB5\xF3\x88\x14a\x05\x99W\x80c\xAD<\xB1\xCC\x14a\x05\xC1W\x80c\xCC\x86g\x82\x14a\x05\xEBW\x80c\xD4\x7F=Y\x14a\x06\x13Wa\x01\xEDV[\x80c\x85\x9A\x1Bp\x11a\0\xDBW\x80c\x85\x9A\x1Bp\x14a\x04\xF9W\x80c\x90u1\x08\x14a\x05!W\x80c\x94\xE7\x0EO\x14a\x05IW\x80c\xA4\xC9\x8F>\x14a\x05qWa\x01\xEDV[\x80cd+\x14\x90\x14a\x04YW\x80cf\x91\x81\xC0\x14a\x04\x81W\x80ck\xB3\xC6\x11\x14a\x04\xA9W\x80c\x83\xE6\xA7 \x14a\x04\xD1Wa\x01\xEDV[\x80c&\x8Dm1\x11a\x01\x84W\x80c@kE\x13\x11a\x01SW\x80c@kE\x13\x14a\x03\xC3W\x80cNrgi\x14a\x03\xEBW\x80cO\x1E\xF2\x86\x14a\x04\x13W\x80cR\xD1\x90-\x14a\x04/Wa\x01\xEDV[\x80c&\x8Dm1\x14a\x033W\x80c4\x8C1\x85\x14a\x03]W\x80c9\xF78\x10\x14a\x03\x85W\x80c<\x16\xFF\r\x14a\x03\x9BWa\x01\xEDV[\x80c\x144\xBAM\x11a\x01\xC0W\x80c\x144\xBAM\x14a\x02\x93W\x80c\x14Rn\x87\x14a\x02\xBBW\x80c\x18V\xD9\x1D\x14a\x02\xE3W\x80c\x1E\xD9\x1F\xF6\x14a\x03\x0BWa\x01\xEDV[\x80c\x02\xDDbv\x14a\x01\xF1W\x80c\t\xB0N\x8F\x14a\x02\x19W\x80c\r\x8En,\x14a\x02AW\x80c\x139\xC5\xEE\x14a\x02kW[_\x80\xFD[4\x80\x15a\x01\xFCW_\x80\xFD[Pa\x02\x17`\x04\x806\x03\x81\x01\x90a\x02\x12\x91\x90alhV[a\x07\x03V[\0[4\x80\x15a\x02$W_\x80\xFD[Pa\x02?`\x04\x806\x03\x81\x01\x90a\x02:\x91\x90al\xB8V[a\t8V[\0[4\x80\x15a\x02LW_\x80\xFD[Pa\x02Ua\x0B{V[`@Qa\x02b\x91\x90am\x80V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x02vW_\x80\xFD[Pa\x02\x91`\x04\x806\x03\x81\x01\x90a\x02\x8C\x91\x90am\xF5V[a\x0B\xF6V[\0[4\x80\x15a\x02\x9EW_\x80\xFD[Pa\x02\xB9`\x04\x806\x03\x81\x01\x90a\x02\xB4\x91\x90am\xF5V[a\x0FQV[\0[4\x80\x15a\x02\xC6W_\x80\xFD[Pa\x02\xE1`\x04\x806\x03\x81\x01\x90a\x02\xDC\x91\x90am\xF5V[a\x13\x7FV[\0[4\x80\x15a\x02\xEEW_\x80\xFD[Pa\x03\t`\x04\x806\x03\x81\x01\x90a\x03\x04\x91\x90am\xF5V[a\x17GV[\0[4\x80\x15a\x03\x16W_\x80\xFD[Pa\x031`\x04\x806\x03\x81\x01\x90a\x03,\x91\x90am\xF5V[a\x1BuV[\0[4\x80\x15a\x03>W_\x80\xFD[Pa\x03Ga\x1F=V[`@Qa\x03T\x91\x90an\xABV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x03hW_\x80\xFD[Pa\x03\x83`\x04\x806\x03\x81\x01\x90a\x03~\x91\x90al\xB8V[a\x1FXV[\0[4\x80\x15a\x03\x90W_\x80\xFD[Pa\x03\x99a!\xCAV[\0[4\x80\x15a\x03\xA6W_\x80\xFD[Pa\x03\xC1`\x04\x806\x03\x81\x01\x90a\x03\xBC\x91\x90am\xF5V[a#:V[\0[4\x80\x15a\x03\xCEW_\x80\xFD[Pa\x03\xE9`\x04\x806\x03\x81\x01\x90a\x03\xE4\x91\x90am\xF5V[a&\x98V[\0[4\x80\x15a\x03\xF6W_\x80\xFD[Pa\x04\x11`\x04\x806\x03\x81\x01\x90a\x04\x0C\x91\x90an\xC4V[a(\xCDV[\0[a\x04-`\x04\x806\x03\x81\x01\x90a\x04(\x91\x90ap\x91V[a+FV[\0[4\x80\x15a\x04:W_\x80\xFD[Pa\x04Ca+eV[`@Qa\x04P\x91\x90ap\xFAV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x04dW_\x80\xFD[Pa\x04\x7F`\x04\x806\x03\x81\x01\x90a\x04z\x91\x90am\xF5V[a+\x96V[\0[4\x80\x15a\x04\x8CW_\x80\xFD[Pa\x04\xA7`\x04\x806\x03\x81\x01\x90a\x04\xA2\x91\x90am\xF5V[a.\xF4V[\0[4\x80\x15a\x04\xB4W_\x80\xFD[Pa\x04\xCF`\x04\x806\x03\x81\x01\x90a\x04\xCA\x91\x90am\xF5V[a2\xBCV[\0[4\x80\x15a\x04\xDCW_\x80\xFD[Pa\x04\xF7`\x04\x806\x03\x81\x01\x90a\x04\xF2\x91\x90am\xF5V[a6\x17V[\0[4\x80\x15a\x05\x04W_\x80\xFD[Pa\x05\x1F`\x04\x806\x03\x81\x01\x90a\x05\x1A\x91\x90am\xF5V[a9\xDFV[\0[4\x80\x15a\x05,W_\x80\xFD[Pa\x05G`\x04\x806\x03\x81\x01\x90a\x05B\x91\x90am\xF5V[a=:V[\0[4\x80\x15a\x05TW_\x80\xFD[Pa\x05o`\x04\x806\x03\x81\x01\x90a\x05j\x91\x90am\xF5V[a@\x98V[\0[4\x80\x15a\x05|W_\x80\xFD[Pa\x05\x97`\x04\x806\x03\x81\x01\x90a\x05\x92\x91\x90alhV[aE?V[\0[4\x80\x15a\x05\xA4W_\x80\xFD[Pa\x05\xBF`\x04\x806\x03\x81\x01\x90a\x05\xBA\x91\x90am\xF5V[aGKV[\0[4\x80\x15a\x05\xCCW_\x80\xFD[Pa\x05\xD5aJ\xA9V[`@Qa\x05\xE2\x91\x90am\x80V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x05\xF6W_\x80\xFD[Pa\x06\x11`\x04\x806\x03\x81\x01\x90a\x06\x0C\x91\x90al\xB8V[aJ\xE2V[\0[4\x80\x15a\x06\x1EW_\x80\xFD[Pa\x069`\x04\x806\x03\x81\x01\x90a\x064\x91\x90am\xF5V[aL\xEFV[\0[4\x80\x15a\x06FW_\x80\xFD[Pa\x06a`\x04\x806\x03\x81\x01\x90a\x06\\\x91\x90am\xF5V[aPJV[\0[4\x80\x15a\x06nW_\x80\xFD[Pa\x06\x89`\x04\x806\x03\x81\x01\x90a\x06\x84\x91\x90am\xF5V[aTxV[\0[4\x80\x15a\x06\x96W_\x80\xFD[Pa\x06\xB1`\x04\x806\x03\x81\x01\x90a\x06\xAC\x91\x90am\xF5V[aV\xADV[\0[4\x80\x15a\x06\xBEW_\x80\xFD[Pa\x06\xD9`\x04\x806\x03\x81\x01\x90a\x06\xD4\x91\x90alhV[a[TV[\0[4\x80\x15a\x06\xE6W_\x80\xFD[Pa\x07\x01`\x04\x806\x03\x81\x01\x90a\x06\xFC\x91\x90am\xF5V[a]\x89V[\0[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x07|W`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x80`S\x81\x11\x15a\x07\x90Wa\x07\x8Faq\x13V[[\x84`S\x81\x11\x15a\x07\xA3Wa\x07\xA2aq\x13V[[\x03a\x07\xB1W` \x90Pa\t'V[`\x02`S\x81\x11\x15a\x07\xC5Wa\x07\xC4aq\x13V[[\x84`S\x81\x11\x15a\x07\xD8Wa\x07\xD7aq\x13V[[\x03a\x07\xE6W` \x90Pa\t&V[`\x03`S\x81\x11\x15a\x07\xFAWa\x07\xF9aq\x13V[[\x84`S\x81\x11\x15a\x08\rWa\x08\x0Caq\x13V[[\x03a\x08\x1BW` \x90Pa\t%V[`\x04`S\x81\x11\x15a\x08/Wa\x08.aq\x13V[[\x84`S\x81\x11\x15a\x08BWa\x08Aaq\x13V[[\x03a\x08PW` \x90Pa\t$V[`\x05`S\x81\x11\x15a\x08dWa\x08caq\x13V[[\x84`S\x81\x11\x15a\x08wWa\x08vaq\x13V[[\x03a\x08\x85W` \x90Pa\t#V[`\x06`S\x81\x11\x15a\x08\x99Wa\x08\x98aq\x13V[[\x84`S\x81\x11\x15a\x08\xACWa\x08\xABaq\x13V[[\x03a\x08\xBAW` \x90Pa\t\"V[`\x08`S\x81\x11\x15a\x08\xCEWa\x08\xCDaq\x13V[[\x84`S\x81\x11\x15a\x08\xE1Wa\x08\xE0aq\x13V[[\x03a\x08\xEFW` \x90Pa\t!V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[[[a\t2\x81\x84\x84a`\xE7V[PPPPV[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\t\xB1W`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x80`S\x81\x11\x15a\t\xC5Wa\t\xC4aq\x13V[[\x83`S\x81\x11\x15a\t\xD8Wa\t\xD7aq\x13V[[\x03a\t\xE7WaJ8\x90Pa\x0BcV[`\x02`S\x81\x11\x15a\t\xFBWa\t\xFAaq\x13V[[\x83`S\x81\x11\x15a\n\x0EWa\n\raq\x13V[[\x03a\n\x1DWaY\xD8\x90Pa\x0BbV[`\x03`S\x81\x11\x15a\n1Wa\n0aq\x13V[[\x83`S\x81\x11\x15a\nDWa\nCaq\x13V[[\x03a\nSWaY\xD8\x90Pa\x0BaV[`\x04`S\x81\x11\x15a\ngWa\nfaq\x13V[[\x83`S\x81\x11\x15a\nzWa\nyaq\x13V[[\x03a\n\x89Wa]\xC0\x90Pa\x0B`V[`\x05`S\x81\x11\x15a\n\x9DWa\n\x9Caq\x13V[[\x83`S\x81\x11\x15a\n\xB0Wa\n\xAFaq\x13V[[\x03a\n\xBFWa]\xC0\x90Pa\x0B_V[`\x06`S\x81\x11\x15a\n\xD3Wa\n\xD2aq\x13V[[\x83`S\x81\x11\x15a\n\xE6Wa\n\xE5aq\x13V[[\x03a\n\xF5Waa\xA8\x90Pa\x0B^V[`\x08`S\x81\x11\x15a\x0B\tWa\x0B\x08aq\x13V[[\x83`S\x81\x11\x15a\x0B\x1CWa\x0B\x1Baq\x13V[[\x03a\x0B+Wau0\x90Pa\x0B]V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[[[a\x0Bl\x81aaSV[a\x0Bv\x82\x82aa\xB3V[PPPV[```@Q\x80`@\x01`@R\x80`\x08\x81R` \x01\x7FHCULimit\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81RPa\x0B\xBC_aa\xBAV[a\x0B\xC6`\x01aa\xBAV[a\x0B\xCF_aa\xBAV[`@Q` \x01a\x0B\xE2\x94\x93\x92\x91\x90ar\x0EV[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x90P\x90V[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x0CoW`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\x01`\xF8\x1B\x85~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x03a\r\xF4W`\x02`S\x81\x11\x15a\x0C\xB1Wa\x0C\xB0aq\x13V[[\x86`S\x81\x11\x15a\x0C\xC4Wa\x0C\xC3aq\x13V[[\x03a\x0C\xD3Wa\xCB \x90Pa\r\xE4V[`\x03`S\x81\x11\x15a\x0C\xE7Wa\x0C\xE6aq\x13V[[\x86`S\x81\x11\x15a\x0C\xFAWa\x0C\xF9aq\x13V[[\x03a\r\tWa\xE2\x90\x90Pa\r\xE3V[`\x04`S\x81\x11\x15a\r\x1DWa\r\x1Caq\x13V[[\x86`S\x81\x11\x15a\r0Wa\r/aq\x13V[[\x03a\r@Wb\x01D8\x90Pa\r\xE2V[`\x05`S\x81\x11\x15a\rTWa\rSaq\x13V[[\x86`S\x81\x11\x15a\rgWa\rfaq\x13V[[\x03a\rwWb\x01\xCC\xF0\x90Pa\r\xE1V[`\x06`S\x81\x11\x15a\r\x8BWa\r\x8Aaq\x13V[[\x86`S\x81\x11\x15a\r\x9EWa\r\x9Daq\x13V[[\x03a\r\xAEWb\x02F\x08\x90Pa\r\xE0V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[a\r\xEF\x81\x85\x84a`\xE7V[a\x0FIV[`\x02`S\x81\x11\x15a\x0E\x08Wa\x0E\x07aq\x13V[[\x86`S\x81\x11\x15a\x0E\x1BWa\x0E\x1Aaq\x13V[[\x03a\x0E*Wa\xE6x\x90Pa\x0F<V[`\x03`S\x81\x11\x15a\x0E>Wa\x0E=aq\x13V[[\x86`S\x81\x11\x15a\x0EQWa\x0EPaq\x13V[[\x03a\x0EaWb\x01H \x90Pa\x0F;V[`\x04`S\x81\x11\x15a\x0EuWa\x0Etaq\x13V[[\x86`S\x81\x11\x15a\x0E\x88Wa\x0E\x87aq\x13V[[\x03a\x0E\x98Wb\x01\xC9\x08\x90Pa\x0F:V[`\x05`S\x81\x11\x15a\x0E\xACWa\x0E\xABaq\x13V[[\x86`S\x81\x11\x15a\x0E\xBFWa\x0E\xBEaq\x13V[[\x03a\x0E\xCFWb\x02:P\x90Pa\x0F9V[`\x06`S\x81\x11\x15a\x0E\xE3Wa\x0E\xE2aq\x13V[[\x86`S\x81\x11\x15a\x0E\xF6Wa\x0E\xF5aq\x13V[[\x03a\x0F\x06Wb\x03G\xD8\x90Pa\x0F8V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[a\x0FH\x81\x85\x85\x85ab\x84V[[PPPPPPV[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x0F\xCAW`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\x01`\xF8\x1B\x85~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x03a\x11\xB9W_`S\x81\x11\x15a\x10\x0BWa\x10\naq\x13V[[\x86`S\x81\x11\x15a\x10\x1EWa\x10\x1Daq\x13V[[\x03a\x10-WaU\xF0\x90Pa\x11\xA9V[`\x02`S\x81\x11\x15a\x10AWa\x10@aq\x13V[[\x86`S\x81\x11\x15a\x10TWa\x10Saq\x13V[[\x03a\x10cWay\x18\x90Pa\x11\xA8V[`\x03`S\x81\x11\x15a\x10wWa\x10vaq\x13V[[\x86`S\x81\x11\x15a\x10\x8AWa\x10\x89aq\x13V[[\x03a\x10\x99Way\x18\x90Pa\x11\xA7V[`\x04`S\x81\x11\x15a\x10\xADWa\x10\xACaq\x13V[[\x86`S\x81\x11\x15a\x10\xC0Wa\x10\xBFaq\x13V[[\x03a\x10\xCFWa}\0\x90Pa\x11\xA6V[`\x05`S\x81\x11\x15a\x10\xE3Wa\x10\xE2aq\x13V[[\x86`S\x81\x11\x15a\x10\xF6Wa\x10\xF5aq\x13V[[\x03a\x11\x05Wa\x84\xD0\x90Pa\x11\xA5V[`\x06`S\x81\x11\x15a\x11\x19Wa\x11\x18aq\x13V[[\x86`S\x81\x11\x15a\x11,Wa\x11+aq\x13V[[\x03a\x11;Wa\x90\x88\x90Pa\x11\xA4V[`\x08`S\x81\x11\x15a\x11OWa\x11Naq\x13V[[\x86`S\x81\x11\x15a\x11bWa\x11aaq\x13V[[\x03a\x11qWa\x98X\x90Pa\x11\xA3V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[[[a\x11\xB4\x81\x85\x84a`\xE7V[a\x13wV[_`S\x81\x11\x15a\x11\xCCWa\x11\xCBaq\x13V[[\x86`S\x81\x11\x15a\x11\xDFWa\x11\xDEaq\x13V[[\x03a\x11\xEEWaU\xF0\x90Pa\x13jV[`\x02`S\x81\x11\x15a\x12\x02Wa\x12\x01aq\x13V[[\x86`S\x81\x11\x15a\x12\x15Wa\x12\x14aq\x13V[[\x03a\x12$Way\x18\x90Pa\x13iV[`\x03`S\x81\x11\x15a\x128Wa\x127aq\x13V[[\x86`S\x81\x11\x15a\x12KWa\x12Jaq\x13V[[\x03a\x12ZWay\x18\x90Pa\x13hV[`\x04`S\x81\x11\x15a\x12nWa\x12maq\x13V[[\x86`S\x81\x11\x15a\x12\x81Wa\x12\x80aq\x13V[[\x03a\x12\x90Wa}\0\x90Pa\x13gV[`\x05`S\x81\x11\x15a\x12\xA4Wa\x12\xA3aq\x13V[[\x86`S\x81\x11\x15a\x12\xB7Wa\x12\xB6aq\x13V[[\x03a\x12\xC6Wa\x84\xD0\x90Pa\x13fV[`\x06`S\x81\x11\x15a\x12\xDAWa\x12\xD9aq\x13V[[\x86`S\x81\x11\x15a\x12\xEDWa\x12\xECaq\x13V[[\x03a\x12\xFCWa\x90\x88\x90Pa\x13eV[`\x08`S\x81\x11\x15a\x13\x10Wa\x13\x0Faq\x13V[[\x86`S\x81\x11\x15a\x13#Wa\x13\"aq\x13V[[\x03a\x132Wa\x98X\x90Pa\x13dV[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[[[a\x13v\x81\x85\x85\x85ab\x84V[[PPPPPPV[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x13\xF8W`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\x01`\xF8\x1B\x85~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x03a\x15\xB1W`\x02`S\x81\x11\x15a\x14:Wa\x149aq\x13V[[\x86`S\x81\x11\x15a\x14MWa\x14Laq\x13V[[\x03a\x14\\Way\x18\x90Pa\x15\xA1V[`\x03`S\x81\x11\x15a\x14pWa\x14oaq\x13V[[\x86`S\x81\x11\x15a\x14\x83Wa\x14\x82aq\x13V[[\x03a\x14\x92Way\x18\x90Pa\x15\xA0V[`\x04`S\x81\x11\x15a\x14\xA6Wa\x14\xA5aq\x13V[[\x86`S\x81\x11\x15a\x14\xB9Wa\x14\xB8aq\x13V[[\x03a\x14\xC8Wa}\0\x90Pa\x15\x9FV[`\x05`S\x81\x11\x15a\x14\xDCWa\x14\xDBaq\x13V[[\x86`S\x81\x11\x15a\x14\xEFWa\x14\xEEaq\x13V[[\x03a\x14\xFEWa\x84\xD0\x90Pa\x15\x9EV[`\x06`S\x81\x11\x15a\x15\x12Wa\x15\x11aq\x13V[[\x86`S\x81\x11\x15a\x15%Wa\x15$aq\x13V[[\x03a\x154Wa\x90\x88\x90Pa\x15\x9DV[`\x08`S\x81\x11\x15a\x15HWa\x15Gaq\x13V[[\x86`S\x81\x11\x15a\x15[Wa\x15Zaq\x13V[[\x03a\x15jWa\x94p\x90Pa\x15\x9CV[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[[a\x15\xAC\x81\x85\x84a`\xE7V[a\x17?V[`\x02`S\x81\x11\x15a\x15\xC5Wa\x15\xC4aq\x13V[[\x86`S\x81\x11\x15a\x15\xD8Wa\x15\xD7aq\x13V[[\x03a\x15\xE8Wb\x01cx\x90Pa\x172V[`\x03`S\x81\x11\x15a\x15\xFCWa\x15\xFBaq\x13V[[\x86`S\x81\x11\x15a\x16\x0FWa\x16\x0Eaq\x13V[[\x03a\x16\x1FWb\x01\xE8H\x90Pa\x171V[`\x04`S\x81\x11\x15a\x163Wa\x162aq\x13V[[\x86`S\x81\x11\x15a\x16FWa\x16Eaq\x13V[[\x03a\x16VWb\x02|\xB8\x90Pa\x170V[`\x05`S\x81\x11\x15a\x16jWa\x16iaq\x13V[[\x86`S\x81\x11\x15a\x16}Wa\x16|aq\x13V[[\x03a\x16\x8DWb\x030h\x90Pa\x17/V[`\x06`S\x81\x11\x15a\x16\xA1Wa\x16\xA0aq\x13V[[\x86`S\x81\x11\x15a\x16\xB4Wa\x16\xB3aq\x13V[[\x03a\x16\xC4Wb\x04=\xF0\x90Pa\x17.V[`\x08`S\x81\x11\x15a\x16\xD8Wa\x16\xD7aq\x13V[[\x86`S\x81\x11\x15a\x16\xEBWa\x16\xEAaq\x13V[[\x03a\x16\xFBWb\x05\xC4\x90\x90Pa\x17-V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[[a\x17>\x81\x85\x85\x85ab\x84V[[PPPPPPV[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x17\xC0W`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\x01`\xF8\x1B\x85~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x03a\x19\xAFW_`S\x81\x11\x15a\x18\x01Wa\x18\0aq\x13V[[\x86`S\x81\x11\x15a\x18\x14Wa\x18\x13aq\x13V[[\x03a\x18#WaU\xF0\x90Pa\x19\x9FV[`\x02`S\x81\x11\x15a\x187Wa\x186aq\x13V[[\x86`S\x81\x11\x15a\x18JWa\x18Iaq\x13V[[\x03a\x18YWay\x18\x90Pa\x19\x9EV[`\x03`S\x81\x11\x15a\x18mWa\x18laq\x13V[[\x86`S\x81\x11\x15a\x18\x80Wa\x18\x7Faq\x13V[[\x03a\x18\x8FWay\x18\x90Pa\x19\x9DV[`\x04`S\x81\x11\x15a\x18\xA3Wa\x18\xA2aq\x13V[[\x86`S\x81\x11\x15a\x18\xB6Wa\x18\xB5aq\x13V[[\x03a\x18\xC5Wa}\0\x90Pa\x19\x9CV[`\x05`S\x81\x11\x15a\x18\xD9Wa\x18\xD8aq\x13V[[\x86`S\x81\x11\x15a\x18\xECWa\x18\xEBaq\x13V[[\x03a\x18\xFBWa\x84\xD0\x90Pa\x19\x9BV[`\x06`S\x81\x11\x15a\x19\x0FWa\x19\x0Eaq\x13V[[\x86`S\x81\x11\x15a\x19\"Wa\x19!aq\x13V[[\x03a\x191Wa\x90\x88\x90Pa\x19\x9AV[`\x08`S\x81\x11\x15a\x19EWa\x19Daq\x13V[[\x86`S\x81\x11\x15a\x19XWa\x19Waq\x13V[[\x03a\x19gWa\x94p\x90Pa\x19\x99V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[[[a\x19\xAA\x81\x85\x84a`\xE7V[a\x1BmV[_`S\x81\x11\x15a\x19\xC2Wa\x19\xC1aq\x13V[[\x86`S\x81\x11\x15a\x19\xD5Wa\x19\xD4aq\x13V[[\x03a\x19\xE4Waa\xA8\x90Pa\x1B`V[`\x02`S\x81\x11\x15a\x19\xF8Wa\x19\xF7aq\x13V[[\x86`S\x81\x11\x15a\x1A\x0BWa\x1A\naq\x13V[[\x03a\x1A\x1AWay\x18\x90Pa\x1B_V[`\x03`S\x81\x11\x15a\x1A.Wa\x1A-aq\x13V[[\x86`S\x81\x11\x15a\x1AAWa\x1A@aq\x13V[[\x03a\x1APWay\x18\x90Pa\x1B^V[`\x04`S\x81\x11\x15a\x1AdWa\x1Acaq\x13V[[\x86`S\x81\x11\x15a\x1AwWa\x1Avaq\x13V[[\x03a\x1A\x86Wa}\0\x90Pa\x1B]V[`\x05`S\x81\x11\x15a\x1A\x9AWa\x1A\x99aq\x13V[[\x86`S\x81\x11\x15a\x1A\xADWa\x1A\xACaq\x13V[[\x03a\x1A\xBCWa\x84\xD0\x90Pa\x1B\\V[`\x06`S\x81\x11\x15a\x1A\xD0Wa\x1A\xCFaq\x13V[[\x86`S\x81\x11\x15a\x1A\xE3Wa\x1A\xE2aq\x13V[[\x03a\x1A\xF2Wa\x90\x88\x90Pa\x1B[V[`\x08`S\x81\x11\x15a\x1B\x06Wa\x1B\x05aq\x13V[[\x86`S\x81\x11\x15a\x1B\x19Wa\x1B\x18aq\x13V[[\x03a\x1B(Wa\x94p\x90Pa\x1BZV[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[[[a\x1Bl\x81\x85\x85\x85ab\x84V[[PPPPPPV[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x1B\xEEW`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\x01`\xF8\x1B\x85~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x03a\x1D\xA7W`\x02`S\x81\x11\x15a\x1C0Wa\x1C/aq\x13V[[\x86`S\x81\x11\x15a\x1CCWa\x1CBaq\x13V[[\x03a\x1CRWa}\0\x90Pa\x1D\x97V[`\x03`S\x81\x11\x15a\x1CfWa\x1Ceaq\x13V[[\x86`S\x81\x11\x15a\x1CyWa\x1Cxaq\x13V[[\x03a\x1C\x88Wa}\0\x90Pa\x1D\x96V[`\x04`S\x81\x11\x15a\x1C\x9CWa\x1C\x9Baq\x13V[[\x86`S\x81\x11\x15a\x1C\xAFWa\x1C\xAEaq\x13V[[\x03a\x1C\xBEWa}\0\x90Pa\x1D\x95V[`\x05`S\x81\x11\x15a\x1C\xD2Wa\x1C\xD1aq\x13V[[\x86`S\x81\x11\x15a\x1C\xE5Wa\x1C\xE4aq\x13V[[\x03a\x1C\xF4Wa\x84\xD0\x90Pa\x1D\x94V[`\x06`S\x81\x11\x15a\x1D\x08Wa\x1D\x07aq\x13V[[\x86`S\x81\x11\x15a\x1D\x1BWa\x1D\x1Aaq\x13V[[\x03a\x1D*Wa\x90\x88\x90Pa\x1D\x93V[`\x08`S\x81\x11\x15a\x1D>Wa\x1D=aq\x13V[[\x86`S\x81\x11\x15a\x1DQWa\x1DPaq\x13V[[\x03a\x1D`Wa\x94p\x90Pa\x1D\x92V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[[a\x1D\xA2\x81\x85\x84a`\xE7V[a\x1F5V[`\x02`S\x81\x11\x15a\x1D\xBBWa\x1D\xBAaq\x13V[[\x86`S\x81\x11\x15a\x1D\xCEWa\x1D\xCDaq\x13V[[\x03a\x1D\xDEWb\x01cx\x90Pa\x1F(V[`\x03`S\x81\x11\x15a\x1D\xF2Wa\x1D\xF1aq\x13V[[\x86`S\x81\x11\x15a\x1E\x05Wa\x1E\x04aq\x13V[[\x03a\x1E\x15Wb\x01\xE0x\x90Pa\x1F'V[`\x04`S\x81\x11\x15a\x1E)Wa\x1E(aq\x13V[[\x86`S\x81\x11\x15a\x1E<Wa\x1E;aq\x13V[[\x03a\x1ELWb\x02|\xB8\x90Pa\x1F&V[`\x05`S\x81\x11\x15a\x1E`Wa\x1E_aq\x13V[[\x86`S\x81\x11\x15a\x1EsWa\x1Eraq\x13V[[\x03a\x1E\x83Wb\x030h\x90Pa\x1F%V[`\x06`S\x81\x11\x15a\x1E\x97Wa\x1E\x96aq\x13V[[\x86`S\x81\x11\x15a\x1E\xAAWa\x1E\xA9aq\x13V[[\x03a\x1E\xBAWb\x04&\x80\x90Pa\x1F$V[`\x08`S\x81\x11\x15a\x1E\xCEWa\x1E\xCDaq\x13V[[\x86`S\x81\x11\x15a\x1E\xE1Wa\x1E\xE0aq\x13V[[\x03a\x1E\xF1Wb\x05\xA1h\x90Pa\x1F#V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[[a\x1F4\x81\x85\x85\x85ab\x84V[[PPPPPPV[_s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$\x90P\x90V[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x1F\xD1W`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x80`S\x81\x11\x15a\x1F\xE5Wa\x1F\xE4aq\x13V[[\x83`S\x81\x11\x15a\x1F\xF8Wa\x1F\xF7aq\x13V[[\x03a \x06W` \x90Pa!\xB2V[`\x02`S\x81\x11\x15a \x1AWa \x19aq\x13V[[\x83`S\x81\x11\x15a -Wa ,aq\x13V[[\x03a ;W` \x90Pa!\xB1V[`\x03`S\x81\x11\x15a OWa Naq\x13V[[\x83`S\x81\x11\x15a bWa aaq\x13V[[\x03a pW` \x90Pa!\xB0V[`\x04`S\x81\x11\x15a \x84Wa \x83aq\x13V[[\x83`S\x81\x11\x15a \x97Wa \x96aq\x13V[[\x03a \xA5W` \x90Pa!\xAFV[`\x05`S\x81\x11\x15a \xB9Wa \xB8aq\x13V[[\x83`S\x81\x11\x15a \xCCWa \xCBaq\x13V[[\x03a \xDAW` \x90Pa!\xAEV[`\x06`S\x81\x11\x15a \xEEWa \xEDaq\x13V[[\x83`S\x81\x11\x15a!\x01Wa!\0aq\x13V[[\x03a!\x0FW` \x90Pa!\xADV[`\x07`S\x81\x11\x15a!#Wa!\"aq\x13V[[\x83`S\x81\x11\x15a!6Wa!5aq\x13V[[\x03a!DW` \x90Pa!\xACV[`\x08`S\x81\x11\x15a!XWa!Waq\x13V[[\x83`S\x81\x11\x15a!kWa!jaq\x13V[[\x03a!yW` \x90Pa!\xABV[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[[[[a!\xBB\x81aaSV[a!\xC5\x82\x82aa\xB3V[PPPV[`\x01a!\xD4ac\x02V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\"\x15W`@Q\x7FoOs\x1F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x02_a\" ac&V[\x90P\x80_\x01`\x08\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x80a\"hWP\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81_\x01_\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x10\x15[\x15a\"\x9FW`@Q\x7F\xF9.\xE8\xA9\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x81\x81_\x01_a\x01\0\n\x81T\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP`\x01\x81_\x01`\x08a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP_\x81_\x01`\x08a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP\x7F\xC7\xF5\x05\xB2\xF3q\xAE!u\xEEI\x13\xF4I\x9E\x1F&3\xA7\xB5\x93c!\xEE\xD1\xCD\xAE\xB6\x11Q\x81\xD2\x82`@Qa#.\x91\x90ar\x8EV[`@Q\x80\x91\x03\x90\xA1PPV[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a#\xB3W`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\x01`\xF8\x1B\x85~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x03a%:W`\x02`S\x81\x11\x15a#\xF5Wa#\xF4aq\x13V[[\x86`S\x81\x11\x15a$\x08Wa$\x07aq\x13V[[\x03a$\x18Wb\x01\xDC\x90\x90Pa%*V[`\x03`S\x81\x11\x15a$,Wa$+aq\x13V[[\x86`S\x81\x11\x15a$?Wa$>aq\x13V[[\x03a$OWb\x02\xF1\xE8\x90Pa%)V[`\x04`S\x81\x11\x15a$cWa$baq\x13V[[\x86`S\x81\x11\x15a$vWa$uaq\x13V[[\x03a$\x86Wb\x04\x0B(\x90Pa%(V[`\x05`S\x81\x11\x15a$\x9AWa$\x99aq\x13V[[\x86`S\x81\x11\x15a$\xADWa$\xACaq\x13V[[\x03a$\xBDWb\x05\x91\xC8\x90Pa%'V[`\x06`S\x81\x11\x15a$\xD1Wa$\xD0aq\x13V[[\x86`S\x81\x11\x15a$\xE4Wa$\xE3aq\x13V[[\x03a$\xF4Wb\n\x9E\xC0\x90Pa%&V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[a%5\x81\x85\x84a`\xE7V[a&\x90V[`\x02`S\x81\x11\x15a%NWa%Maq\x13V[[\x86`S\x81\x11\x15a%aWa%`aq\x13V[[\x03a%qWb\x02I\xF0\x90Pa&\x83V[`\x03`S\x81\x11\x15a%\x85Wa%\x84aq\x13V[[\x86`S\x81\x11\x15a%\x98Wa%\x97aq\x13V[[\x03a%\xA8Wb\x03c0\x90Pa&\x82V[`\x04`S\x81\x11\x15a%\xBCWa%\xBBaq\x13V[[\x86`S\x81\x11\x15a%\xCFWa%\xCEaq\x13V[[\x03a%\xDFWb\x05\x01@\x90Pa&\x81V[`\x05`S\x81\x11\x15a%\xF3Wa%\xF2aq\x13V[[\x86`S\x81\x11\x15a&\x06Wa&\x05aq\x13V[[\x03a&\x16Wb\t\x18 \x90Pa&\x80V[`\x06`S\x81\x11\x15a&*Wa&)aq\x13V[[\x86`S\x81\x11\x15a&=Wa&<aq\x13V[[\x03a&MWb\x19\xB9\xF0\x90Pa&\x7FV[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[a&\x8F\x81\x85\x85\x85ab\x84V[[PPPPPPV[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a'\x11W`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\x01`\xF8\x1B\x85~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x14a'qW`@Q\x7Fj\xA9\xEB\x05\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x02`S\x81\x11\x15a'\x85Wa'\x84aq\x13V[[\x86`S\x81\x11\x15a'\x98Wa'\x97aq\x13V[[\x03a'\xA8Wb\x034P\x90Pa(\xBAV[`\x03`S\x81\x11\x15a'\xBCWa'\xBBaq\x13V[[\x86`S\x81\x11\x15a'\xCFWa'\xCEaq\x13V[[\x03a'\xDFWb\x04\x9B\xB0\x90Pa(\xB9V[`\x04`S\x81\x11\x15a'\xF3Wa'\xF2aq\x13V[[\x86`S\x81\x11\x15a(\x06Wa(\x05aq\x13V[[\x03a(\x16Wb\x06\xAE\xF0\x90Pa(\xB8V[`\x05`S\x81\x11\x15a(*Wa()aq\x13V[[\x86`S\x81\x11\x15a(=Wa(<aq\x13V[[\x03a(MWb\n\xE8\xF8\x90Pa(\xB7V[`\x06`S\x81\x11\x15a(aWa(`aq\x13V[[\x86`S\x81\x11\x15a(tWa(saq\x13V[[\x03a(\x84Wb\x12\xB1(\x90Pa(\xB6V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[a(\xC5\x81\x85\x84a`\xE7V[PPPPPPV[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a)FW`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x80`S\x81\x11\x15a)ZWa)Yaq\x13V[[\x86`S\x81\x11\x15a)mWa)laq\x13V[[\x03a)|Wa\xD6\xD8\x90Pa+1V[`\x02`S\x81\x11\x15a)\x90Wa)\x8Faq\x13V[[\x86`S\x81\x11\x15a)\xA3Wa)\xA2aq\x13V[[\x03a)\xB2Wa\xD6\xD8\x90Pa+0V[`\x03`S\x81\x11\x15a)\xC6Wa)\xC5aq\x13V[[\x86`S\x81\x11\x15a)\xD9Wa)\xD8aq\x13V[[\x03a)\xE8Wa\xD6\xD8\x90Pa+/V[`\x04`S\x81\x11\x15a)\xFCWa)\xFBaq\x13V[[\x86`S\x81\x11\x15a*\x0FWa*\x0Eaq\x13V[[\x03a*\x1EWa\xD6\xD8\x90Pa+.V[`\x05`S\x81\x11\x15a*2Wa*1aq\x13V[[\x86`S\x81\x11\x15a*EWa*Daq\x13V[[\x03a*TWa\xD6\xD8\x90Pa+-V[`\x06`S\x81\x11\x15a*hWa*gaq\x13V[[\x86`S\x81\x11\x15a*{Wa*zaq\x13V[[\x03a*\x8AWa\xDE\xA8\x90Pa+,V[`\x07`S\x81\x11\x15a*\x9EWa*\x9Daq\x13V[[\x86`S\x81\x11\x15a*\xB1Wa*\xB0aq\x13V[[\x03a*\xC1Wb\x01D8\x90Pa++V[`\x08`S\x81\x11\x15a*\xD5Wa*\xD4aq\x13V[[\x86`S\x81\x11\x15a*\xE8Wa*\xE7aq\x13V[[\x03a*\xF8Wb\x01\xA5\xE0\x90Pa+*V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[[[[a+>\x81\x86\x86\x86\x86acMV[PPPPPPV[a+Nac\xDDV[a+W\x82ad\xC3V[a+a\x82\x82ae\xB6V[PPV[_a+naf\xD4V[\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC_\x1B\x90P\x90V[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a,\x0FW`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\x01`\xF8\x1B\x85~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x03a-\x96W`\x02`S\x81\x11\x15a,QWa,Paq\x13V[[\x86`S\x81\x11\x15a,dWa,caq\x13V[[\x03a,tWb\x01H \x90Pa-\x86V[`\x03`S\x81\x11\x15a,\x88Wa,\x87aq\x13V[[\x86`S\x81\x11\x15a,\x9BWa,\x9Aaq\x13V[[\x03a,\xABWb\x01W\xC0\x90Pa-\x85V[`\x04`S\x81\x11\x15a,\xBFWa,\xBEaq\x13V[[\x86`S\x81\x11\x15a,\xD2Wa,\xD1aq\x13V[[\x03a,\xE2Wb\x01\xC9\x08\x90Pa-\x84V[`\x05`S\x81\x11\x15a,\xF6Wa,\xF5aq\x13V[[\x86`S\x81\x11\x15a-\tWa-\x08aq\x13V[[\x03a-\x19Wb\x02I\xF0\x90Pa-\x83V[`\x06`S\x81\x11\x15a--Wa-,aq\x13V[[\x86`S\x81\x11\x15a-@Wa-?aq\x13V[[\x03a-PWb\x02\xD6\x90\x90Pa-\x82V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[a-\x91\x81\x85\x84a`\xE7V[a.\xECV[`\x02`S\x81\x11\x15a-\xAAWa-\xA9aq\x13V[[\x86`S\x81\x11\x15a-\xBDWa-\xBCaq\x13V[[\x03a-\xCDWb\x01\xD0\xD8\x90Pa.\xDFV[`\x03`S\x81\x11\x15a-\xE1Wa-\xE0aq\x13V[[\x86`S\x81\x11\x15a-\xF4Wa-\xF3aq\x13V[[\x03a.\x04Wb\x02:P\x90Pa.\xDEV[`\x04`S\x81\x11\x15a.\x18Wa.\x17aq\x13V[[\x86`S\x81\x11\x15a.+Wa.*aq\x13V[[\x03a.;Wb\x02\xC6\xF0\x90Pa.\xDDV[`\x05`S\x81\x11\x15a.OWa.Naq\x13V[[\x86`S\x81\x11\x15a.bWa.aaq\x13V[[\x03a.rWb\x03Wx\x90Pa.\xDCV[`\x06`S\x81\x11\x15a.\x86Wa.\x85aq\x13V[[\x86`S\x81\x11\x15a.\x99Wa.\x98aq\x13V[[\x03a.\xA9Wb\x04h\xE8\x90Pa.\xDBV[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[a.\xEB\x81\x85\x85\x85ab\x84V[[PPPPPPV[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a/mW`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\x01`\xF8\x1B\x85~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x03a1&W`\x02`S\x81\x11\x15a/\xAFWa/\xAEaq\x13V[[\x86`S\x81\x11\x15a/\xC2Wa/\xC1aq\x13V[[\x03a/\xD1Way\x18\x90Pa1\x16V[`\x03`S\x81\x11\x15a/\xE5Wa/\xE4aq\x13V[[\x86`S\x81\x11\x15a/\xF8Wa/\xF7aq\x13V[[\x03a0\x07Way\x18\x90Pa1\x15V[`\x04`S\x81\x11\x15a0\x1BWa0\x1Aaq\x13V[[\x86`S\x81\x11\x15a0.Wa0-aq\x13V[[\x03a0=Wa}\0\x90Pa1\x14V[`\x05`S\x81\x11\x15a0QWa0Paq\x13V[[\x86`S\x81\x11\x15a0dWa0caq\x13V[[\x03a0sWa\x84\xD0\x90Pa1\x13V[`\x06`S\x81\x11\x15a0\x87Wa0\x86aq\x13V[[\x86`S\x81\x11\x15a0\x9AWa0\x99aq\x13V[[\x03a0\xA9Wa\x90\x88\x90Pa1\x12V[`\x08`S\x81\x11\x15a0\xBDWa0\xBCaq\x13V[[\x86`S\x81\x11\x15a0\xD0Wa0\xCFaq\x13V[[\x03a0\xDFWa\x9C@\x90Pa1\x11V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[[a1!\x81\x85\x84a`\xE7V[a2\xB4V[`\x02`S\x81\x11\x15a1:Wa19aq\x13V[[\x86`S\x81\x11\x15a1MWa1Laq\x13V[[\x03a1]Wb\x01kH\x90Pa2\xA7V[`\x03`S\x81\x11\x15a1qWa1paq\x13V[[\x86`S\x81\x11\x15a1\x84Wa1\x83aq\x13V[[\x03a1\x94Wb\x01\xE8H\x90Pa2\xA6V[`\x04`S\x81\x11\x15a1\xA8Wa1\xA7aq\x13V[[\x86`S\x81\x11\x15a1\xBBWa1\xBAaq\x13V[[\x03a1\xCBWb\x02q\0\x90Pa2\xA5V[`\x05`S\x81\x11\x15a1\xDFWa1\xDEaq\x13V[[\x86`S\x81\x11\x15a1\xF2Wa1\xF1aq\x13V[[\x03a2\x02Wb\x030h\x90Pa2\xA4V[`\x06`S\x81\x11\x15a2\x16Wa2\x15aq\x13V[[\x86`S\x81\x11\x15a2)Wa2(aq\x13V[[\x03a29Wb\x04Qx\x90Pa2\xA3V[`\x08`S\x81\x11\x15a2MWa2Laq\x13V[[\x86`S\x81\x11\x15a2`Wa2_aq\x13V[[\x03a2pWb\x05\xB8\xD8\x90Pa2\xA2V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[[a2\xB3\x81\x85\x85\x85ab\x84V[[PPPPPPV[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a35W`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\x01`\xF8\x1B\x85~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x03a4\xBAW`\x02`S\x81\x11\x15a3wWa3vaq\x13V[[\x86`S\x81\x11\x15a3\x8AWa3\x89aq\x13V[[\x03a3\x99Wa\xCB \x90Pa4\xAAV[`\x03`S\x81\x11\x15a3\xADWa3\xACaq\x13V[[\x86`S\x81\x11\x15a3\xC0Wa3\xBFaq\x13V[[\x03a3\xCFWa\xD6\xD8\x90Pa4\xA9V[`\x04`S\x81\x11\x15a3\xE3Wa3\xE2aq\x13V[[\x86`S\x81\x11\x15a3\xF6Wa3\xF5aq\x13V[[\x03a4\x06Wb\x01H \x90Pa4\xA8V[`\x05`S\x81\x11\x15a4\x1AWa4\x19aq\x13V[[\x86`S\x81\x11\x15a4-Wa4,aq\x13V[[\x03a4=Wb\x01\xC5 \x90Pa4\xA7V[`\x06`S\x81\x11\x15a4QWa4Paq\x13V[[\x86`S\x81\x11\x15a4dWa4caq\x13V[[\x03a4tWb\x02F\x08\x90Pa4\xA6V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[a4\xB5\x81\x85\x84a`\xE7V[a6\x0FV[`\x02`S\x81\x11\x15a4\xCEWa4\xCDaq\x13V[[\x86`S\x81\x11\x15a4\xE1Wa4\xE0aq\x13V[[\x03a4\xF0Wa\xF6\x18\x90Pa6\x02V[`\x03`S\x81\x11\x15a5\x04Wa5\x03aq\x13V[[\x86`S\x81\x11\x15a5\x17Wa5\x16aq\x13V[[\x03a5'Wb\x01H \x90Pa6\x01V[`\x04`S\x81\x11\x15a5;Wa5:aq\x13V[[\x86`S\x81\x11\x15a5NWa5Maq\x13V[[\x03a5^Wb\x01\xCC\xF0\x90Pa6\0V[`\x05`S\x81\x11\x15a5rWa5qaq\x13V[[\x86`S\x81\x11\x15a5\x85Wa5\x84aq\x13V[[\x03a5\x95Wb\x02Q\xC0\x90Pa5\xFFV[`\x06`S\x81\x11\x15a5\xA9Wa5\xA8aq\x13V[[\x86`S\x81\x11\x15a5\xBCWa5\xBBaq\x13V[[\x03a5\xCCWb\x034P\x90Pa5\xFEV[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[a6\x0E\x81\x85\x85\x85ab\x84V[[PPPPPPV[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a6\x90W`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\x01`\xF8\x1B\x85~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x03a8IW`\x02`S\x81\x11\x15a6\xD2Wa6\xD1aq\x13V[[\x86`S\x81\x11\x15a6\xE5Wa6\xE4aq\x13V[[\x03a6\xF4Wa}\0\x90Pa89V[`\x03`S\x81\x11\x15a7\x08Wa7\x07aq\x13V[[\x86`S\x81\x11\x15a7\x1BWa7\x1Aaq\x13V[[\x03a7*Wa}\0\x90Pa88V[`\x04`S\x81\x11\x15a7>Wa7=aq\x13V[[\x86`S\x81\x11\x15a7QWa7Paq\x13V[[\x03a7`Wa}\0\x90Pa87V[`\x05`S\x81\x11\x15a7tWa7saq\x13V[[\x86`S\x81\x11\x15a7\x87Wa7\x86aq\x13V[[\x03a7\x96Wa\x84\xD0\x90Pa86V[`\x06`S\x81\x11\x15a7\xAAWa7\xA9aq\x13V[[\x86`S\x81\x11\x15a7\xBDWa7\xBCaq\x13V[[\x03a7\xCCWa\x90\x88\x90Pa85V[`\x08`S\x81\x11\x15a7\xE0Wa7\xDFaq\x13V[[\x86`S\x81\x11\x15a7\xF3Wa7\xF2aq\x13V[[\x03a8\x02Wa\x98X\x90Pa84V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[[a8D\x81\x85\x84a`\xE7V[a9\xD7V[`\x02`S\x81\x11\x15a8]Wa8\\aq\x13V[[\x86`S\x81\x11\x15a8pWa8oaq\x13V[[\x03a8\x80Wb\x01g`\x90Pa9\xCAV[`\x03`S\x81\x11\x15a8\x94Wa8\x93aq\x13V[[\x86`S\x81\x11\x15a8\xA7Wa8\xA6aq\x13V[[\x03a8\xB7Wb\x01\xE8H\x90Pa9\xC9V[`\x04`S\x81\x11\x15a8\xCBWa8\xCAaq\x13V[[\x86`S\x81\x11\x15a8\xDEWa8\xDDaq\x13V[[\x03a8\xEEWb\x02x\xD0\x90Pa9\xC8V[`\x05`S\x81\x11\x15a9\x02Wa9\x01aq\x13V[[\x86`S\x81\x11\x15a9\x15Wa9\x14aq\x13V[[\x03a9%Wb\x03,\x80\x90Pa9\xC7V[`\x06`S\x81\x11\x15a99Wa98aq\x13V[[\x86`S\x81\x11\x15a9LWa9Kaq\x13V[[\x03a9\\Wb\x04&\x80\x90Pa9\xC6V[`\x08`S\x81\x11\x15a9pWa9oaq\x13V[[\x86`S\x81\x11\x15a9\x83Wa9\x82aq\x13V[[\x03a9\x93Wb\x05\xC4\x90\x90Pa9\xC5V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[[a9\xD6\x81\x85\x85\x85ab\x84V[[PPPPPPV[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a:XW`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\x01`\xF8\x1B\x85~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x03a;\xDDW`\x02`S\x81\x11\x15a:\x9AWa:\x99aq\x13V[[\x86`S\x81\x11\x15a:\xADWa:\xACaq\x13V[[\x03a:\xBCWa\xCB \x90Pa;\xCDV[`\x03`S\x81\x11\x15a:\xD0Wa:\xCFaq\x13V[[\x86`S\x81\x11\x15a:\xE3Wa:\xE2aq\x13V[[\x03a:\xF2Wa\xD6\xD8\x90Pa;\xCCV[`\x04`S\x81\x11\x15a;\x06Wa;\x05aq\x13V[[\x86`S\x81\x11\x15a;\x19Wa;\x18aq\x13V[[\x03a;)Wb\x01H \x90Pa;\xCBV[`\x05`S\x81\x11\x15a;=Wa;<aq\x13V[[\x86`S\x81\x11\x15a;PWa;Oaq\x13V[[\x03a;`Wb\x01\xC9\x08\x90Pa;\xCAV[`\x06`S\x81\x11\x15a;tWa;saq\x13V[[\x86`S\x81\x11\x15a;\x87Wa;\x86aq\x13V[[\x03a;\x97Wb\x02I\xF0\x90Pa;\xC9V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[a;\xD8\x81\x85\x84a`\xE7V[a=2V[`\x02`S\x81\x11\x15a;\xF1Wa;\xF0aq\x13V[[\x86`S\x81\x11\x15a<\x04Wa<\x03aq\x13V[[\x03a<\x13Wa\xE6x\x90Pa=%V[`\x03`S\x81\x11\x15a<'Wa<&aq\x13V[[\x86`S\x81\x11\x15a<:Wa<9aq\x13V[[\x03a<JWb\x01H \x90Pa=$V[`\x04`S\x81\x11\x15a<^Wa<]aq\x13V[[\x86`S\x81\x11\x15a<qWa<paq\x13V[[\x03a<\x81Wb\x01\xCC\xF0\x90Pa=#V[`\x05`S\x81\x11\x15a<\x95Wa<\x94aq\x13V[[\x86`S\x81\x11\x15a<\xA8Wa<\xA7aq\x13V[[\x03a<\xB8Wb\x02Q\xC0\x90Pa=\"V[`\x06`S\x81\x11\x15a<\xCCWa<\xCBaq\x13V[[\x86`S\x81\x11\x15a<\xDFWa<\xDEaq\x13V[[\x03a<\xEFWb\x03S\x90\x90Pa=!V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[a=1\x81\x85\x85\x85ab\x84V[[PPPPPPV[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a=\xB3W`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\x01`\xF8\x1B\x85~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x03a?:W`\x02`S\x81\x11\x15a=\xF5Wa=\xF4aq\x13V[[\x86`S\x81\x11\x15a>\x08Wa>\x07aq\x13V[[\x03a>\x18Wb\x01H \x90Pa?*V[`\x03`S\x81\x11\x15a>,Wa>+aq\x13V[[\x86`S\x81\x11\x15a>?Wa>>aq\x13V[[\x03a>OWb\x01kH\x90Pa?)V[`\x04`S\x81\x11\x15a>cWa>baq\x13V[[\x86`S\x81\x11\x15a>vWa>uaq\x13V[[\x03a>\x86Wb\x01s\x18\x90Pa?(V[`\x05`S\x81\x11\x15a>\x9AWa>\x99aq\x13V[[\x86`S\x81\x11\x15a>\xADWa>\xACaq\x13V[[\x03a>\xBDWb\x02\x07\x88\x90Pa?'V[`\x06`S\x81\x11\x15a>\xD1Wa>\xD0aq\x13V[[\x86`S\x81\x11\x15a>\xE4Wa>\xE3aq\x13V[[\x03a>\xF4Wb\x02\x9F\xE0\x90Pa?&V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[a?5\x81\x85\x84a`\xE7V[a@\x90V[`\x02`S\x81\x11\x15a?NWa?Maq\x13V[[\x86`S\x81\x11\x15a?aWa?`aq\x13V[[\x03a?qWb\x01cx\x90Pa@\x83V[`\x03`S\x81\x11\x15a?\x85Wa?\x84aq\x13V[[\x86`S\x81\x11\x15a?\x98Wa?\x97aq\x13V[[\x03a?\xA8Wb\x01kH\x90Pa@\x82V[`\x04`S\x81\x11\x15a?\xBCWa?\xBBaq\x13V[[\x86`S\x81\x11\x15a?\xCFWa?\xCEaq\x13V[[\x03a?\xDFWb\x01\xE8H\x90Pa@\x81V[`\x05`S\x81\x11\x15a?\xF3Wa?\xF2aq\x13V[[\x86`S\x81\x11\x15a@\x06Wa@\x05aq\x13V[[\x03a@\x16Wb\x02x\xD0\x90Pa@\x80V[`\x06`S\x81\x11\x15a@*Wa@)aq\x13V[[\x86`S\x81\x11\x15a@=Wa@<aq\x13V[[\x03a@MWb\x03\xF7\xA0\x90Pa@\x7FV[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[a@\x8F\x81\x85\x85\x85ab\x84V[[PPPPPPV[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14aA\x11W`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\x01`\xF8\x1B\x85~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x03aC<W_`S\x81\x11\x15aARWaAQaq\x13V[[\x86`S\x81\x11\x15aAeWaAdaq\x13V[[\x03aAtWaa\xA8\x90PaC,V[`\x02`S\x81\x11\x15aA\x88WaA\x87aq\x13V[[\x86`S\x81\x11\x15aA\x9BWaA\x9Aaq\x13V[[\x03aA\xAAWa\xD6\xD8\x90PaC+V[`\x03`S\x81\x11\x15aA\xBEWaA\xBDaq\x13V[[\x86`S\x81\x11\x15aA\xD1WaA\xD0aq\x13V[[\x03aA\xE0Wa\xD6\xD8\x90PaC*V[`\x04`S\x81\x11\x15aA\xF4WaA\xF3aq\x13V[[\x86`S\x81\x11\x15aB\x07WaB\x06aq\x13V[[\x03aB\x17Wb\x01@P\x90PaC)V[`\x05`S\x81\x11\x15aB+WaB*aq\x13V[[\x86`S\x81\x11\x15aB>WaB=aq\x13V[[\x03aBNWb\x01D8\x90PaC(V[`\x06`S\x81\x11\x15aBbWaBaaq\x13V[[\x86`S\x81\x11\x15aBuWaBtaq\x13V[[\x03aB\x85Wb\x01\xC9\x08\x90PaC'V[`\x07`S\x81\x11\x15aB\x99WaB\x98aq\x13V[[\x86`S\x81\x11\x15aB\xACWaB\xABaq\x13V[[\x03aB\xBCWb\x01\xC9\x08\x90PaC&V[`\x08`S\x81\x11\x15aB\xD0WaB\xCFaq\x13V[[\x86`S\x81\x11\x15aB\xE3WaB\xE2aq\x13V[[\x03aB\xF3Wb\x01\xCC\xF0\x90PaC%V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[[[[aC7\x81\x85\x84a`\xE7V[aE7V[_`S\x81\x11\x15aCOWaCNaq\x13V[[\x86`S\x81\x11\x15aCbWaCaaq\x13V[[\x03aCqWae\x90\x90PaE*V[`\x02`S\x81\x11\x15aC\x85WaC\x84aq\x13V[[\x86`S\x81\x11\x15aC\x98WaC\x97aq\x13V[[\x03aC\xA7Wa\xD6\xD8\x90PaE)V[`\x03`S\x81\x11\x15aC\xBBWaC\xBAaq\x13V[[\x86`S\x81\x11\x15aC\xCEWaC\xCDaq\x13V[[\x03aC\xDEWb\x01D8\x90PaE(V[`\x04`S\x81\x11\x15aC\xF2WaC\xF1aq\x13V[[\x86`S\x81\x11\x15aD\x05WaD\x04aq\x13V[[\x03aD\x15Wb\x01O\xF0\x90PaE'V[`\x05`S\x81\x11\x15aD)WaD(aq\x13V[[\x86`S\x81\x11\x15aD<WaD;aq\x13V[[\x03aDLWb\x01\xD4\xC0\x90PaE&V[`\x06`S\x81\x11\x15aD`WaD_aq\x13V[[\x86`S\x81\x11\x15aDsWaDraq\x13V[[\x03aD\x83Wb\x01\xDC\x90\x90PaE%V[`\x07`S\x81\x11\x15aD\x97WaD\x96aq\x13V[[\x86`S\x81\x11\x15aD\xAAWaD\xA9aq\x13V[[\x03aD\xBAWb\x02\x17(\x90PaE$V[`\x08`S\x81\x11\x15aD\xCEWaD\xCDaq\x13V[[\x86`S\x81\x11\x15aD\xE1WaD\xE0aq\x13V[[\x03aD\xF1Wb\x02Q\xC0\x90PaE#V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[[[[aE6\x81\x85\x85\x85ab\x84V[[PPPPPPV[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14aE\xB8W`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\x02`S\x81\x11\x15aE\xCDWaE\xCCaq\x13V[[\x84`S\x81\x11\x15aE\xE0WaE\xDFaq\x13V[[\x03aE\xF0Wb\x014\x98\x90PaG:V[`\x03`S\x81\x11\x15aF\x04WaF\x03aq\x13V[[\x84`S\x81\x11\x15aF\x17WaF\x16aq\x13V[[\x03aF'Wb\x01kH\x90PaG9V[`\x04`S\x81\x11\x15aF;WaF:aq\x13V[[\x84`S\x81\x11\x15aFNWaFMaq\x13V[[\x03aF^Wb\x01s\x18\x90PaG8V[`\x05`S\x81\x11\x15aFrWaFqaq\x13V[[\x84`S\x81\x11\x15aF\x85WaF\x84aq\x13V[[\x03aF\x95Wb\x01\xFF\xB8\x90PaG7V[`\x06`S\x81\x11\x15aF\xA9WaF\xA8aq\x13V[[\x84`S\x81\x11\x15aF\xBCWaF\xBBaq\x13V[[\x03aF\xCCWb\x02\x90@\x90PaG6V[`\x08`S\x81\x11\x15aF\xE0WaF\xDFaq\x13V[[\x84`S\x81\x11\x15aF\xF3WaF\xF2aq\x13V[[\x03aG\x03Wb\x04\x1A\xC8\x90PaG5V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[[aGE\x81\x84\x84a`\xE7V[PPPPV[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14aG\xC4W`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\x01`\xF8\x1B\x85~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x03aIKW`\x02`S\x81\x11\x15aH\x06WaH\x05aq\x13V[[\x86`S\x81\x11\x15aH\x19WaH\x18aq\x13V[[\x03aH)Wb\x01[\xA8\x90PaI;V[`\x03`S\x81\x11\x15aH=WaH<aq\x13V[[\x86`S\x81\x11\x15aHPWaHOaq\x13V[[\x03aH`Wb\x01[\xA8\x90PaI:V[`\x04`S\x81\x11\x15aHtWaHsaq\x13V[[\x86`S\x81\x11\x15aH\x87WaH\x86aq\x13V[[\x03aH\x97Wb\x01\xC9\x08\x90PaI9V[`\x05`S\x81\x11\x15aH\xABWaH\xAAaq\x13V[[\x86`S\x81\x11\x15aH\xBEWaH\xBDaq\x13V[[\x03aH\xCEWb\x02F\x08\x90PaI8V[`\x06`S\x81\x11\x15aH\xE2WaH\xE1aq\x13V[[\x86`S\x81\x11\x15aH\xF5WaH\xF4aq\x13V[[\x03aI\x05Wb\x02\xBF \x90PaI7V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[aIF\x81\x85\x84a`\xE7V[aJ\xA1V[`\x02`S\x81\x11\x15aI_WaI^aq\x13V[[\x86`S\x81\x11\x15aIrWaIqaq\x13V[[\x03aI\x82Wb\x01\xD8\xA8\x90PaJ\x94V[`\x03`S\x81\x11\x15aI\x96WaI\x95aq\x13V[[\x86`S\x81\x11\x15aI\xA9WaI\xA8aq\x13V[[\x03aI\xB9Wb\x026h\x90PaJ\x93V[`\x04`S\x81\x11\x15aI\xCDWaI\xCCaq\x13V[[\x86`S\x81\x11\x15aI\xE0WaI\xDFaq\x13V[[\x03aI\xF0Wb\x02\xBF \x90PaJ\x92V[`\x05`S\x81\x11\x15aJ\x04WaJ\x03aq\x13V[[\x86`S\x81\x11\x15aJ\x17WaJ\x16aq\x13V[[\x03aJ'Wb\x03S\x90\x90PaJ\x91V[`\x06`S\x81\x11\x15aJ;WaJ:aq\x13V[[\x86`S\x81\x11\x15aJNWaJMaq\x13V[[\x03aJ^Wb\x04l\xD0\x90PaJ\x90V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[aJ\xA0\x81\x85\x85\x85ab\x84V[[PPPPPPV[`@Q\x80`@\x01`@R\x80`\x05\x81R` \x01\x7F5.0.0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81RP\x81V[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14aK[W`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\x02`S\x81\x11\x15aKpWaKoaq\x13V[[\x83`S\x81\x11\x15aK\x83WaK\x82aq\x13V[[\x03aK\x92WaY\xD8\x90PaL\xD7V[`\x03`S\x81\x11\x15aK\xA6WaK\xA5aq\x13V[[\x83`S\x81\x11\x15aK\xB9WaK\xB8aq\x13V[[\x03aK\xC8WaY\xD8\x90PaL\xD6V[`\x04`S\x81\x11\x15aK\xDCWaK\xDBaq\x13V[[\x83`S\x81\x11\x15aK\xEFWaK\xEEaq\x13V[[\x03aK\xFEWa]\xC0\x90PaL\xD5V[`\x05`S\x81\x11\x15aL\x12WaL\x11aq\x13V[[\x83`S\x81\x11\x15aL%WaL$aq\x13V[[\x03aL4Wa]\xC0\x90PaL\xD4V[`\x06`S\x81\x11\x15aLHWaLGaq\x13V[[\x83`S\x81\x11\x15aL[WaLZaq\x13V[[\x03aLjWaa\xA8\x90PaL\xD3V[`\x08`S\x81\x11\x15aL~WaL}aq\x13V[[\x83`S\x81\x11\x15aL\x91WaL\x90aq\x13V[[\x03aL\xA0Wau0\x90PaL\xD2V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[[aL\xE0\x81aaSV[aL\xEA\x82\x82aa\xB3V[PPPV[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14aMhW`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\x01`\xF8\x1B\x85~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x03aN\xEDW`\x02`S\x81\x11\x15aM\xAAWaM\xA9aq\x13V[[\x86`S\x81\x11\x15aM\xBDWaM\xBCaq\x13V[[\x03aM\xCCWa\xE2\x90\x90PaN\xDDV[`\x03`S\x81\x11\x15aM\xE0WaM\xDFaq\x13V[[\x86`S\x81\x11\x15aM\xF3WaM\xF2aq\x13V[[\x03aN\x02Wa\xE2\x90\x90PaN\xDCV[`\x04`S\x81\x11\x15aN\x16WaN\x15aq\x13V[[\x86`S\x81\x11\x15aN)WaN(aq\x13V[[\x03aN9Wb\x01H \x90PaN\xDBV[`\x05`S\x81\x11\x15aNMWaNLaq\x13V[[\x86`S\x81\x11\x15aN`WaN_aq\x13V[[\x03aNpWb\x01\xD0\xD8\x90PaN\xDAV[`\x06`S\x81\x11\x15aN\x84WaN\x83aq\x13V[[\x86`S\x81\x11\x15aN\x97WaN\x96aq\x13V[[\x03aN\xA7Wb\x02I\xF0\x90PaN\xD9V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[aN\xE8\x81\x85\x84a`\xE7V[aPBV[`\x02`S\x81\x11\x15aO\x01WaO\0aq\x13V[[\x86`S\x81\x11\x15aO\x14WaO\x13aq\x13V[[\x03aO#Wa\xE2\x90\x90PaP5V[`\x03`S\x81\x11\x15aO7WaO6aq\x13V[[\x86`S\x81\x11\x15aOJWaOIaq\x13V[[\x03aOZWb\x01D8\x90PaP4V[`\x04`S\x81\x11\x15aOnWaOmaq\x13V[[\x86`S\x81\x11\x15aO\x81WaO\x80aq\x13V[[\x03aO\x91Wb\x01\xC9\x08\x90PaP3V[`\x05`S\x81\x11\x15aO\xA5WaO\xA4aq\x13V[[\x86`S\x81\x11\x15aO\xB8WaO\xB7aq\x13V[[\x03aO\xC8Wb\x02F\x08\x90PaP2V[`\x06`S\x81\x11\x15aO\xDCWaO\xDBaq\x13V[[\x86`S\x81\x11\x15aO\xEFWaO\xEEaq\x13V[[\x03aO\xFFWb\x03S\x90\x90PaP1V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[aPA\x81\x85\x85\x85ab\x84V[[PPPPPPV[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14aP\xC3W`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\x01`\xF8\x1B\x85~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x03aR\xB2W_`S\x81\x11\x15aQ\x04WaQ\x03aq\x13V[[\x86`S\x81\x11\x15aQ\x17WaQ\x16aq\x13V[[\x03aQ&WaU\xF0\x90PaR\xA2V[`\x02`S\x81\x11\x15aQ:WaQ9aq\x13V[[\x86`S\x81\x11\x15aQMWaQLaq\x13V[[\x03aQ\\Wau0\x90PaR\xA1V[`\x03`S\x81\x11\x15aQpWaQoaq\x13V[[\x86`S\x81\x11\x15aQ\x83WaQ\x82aq\x13V[[\x03aQ\x92Wau0\x90PaR\xA0V[`\x04`S\x81\x11\x15aQ\xA6WaQ\xA5aq\x13V[[\x86`S\x81\x11\x15aQ\xB9WaQ\xB8aq\x13V[[\x03aQ\xC8Wa}\0\x90PaR\x9FV[`\x05`S\x81\x11\x15aQ\xDCWaQ\xDBaq\x13V[[\x86`S\x81\x11\x15aQ\xEFWaQ\xEEaq\x13V[[\x03aQ\xFEWa\x84\xD0\x90PaR\x9EV[`\x06`S\x81\x11\x15aR\x12WaR\x11aq\x13V[[\x86`S\x81\x11\x15aR%WaR$aq\x13V[[\x03aR4Wa\x90\x88\x90PaR\x9DV[`\x08`S\x81\x11\x15aRHWaRGaq\x13V[[\x86`S\x81\x11\x15aR[WaRZaq\x13V[[\x03aRjWa\x94p\x90PaR\x9CV[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[[[aR\xAD\x81\x85\x84a`\xE7V[aTpV[_`S\x81\x11\x15aR\xC5WaR\xC4aq\x13V[[\x86`S\x81\x11\x15aR\xD8WaR\xD7aq\x13V[[\x03aR\xE7Wa]\xC0\x90PaTcV[`\x02`S\x81\x11\x15aR\xFBWaR\xFAaq\x13V[[\x86`S\x81\x11\x15aS\x0EWaS\raq\x13V[[\x03aS\x1DWau0\x90PaTbV[`\x03`S\x81\x11\x15aS1WaS0aq\x13V[[\x86`S\x81\x11\x15aSDWaSCaq\x13V[[\x03aSSWay\x18\x90PaTaV[`\x04`S\x81\x11\x15aSgWaSfaq\x13V[[\x86`S\x81\x11\x15aSzWaSyaq\x13V[[\x03aS\x89Wa}\0\x90PaT`V[`\x05`S\x81\x11\x15aS\x9DWaS\x9Caq\x13V[[\x86`S\x81\x11\x15aS\xB0WaS\xAFaq\x13V[[\x03aS\xBFWa\x84\xD0\x90PaT_V[`\x06`S\x81\x11\x15aS\xD3WaS\xD2aq\x13V[[\x86`S\x81\x11\x15aS\xE6WaS\xE5aq\x13V[[\x03aS\xF5Wa\x90\x88\x90PaT^V[`\x08`S\x81\x11\x15aT\tWaT\x08aq\x13V[[\x86`S\x81\x11\x15aT\x1CWaT\x1Baq\x13V[[\x03aT+Wa\x94p\x90PaT]V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[[[aTo\x81\x85\x85\x85ab\x84V[[PPPPPPV[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14aT\xF1W`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\x01`\xF8\x1B\x85~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x14aUQW`@Q\x7Fj\xA9\xEB\x05\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x02`S\x81\x11\x15aUeWaUdaq\x13V[[\x86`S\x81\x11\x15aUxWaUwaq\x13V[[\x03aU\x88Wb\x06\xB6\xC0\x90PaV\x9AV[`\x03`S\x81\x11\x15aU\x9CWaU\x9Baq\x13V[[\x86`S\x81\x11\x15aU\xAFWaU\xAEaq\x13V[[\x03aU\xBFWb\x08\xD9\xA0\x90PaV\x99V[`\x04`S\x81\x11\x15aU\xD3WaU\xD2aq\x13V[[\x86`S\x81\x11\x15aU\xE6WaU\xE5aq\x13V[[\x03aU\xF6Wb\x0C\x15\xC0\x90PaV\x98V[`\x05`S\x81\x11\x15aV\nWaV\taq\x13V[[\x86`S\x81\x11\x15aV\x1DWaV\x1Caq\x13V[[\x03aV-Wb\x11\x97\xE8\x90PaV\x97V[`\x06`S\x81\x11\x15aVAWaV@aq\x13V[[\x86`S\x81\x11\x15aVTWaVSaq\x13V[[\x03aVdWb\x1D\xA5\xD8\x90PaV\x96V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[aV\xA5\x81\x85\x84a`\xE7V[PPPPPPV[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14aW&W`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\x01`\xF8\x1B\x85~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x03aYQW_`S\x81\x11\x15aWgWaWfaq\x13V[[\x86`S\x81\x11\x15aWzWaWyaq\x13V[[\x03aW\x89WaY\xD8\x90PaYAV[`\x02`S\x81\x11\x15aW\x9DWaW\x9Caq\x13V[[\x86`S\x81\x11\x15aW\xB0WaW\xAFaq\x13V[[\x03aW\xBFWa\xD6\xD8\x90PaY@V[`\x03`S\x81\x11\x15aW\xD3WaW\xD2aq\x13V[[\x86`S\x81\x11\x15aW\xE6WaW\xE5aq\x13V[[\x03aW\xF5Wa\xD6\xD8\x90PaY?V[`\x04`S\x81\x11\x15aX\tWaX\x08aq\x13V[[\x86`S\x81\x11\x15aX\x1CWaX\x1Baq\x13V[[\x03aX,Wb\x01D8\x90PaY>V[`\x05`S\x81\x11\x15aX@WaX?aq\x13V[[\x86`S\x81\x11\x15aXSWaXRaq\x13V[[\x03aXcWb\x01H \x90PaY=V[`\x06`S\x81\x11\x15aXwWaXvaq\x13V[[\x86`S\x81\x11\x15aX\x8AWaX\x89aq\x13V[[\x03aX\x9AWb\x01\xC9\x08\x90PaY<V[`\x07`S\x81\x11\x15aX\xAEWaX\xADaq\x13V[[\x86`S\x81\x11\x15aX\xC1WaX\xC0aq\x13V[[\x03aX\xD1Wb\x01\xC9\x08\x90PaY;V[`\x08`S\x81\x11\x15aX\xE5WaX\xE4aq\x13V[[\x86`S\x81\x11\x15aX\xF8WaX\xF7aq\x13V[[\x03aY\x08Wb\x01\xC9\x08\x90PaY:V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[[[[aYL\x81\x85\x84a`\xE7V[a[LV[_`S\x81\x11\x15aYdWaYcaq\x13V[[\x86`S\x81\x11\x15aYwWaYvaq\x13V[[\x03aY\x86WaY\xD8\x90Pa[?V[`\x02`S\x81\x11\x15aY\x9AWaY\x99aq\x13V[[\x86`S\x81\x11\x15aY\xADWaY\xACaq\x13V[[\x03aY\xBCWa\xD6\xD8\x90Pa[>V[`\x03`S\x81\x11\x15aY\xD0WaY\xCFaq\x13V[[\x86`S\x81\x11\x15aY\xE3WaY\xE2aq\x13V[[\x03aY\xF3Wb\x01D8\x90Pa[=V[`\x04`S\x81\x11\x15aZ\x07WaZ\x06aq\x13V[[\x86`S\x81\x11\x15aZ\x1AWaZ\x19aq\x13V[[\x03aZ*Wb\x01L\x08\x90Pa[<V[`\x05`S\x81\x11\x15aZ>WaZ=aq\x13V[[\x86`S\x81\x11\x15aZQWaZPaq\x13V[[\x03aZaWb\x01\xCC\xF0\x90Pa[;V[`\x06`S\x81\x11\x15aZuWaZtaq\x13V[[\x86`S\x81\x11\x15aZ\x88WaZ\x87aq\x13V[[\x03aZ\x98Wb\x01\xDC\x90\x90Pa[:V[`\x07`S\x81\x11\x15aZ\xACWaZ\xABaq\x13V[[\x86`S\x81\x11\x15aZ\xBFWaZ\xBEaq\x13V[[\x03aZ\xCFWb\x02\x13@\x90Pa[9V[`\x08`S\x81\x11\x15aZ\xE3WaZ\xE2aq\x13V[[\x86`S\x81\x11\x15aZ\xF6WaZ\xF5aq\x13V[[\x03a[\x06Wb\x02I\xF0\x90Pa[8V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[[[[a[K\x81\x85\x85\x85ab\x84V[[PPPPPPV[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a[\xCDW`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x80`S\x81\x11\x15a[\xE1Wa[\xE0aq\x13V[[\x84`S\x81\x11\x15a[\xF4Wa[\xF3aq\x13V[[\x03a\\\x02W`\x02\x90Pa]xV[`\x02`S\x81\x11\x15a\\\x16Wa\\\x15aq\x13V[[\x84`S\x81\x11\x15a\\)Wa\\(aq\x13V[[\x03a\\7W`\t\x90Pa]wV[`\x03`S\x81\x11\x15a\\KWa\\Jaq\x13V[[\x84`S\x81\x11\x15a\\^Wa\\]aq\x13V[[\x03a\\lW`\x10\x90Pa]vV[`\x04`S\x81\x11\x15a\\\x80Wa\\\x7Faq\x13V[[\x84`S\x81\x11\x15a\\\x93Wa\\\x92aq\x13V[[\x03a\\\xA1W` \x90Pa]uV[`\x05`S\x81\x11\x15a\\\xB5Wa\\\xB4aq\x13V[[\x84`S\x81\x11\x15a\\\xC8Wa\\\xC7aq\x13V[[\x03a\\\xD6W`?\x90Pa]tV[`\x06`S\x81\x11\x15a\\\xEAWa\\\xE9aq\x13V[[\x84`S\x81\x11\x15a\\\xFDWa\\\xFCaq\x13V[[\x03a]\x0BW`\x82\x90Pa]sV[`\x08`S\x81\x11\x15a]\x1FWa]\x1Eaq\x13V[[\x84`S\x81\x11\x15a]2Wa]1aq\x13V[[\x03a]@W`\x82\x90Pa]rV[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[[[a]\x83\x81\x84\x84a`\xE7V[PPPPV[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a^\x02W`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\x01`\xF8\x1B\x85~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x03a_\x89W`\x02`S\x81\x11\x15a^DWa^Caq\x13V[[\x86`S\x81\x11\x15a^WWa^Vaq\x13V[[\x03a^gWb\x01H \x90Pa_yV[`\x03`S\x81\x11\x15a^{Wa^zaq\x13V[[\x86`S\x81\x11\x15a^\x8EWa^\x8Daq\x13V[[\x03a^\x9EWb\x01kH\x90Pa_xV[`\x04`S\x81\x11\x15a^\xB2Wa^\xB1aq\x13V[[\x86`S\x81\x11\x15a^\xC5Wa^\xC4aq\x13V[[\x03a^\xD5Wb\x01s\x18\x90Pa_wV[`\x05`S\x81\x11\x15a^\xE9Wa^\xE8aq\x13V[[\x86`S\x81\x11\x15a^\xFCWa^\xFBaq\x13V[[\x03a_\x0CWb\x02\x07\x88\x90Pa_vV[`\x06`S\x81\x11\x15a_ Wa_\x1Faq\x13V[[\x86`S\x81\x11\x15a_3Wa_2aq\x13V[[\x03a_CWb\x02\x9F\xE0\x90Pa_uV[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[a_\x84\x81\x85\x84a`\xE7V[a`\xDFV[`\x02`S\x81\x11\x15a_\x9DWa_\x9Caq\x13V[[\x86`S\x81\x11\x15a_\xB0Wa_\xAFaq\x13V[[\x03a_\xC0Wb\x01W\xC0\x90Pa`\xD2V[`\x03`S\x81\x11\x15a_\xD4Wa_\xD3aq\x13V[[\x86`S\x81\x11\x15a_\xE7Wa_\xE6aq\x13V[[\x03a_\xF7Wb\x01kH\x90Pa`\xD1V[`\x04`S\x81\x11\x15a`\x0BWa`\naq\x13V[[\x86`S\x81\x11\x15a`\x1EWa`\x1Daq\x13V[[\x03a`.Wb\x01\xE8H\x90Pa`\xD0V[`\x05`S\x81\x11\x15a`BWa`Aaq\x13V[[\x86`S\x81\x11\x15a`UWa`Taq\x13V[[\x03a`eWb\x02x\xD0\x90Pa`\xCFV[`\x06`S\x81\x11\x15a`yWa`xaq\x13V[[\x86`S\x81\x11\x15a`\x8CWa`\x8Baq\x13V[[\x03a`\x9CWb\x03\xF3\xB8\x90Pa`\xCEV[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[a`\xDE\x81\x85\x85\x85ab\x84V[[PPPPPPV[a`\xF0\x83aaSV[_a`\xFA\x83ag[V[\x84aa\x05\x91\x90ar\xDDV[\x90PbLK@\x81\x10aaCW`@Q\x7F\xFC4Hp\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[aaM\x82\x82aa\xB3V[PPPPV[_aa\\ageV[\x82aag\x91\x90ar\xDDV[\x90Pc\x011-\0\x81\x10aa\xA6W`@Q\x7Fw\xE3\xC2\x93\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[aa\xAF\x81agmV[PPV[\x80\x82]PPV[``_`\x01aa\xC8\x84agsV[\x01\x90P_\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15aa\xE6Waa\xE5aomV[[`@Q\x90\x80\x82R\x80`\x1F\x01`\x1F\x19\x16` \x01\x82\x01`@R\x80\x15ab\x18W\x81` \x01`\x01\x82\x02\x806\x837\x80\x82\x01\x91PP\x90P[P\x90P_\x82` \x01\x82\x01\x90P[`\x01\x15abyW\x80\x80`\x01\x90\x03\x91PP\x7F0123456789abcdef\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\n\x86\x06\x1A\x81S`\n\x85\x81abnWabmas\x10V[[\x04\x94P_\x85\x03ab%W[\x81\x93PPPP\x91\x90PV[ab\x8D\x84aaSV[_ab\xA8ab\x9A\x85ag[V[ab\xA3\x85ag[V[ah\xC4V[\x85ab\xB3\x91\x90ar\xDDV[\x90PbLK@\x81\x10ab\xF1W`@Q\x7F\xFC4Hp\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[ab\xFB\x82\x82aa\xB3V[PPPPPV[_ac\x0Bac&V[_\x01_\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P\x90V[_\x7F\xF0\xC5~\x16\x84\r\xF0@\xF1P\x88\xDC/\x81\xFE9\x1C9#\xBE\xC7>#\xA9f.\xFC\x9C\"\x9Cj\0\x90P\x90V[acV\x85aaSV[_ac\x82acc\x86ag[V[ac}aco\x87ag[V[acx\x87ag[V[ah\xC4V[ah\xC4V[\x86ac\x8D\x91\x90ar\xDDV[\x90PbLK@\x81\x10ac\xCBW`@Q\x7F\xFC4Hp\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[ac\xD5\x82\x82aa\xB3V[PPPPPPV[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x160s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14\x80ad\x8AWP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16adqah\xDDV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14\x15[\x15ad\xC1W`@Q\x7F\xE0|\x8D\xBA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[V[sP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x8D\xA5\xCB[`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15ae W=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90aeD\x91\x90asQV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14ae\xB3W3`@Q\x7F!\xBF\xDA\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01ae\xAA\x91\x90an\xABV[`@Q\x80\x91\x03\x90\xFD[PV[\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16cR\xD1\x90-`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x92PPP\x80\x15af\x1EWP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90af\x1B\x91\x90as\x90V[`\x01[af_W\x81`@Q\x7FL\x9C\x8C\xE3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01afV\x91\x90an\xABV[`@Q\x80\x91\x03\x90\xFD[\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC_\x1B\x81\x14af\xC5W\x80`@Q\x7F\xAA\x1DI\xA4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01af\xBC\x91\x90ap\xFAV[`@Q\x80\x91\x03\x90\xFD[af\xCF\x83\x83ai0V[PPPV[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x160s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14agYW`@Q\x7F\xE0|\x8D\xBA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[V[_\x81\\\x90P\x91\x90PV[_\x80\\\x90P\x90V[\x80_]PV[_\x80_\x90Pz\x18O\x03\xE9?\xF9\xF4\xDA\xA7\x97\xEDn8\xEDd\xBFj\x1F\x01\0\0\0\0\0\0\0\0\x83\x10ag\xCFWz\x18O\x03\xE9?\xF9\xF4\xDA\xA7\x97\xEDn8\xEDd\xBFj\x1F\x01\0\0\0\0\0\0\0\0\x83\x81ag\xC5Wag\xC4as\x10V[[\x04\x92P`@\x81\x01\x90P[m\x04\xEE-mA[\x85\xAC\xEF\x81\0\0\0\0\x83\x10ah\x0CWm\x04\xEE-mA[\x85\xAC\xEF\x81\0\0\0\0\x83\x81ah\x02Wah\x01as\x10V[[\x04\x92P` \x81\x01\x90P[f#\x86\xF2o\xC1\0\0\x83\x10ah;Wf#\x86\xF2o\xC1\0\0\x83\x81ah1Wah0as\x10V[[\x04\x92P`\x10\x81\x01\x90P[c\x05\xF5\xE1\0\x83\x10ahdWc\x05\xF5\xE1\0\x83\x81ahZWahYas\x10V[[\x04\x92P`\x08\x81\x01\x90P[a'\x10\x83\x10ah\x89Wa'\x10\x83\x81ah\x7FWah~as\x10V[[\x04\x92P`\x04\x81\x01\x90P[`d\x83\x10ah\xACW`d\x83\x81ah\xA2Wah\xA1as\x10V[[\x04\x92P`\x02\x81\x01\x90P[`\n\x83\x10ah\xBBW`\x01\x81\x01\x90P[\x80\x91PP\x91\x90PV[_\x81\x83\x10\x15ah\xD3W\x81ah\xD5V[\x82[\x90P\x92\x91PPV[_ai\t\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC_\x1Bai\xA2V[_\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P\x90V[ai9\x82ai\xABV[\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xBC|\xD7Z \xEE'\xFD\x9A\xDE\xBA\xB3 A\xF7U!M\xBCk\xFF\xA9\x0C\xC0\"[9\xDA.\\-;`@Q`@Q\x80\x91\x03\x90\xA2_\x81Q\x11\x15ai\x95Wai\x8F\x82\x82ajtV[Pai\x9EV[ai\x9Daj\xF4V[[PPV[_\x81\x90P\x91\x90PV[_\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16;\x03aj\x06W\x80`@Q\x7FL\x9C\x8C\xE3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01ai\xFD\x91\x90an\xABV[`@Q\x80\x91\x03\x90\xFD[\x80aj2\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC_\x1Bai\xA2V[_\x01_a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UPPV[``_\x80\x84s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x84`@Qaj\x9D\x91\x90as\xFFV[_`@Q\x80\x83\x03\x81\x85Z\xF4\x91PP=\x80_\x81\x14aj\xD5W`@Q\x91P`\x1F\x19`?=\x01\x16\x82\x01`@R=\x82R=_` \x84\x01>aj\xDAV[``\x91P[P\x91P\x91Paj\xEA\x85\x83\x83ak0V[\x92PPP\x92\x91PPV[_4\x11\x15ak.W`@Q\x7F\xB3\x98\x97\x9F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[V[``\x82akEWak@\x82ak\xBDV[ak\xB5V[_\x82Q\x14\x80\x15akkWP_\x84s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16;\x14[\x15ak\xADW\x83`@Q\x7F\x99\x96\xB3\x15\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01ak\xA4\x91\x90an\xABV[`@Q\x80\x91\x03\x90\xFD[\x81\x90Pak\xB6V[[\x93\x92PPPV[_\x81Q\x11\x15ak\xCFW\x80Q\x80\x82` \x01\xFD[`@Q\x7F\xD6\xBD\xA2u\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`@Q\x90P\x90V[_\x80\xFD[_\x80\xFD[`T\x81\x10al\x1EW_\x80\xFD[PV[_\x815\x90Pal/\x81al\x12V[\x92\x91PPV[_\x81\x90P\x91\x90PV[alG\x81al5V[\x81\x14alQW_\x80\xFD[PV[_\x815\x90Palb\x81al>V[\x92\x91PPV[_\x80_``\x84\x86\x03\x12\x15al\x7FWal~al\nV[[_al\x8C\x86\x82\x87\x01al!V[\x93PP` al\x9D\x86\x82\x87\x01alTV[\x92PP`@al\xAE\x86\x82\x87\x01alTV[\x91PP\x92P\x92P\x92V[_\x80`@\x83\x85\x03\x12\x15al\xCEWal\xCDal\nV[[_al\xDB\x85\x82\x86\x01al!V[\x92PP` al\xEC\x85\x82\x86\x01alTV[\x91PP\x92P\x92\x90PV[_\x81Q\x90P\x91\x90PV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[_[\x83\x81\x10\x15am-W\x80\x82\x01Q\x81\x84\x01R` \x81\x01\x90Pam\x12V[_\x84\x84\x01RPPPPV[_`\x1F\x19`\x1F\x83\x01\x16\x90P\x91\x90PV[_amR\x82al\xF6V[am\\\x81\x85am\0V[\x93Paml\x81\x85` \x86\x01am\x10V[amu\x81am8V[\x84\x01\x91PP\x92\x91PPV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ram\x98\x81\x84amHV[\x90P\x92\x91PPV[_\x7F\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\x16\x90P\x91\x90PV[am\xD4\x81am\xA0V[\x81\x14am\xDEW_\x80\xFD[PV[_\x815\x90Pam\xEF\x81am\xCBV[\x92\x91PPV[_\x80_\x80_`\xA0\x86\x88\x03\x12\x15an\x0EWan\ral\nV[[_an\x1B\x88\x82\x89\x01al!V[\x95PP` an,\x88\x82\x89\x01am\xE1V[\x94PP`@an=\x88\x82\x89\x01alTV[\x93PP``anN\x88\x82\x89\x01alTV[\x92PP`\x80an_\x88\x82\x89\x01alTV[\x91PP\x92\x95P\x92\x95\x90\x93PV[_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[_an\x95\x82anlV[\x90P\x91\x90PV[an\xA5\x81an\x8BV[\x82RPPV[_` \x82\x01\x90Pan\xBE_\x83\x01\x84an\x9CV[\x92\x91PPV[_\x80_\x80_`\xA0\x86\x88\x03\x12\x15an\xDDWan\xDCal\nV[[_an\xEA\x88\x82\x89\x01al!V[\x95PP` an\xFB\x88\x82\x89\x01alTV[\x94PP`@ao\x0C\x88\x82\x89\x01alTV[\x93PP``ao\x1D\x88\x82\x89\x01alTV[\x92PP`\x80ao.\x88\x82\x89\x01alTV[\x91PP\x92\x95P\x92\x95\x90\x93PV[aoD\x81an\x8BV[\x81\x14aoNW_\x80\xFD[PV[_\x815\x90Pao_\x81ao;V[\x92\x91PPV[_\x80\xFD[_\x80\xFD[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`A`\x04R`$_\xFD[ao\xA3\x82am8V[\x81\x01\x81\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17\x15ao\xC2Wao\xC1aomV[[\x80`@RPPPV[_ao\xD4al\x01V[\x90Pao\xE0\x82\x82ao\x9AV[\x91\x90PV[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15ao\xFFWao\xFEaomV[[ap\x08\x82am8V[\x90P` \x81\x01\x90P\x91\x90PV[\x82\x81\x837_\x83\x83\x01RPPPV[_ap5ap0\x84ao\xE5V[ao\xCBV[\x90P\x82\x81R` \x81\x01\x84\x84\x84\x01\x11\x15apQWapPaoiV[[ap\\\x84\x82\x85ap\x15V[P\x93\x92PPPV[_\x82`\x1F\x83\x01\x12apxWapwaoeV[[\x815ap\x88\x84\x82` \x86\x01ap#V[\x91PP\x92\x91PPV[_\x80`@\x83\x85\x03\x12\x15ap\xA7Wap\xA6al\nV[[_ap\xB4\x85\x82\x86\x01aoQV[\x92PP` \x83\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15ap\xD5Wap\xD4al\x0EV[[ap\xE1\x85\x82\x86\x01apdV[\x91PP\x92P\x92\x90PV[ap\xF4\x81al5V[\x82RPPV[_` \x82\x01\x90Paq\r_\x83\x01\x84ap\xEBV[\x92\x91PPV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`!`\x04R`$_\xFD[_\x81\x90P\x92\x91PPV[_aqT\x82al\xF6V[aq^\x81\x85aq@V[\x93Paqn\x81\x85` \x86\x01am\x10V[\x80\x84\x01\x91PP\x92\x91PPV[\x7F v\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_aq\xAE`\x02\x83aq@V[\x91Paq\xB9\x82aqzV[`\x02\x82\x01\x90P\x91\x90PV[\x7F.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_aq\xF8`\x01\x83aq@V[\x91Par\x03\x82aq\xC4V[`\x01\x82\x01\x90P\x91\x90PV[_ar\x19\x82\x87aqJV[\x91Par$\x82aq\xA2V[\x91Par0\x82\x86aqJV[\x91Par;\x82aq\xECV[\x91ParG\x82\x85aqJV[\x91ParR\x82aq\xECV[\x91Par^\x82\x84aqJV[\x91P\x81\x90P\x95\x94PPPPPV[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[ar\x88\x81arlV[\x82RPPV[_` \x82\x01\x90Par\xA1_\x83\x01\x84ar\x7FV[\x92\x91PPV[_\x81\x90P\x91\x90PV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x11`\x04R`$_\xFD[_ar\xE7\x82ar\xA7V[\x91Par\xF2\x83ar\xA7V[\x92P\x82\x82\x01\x90P\x80\x82\x11\x15as\nWas\tar\xB0V[[\x92\x91PPV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x12`\x04R`$_\xFD[_\x81Q\x90PasK\x81ao;V[\x92\x91PPV[_` \x82\x84\x03\x12\x15asfWaseal\nV[[_ass\x84\x82\x85\x01as=V[\x91PP\x92\x91PPV[_\x81Q\x90Pas\x8A\x81al>V[\x92\x91PPV[_` \x82\x84\x03\x12\x15as\xA5Was\xA4al\nV[[_as\xB2\x84\x82\x85\x01as|V[\x91PP\x92\x91PPV[_\x81Q\x90P\x91\x90PV[_\x81\x90P\x92\x91PPV[_as\xD9\x82as\xBBV[as\xE3\x81\x85as\xC5V[\x93Pas\xF3\x81\x85` \x86\x01am\x10V[\x80\x84\x01\x91PP\x92\x91PPV[_at\n\x82\x84as\xCFV[\x91P\x81\x90P\x92\x91PPV",
    );
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct FheType(u8);
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<FheType> for u8 {
            #[inline]
            fn stv_to_tokens(
                &self,
            ) -> <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::Token<'_> {
                alloy_sol_types::private::SolTypeValue::<
                    alloy::sol_types::sol_data::Uint<8>,
                >::stv_to_tokens(self)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::tokenize(self)
                    .0
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(self, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::abi_encoded_size(self)
            }
        }
        #[automatically_derived]
        impl FheType {
            /// The Solidity type name.
            pub const NAME: &'static str = stringify!(@ name);
            /// Convert from the underlying value type.
            #[inline]
            pub const fn from_underlying(value: u8) -> Self {
                Self(value)
            }
            /// Return the underlying value.
            #[inline]
            pub const fn into_underlying(self) -> u8 {
                self.0
            }
            /// Return the single encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode(&self.0)
            }
            /// Return the packed encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode_packed(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode_packed(&self.0)
            }
        }
        #[automatically_derived]
        impl From<u8> for FheType {
            fn from(value: u8) -> Self {
                Self::from_underlying(value)
            }
        }
        #[automatically_derived]
        impl From<FheType> for u8 {
            fn from(value: FheType) -> Self {
                value.into_underlying()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for FheType {
            type RustType = u8;
            type Token<'a> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = Self::NAME;
            const ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                Self::type_check(token).is_ok()
            }
            #[inline]
            fn type_check(token: &Self::Token<'_>) -> alloy_sol_types::Result<()> {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::type_check(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::detokenize(token)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for FheType {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::topic_preimage_length(rust)
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(rust, out)
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic(rust)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `AddressEmptyCode(address)` and selector `0x9996b315`.
```solidity
error AddressEmptyCode(address target);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AddressEmptyCode {
        #[allow(missing_docs)]
        pub target: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AddressEmptyCode> for UnderlyingRustTuple<'_> {
            fn from(value: AddressEmptyCode) -> Self {
                (value.target,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for AddressEmptyCode {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { target: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AddressEmptyCode {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AddressEmptyCode(address)";
            const SELECTOR: [u8; 4] = [153u8, 150u8, 179u8, 21u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.target,
                    ),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `CallerMustBeFHEVMExecutorContract()` and selector `0x31a81a81`.
```solidity
error CallerMustBeFHEVMExecutorContract();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct CallerMustBeFHEVMExecutorContract;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<CallerMustBeFHEVMExecutorContract>
        for UnderlyingRustTuple<'_> {
            fn from(value: CallerMustBeFHEVMExecutorContract) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for CallerMustBeFHEVMExecutorContract {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for CallerMustBeFHEVMExecutorContract {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "CallerMustBeFHEVMExecutorContract()";
            const SELECTOR: [u8; 4] = [49u8, 168u8, 26u8, 129u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `ERC1967InvalidImplementation(address)` and selector `0x4c9c8ce3`.
```solidity
error ERC1967InvalidImplementation(address implementation);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC1967InvalidImplementation {
        #[allow(missing_docs)]
        pub implementation: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC1967InvalidImplementation>
        for UnderlyingRustTuple<'_> {
            fn from(value: ERC1967InvalidImplementation) -> Self {
                (value.implementation,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ERC1967InvalidImplementation {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { implementation: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC1967InvalidImplementation {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC1967InvalidImplementation(address)";
            const SELECTOR: [u8; 4] = [76u8, 156u8, 140u8, 227u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.implementation,
                    ),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `ERC1967NonPayable()` and selector `0xb398979f`.
```solidity
error ERC1967NonPayable();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC1967NonPayable;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC1967NonPayable> for UnderlyingRustTuple<'_> {
            fn from(value: ERC1967NonPayable) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ERC1967NonPayable {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC1967NonPayable {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC1967NonPayable()";
            const SELECTOR: [u8; 4] = [179u8, 152u8, 151u8, 159u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `FailedCall()` and selector `0xd6bda275`.
```solidity
error FailedCall();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct FailedCall;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<FailedCall> for UnderlyingRustTuple<'_> {
            fn from(value: FailedCall) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for FailedCall {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for FailedCall {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "FailedCall()";
            const SELECTOR: [u8; 4] = [214u8, 189u8, 162u8, 117u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `HCUTransactionDepthLimitExceeded()` and selector `0xfc344870`.
```solidity
error HCUTransactionDepthLimitExceeded();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct HCUTransactionDepthLimitExceeded;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<HCUTransactionDepthLimitExceeded>
        for UnderlyingRustTuple<'_> {
            fn from(value: HCUTransactionDepthLimitExceeded) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for HCUTransactionDepthLimitExceeded {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for HCUTransactionDepthLimitExceeded {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "HCUTransactionDepthLimitExceeded()";
            const SELECTOR: [u8; 4] = [252u8, 52u8, 72u8, 112u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `HCUTransactionLimitExceeded()` and selector `0x77e3c293`.
```solidity
error HCUTransactionLimitExceeded();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct HCUTransactionLimitExceeded;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<HCUTransactionLimitExceeded>
        for UnderlyingRustTuple<'_> {
            fn from(value: HCUTransactionLimitExceeded) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for HCUTransactionLimitExceeded {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for HCUTransactionLimitExceeded {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "HCUTransactionLimitExceeded()";
            const SELECTOR: [u8; 4] = [119u8, 227u8, 194u8, 147u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidInitialization()` and selector `0xf92ee8a9`.
```solidity
error InvalidInitialization();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidInitialization;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidInitialization> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidInitialization) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidInitialization {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidInitialization {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidInitialization()";
            const SELECTOR: [u8; 4] = [249u8, 46u8, 232u8, 169u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `NotHostOwner(address)` and selector `0x21bfda10`.
```solidity
error NotHostOwner(address sender);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NotHostOwner {
        #[allow(missing_docs)]
        pub sender: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NotHostOwner> for UnderlyingRustTuple<'_> {
            fn from(value: NotHostOwner) -> Self {
                (value.sender,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NotHostOwner {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { sender: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NotHostOwner {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NotHostOwner(address)";
            const SELECTOR: [u8; 4] = [33u8, 191u8, 218u8, 16u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sender,
                    ),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `NotInitializing()` and selector `0xd7e6bcf8`.
```solidity
error NotInitializing();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NotInitializing;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NotInitializing> for UnderlyingRustTuple<'_> {
            fn from(value: NotInitializing) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NotInitializing {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NotInitializing {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NotInitializing()";
            const SELECTOR: [u8; 4] = [215u8, 230u8, 188u8, 248u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `NotInitializingFromEmptyProxy()` and selector `0x6f4f731f`.
```solidity
error NotInitializingFromEmptyProxy();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NotInitializingFromEmptyProxy;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NotInitializingFromEmptyProxy>
        for UnderlyingRustTuple<'_> {
            fn from(value: NotInitializingFromEmptyProxy) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for NotInitializingFromEmptyProxy {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NotInitializingFromEmptyProxy {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NotInitializingFromEmptyProxy()";
            const SELECTOR: [u8; 4] = [111u8, 79u8, 115u8, 31u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `OnlyScalarOperationsAreSupported()` and selector `0x6aa9eb05`.
```solidity
error OnlyScalarOperationsAreSupported();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct OnlyScalarOperationsAreSupported;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<OnlyScalarOperationsAreSupported>
        for UnderlyingRustTuple<'_> {
            fn from(value: OnlyScalarOperationsAreSupported) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for OnlyScalarOperationsAreSupported {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for OnlyScalarOperationsAreSupported {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "OnlyScalarOperationsAreSupported()";
            const SELECTOR: [u8; 4] = [106u8, 169u8, 235u8, 5u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `UUPSUnauthorizedCallContext()` and selector `0xe07c8dba`.
```solidity
error UUPSUnauthorizedCallContext();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct UUPSUnauthorizedCallContext;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UUPSUnauthorizedCallContext>
        for UnderlyingRustTuple<'_> {
            fn from(value: UUPSUnauthorizedCallContext) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for UUPSUnauthorizedCallContext {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for UUPSUnauthorizedCallContext {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "UUPSUnauthorizedCallContext()";
            const SELECTOR: [u8; 4] = [224u8, 124u8, 141u8, 186u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `UUPSUnsupportedProxiableUUID(bytes32)` and selector `0xaa1d49a4`.
```solidity
error UUPSUnsupportedProxiableUUID(bytes32 slot);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct UUPSUnsupportedProxiableUUID {
        #[allow(missing_docs)]
        pub slot: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UUPSUnsupportedProxiableUUID>
        for UnderlyingRustTuple<'_> {
            fn from(value: UUPSUnsupportedProxiableUUID) -> Self {
                (value.slot,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for UUPSUnsupportedProxiableUUID {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { slot: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for UUPSUnsupportedProxiableUUID {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "UUPSUnsupportedProxiableUUID(bytes32)";
            const SELECTOR: [u8; 4] = [170u8, 29u8, 73u8, 164u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.slot),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `UnsupportedOperation()` and selector `0x9ba6061b`.
```solidity
error UnsupportedOperation();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct UnsupportedOperation;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnsupportedOperation> for UnderlyingRustTuple<'_> {
            fn from(value: UnsupportedOperation) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for UnsupportedOperation {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for UnsupportedOperation {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "UnsupportedOperation()";
            const SELECTOR: [u8; 4] = [155u8, 166u8, 6u8, 27u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `Initialized(uint64)` and selector `0xc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d2`.
```solidity
event Initialized(uint64 version);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Initialized {
        #[allow(missing_docs)]
        pub version: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Initialized {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "Initialized(uint64)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                199u8, 245u8, 5u8, 178u8, 243u8, 113u8, 174u8, 33u8, 117u8, 238u8, 73u8,
                19u8, 244u8, 73u8, 158u8, 31u8, 38u8, 51u8, 167u8, 181u8, 147u8, 99u8,
                33u8, 238u8, 209u8, 205u8, 174u8, 182u8, 17u8, 81u8, 129u8, 210u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { version: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.version),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Initialized {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Initialized> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Initialized) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `Upgraded(address)` and selector `0xbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b`.
```solidity
event Upgraded(address indexed implementation);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Upgraded {
        #[allow(missing_docs)]
        pub implementation: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Upgraded {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "Upgraded(address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                188u8, 124u8, 215u8, 90u8, 32u8, 238u8, 39u8, 253u8, 154u8, 222u8, 186u8,
                179u8, 32u8, 65u8, 247u8, 85u8, 33u8, 77u8, 188u8, 107u8, 255u8, 169u8,
                12u8, 192u8, 34u8, 91u8, 57u8, 218u8, 46u8, 92u8, 45u8, 59u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { implementation: topics.1 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.implementation.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.implementation,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Upgraded {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Upgraded> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Upgraded) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Constructor`.
```solidity
constructor();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct constructorCall {}
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<constructorCall> for UnderlyingRustTuple<'_> {
                fn from(value: constructorCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for constructorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolConstructor for constructorCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `UPGRADE_INTERFACE_VERSION()` and selector `0xad3cb1cc`.
```solidity
function UPGRADE_INTERFACE_VERSION() external view returns (string memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct UPGRADE_INTERFACE_VERSIONCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`UPGRADE_INTERFACE_VERSION()`](UPGRADE_INTERFACE_VERSIONCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct UPGRADE_INTERFACE_VERSIONReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UPGRADE_INTERFACE_VERSIONCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: UPGRADE_INTERFACE_VERSIONCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for UPGRADE_INTERFACE_VERSIONCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UPGRADE_INTERFACE_VERSIONReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: UPGRADE_INTERFACE_VERSIONReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for UPGRADE_INTERFACE_VERSIONReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for UPGRADE_INTERFACE_VERSIONCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::String;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "UPGRADE_INTERFACE_VERSION()";
            const SELECTOR: [u8; 4] = [173u8, 60u8, 177u8, 204u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: UPGRADE_INTERFACE_VERSIONReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: UPGRADE_INTERFACE_VERSIONReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `checkHCUForCast(uint8,bytes32,bytes32)` and selector `0x02dd6276`.
```solidity
function checkHCUForCast(FheType resultType, bytes32 ct, bytes32 result) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForCastCall {
        #[allow(missing_docs)]
        pub resultType: <FheType as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub ct: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`checkHCUForCast(uint8,bytes32,bytes32)`](checkHCUForCastCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForCastReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <FheType as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForCastCall> for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForCastCall) -> Self {
                    (value.resultType, value.ct, value.result)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for checkHCUForCastCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        resultType: tuple.0,
                        ct: tuple.1,
                        result: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForCastReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForCastReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForCastReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl checkHCUForCastReturn {
            fn _tokenize(
                &self,
            ) -> <checkHCUForCastCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for checkHCUForCastCall {
            type Parameters<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = checkHCUForCastReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "checkHCUForCast(uint8,bytes32,bytes32)";
            const SELECTOR: [u8; 4] = [2u8, 221u8, 98u8, 118u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <FheType as alloy_sol_types::SolType>::tokenize(&self.resultType),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.ct),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                checkHCUForCastReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `checkHCUForFheAdd(uint8,bytes1,bytes32,bytes32,bytes32)` and selector `0xfdad4c96`.
```solidity
function checkHCUForFheAdd(FheType resultType, bytes1 scalarByte, bytes32 lhs, bytes32 rhs, bytes32 result) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForFheAddCall {
        #[allow(missing_docs)]
        pub resultType: <FheType as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`checkHCUForFheAdd(uint8,bytes1,bytes32,bytes32,bytes32)`](checkHCUForFheAddCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForFheAddReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <FheType as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::FixedBytes<1>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForFheAddCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForFheAddCall) -> Self {
                    (
                        value.resultType,
                        value.scalarByte,
                        value.lhs,
                        value.rhs,
                        value.result,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForFheAddCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        resultType: tuple.0,
                        scalarByte: tuple.1,
                        lhs: tuple.2,
                        rhs: tuple.3,
                        result: tuple.4,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForFheAddReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForFheAddReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForFheAddReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl checkHCUForFheAddReturn {
            fn _tokenize(
                &self,
            ) -> <checkHCUForFheAddCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for checkHCUForFheAddCall {
            type Parameters<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = checkHCUForFheAddReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "checkHCUForFheAdd(uint8,bytes1,bytes32,bytes32,bytes32)";
            const SELECTOR: [u8; 4] = [253u8, 173u8, 76u8, 150u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <FheType as alloy_sol_types::SolType>::tokenize(&self.resultType),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                checkHCUForFheAddReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `checkHCUForFheBitAnd(uint8,bytes1,bytes32,bytes32,bytes32)` and selector `0x1856d91d`.
```solidity
function checkHCUForFheBitAnd(FheType resultType, bytes1 scalarByte, bytes32 lhs, bytes32 rhs, bytes32 result) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForFheBitAndCall {
        #[allow(missing_docs)]
        pub resultType: <FheType as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`checkHCUForFheBitAnd(uint8,bytes1,bytes32,bytes32,bytes32)`](checkHCUForFheBitAndCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForFheBitAndReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <FheType as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::FixedBytes<1>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForFheBitAndCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForFheBitAndCall) -> Self {
                    (
                        value.resultType,
                        value.scalarByte,
                        value.lhs,
                        value.rhs,
                        value.result,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForFheBitAndCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        resultType: tuple.0,
                        scalarByte: tuple.1,
                        lhs: tuple.2,
                        rhs: tuple.3,
                        result: tuple.4,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForFheBitAndReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForFheBitAndReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForFheBitAndReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl checkHCUForFheBitAndReturn {
            fn _tokenize(
                &self,
            ) -> <checkHCUForFheBitAndCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for checkHCUForFheBitAndCall {
            type Parameters<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = checkHCUForFheBitAndReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "checkHCUForFheBitAnd(uint8,bytes1,bytes32,bytes32,bytes32)";
            const SELECTOR: [u8; 4] = [24u8, 86u8, 217u8, 29u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <FheType as alloy_sol_types::SolType>::tokenize(&self.resultType),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                checkHCUForFheBitAndReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `checkHCUForFheBitOr(uint8,bytes1,bytes32,bytes32,bytes32)` and selector `0xe8e399ad`.
```solidity
function checkHCUForFheBitOr(FheType resultType, bytes1 scalarByte, bytes32 lhs, bytes32 rhs, bytes32 result) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForFheBitOrCall {
        #[allow(missing_docs)]
        pub resultType: <FheType as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`checkHCUForFheBitOr(uint8,bytes1,bytes32,bytes32,bytes32)`](checkHCUForFheBitOrCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForFheBitOrReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <FheType as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::FixedBytes<1>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForFheBitOrCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForFheBitOrCall) -> Self {
                    (
                        value.resultType,
                        value.scalarByte,
                        value.lhs,
                        value.rhs,
                        value.result,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForFheBitOrCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        resultType: tuple.0,
                        scalarByte: tuple.1,
                        lhs: tuple.2,
                        rhs: tuple.3,
                        result: tuple.4,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForFheBitOrReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForFheBitOrReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForFheBitOrReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl checkHCUForFheBitOrReturn {
            fn _tokenize(
                &self,
            ) -> <checkHCUForFheBitOrCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for checkHCUForFheBitOrCall {
            type Parameters<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = checkHCUForFheBitOrReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "checkHCUForFheBitOr(uint8,bytes1,bytes32,bytes32,bytes32)";
            const SELECTOR: [u8; 4] = [232u8, 227u8, 153u8, 173u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <FheType as alloy_sol_types::SolType>::tokenize(&self.resultType),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                checkHCUForFheBitOrReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `checkHCUForFheBitXor(uint8,bytes1,bytes32,bytes32,bytes32)` and selector `0x1434ba4d`.
```solidity
function checkHCUForFheBitXor(FheType resultType, bytes1 scalarByte, bytes32 lhs, bytes32 rhs, bytes32 result) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForFheBitXorCall {
        #[allow(missing_docs)]
        pub resultType: <FheType as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`checkHCUForFheBitXor(uint8,bytes1,bytes32,bytes32,bytes32)`](checkHCUForFheBitXorCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForFheBitXorReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <FheType as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::FixedBytes<1>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForFheBitXorCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForFheBitXorCall) -> Self {
                    (
                        value.resultType,
                        value.scalarByte,
                        value.lhs,
                        value.rhs,
                        value.result,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForFheBitXorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        resultType: tuple.0,
                        scalarByte: tuple.1,
                        lhs: tuple.2,
                        rhs: tuple.3,
                        result: tuple.4,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForFheBitXorReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForFheBitXorReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForFheBitXorReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl checkHCUForFheBitXorReturn {
            fn _tokenize(
                &self,
            ) -> <checkHCUForFheBitXorCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for checkHCUForFheBitXorCall {
            type Parameters<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = checkHCUForFheBitXorReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "checkHCUForFheBitXor(uint8,bytes1,bytes32,bytes32,bytes32)";
            const SELECTOR: [u8; 4] = [20u8, 52u8, 186u8, 77u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <FheType as alloy_sol_types::SolType>::tokenize(&self.resultType),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                checkHCUForFheBitXorReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `checkHCUForFheDiv(uint8,bytes1,bytes32,bytes32,bytes32)` and selector `0x406b4513`.
```solidity
function checkHCUForFheDiv(FheType resultType, bytes1 scalarByte, bytes32 lhs, bytes32, bytes32 result) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForFheDivCall {
        #[allow(missing_docs)]
        pub resultType: <FheType as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub _3: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`checkHCUForFheDiv(uint8,bytes1,bytes32,bytes32,bytes32)`](checkHCUForFheDivCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForFheDivReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <FheType as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::FixedBytes<1>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForFheDivCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForFheDivCall) -> Self {
                    (
                        value.resultType,
                        value.scalarByte,
                        value.lhs,
                        value._3,
                        value.result,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForFheDivCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        resultType: tuple.0,
                        scalarByte: tuple.1,
                        lhs: tuple.2,
                        _3: tuple.3,
                        result: tuple.4,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForFheDivReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForFheDivReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForFheDivReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl checkHCUForFheDivReturn {
            fn _tokenize(
                &self,
            ) -> <checkHCUForFheDivCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for checkHCUForFheDivCall {
            type Parameters<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = checkHCUForFheDivReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "checkHCUForFheDiv(uint8,bytes1,bytes32,bytes32,bytes32)";
            const SELECTOR: [u8; 4] = [64u8, 107u8, 69u8, 19u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <FheType as alloy_sol_types::SolType>::tokenize(&self.resultType),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self._3),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                checkHCUForFheDivReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `checkHCUForFheEq(uint8,bytes1,bytes32,bytes32,bytes32)` and selector `0x94e70e4f`.
```solidity
function checkHCUForFheEq(FheType resultType, bytes1 scalarByte, bytes32 lhs, bytes32 rhs, bytes32 result) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForFheEqCall {
        #[allow(missing_docs)]
        pub resultType: <FheType as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`checkHCUForFheEq(uint8,bytes1,bytes32,bytes32,bytes32)`](checkHCUForFheEqCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForFheEqReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <FheType as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::FixedBytes<1>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForFheEqCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForFheEqCall) -> Self {
                    (
                        value.resultType,
                        value.scalarByte,
                        value.lhs,
                        value.rhs,
                        value.result,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForFheEqCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        resultType: tuple.0,
                        scalarByte: tuple.1,
                        lhs: tuple.2,
                        rhs: tuple.3,
                        result: tuple.4,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForFheEqReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForFheEqReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForFheEqReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl checkHCUForFheEqReturn {
            fn _tokenize(
                &self,
            ) -> <checkHCUForFheEqCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for checkHCUForFheEqCall {
            type Parameters<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = checkHCUForFheEqReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "checkHCUForFheEq(uint8,bytes1,bytes32,bytes32,bytes32)";
            const SELECTOR: [u8; 4] = [148u8, 231u8, 14u8, 79u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <FheType as alloy_sol_types::SolType>::tokenize(&self.resultType),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                checkHCUForFheEqReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `checkHCUForFheGe(uint8,bytes1,bytes32,bytes32,bytes32)` and selector `0x6bb3c611`.
```solidity
function checkHCUForFheGe(FheType resultType, bytes1 scalarByte, bytes32 lhs, bytes32 rhs, bytes32 result) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForFheGeCall {
        #[allow(missing_docs)]
        pub resultType: <FheType as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`checkHCUForFheGe(uint8,bytes1,bytes32,bytes32,bytes32)`](checkHCUForFheGeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForFheGeReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <FheType as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::FixedBytes<1>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForFheGeCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForFheGeCall) -> Self {
                    (
                        value.resultType,
                        value.scalarByte,
                        value.lhs,
                        value.rhs,
                        value.result,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForFheGeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        resultType: tuple.0,
                        scalarByte: tuple.1,
                        lhs: tuple.2,
                        rhs: tuple.3,
                        result: tuple.4,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForFheGeReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForFheGeReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForFheGeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl checkHCUForFheGeReturn {
            fn _tokenize(
                &self,
            ) -> <checkHCUForFheGeCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for checkHCUForFheGeCall {
            type Parameters<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = checkHCUForFheGeReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "checkHCUForFheGe(uint8,bytes1,bytes32,bytes32,bytes32)";
            const SELECTOR: [u8; 4] = [107u8, 179u8, 198u8, 17u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <FheType as alloy_sol_types::SolType>::tokenize(&self.resultType),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                checkHCUForFheGeReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `checkHCUForFheGt(uint8,bytes1,bytes32,bytes32,bytes32)` and selector `0x859a1b70`.
```solidity
function checkHCUForFheGt(FheType resultType, bytes1 scalarByte, bytes32 lhs, bytes32 rhs, bytes32 result) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForFheGtCall {
        #[allow(missing_docs)]
        pub resultType: <FheType as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`checkHCUForFheGt(uint8,bytes1,bytes32,bytes32,bytes32)`](checkHCUForFheGtCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForFheGtReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <FheType as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::FixedBytes<1>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForFheGtCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForFheGtCall) -> Self {
                    (
                        value.resultType,
                        value.scalarByte,
                        value.lhs,
                        value.rhs,
                        value.result,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForFheGtCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        resultType: tuple.0,
                        scalarByte: tuple.1,
                        lhs: tuple.2,
                        rhs: tuple.3,
                        result: tuple.4,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForFheGtReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForFheGtReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForFheGtReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl checkHCUForFheGtReturn {
            fn _tokenize(
                &self,
            ) -> <checkHCUForFheGtCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for checkHCUForFheGtCall {
            type Parameters<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = checkHCUForFheGtReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "checkHCUForFheGt(uint8,bytes1,bytes32,bytes32,bytes32)";
            const SELECTOR: [u8; 4] = [133u8, 154u8, 27u8, 112u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <FheType as alloy_sol_types::SolType>::tokenize(&self.resultType),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                checkHCUForFheGtReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `checkHCUForFheLe(uint8,bytes1,bytes32,bytes32,bytes32)` and selector `0xd47f3d59`.
```solidity
function checkHCUForFheLe(FheType resultType, bytes1 scalarByte, bytes32 lhs, bytes32 rhs, bytes32 result) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForFheLeCall {
        #[allow(missing_docs)]
        pub resultType: <FheType as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`checkHCUForFheLe(uint8,bytes1,bytes32,bytes32,bytes32)`](checkHCUForFheLeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForFheLeReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <FheType as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::FixedBytes<1>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForFheLeCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForFheLeCall) -> Self {
                    (
                        value.resultType,
                        value.scalarByte,
                        value.lhs,
                        value.rhs,
                        value.result,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForFheLeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        resultType: tuple.0,
                        scalarByte: tuple.1,
                        lhs: tuple.2,
                        rhs: tuple.3,
                        result: tuple.4,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForFheLeReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForFheLeReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForFheLeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl checkHCUForFheLeReturn {
            fn _tokenize(
                &self,
            ) -> <checkHCUForFheLeCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for checkHCUForFheLeCall {
            type Parameters<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = checkHCUForFheLeReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "checkHCUForFheLe(uint8,bytes1,bytes32,bytes32,bytes32)";
            const SELECTOR: [u8; 4] = [212u8, 127u8, 61u8, 89u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <FheType as alloy_sol_types::SolType>::tokenize(&self.resultType),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                checkHCUForFheLeReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `checkHCUForFheLt(uint8,bytes1,bytes32,bytes32,bytes32)` and selector `0x1339c5ee`.
```solidity
function checkHCUForFheLt(FheType resultType, bytes1 scalarByte, bytes32 lhs, bytes32 rhs, bytes32 result) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForFheLtCall {
        #[allow(missing_docs)]
        pub resultType: <FheType as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`checkHCUForFheLt(uint8,bytes1,bytes32,bytes32,bytes32)`](checkHCUForFheLtCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForFheLtReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <FheType as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::FixedBytes<1>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForFheLtCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForFheLtCall) -> Self {
                    (
                        value.resultType,
                        value.scalarByte,
                        value.lhs,
                        value.rhs,
                        value.result,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForFheLtCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        resultType: tuple.0,
                        scalarByte: tuple.1,
                        lhs: tuple.2,
                        rhs: tuple.3,
                        result: tuple.4,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForFheLtReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForFheLtReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForFheLtReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl checkHCUForFheLtReturn {
            fn _tokenize(
                &self,
            ) -> <checkHCUForFheLtCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for checkHCUForFheLtCall {
            type Parameters<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = checkHCUForFheLtReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "checkHCUForFheLt(uint8,bytes1,bytes32,bytes32,bytes32)";
            const SELECTOR: [u8; 4] = [19u8, 57u8, 197u8, 238u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <FheType as alloy_sol_types::SolType>::tokenize(&self.resultType),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                checkHCUForFheLtReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `checkHCUForFheMax(uint8,bytes1,bytes32,bytes32,bytes32)` and selector `0xacb5f388`.
```solidity
function checkHCUForFheMax(FheType resultType, bytes1 scalarByte, bytes32 lhs, bytes32 rhs, bytes32 result) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForFheMaxCall {
        #[allow(missing_docs)]
        pub resultType: <FheType as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`checkHCUForFheMax(uint8,bytes1,bytes32,bytes32,bytes32)`](checkHCUForFheMaxCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForFheMaxReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <FheType as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::FixedBytes<1>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForFheMaxCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForFheMaxCall) -> Self {
                    (
                        value.resultType,
                        value.scalarByte,
                        value.lhs,
                        value.rhs,
                        value.result,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForFheMaxCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        resultType: tuple.0,
                        scalarByte: tuple.1,
                        lhs: tuple.2,
                        rhs: tuple.3,
                        result: tuple.4,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForFheMaxReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForFheMaxReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForFheMaxReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl checkHCUForFheMaxReturn {
            fn _tokenize(
                &self,
            ) -> <checkHCUForFheMaxCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for checkHCUForFheMaxCall {
            type Parameters<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = checkHCUForFheMaxReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "checkHCUForFheMax(uint8,bytes1,bytes32,bytes32,bytes32)";
            const SELECTOR: [u8; 4] = [172u8, 181u8, 243u8, 136u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <FheType as alloy_sol_types::SolType>::tokenize(&self.resultType),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                checkHCUForFheMaxReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `checkHCUForFheMin(uint8,bytes1,bytes32,bytes32,bytes32)` and selector `0x642b1490`.
```solidity
function checkHCUForFheMin(FheType resultType, bytes1 scalarByte, bytes32 lhs, bytes32 rhs, bytes32 result) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForFheMinCall {
        #[allow(missing_docs)]
        pub resultType: <FheType as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`checkHCUForFheMin(uint8,bytes1,bytes32,bytes32,bytes32)`](checkHCUForFheMinCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForFheMinReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <FheType as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::FixedBytes<1>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForFheMinCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForFheMinCall) -> Self {
                    (
                        value.resultType,
                        value.scalarByte,
                        value.lhs,
                        value.rhs,
                        value.result,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForFheMinCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        resultType: tuple.0,
                        scalarByte: tuple.1,
                        lhs: tuple.2,
                        rhs: tuple.3,
                        result: tuple.4,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForFheMinReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForFheMinReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForFheMinReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl checkHCUForFheMinReturn {
            fn _tokenize(
                &self,
            ) -> <checkHCUForFheMinCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for checkHCUForFheMinCall {
            type Parameters<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = checkHCUForFheMinReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "checkHCUForFheMin(uint8,bytes1,bytes32,bytes32,bytes32)";
            const SELECTOR: [u8; 4] = [100u8, 43u8, 20u8, 144u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <FheType as alloy_sol_types::SolType>::tokenize(&self.resultType),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                checkHCUForFheMinReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `checkHCUForFheMul(uint8,bytes1,bytes32,bytes32,bytes32)` and selector `0x3c16ff0d`.
```solidity
function checkHCUForFheMul(FheType resultType, bytes1 scalarByte, bytes32 lhs, bytes32 rhs, bytes32 result) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForFheMulCall {
        #[allow(missing_docs)]
        pub resultType: <FheType as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`checkHCUForFheMul(uint8,bytes1,bytes32,bytes32,bytes32)`](checkHCUForFheMulCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForFheMulReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <FheType as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::FixedBytes<1>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForFheMulCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForFheMulCall) -> Self {
                    (
                        value.resultType,
                        value.scalarByte,
                        value.lhs,
                        value.rhs,
                        value.result,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForFheMulCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        resultType: tuple.0,
                        scalarByte: tuple.1,
                        lhs: tuple.2,
                        rhs: tuple.3,
                        result: tuple.4,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForFheMulReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForFheMulReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForFheMulReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl checkHCUForFheMulReturn {
            fn _tokenize(
                &self,
            ) -> <checkHCUForFheMulCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for checkHCUForFheMulCall {
            type Parameters<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = checkHCUForFheMulReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "checkHCUForFheMul(uint8,bytes1,bytes32,bytes32,bytes32)";
            const SELECTOR: [u8; 4] = [60u8, 22u8, 255u8, 13u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <FheType as alloy_sol_types::SolType>::tokenize(&self.resultType),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                checkHCUForFheMulReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `checkHCUForFheNe(uint8,bytes1,bytes32,bytes32,bytes32)` and selector `0xfa5defdb`.
```solidity
function checkHCUForFheNe(FheType resultType, bytes1 scalarByte, bytes32 lhs, bytes32 rhs, bytes32 result) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForFheNeCall {
        #[allow(missing_docs)]
        pub resultType: <FheType as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`checkHCUForFheNe(uint8,bytes1,bytes32,bytes32,bytes32)`](checkHCUForFheNeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForFheNeReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <FheType as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::FixedBytes<1>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForFheNeCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForFheNeCall) -> Self {
                    (
                        value.resultType,
                        value.scalarByte,
                        value.lhs,
                        value.rhs,
                        value.result,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForFheNeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        resultType: tuple.0,
                        scalarByte: tuple.1,
                        lhs: tuple.2,
                        rhs: tuple.3,
                        result: tuple.4,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForFheNeReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForFheNeReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForFheNeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl checkHCUForFheNeReturn {
            fn _tokenize(
                &self,
            ) -> <checkHCUForFheNeCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for checkHCUForFheNeCall {
            type Parameters<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = checkHCUForFheNeReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "checkHCUForFheNe(uint8,bytes1,bytes32,bytes32,bytes32)";
            const SELECTOR: [u8; 4] = [250u8, 93u8, 239u8, 219u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <FheType as alloy_sol_types::SolType>::tokenize(&self.resultType),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                checkHCUForFheNeReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `checkHCUForFheNeg(uint8,bytes32,bytes32)` and selector `0xa4c98f3e`.
```solidity
function checkHCUForFheNeg(FheType resultType, bytes32 ct, bytes32 result) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForFheNegCall {
        #[allow(missing_docs)]
        pub resultType: <FheType as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub ct: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`checkHCUForFheNeg(uint8,bytes32,bytes32)`](checkHCUForFheNegCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForFheNegReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <FheType as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForFheNegCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForFheNegCall) -> Self {
                    (value.resultType, value.ct, value.result)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForFheNegCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        resultType: tuple.0,
                        ct: tuple.1,
                        result: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForFheNegReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForFheNegReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForFheNegReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl checkHCUForFheNegReturn {
            fn _tokenize(
                &self,
            ) -> <checkHCUForFheNegCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for checkHCUForFheNegCall {
            type Parameters<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = checkHCUForFheNegReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "checkHCUForFheNeg(uint8,bytes32,bytes32)";
            const SELECTOR: [u8; 4] = [164u8, 201u8, 143u8, 62u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <FheType as alloy_sol_types::SolType>::tokenize(&self.resultType),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.ct),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                checkHCUForFheNegReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `checkHCUForFheNot(uint8,bytes32,bytes32)` and selector `0xfc063c62`.
```solidity
function checkHCUForFheNot(FheType resultType, bytes32 ct, bytes32 result) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForFheNotCall {
        #[allow(missing_docs)]
        pub resultType: <FheType as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub ct: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`checkHCUForFheNot(uint8,bytes32,bytes32)`](checkHCUForFheNotCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForFheNotReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <FheType as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForFheNotCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForFheNotCall) -> Self {
                    (value.resultType, value.ct, value.result)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForFheNotCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        resultType: tuple.0,
                        ct: tuple.1,
                        result: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForFheNotReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForFheNotReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForFheNotReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl checkHCUForFheNotReturn {
            fn _tokenize(
                &self,
            ) -> <checkHCUForFheNotCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for checkHCUForFheNotCall {
            type Parameters<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = checkHCUForFheNotReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "checkHCUForFheNot(uint8,bytes32,bytes32)";
            const SELECTOR: [u8; 4] = [252u8, 6u8, 60u8, 98u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <FheType as alloy_sol_types::SolType>::tokenize(&self.resultType),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.ct),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                checkHCUForFheNotReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `checkHCUForFheRand(uint8,bytes32)` and selector `0x09b04e8f`.
```solidity
function checkHCUForFheRand(FheType resultType, bytes32 result) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForFheRandCall {
        #[allow(missing_docs)]
        pub resultType: <FheType as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`checkHCUForFheRand(uint8,bytes32)`](checkHCUForFheRandCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForFheRandReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <FheType as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForFheRandCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForFheRandCall) -> Self {
                    (value.resultType, value.result)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForFheRandCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        resultType: tuple.0,
                        result: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForFheRandReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForFheRandReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForFheRandReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl checkHCUForFheRandReturn {
            fn _tokenize(
                &self,
            ) -> <checkHCUForFheRandCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for checkHCUForFheRandCall {
            type Parameters<'a> = (FheType, alloy::sol_types::sol_data::FixedBytes<32>);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = checkHCUForFheRandReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "checkHCUForFheRand(uint8,bytes32)";
            const SELECTOR: [u8; 4] = [9u8, 176u8, 78u8, 143u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <FheType as alloy_sol_types::SolType>::tokenize(&self.resultType),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                checkHCUForFheRandReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `checkHCUForFheRandBounded(uint8,bytes32)` and selector `0xcc866782`.
```solidity
function checkHCUForFheRandBounded(FheType resultType, bytes32 result) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForFheRandBoundedCall {
        #[allow(missing_docs)]
        pub resultType: <FheType as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`checkHCUForFheRandBounded(uint8,bytes32)`](checkHCUForFheRandBoundedCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForFheRandBoundedReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <FheType as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForFheRandBoundedCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForFheRandBoundedCall) -> Self {
                    (value.resultType, value.result)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForFheRandBoundedCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        resultType: tuple.0,
                        result: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForFheRandBoundedReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForFheRandBoundedReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForFheRandBoundedReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl checkHCUForFheRandBoundedReturn {
            fn _tokenize(
                &self,
            ) -> <checkHCUForFheRandBoundedCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for checkHCUForFheRandBoundedCall {
            type Parameters<'a> = (FheType, alloy::sol_types::sol_data::FixedBytes<32>);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = checkHCUForFheRandBoundedReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "checkHCUForFheRandBounded(uint8,bytes32)";
            const SELECTOR: [u8; 4] = [204u8, 134u8, 103u8, 130u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <FheType as alloy_sol_types::SolType>::tokenize(&self.resultType),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                checkHCUForFheRandBoundedReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `checkHCUForFheRem(uint8,bytes1,bytes32,bytes32,bytes32)` and selector `0xfa08e38d`.
```solidity
function checkHCUForFheRem(FheType resultType, bytes1 scalarByte, bytes32 lhs, bytes32, bytes32 result) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForFheRemCall {
        #[allow(missing_docs)]
        pub resultType: <FheType as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub _3: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`checkHCUForFheRem(uint8,bytes1,bytes32,bytes32,bytes32)`](checkHCUForFheRemCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForFheRemReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <FheType as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::FixedBytes<1>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForFheRemCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForFheRemCall) -> Self {
                    (
                        value.resultType,
                        value.scalarByte,
                        value.lhs,
                        value._3,
                        value.result,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForFheRemCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        resultType: tuple.0,
                        scalarByte: tuple.1,
                        lhs: tuple.2,
                        _3: tuple.3,
                        result: tuple.4,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForFheRemReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForFheRemReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForFheRemReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl checkHCUForFheRemReturn {
            fn _tokenize(
                &self,
            ) -> <checkHCUForFheRemCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for checkHCUForFheRemCall {
            type Parameters<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = checkHCUForFheRemReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "checkHCUForFheRem(uint8,bytes1,bytes32,bytes32,bytes32)";
            const SELECTOR: [u8; 4] = [250u8, 8u8, 227u8, 141u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <FheType as alloy_sol_types::SolType>::tokenize(&self.resultType),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self._3),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                checkHCUForFheRemReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `checkHCUForFheRotl(uint8,bytes1,bytes32,bytes32,bytes32)` and selector `0x14526e87`.
```solidity
function checkHCUForFheRotl(FheType resultType, bytes1 scalarByte, bytes32 lhs, bytes32 rhs, bytes32 result) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForFheRotlCall {
        #[allow(missing_docs)]
        pub resultType: <FheType as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`checkHCUForFheRotl(uint8,bytes1,bytes32,bytes32,bytes32)`](checkHCUForFheRotlCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForFheRotlReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <FheType as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::FixedBytes<1>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForFheRotlCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForFheRotlCall) -> Self {
                    (
                        value.resultType,
                        value.scalarByte,
                        value.lhs,
                        value.rhs,
                        value.result,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForFheRotlCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        resultType: tuple.0,
                        scalarByte: tuple.1,
                        lhs: tuple.2,
                        rhs: tuple.3,
                        result: tuple.4,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForFheRotlReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForFheRotlReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForFheRotlReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl checkHCUForFheRotlReturn {
            fn _tokenize(
                &self,
            ) -> <checkHCUForFheRotlCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for checkHCUForFheRotlCall {
            type Parameters<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = checkHCUForFheRotlReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "checkHCUForFheRotl(uint8,bytes1,bytes32,bytes32,bytes32)";
            const SELECTOR: [u8; 4] = [20u8, 82u8, 110u8, 135u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <FheType as alloy_sol_types::SolType>::tokenize(&self.resultType),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                checkHCUForFheRotlReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `checkHCUForFheRotr(uint8,bytes1,bytes32,bytes32,bytes32)` and selector `0x669181c0`.
```solidity
function checkHCUForFheRotr(FheType resultType, bytes1 scalarByte, bytes32 lhs, bytes32 rhs, bytes32 result) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForFheRotrCall {
        #[allow(missing_docs)]
        pub resultType: <FheType as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`checkHCUForFheRotr(uint8,bytes1,bytes32,bytes32,bytes32)`](checkHCUForFheRotrCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForFheRotrReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <FheType as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::FixedBytes<1>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForFheRotrCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForFheRotrCall) -> Self {
                    (
                        value.resultType,
                        value.scalarByte,
                        value.lhs,
                        value.rhs,
                        value.result,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForFheRotrCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        resultType: tuple.0,
                        scalarByte: tuple.1,
                        lhs: tuple.2,
                        rhs: tuple.3,
                        result: tuple.4,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForFheRotrReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForFheRotrReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForFheRotrReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl checkHCUForFheRotrReturn {
            fn _tokenize(
                &self,
            ) -> <checkHCUForFheRotrCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for checkHCUForFheRotrCall {
            type Parameters<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = checkHCUForFheRotrReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "checkHCUForFheRotr(uint8,bytes1,bytes32,bytes32,bytes32)";
            const SELECTOR: [u8; 4] = [102u8, 145u8, 129u8, 192u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <FheType as alloy_sol_types::SolType>::tokenize(&self.resultType),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                checkHCUForFheRotrReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `checkHCUForFheShl(uint8,bytes1,bytes32,bytes32,bytes32)` and selector `0x83e6a720`.
```solidity
function checkHCUForFheShl(FheType resultType, bytes1 scalarByte, bytes32 lhs, bytes32 rhs, bytes32 result) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForFheShlCall {
        #[allow(missing_docs)]
        pub resultType: <FheType as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`checkHCUForFheShl(uint8,bytes1,bytes32,bytes32,bytes32)`](checkHCUForFheShlCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForFheShlReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <FheType as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::FixedBytes<1>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForFheShlCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForFheShlCall) -> Self {
                    (
                        value.resultType,
                        value.scalarByte,
                        value.lhs,
                        value.rhs,
                        value.result,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForFheShlCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        resultType: tuple.0,
                        scalarByte: tuple.1,
                        lhs: tuple.2,
                        rhs: tuple.3,
                        result: tuple.4,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForFheShlReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForFheShlReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForFheShlReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl checkHCUForFheShlReturn {
            fn _tokenize(
                &self,
            ) -> <checkHCUForFheShlCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for checkHCUForFheShlCall {
            type Parameters<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = checkHCUForFheShlReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "checkHCUForFheShl(uint8,bytes1,bytes32,bytes32,bytes32)";
            const SELECTOR: [u8; 4] = [131u8, 230u8, 167u8, 32u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <FheType as alloy_sol_types::SolType>::tokenize(&self.resultType),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                checkHCUForFheShlReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `checkHCUForFheShr(uint8,bytes1,bytes32,bytes32,bytes32)` and selector `0x1ed91ff6`.
```solidity
function checkHCUForFheShr(FheType resultType, bytes1 scalarByte, bytes32 lhs, bytes32 rhs, bytes32 result) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForFheShrCall {
        #[allow(missing_docs)]
        pub resultType: <FheType as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`checkHCUForFheShr(uint8,bytes1,bytes32,bytes32,bytes32)`](checkHCUForFheShrCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForFheShrReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <FheType as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::FixedBytes<1>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForFheShrCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForFheShrCall) -> Self {
                    (
                        value.resultType,
                        value.scalarByte,
                        value.lhs,
                        value.rhs,
                        value.result,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForFheShrCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        resultType: tuple.0,
                        scalarByte: tuple.1,
                        lhs: tuple.2,
                        rhs: tuple.3,
                        result: tuple.4,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForFheShrReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForFheShrReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForFheShrReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl checkHCUForFheShrReturn {
            fn _tokenize(
                &self,
            ) -> <checkHCUForFheShrCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for checkHCUForFheShrCall {
            type Parameters<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = checkHCUForFheShrReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "checkHCUForFheShr(uint8,bytes1,bytes32,bytes32,bytes32)";
            const SELECTOR: [u8; 4] = [30u8, 217u8, 31u8, 246u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <FheType as alloy_sol_types::SolType>::tokenize(&self.resultType),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                checkHCUForFheShrReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `checkHCUForFheSub(uint8,bytes1,bytes32,bytes32,bytes32)` and selector `0x90753108`.
```solidity
function checkHCUForFheSub(FheType resultType, bytes1 scalarByte, bytes32 lhs, bytes32 rhs, bytes32 result) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForFheSubCall {
        #[allow(missing_docs)]
        pub resultType: <FheType as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`checkHCUForFheSub(uint8,bytes1,bytes32,bytes32,bytes32)`](checkHCUForFheSubCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForFheSubReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <FheType as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::FixedBytes<1>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForFheSubCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForFheSubCall) -> Self {
                    (
                        value.resultType,
                        value.scalarByte,
                        value.lhs,
                        value.rhs,
                        value.result,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForFheSubCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        resultType: tuple.0,
                        scalarByte: tuple.1,
                        lhs: tuple.2,
                        rhs: tuple.3,
                        result: tuple.4,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForFheSubReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForFheSubReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForFheSubReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl checkHCUForFheSubReturn {
            fn _tokenize(
                &self,
            ) -> <checkHCUForFheSubCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for checkHCUForFheSubCall {
            type Parameters<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = checkHCUForFheSubReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "checkHCUForFheSub(uint8,bytes1,bytes32,bytes32,bytes32)";
            const SELECTOR: [u8; 4] = [144u8, 117u8, 49u8, 8u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <FheType as alloy_sol_types::SolType>::tokenize(&self.resultType),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                checkHCUForFheSubReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `checkHCUForIfThenElse(uint8,bytes32,bytes32,bytes32,bytes32)` and selector `0x4e726769`.
```solidity
function checkHCUForIfThenElse(FheType resultType, bytes32 lhs, bytes32 middle, bytes32 rhs, bytes32 result) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForIfThenElseCall {
        #[allow(missing_docs)]
        pub resultType: <FheType as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub middle: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`checkHCUForIfThenElse(uint8,bytes32,bytes32,bytes32,bytes32)`](checkHCUForIfThenElseCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForIfThenElseReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <FheType as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForIfThenElseCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForIfThenElseCall) -> Self {
                    (value.resultType, value.lhs, value.middle, value.rhs, value.result)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForIfThenElseCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        resultType: tuple.0,
                        lhs: tuple.1,
                        middle: tuple.2,
                        rhs: tuple.3,
                        result: tuple.4,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForIfThenElseReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForIfThenElseReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForIfThenElseReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl checkHCUForIfThenElseReturn {
            fn _tokenize(
                &self,
            ) -> <checkHCUForIfThenElseCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for checkHCUForIfThenElseCall {
            type Parameters<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = checkHCUForIfThenElseReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "checkHCUForIfThenElse(uint8,bytes32,bytes32,bytes32,bytes32)";
            const SELECTOR: [u8; 4] = [78u8, 114u8, 103u8, 105u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <FheType as alloy_sol_types::SolType>::tokenize(&self.resultType),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.middle),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                checkHCUForIfThenElseReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `checkHCUForTrivialEncrypt(uint8,bytes32)` and selector `0x348c3185`.
```solidity
function checkHCUForTrivialEncrypt(FheType resultType, bytes32 result) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForTrivialEncryptCall {
        #[allow(missing_docs)]
        pub resultType: <FheType as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`checkHCUForTrivialEncrypt(uint8,bytes32)`](checkHCUForTrivialEncryptCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForTrivialEncryptReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <FheType as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForTrivialEncryptCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForTrivialEncryptCall) -> Self {
                    (value.resultType, value.result)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForTrivialEncryptCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        resultType: tuple.0,
                        result: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForTrivialEncryptReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForTrivialEncryptReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForTrivialEncryptReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl checkHCUForTrivialEncryptReturn {
            fn _tokenize(
                &self,
            ) -> <checkHCUForTrivialEncryptCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for checkHCUForTrivialEncryptCall {
            type Parameters<'a> = (FheType, alloy::sol_types::sol_data::FixedBytes<32>);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = checkHCUForTrivialEncryptReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "checkHCUForTrivialEncrypt(uint8,bytes32)";
            const SELECTOR: [u8; 4] = [52u8, 140u8, 49u8, 133u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <FheType as alloy_sol_types::SolType>::tokenize(&self.resultType),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                checkHCUForTrivialEncryptReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getFHEVMExecutorAddress()` and selector `0x268d6d31`.
```solidity
function getFHEVMExecutorAddress() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getFHEVMExecutorAddressCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getFHEVMExecutorAddress()`](getFHEVMExecutorAddressCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getFHEVMExecutorAddressReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getFHEVMExecutorAddressCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getFHEVMExecutorAddressCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getFHEVMExecutorAddressCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getFHEVMExecutorAddressReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getFHEVMExecutorAddressReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getFHEVMExecutorAddressReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getFHEVMExecutorAddressCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getFHEVMExecutorAddress()";
            const SELECTOR: [u8; 4] = [38u8, 141u8, 109u8, 49u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getFHEVMExecutorAddressReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getFHEVMExecutorAddressReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getVersion()` and selector `0x0d8e6e2c`.
```solidity
function getVersion() external pure returns (string memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getVersionCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getVersion()`](getVersionCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getVersionReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getVersionCall> for UnderlyingRustTuple<'_> {
                fn from(value: getVersionCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getVersionCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getVersionReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getVersionReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getVersionReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getVersionCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::String;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getVersion()";
            const SELECTOR: [u8; 4] = [13u8, 142u8, 110u8, 44u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getVersionReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getVersionReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `initializeFromEmptyProxy()` and selector `0x39f73810`.
```solidity
function initializeFromEmptyProxy() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct initializeFromEmptyProxyCall;
    ///Container type for the return parameters of the [`initializeFromEmptyProxy()`](initializeFromEmptyProxyCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct initializeFromEmptyProxyReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<initializeFromEmptyProxyCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: initializeFromEmptyProxyCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for initializeFromEmptyProxyCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<initializeFromEmptyProxyReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: initializeFromEmptyProxyReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for initializeFromEmptyProxyReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl initializeFromEmptyProxyReturn {
            fn _tokenize(
                &self,
            ) -> <initializeFromEmptyProxyCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for initializeFromEmptyProxyCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = initializeFromEmptyProxyReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "initializeFromEmptyProxy()";
            const SELECTOR: [u8; 4] = [57u8, 247u8, 56u8, 16u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                initializeFromEmptyProxyReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `proxiableUUID()` and selector `0x52d1902d`.
```solidity
function proxiableUUID() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct proxiableUUIDCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`proxiableUUID()`](proxiableUUIDCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct proxiableUUIDReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<proxiableUUIDCall> for UnderlyingRustTuple<'_> {
                fn from(value: proxiableUUIDCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for proxiableUUIDCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<proxiableUUIDReturn> for UnderlyingRustTuple<'_> {
                fn from(value: proxiableUUIDReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for proxiableUUIDReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for proxiableUUIDCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "proxiableUUID()";
            const SELECTOR: [u8; 4] = [82u8, 209u8, 144u8, 45u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: proxiableUUIDReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: proxiableUUIDReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `upgradeToAndCall(address,bytes)` and selector `0x4f1ef286`.
```solidity
function upgradeToAndCall(address newImplementation, bytes memory data) external payable;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct upgradeToAndCallCall {
        #[allow(missing_docs)]
        pub newImplementation: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub data: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`upgradeToAndCall(address,bytes)`](upgradeToAndCallCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct upgradeToAndCallReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<upgradeToAndCallCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: upgradeToAndCallCall) -> Self {
                    (value.newImplementation, value.data)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for upgradeToAndCallCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        newImplementation: tuple.0,
                        data: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<upgradeToAndCallReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: upgradeToAndCallReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for upgradeToAndCallReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl upgradeToAndCallReturn {
            fn _tokenize(
                &self,
            ) -> <upgradeToAndCallCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for upgradeToAndCallCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = upgradeToAndCallReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "upgradeToAndCall(address,bytes)";
            const SELECTOR: [u8; 4] = [79u8, 30u8, 242u8, 134u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.newImplementation,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.data,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                upgradeToAndCallReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    ///Container for all the [`HCULimit`](self) function calls.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive()]
    pub enum HCULimitCalls {
        #[allow(missing_docs)]
        UPGRADE_INTERFACE_VERSION(UPGRADE_INTERFACE_VERSIONCall),
        #[allow(missing_docs)]
        checkHCUForCast(checkHCUForCastCall),
        #[allow(missing_docs)]
        checkHCUForFheAdd(checkHCUForFheAddCall),
        #[allow(missing_docs)]
        checkHCUForFheBitAnd(checkHCUForFheBitAndCall),
        #[allow(missing_docs)]
        checkHCUForFheBitOr(checkHCUForFheBitOrCall),
        #[allow(missing_docs)]
        checkHCUForFheBitXor(checkHCUForFheBitXorCall),
        #[allow(missing_docs)]
        checkHCUForFheDiv(checkHCUForFheDivCall),
        #[allow(missing_docs)]
        checkHCUForFheEq(checkHCUForFheEqCall),
        #[allow(missing_docs)]
        checkHCUForFheGe(checkHCUForFheGeCall),
        #[allow(missing_docs)]
        checkHCUForFheGt(checkHCUForFheGtCall),
        #[allow(missing_docs)]
        checkHCUForFheLe(checkHCUForFheLeCall),
        #[allow(missing_docs)]
        checkHCUForFheLt(checkHCUForFheLtCall),
        #[allow(missing_docs)]
        checkHCUForFheMax(checkHCUForFheMaxCall),
        #[allow(missing_docs)]
        checkHCUForFheMin(checkHCUForFheMinCall),
        #[allow(missing_docs)]
        checkHCUForFheMul(checkHCUForFheMulCall),
        #[allow(missing_docs)]
        checkHCUForFheNe(checkHCUForFheNeCall),
        #[allow(missing_docs)]
        checkHCUForFheNeg(checkHCUForFheNegCall),
        #[allow(missing_docs)]
        checkHCUForFheNot(checkHCUForFheNotCall),
        #[allow(missing_docs)]
        checkHCUForFheRand(checkHCUForFheRandCall),
        #[allow(missing_docs)]
        checkHCUForFheRandBounded(checkHCUForFheRandBoundedCall),
        #[allow(missing_docs)]
        checkHCUForFheRem(checkHCUForFheRemCall),
        #[allow(missing_docs)]
        checkHCUForFheRotl(checkHCUForFheRotlCall),
        #[allow(missing_docs)]
        checkHCUForFheRotr(checkHCUForFheRotrCall),
        #[allow(missing_docs)]
        checkHCUForFheShl(checkHCUForFheShlCall),
        #[allow(missing_docs)]
        checkHCUForFheShr(checkHCUForFheShrCall),
        #[allow(missing_docs)]
        checkHCUForFheSub(checkHCUForFheSubCall),
        #[allow(missing_docs)]
        checkHCUForIfThenElse(checkHCUForIfThenElseCall),
        #[allow(missing_docs)]
        checkHCUForTrivialEncrypt(checkHCUForTrivialEncryptCall),
        #[allow(missing_docs)]
        getFHEVMExecutorAddress(getFHEVMExecutorAddressCall),
        #[allow(missing_docs)]
        getVersion(getVersionCall),
        #[allow(missing_docs)]
        initializeFromEmptyProxy(initializeFromEmptyProxyCall),
        #[allow(missing_docs)]
        proxiableUUID(proxiableUUIDCall),
        #[allow(missing_docs)]
        upgradeToAndCall(upgradeToAndCallCall),
    }
    #[automatically_derived]
    impl HCULimitCalls {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [2u8, 221u8, 98u8, 118u8],
            [9u8, 176u8, 78u8, 143u8],
            [13u8, 142u8, 110u8, 44u8],
            [19u8, 57u8, 197u8, 238u8],
            [20u8, 52u8, 186u8, 77u8],
            [20u8, 82u8, 110u8, 135u8],
            [24u8, 86u8, 217u8, 29u8],
            [30u8, 217u8, 31u8, 246u8],
            [38u8, 141u8, 109u8, 49u8],
            [52u8, 140u8, 49u8, 133u8],
            [57u8, 247u8, 56u8, 16u8],
            [60u8, 22u8, 255u8, 13u8],
            [64u8, 107u8, 69u8, 19u8],
            [78u8, 114u8, 103u8, 105u8],
            [79u8, 30u8, 242u8, 134u8],
            [82u8, 209u8, 144u8, 45u8],
            [100u8, 43u8, 20u8, 144u8],
            [102u8, 145u8, 129u8, 192u8],
            [107u8, 179u8, 198u8, 17u8],
            [131u8, 230u8, 167u8, 32u8],
            [133u8, 154u8, 27u8, 112u8],
            [144u8, 117u8, 49u8, 8u8],
            [148u8, 231u8, 14u8, 79u8],
            [164u8, 201u8, 143u8, 62u8],
            [172u8, 181u8, 243u8, 136u8],
            [173u8, 60u8, 177u8, 204u8],
            [204u8, 134u8, 103u8, 130u8],
            [212u8, 127u8, 61u8, 89u8],
            [232u8, 227u8, 153u8, 173u8],
            [250u8, 8u8, 227u8, 141u8],
            [250u8, 93u8, 239u8, 219u8],
            [252u8, 6u8, 60u8, 98u8],
            [253u8, 173u8, 76u8, 150u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for HCULimitCalls {
        const NAME: &'static str = "HCULimitCalls";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 33usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::UPGRADE_INTERFACE_VERSION(_) => {
                    <UPGRADE_INTERFACE_VERSIONCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::checkHCUForCast(_) => {
                    <checkHCUForCastCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::checkHCUForFheAdd(_) => {
                    <checkHCUForFheAddCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::checkHCUForFheBitAnd(_) => {
                    <checkHCUForFheBitAndCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::checkHCUForFheBitOr(_) => {
                    <checkHCUForFheBitOrCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::checkHCUForFheBitXor(_) => {
                    <checkHCUForFheBitXorCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::checkHCUForFheDiv(_) => {
                    <checkHCUForFheDivCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::checkHCUForFheEq(_) => {
                    <checkHCUForFheEqCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::checkHCUForFheGe(_) => {
                    <checkHCUForFheGeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::checkHCUForFheGt(_) => {
                    <checkHCUForFheGtCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::checkHCUForFheLe(_) => {
                    <checkHCUForFheLeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::checkHCUForFheLt(_) => {
                    <checkHCUForFheLtCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::checkHCUForFheMax(_) => {
                    <checkHCUForFheMaxCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::checkHCUForFheMin(_) => {
                    <checkHCUForFheMinCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::checkHCUForFheMul(_) => {
                    <checkHCUForFheMulCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::checkHCUForFheNe(_) => {
                    <checkHCUForFheNeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::checkHCUForFheNeg(_) => {
                    <checkHCUForFheNegCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::checkHCUForFheNot(_) => {
                    <checkHCUForFheNotCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::checkHCUForFheRand(_) => {
                    <checkHCUForFheRandCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::checkHCUForFheRandBounded(_) => {
                    <checkHCUForFheRandBoundedCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::checkHCUForFheRem(_) => {
                    <checkHCUForFheRemCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::checkHCUForFheRotl(_) => {
                    <checkHCUForFheRotlCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::checkHCUForFheRotr(_) => {
                    <checkHCUForFheRotrCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::checkHCUForFheShl(_) => {
                    <checkHCUForFheShlCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::checkHCUForFheShr(_) => {
                    <checkHCUForFheShrCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::checkHCUForFheSub(_) => {
                    <checkHCUForFheSubCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::checkHCUForIfThenElse(_) => {
                    <checkHCUForIfThenElseCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::checkHCUForTrivialEncrypt(_) => {
                    <checkHCUForTrivialEncryptCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getFHEVMExecutorAddress(_) => {
                    <getFHEVMExecutorAddressCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getVersion(_) => {
                    <getVersionCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::initializeFromEmptyProxy(_) => {
                    <initializeFromEmptyProxyCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::proxiableUUID(_) => {
                    <proxiableUUIDCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::upgradeToAndCall(_) => {
                    <upgradeToAndCallCall as alloy_sol_types::SolCall>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<HCULimitCalls>] = &[
                {
                    fn checkHCUForCast(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForCastCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForCast)
                    }
                    checkHCUForCast
                },
                {
                    fn checkHCUForFheRand(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForFheRandCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForFheRand)
                    }
                    checkHCUForFheRand
                },
                {
                    fn getVersion(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <getVersionCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitCalls::getVersion)
                    }
                    getVersion
                },
                {
                    fn checkHCUForFheLt(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForFheLtCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForFheLt)
                    }
                    checkHCUForFheLt
                },
                {
                    fn checkHCUForFheBitXor(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForFheBitXorCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForFheBitXor)
                    }
                    checkHCUForFheBitXor
                },
                {
                    fn checkHCUForFheRotl(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForFheRotlCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForFheRotl)
                    }
                    checkHCUForFheRotl
                },
                {
                    fn checkHCUForFheBitAnd(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForFheBitAndCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForFheBitAnd)
                    }
                    checkHCUForFheBitAnd
                },
                {
                    fn checkHCUForFheShr(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForFheShrCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForFheShr)
                    }
                    checkHCUForFheShr
                },
                {
                    fn getFHEVMExecutorAddress(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <getFHEVMExecutorAddressCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitCalls::getFHEVMExecutorAddress)
                    }
                    getFHEVMExecutorAddress
                },
                {
                    fn checkHCUForTrivialEncrypt(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForTrivialEncryptCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForTrivialEncrypt)
                    }
                    checkHCUForTrivialEncrypt
                },
                {
                    fn initializeFromEmptyProxy(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <initializeFromEmptyProxyCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitCalls::initializeFromEmptyProxy)
                    }
                    initializeFromEmptyProxy
                },
                {
                    fn checkHCUForFheMul(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForFheMulCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForFheMul)
                    }
                    checkHCUForFheMul
                },
                {
                    fn checkHCUForFheDiv(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForFheDivCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForFheDiv)
                    }
                    checkHCUForFheDiv
                },
                {
                    fn checkHCUForIfThenElse(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForIfThenElseCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForIfThenElse)
                    }
                    checkHCUForIfThenElse
                },
                {
                    fn upgradeToAndCall(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <upgradeToAndCallCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitCalls::upgradeToAndCall)
                    }
                    upgradeToAndCall
                },
                {
                    fn proxiableUUID(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <proxiableUUIDCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitCalls::proxiableUUID)
                    }
                    proxiableUUID
                },
                {
                    fn checkHCUForFheMin(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForFheMinCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForFheMin)
                    }
                    checkHCUForFheMin
                },
                {
                    fn checkHCUForFheRotr(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForFheRotrCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForFheRotr)
                    }
                    checkHCUForFheRotr
                },
                {
                    fn checkHCUForFheGe(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForFheGeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForFheGe)
                    }
                    checkHCUForFheGe
                },
                {
                    fn checkHCUForFheShl(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForFheShlCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForFheShl)
                    }
                    checkHCUForFheShl
                },
                {
                    fn checkHCUForFheGt(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForFheGtCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForFheGt)
                    }
                    checkHCUForFheGt
                },
                {
                    fn checkHCUForFheSub(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForFheSubCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForFheSub)
                    }
                    checkHCUForFheSub
                },
                {
                    fn checkHCUForFheEq(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForFheEqCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForFheEq)
                    }
                    checkHCUForFheEq
                },
                {
                    fn checkHCUForFheNeg(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForFheNegCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForFheNeg)
                    }
                    checkHCUForFheNeg
                },
                {
                    fn checkHCUForFheMax(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForFheMaxCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForFheMax)
                    }
                    checkHCUForFheMax
                },
                {
                    fn UPGRADE_INTERFACE_VERSION(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <UPGRADE_INTERFACE_VERSIONCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitCalls::UPGRADE_INTERFACE_VERSION)
                    }
                    UPGRADE_INTERFACE_VERSION
                },
                {
                    fn checkHCUForFheRandBounded(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForFheRandBoundedCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForFheRandBounded)
                    }
                    checkHCUForFheRandBounded
                },
                {
                    fn checkHCUForFheLe(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForFheLeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForFheLe)
                    }
                    checkHCUForFheLe
                },
                {
                    fn checkHCUForFheBitOr(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForFheBitOrCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForFheBitOr)
                    }
                    checkHCUForFheBitOr
                },
                {
                    fn checkHCUForFheRem(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForFheRemCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForFheRem)
                    }
                    checkHCUForFheRem
                },
                {
                    fn checkHCUForFheNe(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForFheNeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForFheNe)
                    }
                    checkHCUForFheNe
                },
                {
                    fn checkHCUForFheNot(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForFheNotCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForFheNot)
                    }
                    checkHCUForFheNot
                },
                {
                    fn checkHCUForFheAdd(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForFheAddCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForFheAdd)
                    }
                    checkHCUForFheAdd
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data)
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw_validate(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_VALIDATE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<HCULimitCalls>] = &[
                {
                    fn checkHCUForCast(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForCastCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForCast)
                    }
                    checkHCUForCast
                },
                {
                    fn checkHCUForFheRand(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForFheRandCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForFheRand)
                    }
                    checkHCUForFheRand
                },
                {
                    fn getVersion(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <getVersionCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitCalls::getVersion)
                    }
                    getVersion
                },
                {
                    fn checkHCUForFheLt(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForFheLtCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForFheLt)
                    }
                    checkHCUForFheLt
                },
                {
                    fn checkHCUForFheBitXor(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForFheBitXorCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForFheBitXor)
                    }
                    checkHCUForFheBitXor
                },
                {
                    fn checkHCUForFheRotl(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForFheRotlCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForFheRotl)
                    }
                    checkHCUForFheRotl
                },
                {
                    fn checkHCUForFheBitAnd(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForFheBitAndCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForFheBitAnd)
                    }
                    checkHCUForFheBitAnd
                },
                {
                    fn checkHCUForFheShr(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForFheShrCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForFheShr)
                    }
                    checkHCUForFheShr
                },
                {
                    fn getFHEVMExecutorAddress(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <getFHEVMExecutorAddressCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitCalls::getFHEVMExecutorAddress)
                    }
                    getFHEVMExecutorAddress
                },
                {
                    fn checkHCUForTrivialEncrypt(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForTrivialEncryptCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForTrivialEncrypt)
                    }
                    checkHCUForTrivialEncrypt
                },
                {
                    fn initializeFromEmptyProxy(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <initializeFromEmptyProxyCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitCalls::initializeFromEmptyProxy)
                    }
                    initializeFromEmptyProxy
                },
                {
                    fn checkHCUForFheMul(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForFheMulCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForFheMul)
                    }
                    checkHCUForFheMul
                },
                {
                    fn checkHCUForFheDiv(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForFheDivCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForFheDiv)
                    }
                    checkHCUForFheDiv
                },
                {
                    fn checkHCUForIfThenElse(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForIfThenElseCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForIfThenElse)
                    }
                    checkHCUForIfThenElse
                },
                {
                    fn upgradeToAndCall(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <upgradeToAndCallCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitCalls::upgradeToAndCall)
                    }
                    upgradeToAndCall
                },
                {
                    fn proxiableUUID(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <proxiableUUIDCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitCalls::proxiableUUID)
                    }
                    proxiableUUID
                },
                {
                    fn checkHCUForFheMin(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForFheMinCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForFheMin)
                    }
                    checkHCUForFheMin
                },
                {
                    fn checkHCUForFheRotr(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForFheRotrCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForFheRotr)
                    }
                    checkHCUForFheRotr
                },
                {
                    fn checkHCUForFheGe(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForFheGeCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForFheGe)
                    }
                    checkHCUForFheGe
                },
                {
                    fn checkHCUForFheShl(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForFheShlCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForFheShl)
                    }
                    checkHCUForFheShl
                },
                {
                    fn checkHCUForFheGt(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForFheGtCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForFheGt)
                    }
                    checkHCUForFheGt
                },
                {
                    fn checkHCUForFheSub(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForFheSubCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForFheSub)
                    }
                    checkHCUForFheSub
                },
                {
                    fn checkHCUForFheEq(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForFheEqCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForFheEq)
                    }
                    checkHCUForFheEq
                },
                {
                    fn checkHCUForFheNeg(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForFheNegCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForFheNeg)
                    }
                    checkHCUForFheNeg
                },
                {
                    fn checkHCUForFheMax(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForFheMaxCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForFheMax)
                    }
                    checkHCUForFheMax
                },
                {
                    fn UPGRADE_INTERFACE_VERSION(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <UPGRADE_INTERFACE_VERSIONCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitCalls::UPGRADE_INTERFACE_VERSION)
                    }
                    UPGRADE_INTERFACE_VERSION
                },
                {
                    fn checkHCUForFheRandBounded(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForFheRandBoundedCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForFheRandBounded)
                    }
                    checkHCUForFheRandBounded
                },
                {
                    fn checkHCUForFheLe(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForFheLeCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForFheLe)
                    }
                    checkHCUForFheLe
                },
                {
                    fn checkHCUForFheBitOr(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForFheBitOrCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForFheBitOr)
                    }
                    checkHCUForFheBitOr
                },
                {
                    fn checkHCUForFheRem(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForFheRemCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForFheRem)
                    }
                    checkHCUForFheRem
                },
                {
                    fn checkHCUForFheNe(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForFheNeCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForFheNe)
                    }
                    checkHCUForFheNe
                },
                {
                    fn checkHCUForFheNot(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForFheNotCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForFheNot)
                    }
                    checkHCUForFheNot
                },
                {
                    fn checkHCUForFheAdd(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForFheAddCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForFheAdd)
                    }
                    checkHCUForFheAdd
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_VALIDATE_SHIMS[idx](data)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::UPGRADE_INTERFACE_VERSION(inner) => {
                    <UPGRADE_INTERFACE_VERSIONCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::checkHCUForCast(inner) => {
                    <checkHCUForCastCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::checkHCUForFheAdd(inner) => {
                    <checkHCUForFheAddCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::checkHCUForFheBitAnd(inner) => {
                    <checkHCUForFheBitAndCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::checkHCUForFheBitOr(inner) => {
                    <checkHCUForFheBitOrCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::checkHCUForFheBitXor(inner) => {
                    <checkHCUForFheBitXorCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::checkHCUForFheDiv(inner) => {
                    <checkHCUForFheDivCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::checkHCUForFheEq(inner) => {
                    <checkHCUForFheEqCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::checkHCUForFheGe(inner) => {
                    <checkHCUForFheGeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::checkHCUForFheGt(inner) => {
                    <checkHCUForFheGtCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::checkHCUForFheLe(inner) => {
                    <checkHCUForFheLeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::checkHCUForFheLt(inner) => {
                    <checkHCUForFheLtCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::checkHCUForFheMax(inner) => {
                    <checkHCUForFheMaxCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::checkHCUForFheMin(inner) => {
                    <checkHCUForFheMinCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::checkHCUForFheMul(inner) => {
                    <checkHCUForFheMulCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::checkHCUForFheNe(inner) => {
                    <checkHCUForFheNeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::checkHCUForFheNeg(inner) => {
                    <checkHCUForFheNegCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::checkHCUForFheNot(inner) => {
                    <checkHCUForFheNotCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::checkHCUForFheRand(inner) => {
                    <checkHCUForFheRandCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::checkHCUForFheRandBounded(inner) => {
                    <checkHCUForFheRandBoundedCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::checkHCUForFheRem(inner) => {
                    <checkHCUForFheRemCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::checkHCUForFheRotl(inner) => {
                    <checkHCUForFheRotlCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::checkHCUForFheRotr(inner) => {
                    <checkHCUForFheRotrCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::checkHCUForFheShl(inner) => {
                    <checkHCUForFheShlCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::checkHCUForFheShr(inner) => {
                    <checkHCUForFheShrCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::checkHCUForFheSub(inner) => {
                    <checkHCUForFheSubCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::checkHCUForIfThenElse(inner) => {
                    <checkHCUForIfThenElseCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::checkHCUForTrivialEncrypt(inner) => {
                    <checkHCUForTrivialEncryptCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getFHEVMExecutorAddress(inner) => {
                    <getFHEVMExecutorAddressCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getVersion(inner) => {
                    <getVersionCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::initializeFromEmptyProxy(inner) => {
                    <initializeFromEmptyProxyCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::proxiableUUID(inner) => {
                    <proxiableUUIDCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::upgradeToAndCall(inner) => {
                    <upgradeToAndCallCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::UPGRADE_INTERFACE_VERSION(inner) => {
                    <UPGRADE_INTERFACE_VERSIONCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::checkHCUForCast(inner) => {
                    <checkHCUForCastCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::checkHCUForFheAdd(inner) => {
                    <checkHCUForFheAddCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::checkHCUForFheBitAnd(inner) => {
                    <checkHCUForFheBitAndCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::checkHCUForFheBitOr(inner) => {
                    <checkHCUForFheBitOrCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::checkHCUForFheBitXor(inner) => {
                    <checkHCUForFheBitXorCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::checkHCUForFheDiv(inner) => {
                    <checkHCUForFheDivCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::checkHCUForFheEq(inner) => {
                    <checkHCUForFheEqCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::checkHCUForFheGe(inner) => {
                    <checkHCUForFheGeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::checkHCUForFheGt(inner) => {
                    <checkHCUForFheGtCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::checkHCUForFheLe(inner) => {
                    <checkHCUForFheLeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::checkHCUForFheLt(inner) => {
                    <checkHCUForFheLtCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::checkHCUForFheMax(inner) => {
                    <checkHCUForFheMaxCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::checkHCUForFheMin(inner) => {
                    <checkHCUForFheMinCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::checkHCUForFheMul(inner) => {
                    <checkHCUForFheMulCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::checkHCUForFheNe(inner) => {
                    <checkHCUForFheNeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::checkHCUForFheNeg(inner) => {
                    <checkHCUForFheNegCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::checkHCUForFheNot(inner) => {
                    <checkHCUForFheNotCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::checkHCUForFheRand(inner) => {
                    <checkHCUForFheRandCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::checkHCUForFheRandBounded(inner) => {
                    <checkHCUForFheRandBoundedCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::checkHCUForFheRem(inner) => {
                    <checkHCUForFheRemCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::checkHCUForFheRotl(inner) => {
                    <checkHCUForFheRotlCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::checkHCUForFheRotr(inner) => {
                    <checkHCUForFheRotrCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::checkHCUForFheShl(inner) => {
                    <checkHCUForFheShlCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::checkHCUForFheShr(inner) => {
                    <checkHCUForFheShrCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::checkHCUForFheSub(inner) => {
                    <checkHCUForFheSubCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::checkHCUForIfThenElse(inner) => {
                    <checkHCUForIfThenElseCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::checkHCUForTrivialEncrypt(inner) => {
                    <checkHCUForTrivialEncryptCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getFHEVMExecutorAddress(inner) => {
                    <getFHEVMExecutorAddressCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getVersion(inner) => {
                    <getVersionCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::initializeFromEmptyProxy(inner) => {
                    <initializeFromEmptyProxyCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::proxiableUUID(inner) => {
                    <proxiableUUIDCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::upgradeToAndCall(inner) => {
                    <upgradeToAndCallCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`HCULimit`](self) custom errors.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub enum HCULimitErrors {
        #[allow(missing_docs)]
        AddressEmptyCode(AddressEmptyCode),
        #[allow(missing_docs)]
        CallerMustBeFHEVMExecutorContract(CallerMustBeFHEVMExecutorContract),
        #[allow(missing_docs)]
        ERC1967InvalidImplementation(ERC1967InvalidImplementation),
        #[allow(missing_docs)]
        ERC1967NonPayable(ERC1967NonPayable),
        #[allow(missing_docs)]
        FailedCall(FailedCall),
        #[allow(missing_docs)]
        HCUTransactionDepthLimitExceeded(HCUTransactionDepthLimitExceeded),
        #[allow(missing_docs)]
        HCUTransactionLimitExceeded(HCUTransactionLimitExceeded),
        #[allow(missing_docs)]
        InvalidInitialization(InvalidInitialization),
        #[allow(missing_docs)]
        NotHostOwner(NotHostOwner),
        #[allow(missing_docs)]
        NotInitializing(NotInitializing),
        #[allow(missing_docs)]
        NotInitializingFromEmptyProxy(NotInitializingFromEmptyProxy),
        #[allow(missing_docs)]
        OnlyScalarOperationsAreSupported(OnlyScalarOperationsAreSupported),
        #[allow(missing_docs)]
        UUPSUnauthorizedCallContext(UUPSUnauthorizedCallContext),
        #[allow(missing_docs)]
        UUPSUnsupportedProxiableUUID(UUPSUnsupportedProxiableUUID),
        #[allow(missing_docs)]
        UnsupportedOperation(UnsupportedOperation),
    }
    #[automatically_derived]
    impl HCULimitErrors {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [33u8, 191u8, 218u8, 16u8],
            [49u8, 168u8, 26u8, 129u8],
            [76u8, 156u8, 140u8, 227u8],
            [106u8, 169u8, 235u8, 5u8],
            [111u8, 79u8, 115u8, 31u8],
            [119u8, 227u8, 194u8, 147u8],
            [153u8, 150u8, 179u8, 21u8],
            [155u8, 166u8, 6u8, 27u8],
            [170u8, 29u8, 73u8, 164u8],
            [179u8, 152u8, 151u8, 159u8],
            [214u8, 189u8, 162u8, 117u8],
            [215u8, 230u8, 188u8, 248u8],
            [224u8, 124u8, 141u8, 186u8],
            [249u8, 46u8, 232u8, 169u8],
            [252u8, 52u8, 72u8, 112u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for HCULimitErrors {
        const NAME: &'static str = "HCULimitErrors";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 15usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::AddressEmptyCode(_) => {
                    <AddressEmptyCode as alloy_sol_types::SolError>::SELECTOR
                }
                Self::CallerMustBeFHEVMExecutorContract(_) => {
                    <CallerMustBeFHEVMExecutorContract as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC1967InvalidImplementation(_) => {
                    <ERC1967InvalidImplementation as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC1967NonPayable(_) => {
                    <ERC1967NonPayable as alloy_sol_types::SolError>::SELECTOR
                }
                Self::FailedCall(_) => {
                    <FailedCall as alloy_sol_types::SolError>::SELECTOR
                }
                Self::HCUTransactionDepthLimitExceeded(_) => {
                    <HCUTransactionDepthLimitExceeded as alloy_sol_types::SolError>::SELECTOR
                }
                Self::HCUTransactionLimitExceeded(_) => {
                    <HCUTransactionLimitExceeded as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidInitialization(_) => {
                    <InvalidInitialization as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NotHostOwner(_) => {
                    <NotHostOwner as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NotInitializing(_) => {
                    <NotInitializing as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NotInitializingFromEmptyProxy(_) => {
                    <NotInitializingFromEmptyProxy as alloy_sol_types::SolError>::SELECTOR
                }
                Self::OnlyScalarOperationsAreSupported(_) => {
                    <OnlyScalarOperationsAreSupported as alloy_sol_types::SolError>::SELECTOR
                }
                Self::UUPSUnauthorizedCallContext(_) => {
                    <UUPSUnauthorizedCallContext as alloy_sol_types::SolError>::SELECTOR
                }
                Self::UUPSUnsupportedProxiableUUID(_) => {
                    <UUPSUnsupportedProxiableUUID as alloy_sol_types::SolError>::SELECTOR
                }
                Self::UnsupportedOperation(_) => {
                    <UnsupportedOperation as alloy_sol_types::SolError>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<HCULimitErrors>] = &[
                {
                    fn NotHostOwner(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitErrors> {
                        <NotHostOwner as alloy_sol_types::SolError>::abi_decode_raw(data)
                            .map(HCULimitErrors::NotHostOwner)
                    }
                    NotHostOwner
                },
                {
                    fn CallerMustBeFHEVMExecutorContract(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitErrors> {
                        <CallerMustBeFHEVMExecutorContract as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitErrors::CallerMustBeFHEVMExecutorContract)
                    }
                    CallerMustBeFHEVMExecutorContract
                },
                {
                    fn ERC1967InvalidImplementation(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitErrors> {
                        <ERC1967InvalidImplementation as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitErrors::ERC1967InvalidImplementation)
                    }
                    ERC1967InvalidImplementation
                },
                {
                    fn OnlyScalarOperationsAreSupported(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitErrors> {
                        <OnlyScalarOperationsAreSupported as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitErrors::OnlyScalarOperationsAreSupported)
                    }
                    OnlyScalarOperationsAreSupported
                },
                {
                    fn NotInitializingFromEmptyProxy(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitErrors> {
                        <NotInitializingFromEmptyProxy as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitErrors::NotInitializingFromEmptyProxy)
                    }
                    NotInitializingFromEmptyProxy
                },
                {
                    fn HCUTransactionLimitExceeded(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitErrors> {
                        <HCUTransactionLimitExceeded as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitErrors::HCUTransactionLimitExceeded)
                    }
                    HCUTransactionLimitExceeded
                },
                {
                    fn AddressEmptyCode(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitErrors> {
                        <AddressEmptyCode as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitErrors::AddressEmptyCode)
                    }
                    AddressEmptyCode
                },
                {
                    fn UnsupportedOperation(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitErrors> {
                        <UnsupportedOperation as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitErrors::UnsupportedOperation)
                    }
                    UnsupportedOperation
                },
                {
                    fn UUPSUnsupportedProxiableUUID(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitErrors> {
                        <UUPSUnsupportedProxiableUUID as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitErrors::UUPSUnsupportedProxiableUUID)
                    }
                    UUPSUnsupportedProxiableUUID
                },
                {
                    fn ERC1967NonPayable(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitErrors> {
                        <ERC1967NonPayable as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitErrors::ERC1967NonPayable)
                    }
                    ERC1967NonPayable
                },
                {
                    fn FailedCall(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitErrors> {
                        <FailedCall as alloy_sol_types::SolError>::abi_decode_raw(data)
                            .map(HCULimitErrors::FailedCall)
                    }
                    FailedCall
                },
                {
                    fn NotInitializing(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitErrors> {
                        <NotInitializing as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitErrors::NotInitializing)
                    }
                    NotInitializing
                },
                {
                    fn UUPSUnauthorizedCallContext(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitErrors> {
                        <UUPSUnauthorizedCallContext as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitErrors::UUPSUnauthorizedCallContext)
                    }
                    UUPSUnauthorizedCallContext
                },
                {
                    fn InvalidInitialization(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitErrors> {
                        <InvalidInitialization as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitErrors::InvalidInitialization)
                    }
                    InvalidInitialization
                },
                {
                    fn HCUTransactionDepthLimitExceeded(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitErrors> {
                        <HCUTransactionDepthLimitExceeded as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitErrors::HCUTransactionDepthLimitExceeded)
                    }
                    HCUTransactionDepthLimitExceeded
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data)
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw_validate(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_VALIDATE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<HCULimitErrors>] = &[
                {
                    fn NotHostOwner(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitErrors> {
                        <NotHostOwner as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitErrors::NotHostOwner)
                    }
                    NotHostOwner
                },
                {
                    fn CallerMustBeFHEVMExecutorContract(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitErrors> {
                        <CallerMustBeFHEVMExecutorContract as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitErrors::CallerMustBeFHEVMExecutorContract)
                    }
                    CallerMustBeFHEVMExecutorContract
                },
                {
                    fn ERC1967InvalidImplementation(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitErrors> {
                        <ERC1967InvalidImplementation as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitErrors::ERC1967InvalidImplementation)
                    }
                    ERC1967InvalidImplementation
                },
                {
                    fn OnlyScalarOperationsAreSupported(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitErrors> {
                        <OnlyScalarOperationsAreSupported as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitErrors::OnlyScalarOperationsAreSupported)
                    }
                    OnlyScalarOperationsAreSupported
                },
                {
                    fn NotInitializingFromEmptyProxy(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitErrors> {
                        <NotInitializingFromEmptyProxy as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitErrors::NotInitializingFromEmptyProxy)
                    }
                    NotInitializingFromEmptyProxy
                },
                {
                    fn HCUTransactionLimitExceeded(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitErrors> {
                        <HCUTransactionLimitExceeded as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitErrors::HCUTransactionLimitExceeded)
                    }
                    HCUTransactionLimitExceeded
                },
                {
                    fn AddressEmptyCode(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitErrors> {
                        <AddressEmptyCode as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitErrors::AddressEmptyCode)
                    }
                    AddressEmptyCode
                },
                {
                    fn UnsupportedOperation(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitErrors> {
                        <UnsupportedOperation as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitErrors::UnsupportedOperation)
                    }
                    UnsupportedOperation
                },
                {
                    fn UUPSUnsupportedProxiableUUID(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitErrors> {
                        <UUPSUnsupportedProxiableUUID as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitErrors::UUPSUnsupportedProxiableUUID)
                    }
                    UUPSUnsupportedProxiableUUID
                },
                {
                    fn ERC1967NonPayable(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitErrors> {
                        <ERC1967NonPayable as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitErrors::ERC1967NonPayable)
                    }
                    ERC1967NonPayable
                },
                {
                    fn FailedCall(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitErrors> {
                        <FailedCall as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitErrors::FailedCall)
                    }
                    FailedCall
                },
                {
                    fn NotInitializing(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitErrors> {
                        <NotInitializing as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitErrors::NotInitializing)
                    }
                    NotInitializing
                },
                {
                    fn UUPSUnauthorizedCallContext(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitErrors> {
                        <UUPSUnauthorizedCallContext as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitErrors::UUPSUnauthorizedCallContext)
                    }
                    UUPSUnauthorizedCallContext
                },
                {
                    fn InvalidInitialization(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitErrors> {
                        <InvalidInitialization as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitErrors::InvalidInitialization)
                    }
                    InvalidInitialization
                },
                {
                    fn HCUTransactionDepthLimitExceeded(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitErrors> {
                        <HCUTransactionDepthLimitExceeded as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitErrors::HCUTransactionDepthLimitExceeded)
                    }
                    HCUTransactionDepthLimitExceeded
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_VALIDATE_SHIMS[idx](data)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::AddressEmptyCode(inner) => {
                    <AddressEmptyCode as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::CallerMustBeFHEVMExecutorContract(inner) => {
                    <CallerMustBeFHEVMExecutorContract as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC1967InvalidImplementation(inner) => {
                    <ERC1967InvalidImplementation as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC1967NonPayable(inner) => {
                    <ERC1967NonPayable as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::FailedCall(inner) => {
                    <FailedCall as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::HCUTransactionDepthLimitExceeded(inner) => {
                    <HCUTransactionDepthLimitExceeded as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::HCUTransactionLimitExceeded(inner) => {
                    <HCUTransactionLimitExceeded as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidInitialization(inner) => {
                    <InvalidInitialization as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NotHostOwner(inner) => {
                    <NotHostOwner as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::NotInitializing(inner) => {
                    <NotInitializing as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NotInitializingFromEmptyProxy(inner) => {
                    <NotInitializingFromEmptyProxy as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::OnlyScalarOperationsAreSupported(inner) => {
                    <OnlyScalarOperationsAreSupported as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::UUPSUnauthorizedCallContext(inner) => {
                    <UUPSUnauthorizedCallContext as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::UUPSUnsupportedProxiableUUID(inner) => {
                    <UUPSUnsupportedProxiableUUID as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::UnsupportedOperation(inner) => {
                    <UnsupportedOperation as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::AddressEmptyCode(inner) => {
                    <AddressEmptyCode as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::CallerMustBeFHEVMExecutorContract(inner) => {
                    <CallerMustBeFHEVMExecutorContract as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC1967InvalidImplementation(inner) => {
                    <ERC1967InvalidImplementation as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC1967NonPayable(inner) => {
                    <ERC1967NonPayable as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::FailedCall(inner) => {
                    <FailedCall as alloy_sol_types::SolError>::abi_encode_raw(inner, out)
                }
                Self::HCUTransactionDepthLimitExceeded(inner) => {
                    <HCUTransactionDepthLimitExceeded as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::HCUTransactionLimitExceeded(inner) => {
                    <HCUTransactionLimitExceeded as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidInitialization(inner) => {
                    <InvalidInitialization as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NotHostOwner(inner) => {
                    <NotHostOwner as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NotInitializing(inner) => {
                    <NotInitializing as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NotInitializingFromEmptyProxy(inner) => {
                    <NotInitializingFromEmptyProxy as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::OnlyScalarOperationsAreSupported(inner) => {
                    <OnlyScalarOperationsAreSupported as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::UUPSUnauthorizedCallContext(inner) => {
                    <UUPSUnauthorizedCallContext as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::UUPSUnsupportedProxiableUUID(inner) => {
                    <UUPSUnsupportedProxiableUUID as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::UnsupportedOperation(inner) => {
                    <UnsupportedOperation as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`HCULimit`](self) events.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub enum HCULimitEvents {
        #[allow(missing_docs)]
        Initialized(Initialized),
        #[allow(missing_docs)]
        Upgraded(Upgraded),
    }
    #[automatically_derived]
    impl HCULimitEvents {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 32usize]] = &[
            [
                188u8, 124u8, 215u8, 90u8, 32u8, 238u8, 39u8, 253u8, 154u8, 222u8, 186u8,
                179u8, 32u8, 65u8, 247u8, 85u8, 33u8, 77u8, 188u8, 107u8, 255u8, 169u8,
                12u8, 192u8, 34u8, 91u8, 57u8, 218u8, 46u8, 92u8, 45u8, 59u8,
            ],
            [
                199u8, 245u8, 5u8, 178u8, 243u8, 113u8, 174u8, 33u8, 117u8, 238u8, 73u8,
                19u8, 244u8, 73u8, 158u8, 31u8, 38u8, 51u8, 167u8, 181u8, 147u8, 99u8,
                33u8, 238u8, 209u8, 205u8, 174u8, 182u8, 17u8, 81u8, 129u8, 210u8,
            ],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolEventInterface for HCULimitEvents {
        const NAME: &'static str = "HCULimitEvents";
        const COUNT: usize = 2usize;
        fn decode_raw_log(
            topics: &[alloy_sol_types::Word],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            match topics.first().copied() {
                Some(<Initialized as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Initialized as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::Initialized)
                }
                Some(<Upgraded as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Upgraded as alloy_sol_types::SolEvent>::decode_raw_log(topics, data)
                        .map(Self::Upgraded)
                }
                _ => {
                    alloy_sol_types::private::Err(alloy_sol_types::Error::InvalidLog {
                        name: <Self as alloy_sol_types::SolEventInterface>::NAME,
                        log: alloy_sol_types::private::Box::new(
                            alloy_sol_types::private::LogData::new_unchecked(
                                topics.to_vec(),
                                data.to_vec().into(),
                            ),
                        ),
                    })
                }
            }
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::private::IntoLogData for HCULimitEvents {
        fn to_log_data(&self) -> alloy_sol_types::private::LogData {
            match self {
                Self::Initialized(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Upgraded(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
            }
        }
        fn into_log_data(self) -> alloy_sol_types::private::LogData {
            match self {
                Self::Initialized(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Upgraded(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`HCULimit`](self) contract instance.

See the [wrapper's documentation](`HCULimitInstance`) for more details.*/
    #[inline]
    pub const fn new<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> HCULimitInstance<P, N> {
        HCULimitInstance::<P, N>::new(address, provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
    ) -> impl ::core::future::Future<
        Output = alloy_contract::Result<HCULimitInstance<P, N>>,
    > {
        HCULimitInstance::<P, N>::deploy(provider)
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(provider: P) -> alloy_contract::RawCallBuilder<P, N> {
        HCULimitInstance::<P, N>::deploy_builder(provider)
    }
    /**A [`HCULimit`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`HCULimit`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct HCULimitInstance<P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network: ::core::marker::PhantomData<N>,
    }
    #[automatically_derived]
    impl<P, N> ::core::fmt::Debug for HCULimitInstance<P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("HCULimitInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > HCULimitInstance<P, N> {
        /**Creates a new wrapper around an on-chain [`HCULimit`](self) contract instance.

See the [wrapper's documentation](`HCULimitInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            provider: P,
        ) -> Self {
            Self {
                address,
                provider,
                _network: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            provider: P,
        ) -> alloy_contract::Result<HCULimitInstance<P, N>> {
            let call_builder = Self::deploy_builder(provider);
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(provider: P) -> alloy_contract::RawCallBuilder<P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                provider,
                ::core::clone::Clone::clone(&BYTECODE),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<P: ::core::clone::Clone, N> HCULimitInstance<&P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> HCULimitInstance<P, N> {
            HCULimitInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > HCULimitInstance<P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<&P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        ///Creates a new call builder for the [`UPGRADE_INTERFACE_VERSION`] function.
        pub fn UPGRADE_INTERFACE_VERSION(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, UPGRADE_INTERFACE_VERSIONCall, N> {
            self.call_builder(&UPGRADE_INTERFACE_VERSIONCall)
        }
        ///Creates a new call builder for the [`checkHCUForCast`] function.
        pub fn checkHCUForCast(
            &self,
            resultType: <FheType as alloy::sol_types::SolType>::RustType,
            ct: alloy::sol_types::private::FixedBytes<32>,
            result: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<&P, checkHCUForCastCall, N> {
            self.call_builder(
                &checkHCUForCastCall {
                    resultType,
                    ct,
                    result,
                },
            )
        }
        ///Creates a new call builder for the [`checkHCUForFheAdd`] function.
        pub fn checkHCUForFheAdd(
            &self,
            resultType: <FheType as alloy::sol_types::SolType>::RustType,
            scalarByte: alloy::sol_types::private::FixedBytes<1>,
            lhs: alloy::sol_types::private::FixedBytes<32>,
            rhs: alloy::sol_types::private::FixedBytes<32>,
            result: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<&P, checkHCUForFheAddCall, N> {
            self.call_builder(
                &checkHCUForFheAddCall {
                    resultType,
                    scalarByte,
                    lhs,
                    rhs,
                    result,
                },
            )
        }
        ///Creates a new call builder for the [`checkHCUForFheBitAnd`] function.
        pub fn checkHCUForFheBitAnd(
            &self,
            resultType: <FheType as alloy::sol_types::SolType>::RustType,
            scalarByte: alloy::sol_types::private::FixedBytes<1>,
            lhs: alloy::sol_types::private::FixedBytes<32>,
            rhs: alloy::sol_types::private::FixedBytes<32>,
            result: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<&P, checkHCUForFheBitAndCall, N> {
            self.call_builder(
                &checkHCUForFheBitAndCall {
                    resultType,
                    scalarByte,
                    lhs,
                    rhs,
                    result,
                },
            )
        }
        ///Creates a new call builder for the [`checkHCUForFheBitOr`] function.
        pub fn checkHCUForFheBitOr(
            &self,
            resultType: <FheType as alloy::sol_types::SolType>::RustType,
            scalarByte: alloy::sol_types::private::FixedBytes<1>,
            lhs: alloy::sol_types::private::FixedBytes<32>,
            rhs: alloy::sol_types::private::FixedBytes<32>,
            result: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<&P, checkHCUForFheBitOrCall, N> {
            self.call_builder(
                &checkHCUForFheBitOrCall {
                    resultType,
                    scalarByte,
                    lhs,
                    rhs,
                    result,
                },
            )
        }
        ///Creates a new call builder for the [`checkHCUForFheBitXor`] function.
        pub fn checkHCUForFheBitXor(
            &self,
            resultType: <FheType as alloy::sol_types::SolType>::RustType,
            scalarByte: alloy::sol_types::private::FixedBytes<1>,
            lhs: alloy::sol_types::private::FixedBytes<32>,
            rhs: alloy::sol_types::private::FixedBytes<32>,
            result: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<&P, checkHCUForFheBitXorCall, N> {
            self.call_builder(
                &checkHCUForFheBitXorCall {
                    resultType,
                    scalarByte,
                    lhs,
                    rhs,
                    result,
                },
            )
        }
        ///Creates a new call builder for the [`checkHCUForFheDiv`] function.
        pub fn checkHCUForFheDiv(
            &self,
            resultType: <FheType as alloy::sol_types::SolType>::RustType,
            scalarByte: alloy::sol_types::private::FixedBytes<1>,
            lhs: alloy::sol_types::private::FixedBytes<32>,
            _3: alloy::sol_types::private::FixedBytes<32>,
            result: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<&P, checkHCUForFheDivCall, N> {
            self.call_builder(
                &checkHCUForFheDivCall {
                    resultType,
                    scalarByte,
                    lhs,
                    _3,
                    result,
                },
            )
        }
        ///Creates a new call builder for the [`checkHCUForFheEq`] function.
        pub fn checkHCUForFheEq(
            &self,
            resultType: <FheType as alloy::sol_types::SolType>::RustType,
            scalarByte: alloy::sol_types::private::FixedBytes<1>,
            lhs: alloy::sol_types::private::FixedBytes<32>,
            rhs: alloy::sol_types::private::FixedBytes<32>,
            result: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<&P, checkHCUForFheEqCall, N> {
            self.call_builder(
                &checkHCUForFheEqCall {
                    resultType,
                    scalarByte,
                    lhs,
                    rhs,
                    result,
                },
            )
        }
        ///Creates a new call builder for the [`checkHCUForFheGe`] function.
        pub fn checkHCUForFheGe(
            &self,
            resultType: <FheType as alloy::sol_types::SolType>::RustType,
            scalarByte: alloy::sol_types::private::FixedBytes<1>,
            lhs: alloy::sol_types::private::FixedBytes<32>,
            rhs: alloy::sol_types::private::FixedBytes<32>,
            result: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<&P, checkHCUForFheGeCall, N> {
            self.call_builder(
                &checkHCUForFheGeCall {
                    resultType,
                    scalarByte,
                    lhs,
                    rhs,
                    result,
                },
            )
        }
        ///Creates a new call builder for the [`checkHCUForFheGt`] function.
        pub fn checkHCUForFheGt(
            &self,
            resultType: <FheType as alloy::sol_types::SolType>::RustType,
            scalarByte: alloy::sol_types::private::FixedBytes<1>,
            lhs: alloy::sol_types::private::FixedBytes<32>,
            rhs: alloy::sol_types::private::FixedBytes<32>,
            result: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<&P, checkHCUForFheGtCall, N> {
            self.call_builder(
                &checkHCUForFheGtCall {
                    resultType,
                    scalarByte,
                    lhs,
                    rhs,
                    result,
                },
            )
        }
        ///Creates a new call builder for the [`checkHCUForFheLe`] function.
        pub fn checkHCUForFheLe(
            &self,
            resultType: <FheType as alloy::sol_types::SolType>::RustType,
            scalarByte: alloy::sol_types::private::FixedBytes<1>,
            lhs: alloy::sol_types::private::FixedBytes<32>,
            rhs: alloy::sol_types::private::FixedBytes<32>,
            result: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<&P, checkHCUForFheLeCall, N> {
            self.call_builder(
                &checkHCUForFheLeCall {
                    resultType,
                    scalarByte,
                    lhs,
                    rhs,
                    result,
                },
            )
        }
        ///Creates a new call builder for the [`checkHCUForFheLt`] function.
        pub fn checkHCUForFheLt(
            &self,
            resultType: <FheType as alloy::sol_types::SolType>::RustType,
            scalarByte: alloy::sol_types::private::FixedBytes<1>,
            lhs: alloy::sol_types::private::FixedBytes<32>,
            rhs: alloy::sol_types::private::FixedBytes<32>,
            result: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<&P, checkHCUForFheLtCall, N> {
            self.call_builder(
                &checkHCUForFheLtCall {
                    resultType,
                    scalarByte,
                    lhs,
                    rhs,
                    result,
                },
            )
        }
        ///Creates a new call builder for the [`checkHCUForFheMax`] function.
        pub fn checkHCUForFheMax(
            &self,
            resultType: <FheType as alloy::sol_types::SolType>::RustType,
            scalarByte: alloy::sol_types::private::FixedBytes<1>,
            lhs: alloy::sol_types::private::FixedBytes<32>,
            rhs: alloy::sol_types::private::FixedBytes<32>,
            result: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<&P, checkHCUForFheMaxCall, N> {
            self.call_builder(
                &checkHCUForFheMaxCall {
                    resultType,
                    scalarByte,
                    lhs,
                    rhs,
                    result,
                },
            )
        }
        ///Creates a new call builder for the [`checkHCUForFheMin`] function.
        pub fn checkHCUForFheMin(
            &self,
            resultType: <FheType as alloy::sol_types::SolType>::RustType,
            scalarByte: alloy::sol_types::private::FixedBytes<1>,
            lhs: alloy::sol_types::private::FixedBytes<32>,
            rhs: alloy::sol_types::private::FixedBytes<32>,
            result: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<&P, checkHCUForFheMinCall, N> {
            self.call_builder(
                &checkHCUForFheMinCall {
                    resultType,
                    scalarByte,
                    lhs,
                    rhs,
                    result,
                },
            )
        }
        ///Creates a new call builder for the [`checkHCUForFheMul`] function.
        pub fn checkHCUForFheMul(
            &self,
            resultType: <FheType as alloy::sol_types::SolType>::RustType,
            scalarByte: alloy::sol_types::private::FixedBytes<1>,
            lhs: alloy::sol_types::private::FixedBytes<32>,
            rhs: alloy::sol_types::private::FixedBytes<32>,
            result: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<&P, checkHCUForFheMulCall, N> {
            self.call_builder(
                &checkHCUForFheMulCall {
                    resultType,
                    scalarByte,
                    lhs,
                    rhs,
                    result,
                },
            )
        }
        ///Creates a new call builder for the [`checkHCUForFheNe`] function.
        pub fn checkHCUForFheNe(
            &self,
            resultType: <FheType as alloy::sol_types::SolType>::RustType,
            scalarByte: alloy::sol_types::private::FixedBytes<1>,
            lhs: alloy::sol_types::private::FixedBytes<32>,
            rhs: alloy::sol_types::private::FixedBytes<32>,
            result: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<&P, checkHCUForFheNeCall, N> {
            self.call_builder(
                &checkHCUForFheNeCall {
                    resultType,
                    scalarByte,
                    lhs,
                    rhs,
                    result,
                },
            )
        }
        ///Creates a new call builder for the [`checkHCUForFheNeg`] function.
        pub fn checkHCUForFheNeg(
            &self,
            resultType: <FheType as alloy::sol_types::SolType>::RustType,
            ct: alloy::sol_types::private::FixedBytes<32>,
            result: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<&P, checkHCUForFheNegCall, N> {
            self.call_builder(
                &checkHCUForFheNegCall {
                    resultType,
                    ct,
                    result,
                },
            )
        }
        ///Creates a new call builder for the [`checkHCUForFheNot`] function.
        pub fn checkHCUForFheNot(
            &self,
            resultType: <FheType as alloy::sol_types::SolType>::RustType,
            ct: alloy::sol_types::private::FixedBytes<32>,
            result: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<&P, checkHCUForFheNotCall, N> {
            self.call_builder(
                &checkHCUForFheNotCall {
                    resultType,
                    ct,
                    result,
                },
            )
        }
        ///Creates a new call builder for the [`checkHCUForFheRand`] function.
        pub fn checkHCUForFheRand(
            &self,
            resultType: <FheType as alloy::sol_types::SolType>::RustType,
            result: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<&P, checkHCUForFheRandCall, N> {
            self.call_builder(
                &checkHCUForFheRandCall {
                    resultType,
                    result,
                },
            )
        }
        ///Creates a new call builder for the [`checkHCUForFheRandBounded`] function.
        pub fn checkHCUForFheRandBounded(
            &self,
            resultType: <FheType as alloy::sol_types::SolType>::RustType,
            result: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<&P, checkHCUForFheRandBoundedCall, N> {
            self.call_builder(
                &checkHCUForFheRandBoundedCall {
                    resultType,
                    result,
                },
            )
        }
        ///Creates a new call builder for the [`checkHCUForFheRem`] function.
        pub fn checkHCUForFheRem(
            &self,
            resultType: <FheType as alloy::sol_types::SolType>::RustType,
            scalarByte: alloy::sol_types::private::FixedBytes<1>,
            lhs: alloy::sol_types::private::FixedBytes<32>,
            _3: alloy::sol_types::private::FixedBytes<32>,
            result: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<&P, checkHCUForFheRemCall, N> {
            self.call_builder(
                &checkHCUForFheRemCall {
                    resultType,
                    scalarByte,
                    lhs,
                    _3,
                    result,
                },
            )
        }
        ///Creates a new call builder for the [`checkHCUForFheRotl`] function.
        pub fn checkHCUForFheRotl(
            &self,
            resultType: <FheType as alloy::sol_types::SolType>::RustType,
            scalarByte: alloy::sol_types::private::FixedBytes<1>,
            lhs: alloy::sol_types::private::FixedBytes<32>,
            rhs: alloy::sol_types::private::FixedBytes<32>,
            result: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<&P, checkHCUForFheRotlCall, N> {
            self.call_builder(
                &checkHCUForFheRotlCall {
                    resultType,
                    scalarByte,
                    lhs,
                    rhs,
                    result,
                },
            )
        }
        ///Creates a new call builder for the [`checkHCUForFheRotr`] function.
        pub fn checkHCUForFheRotr(
            &self,
            resultType: <FheType as alloy::sol_types::SolType>::RustType,
            scalarByte: alloy::sol_types::private::FixedBytes<1>,
            lhs: alloy::sol_types::private::FixedBytes<32>,
            rhs: alloy::sol_types::private::FixedBytes<32>,
            result: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<&P, checkHCUForFheRotrCall, N> {
            self.call_builder(
                &checkHCUForFheRotrCall {
                    resultType,
                    scalarByte,
                    lhs,
                    rhs,
                    result,
                },
            )
        }
        ///Creates a new call builder for the [`checkHCUForFheShl`] function.
        pub fn checkHCUForFheShl(
            &self,
            resultType: <FheType as alloy::sol_types::SolType>::RustType,
            scalarByte: alloy::sol_types::private::FixedBytes<1>,
            lhs: alloy::sol_types::private::FixedBytes<32>,
            rhs: alloy::sol_types::private::FixedBytes<32>,
            result: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<&P, checkHCUForFheShlCall, N> {
            self.call_builder(
                &checkHCUForFheShlCall {
                    resultType,
                    scalarByte,
                    lhs,
                    rhs,
                    result,
                },
            )
        }
        ///Creates a new call builder for the [`checkHCUForFheShr`] function.
        pub fn checkHCUForFheShr(
            &self,
            resultType: <FheType as alloy::sol_types::SolType>::RustType,
            scalarByte: alloy::sol_types::private::FixedBytes<1>,
            lhs: alloy::sol_types::private::FixedBytes<32>,
            rhs: alloy::sol_types::private::FixedBytes<32>,
            result: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<&P, checkHCUForFheShrCall, N> {
            self.call_builder(
                &checkHCUForFheShrCall {
                    resultType,
                    scalarByte,
                    lhs,
                    rhs,
                    result,
                },
            )
        }
        ///Creates a new call builder for the [`checkHCUForFheSub`] function.
        pub fn checkHCUForFheSub(
            &self,
            resultType: <FheType as alloy::sol_types::SolType>::RustType,
            scalarByte: alloy::sol_types::private::FixedBytes<1>,
            lhs: alloy::sol_types::private::FixedBytes<32>,
            rhs: alloy::sol_types::private::FixedBytes<32>,
            result: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<&P, checkHCUForFheSubCall, N> {
            self.call_builder(
                &checkHCUForFheSubCall {
                    resultType,
                    scalarByte,
                    lhs,
                    rhs,
                    result,
                },
            )
        }
        ///Creates a new call builder for the [`checkHCUForIfThenElse`] function.
        pub fn checkHCUForIfThenElse(
            &self,
            resultType: <FheType as alloy::sol_types::SolType>::RustType,
            lhs: alloy::sol_types::private::FixedBytes<32>,
            middle: alloy::sol_types::private::FixedBytes<32>,
            rhs: alloy::sol_types::private::FixedBytes<32>,
            result: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<&P, checkHCUForIfThenElseCall, N> {
            self.call_builder(
                &checkHCUForIfThenElseCall {
                    resultType,
                    lhs,
                    middle,
                    rhs,
                    result,
                },
            )
        }
        ///Creates a new call builder for the [`checkHCUForTrivialEncrypt`] function.
        pub fn checkHCUForTrivialEncrypt(
            &self,
            resultType: <FheType as alloy::sol_types::SolType>::RustType,
            result: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<&P, checkHCUForTrivialEncryptCall, N> {
            self.call_builder(
                &checkHCUForTrivialEncryptCall {
                    resultType,
                    result,
                },
            )
        }
        ///Creates a new call builder for the [`getFHEVMExecutorAddress`] function.
        pub fn getFHEVMExecutorAddress(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, getFHEVMExecutorAddressCall, N> {
            self.call_builder(&getFHEVMExecutorAddressCall)
        }
        ///Creates a new call builder for the [`getVersion`] function.
        pub fn getVersion(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, getVersionCall, N> {
            self.call_builder(&getVersionCall)
        }
        ///Creates a new call builder for the [`initializeFromEmptyProxy`] function.
        pub fn initializeFromEmptyProxy(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, initializeFromEmptyProxyCall, N> {
            self.call_builder(&initializeFromEmptyProxyCall)
        }
        ///Creates a new call builder for the [`proxiableUUID`] function.
        pub fn proxiableUUID(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, proxiableUUIDCall, N> {
            self.call_builder(&proxiableUUIDCall)
        }
        ///Creates a new call builder for the [`upgradeToAndCall`] function.
        pub fn upgradeToAndCall(
            &self,
            newImplementation: alloy::sol_types::private::Address,
            data: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<&P, upgradeToAndCallCall, N> {
            self.call_builder(
                &upgradeToAndCallCall {
                    newImplementation,
                    data,
                },
            )
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > HCULimitInstance<P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<&P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
        ///Creates a new event filter for the [`Initialized`] event.
        pub fn Initialized_filter(&self) -> alloy_contract::Event<&P, Initialized, N> {
            self.event_filter::<Initialized>()
        }
        ///Creates a new event filter for the [`Upgraded`] event.
        pub fn Upgraded_filter(&self) -> alloy_contract::Event<&P, Upgraded, N> {
            self.event_filter::<Upgraded>()
        }
    }
}
