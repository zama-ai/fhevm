/**

Generated by the following Solidity interface...
```solidity
interface HCULimit {
    type FheType is uint8;

    error AddressEmptyCode(address target);
    error AlreadyBlockHCUWhitelisted(address account);
    error CallerMustBeFHEVMExecutorContract();
    error ERC1967InvalidImplementation(address implementation);
    error ERC1967NonPayable();
    error FailedCall();
    error HCUBlockLimitExceeded();
    error HCUTransactionDepthLimitExceeded();
    error HCUTransactionLimitExceeded();
    error InvalidInitialization();
    error NotBlockHCUWhitelisted(address account);
    error NotHostOwner(address sender);
    error NotInitializing();
    error NotInitializingFromEmptyProxy();
    error OnlyScalarOperationsAreSupported();
    error UUPSUnauthorizedCallContext();
    error UUPSUnsupportedProxiableUUID(bytes32 slot);
    error UnsupportedOperation();

    event BlockHCUWhitelistAdded(address indexed account);
    event BlockHCUWhitelistRemoved(address indexed account);
    event HCUPerBlockSet(uint48 hcuPerBlock);
    event Initialized(uint64 version);
    event MaxHCUDepthPerTxSet(uint48 maxHCUDepthPerTx);
    event MaxHCUPerTxSet(uint48 maxHCUPerTx);
    event Upgraded(address indexed implementation);

    constructor();

    function UPGRADE_INTERFACE_VERSION() external view returns (string memory);
    function addToBlockHCUWhitelist(address account) external;
    function checkHCUForCast(FheType resultType, bytes32 ct, bytes32 result, address caller) external;
    function checkHCUForFheAdd(FheType resultType, bytes1 scalarByte, bytes32 lhs, bytes32 rhs, bytes32 result, address caller) external;
    function checkHCUForFheBitAnd(FheType resultType, bytes1 scalarByte, bytes32 lhs, bytes32 rhs, bytes32 result, address caller) external;
    function checkHCUForFheBitOr(FheType resultType, bytes1 scalarByte, bytes32 lhs, bytes32 rhs, bytes32 result, address caller) external;
    function checkHCUForFheBitXor(FheType resultType, bytes1 scalarByte, bytes32 lhs, bytes32 rhs, bytes32 result, address caller) external;
    function checkHCUForFheDiv(FheType resultType, bytes1 scalarByte, bytes32 lhs, bytes32, bytes32 result, address caller) external;
    function checkHCUForFheEq(FheType resultType, bytes1 scalarByte, bytes32 lhs, bytes32 rhs, bytes32 result, address caller) external;
    function checkHCUForFheGe(FheType resultType, bytes1 scalarByte, bytes32 lhs, bytes32 rhs, bytes32 result, address caller) external;
    function checkHCUForFheGt(FheType resultType, bytes1 scalarByte, bytes32 lhs, bytes32 rhs, bytes32 result, address caller) external;
    function checkHCUForFheLe(FheType resultType, bytes1 scalarByte, bytes32 lhs, bytes32 rhs, bytes32 result, address caller) external;
    function checkHCUForFheLt(FheType resultType, bytes1 scalarByte, bytes32 lhs, bytes32 rhs, bytes32 result, address caller) external;
    function checkHCUForFheMax(FheType resultType, bytes1 scalarByte, bytes32 lhs, bytes32 rhs, bytes32 result, address caller) external;
    function checkHCUForFheMin(FheType resultType, bytes1 scalarByte, bytes32 lhs, bytes32 rhs, bytes32 result, address caller) external;
    function checkHCUForFheMul(FheType resultType, bytes1 scalarByte, bytes32 lhs, bytes32 rhs, bytes32 result, address caller) external;
    function checkHCUForFheNe(FheType resultType, bytes1 scalarByte, bytes32 lhs, bytes32 rhs, bytes32 result, address caller) external;
    function checkHCUForFheNeg(FheType resultType, bytes32 ct, bytes32 result, address caller) external;
    function checkHCUForFheNot(FheType resultType, bytes32 ct, bytes32 result, address caller) external;
    function checkHCUForFheRand(FheType resultType, bytes32 result, address caller) external;
    function checkHCUForFheRandBounded(FheType resultType, bytes32 result, address caller) external;
    function checkHCUForFheRem(FheType resultType, bytes1 scalarByte, bytes32 lhs, bytes32, bytes32 result, address caller) external;
    function checkHCUForFheRotl(FheType resultType, bytes1 scalarByte, bytes32 lhs, bytes32 rhs, bytes32 result, address caller) external;
    function checkHCUForFheRotr(FheType resultType, bytes1 scalarByte, bytes32 lhs, bytes32 rhs, bytes32 result, address caller) external;
    function checkHCUForFheShl(FheType resultType, bytes1 scalarByte, bytes32 lhs, bytes32 rhs, bytes32 result, address caller) external;
    function checkHCUForFheShr(FheType resultType, bytes1 scalarByte, bytes32 lhs, bytes32 rhs, bytes32 result, address caller) external;
    function checkHCUForFheSub(FheType resultType, bytes1 scalarByte, bytes32 lhs, bytes32 rhs, bytes32 result, address caller) external;
    function checkHCUForIfThenElse(FheType resultType, bytes32 lhs, bytes32 middle, bytes32 rhs, bytes32 result, address caller) external;
    function checkHCUForTrivialEncrypt(FheType resultType, bytes32 result, address caller) external;
    function getBlockMeter() external view returns (uint48 blockNumber, uint48 usedHCU);
    function getFHEVMExecutorAddress() external view returns (address);
    function getGlobalHCUCapPerBlock() external view returns (uint48);
    function getMaxHCUDepthPerTx() external view returns (uint48);
    function getMaxHCUPerTx() external view returns (uint48);
    function getVersion() external pure returns (string memory);
    function initializeFromEmptyProxy(uint48 hcuCapPerBlock, uint48 maxHCUDepthPerTx, uint48 maxHCUPerTx) external;
    function isBlockHCUWhitelisted(address account) external view returns (bool);
    function proxiableUUID() external view returns (bytes32);
    function reinitializeV2(uint48 hcuCapPerBlock, uint48 maxHCUDepthPerTx, uint48 maxHCUPerTx) external;
    function removeFromBlockHCUWhitelist(address account) external;
    function setHCUPerBlock(uint48 hcuPerBlock) external;
    function setMaxHCUDepthPerTx(uint48 maxHCUDepthPerTx) external;
    function setMaxHCUPerTx(uint48 maxHCUPerTx) external;
    function upgradeToAndCall(address newImplementation, bytes memory data) external payable;
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "constructor",
    "inputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "UPGRADE_INTERFACE_VERSION",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "addToBlockHCUWhitelist",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "checkHCUForCast",
    "inputs": [
      {
        "name": "resultType",
        "type": "uint8",
        "internalType": "enum FheType"
      },
      {
        "name": "ct",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "caller",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "checkHCUForFheAdd",
    "inputs": [
      {
        "name": "resultType",
        "type": "uint8",
        "internalType": "enum FheType"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "internalType": "bytes1"
      },
      {
        "name": "lhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "caller",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "checkHCUForFheBitAnd",
    "inputs": [
      {
        "name": "resultType",
        "type": "uint8",
        "internalType": "enum FheType"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "internalType": "bytes1"
      },
      {
        "name": "lhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "caller",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "checkHCUForFheBitOr",
    "inputs": [
      {
        "name": "resultType",
        "type": "uint8",
        "internalType": "enum FheType"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "internalType": "bytes1"
      },
      {
        "name": "lhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "caller",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "checkHCUForFheBitXor",
    "inputs": [
      {
        "name": "resultType",
        "type": "uint8",
        "internalType": "enum FheType"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "internalType": "bytes1"
      },
      {
        "name": "lhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "caller",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "checkHCUForFheDiv",
    "inputs": [
      {
        "name": "resultType",
        "type": "uint8",
        "internalType": "enum FheType"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "internalType": "bytes1"
      },
      {
        "name": "lhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "caller",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "checkHCUForFheEq",
    "inputs": [
      {
        "name": "resultType",
        "type": "uint8",
        "internalType": "enum FheType"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "internalType": "bytes1"
      },
      {
        "name": "lhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "caller",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "checkHCUForFheGe",
    "inputs": [
      {
        "name": "resultType",
        "type": "uint8",
        "internalType": "enum FheType"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "internalType": "bytes1"
      },
      {
        "name": "lhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "caller",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "checkHCUForFheGt",
    "inputs": [
      {
        "name": "resultType",
        "type": "uint8",
        "internalType": "enum FheType"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "internalType": "bytes1"
      },
      {
        "name": "lhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "caller",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "checkHCUForFheLe",
    "inputs": [
      {
        "name": "resultType",
        "type": "uint8",
        "internalType": "enum FheType"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "internalType": "bytes1"
      },
      {
        "name": "lhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "caller",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "checkHCUForFheLt",
    "inputs": [
      {
        "name": "resultType",
        "type": "uint8",
        "internalType": "enum FheType"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "internalType": "bytes1"
      },
      {
        "name": "lhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "caller",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "checkHCUForFheMax",
    "inputs": [
      {
        "name": "resultType",
        "type": "uint8",
        "internalType": "enum FheType"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "internalType": "bytes1"
      },
      {
        "name": "lhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "caller",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "checkHCUForFheMin",
    "inputs": [
      {
        "name": "resultType",
        "type": "uint8",
        "internalType": "enum FheType"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "internalType": "bytes1"
      },
      {
        "name": "lhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "caller",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "checkHCUForFheMul",
    "inputs": [
      {
        "name": "resultType",
        "type": "uint8",
        "internalType": "enum FheType"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "internalType": "bytes1"
      },
      {
        "name": "lhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "caller",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "checkHCUForFheNe",
    "inputs": [
      {
        "name": "resultType",
        "type": "uint8",
        "internalType": "enum FheType"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "internalType": "bytes1"
      },
      {
        "name": "lhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "caller",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "checkHCUForFheNeg",
    "inputs": [
      {
        "name": "resultType",
        "type": "uint8",
        "internalType": "enum FheType"
      },
      {
        "name": "ct",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "caller",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "checkHCUForFheNot",
    "inputs": [
      {
        "name": "resultType",
        "type": "uint8",
        "internalType": "enum FheType"
      },
      {
        "name": "ct",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "caller",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "checkHCUForFheRand",
    "inputs": [
      {
        "name": "resultType",
        "type": "uint8",
        "internalType": "enum FheType"
      },
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "caller",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "checkHCUForFheRandBounded",
    "inputs": [
      {
        "name": "resultType",
        "type": "uint8",
        "internalType": "enum FheType"
      },
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "caller",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "checkHCUForFheRem",
    "inputs": [
      {
        "name": "resultType",
        "type": "uint8",
        "internalType": "enum FheType"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "internalType": "bytes1"
      },
      {
        "name": "lhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "caller",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "checkHCUForFheRotl",
    "inputs": [
      {
        "name": "resultType",
        "type": "uint8",
        "internalType": "enum FheType"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "internalType": "bytes1"
      },
      {
        "name": "lhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "caller",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "checkHCUForFheRotr",
    "inputs": [
      {
        "name": "resultType",
        "type": "uint8",
        "internalType": "enum FheType"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "internalType": "bytes1"
      },
      {
        "name": "lhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "caller",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "checkHCUForFheShl",
    "inputs": [
      {
        "name": "resultType",
        "type": "uint8",
        "internalType": "enum FheType"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "internalType": "bytes1"
      },
      {
        "name": "lhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "caller",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "checkHCUForFheShr",
    "inputs": [
      {
        "name": "resultType",
        "type": "uint8",
        "internalType": "enum FheType"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "internalType": "bytes1"
      },
      {
        "name": "lhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "caller",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "checkHCUForFheSub",
    "inputs": [
      {
        "name": "resultType",
        "type": "uint8",
        "internalType": "enum FheType"
      },
      {
        "name": "scalarByte",
        "type": "bytes1",
        "internalType": "bytes1"
      },
      {
        "name": "lhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "caller",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "checkHCUForIfThenElse",
    "inputs": [
      {
        "name": "resultType",
        "type": "uint8",
        "internalType": "enum FheType"
      },
      {
        "name": "lhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "middle",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "rhs",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "caller",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "checkHCUForTrivialEncrypt",
    "inputs": [
      {
        "name": "resultType",
        "type": "uint8",
        "internalType": "enum FheType"
      },
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "caller",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "getBlockMeter",
    "inputs": [],
    "outputs": [
      {
        "name": "blockNumber",
        "type": "uint48",
        "internalType": "uint48"
      },
      {
        "name": "usedHCU",
        "type": "uint48",
        "internalType": "uint48"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getFHEVMExecutorAddress",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getGlobalHCUCapPerBlock",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint48",
        "internalType": "uint48"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getMaxHCUDepthPerTx",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint48",
        "internalType": "uint48"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getMaxHCUPerTx",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint48",
        "internalType": "uint48"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getVersion",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "initializeFromEmptyProxy",
    "inputs": [
      {
        "name": "hcuCapPerBlock",
        "type": "uint48",
        "internalType": "uint48"
      },
      {
        "name": "maxHCUDepthPerTx",
        "type": "uint48",
        "internalType": "uint48"
      },
      {
        "name": "maxHCUPerTx",
        "type": "uint48",
        "internalType": "uint48"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "isBlockHCUWhitelisted",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "proxiableUUID",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "reinitializeV2",
    "inputs": [
      {
        "name": "hcuCapPerBlock",
        "type": "uint48",
        "internalType": "uint48"
      },
      {
        "name": "maxHCUDepthPerTx",
        "type": "uint48",
        "internalType": "uint48"
      },
      {
        "name": "maxHCUPerTx",
        "type": "uint48",
        "internalType": "uint48"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "removeFromBlockHCUWhitelist",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setHCUPerBlock",
    "inputs": [
      {
        "name": "hcuPerBlock",
        "type": "uint48",
        "internalType": "uint48"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setMaxHCUDepthPerTx",
    "inputs": [
      {
        "name": "maxHCUDepthPerTx",
        "type": "uint48",
        "internalType": "uint48"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setMaxHCUPerTx",
    "inputs": [
      {
        "name": "maxHCUPerTx",
        "type": "uint48",
        "internalType": "uint48"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "upgradeToAndCall",
    "inputs": [
      {
        "name": "newImplementation",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "data",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [],
    "stateMutability": "payable"
  },
  {
    "type": "event",
    "name": "BlockHCUWhitelistAdded",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "BlockHCUWhitelistRemoved",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "HCUPerBlockSet",
    "inputs": [
      {
        "name": "hcuPerBlock",
        "type": "uint48",
        "indexed": false,
        "internalType": "uint48"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Initialized",
    "inputs": [
      {
        "name": "version",
        "type": "uint64",
        "indexed": false,
        "internalType": "uint64"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "MaxHCUDepthPerTxSet",
    "inputs": [
      {
        "name": "maxHCUDepthPerTx",
        "type": "uint48",
        "indexed": false,
        "internalType": "uint48"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "MaxHCUPerTxSet",
    "inputs": [
      {
        "name": "maxHCUPerTx",
        "type": "uint48",
        "indexed": false,
        "internalType": "uint48"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Upgraded",
    "inputs": [
      {
        "name": "implementation",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "error",
    "name": "AddressEmptyCode",
    "inputs": [
      {
        "name": "target",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "AlreadyBlockHCUWhitelisted",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "CallerMustBeFHEVMExecutorContract",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ERC1967InvalidImplementation",
    "inputs": [
      {
        "name": "implementation",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "ERC1967NonPayable",
    "inputs": []
  },
  {
    "type": "error",
    "name": "FailedCall",
    "inputs": []
  },
  {
    "type": "error",
    "name": "HCUBlockLimitExceeded",
    "inputs": []
  },
  {
    "type": "error",
    "name": "HCUTransactionDepthLimitExceeded",
    "inputs": []
  },
  {
    "type": "error",
    "name": "HCUTransactionLimitExceeded",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidInitialization",
    "inputs": []
  },
  {
    "type": "error",
    "name": "NotBlockHCUWhitelisted",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "NotHostOwner",
    "inputs": [
      {
        "name": "sender",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "NotInitializing",
    "inputs": []
  },
  {
    "type": "error",
    "name": "NotInitializingFromEmptyProxy",
    "inputs": []
  },
  {
    "type": "error",
    "name": "OnlyScalarOperationsAreSupported",
    "inputs": []
  },
  {
    "type": "error",
    "name": "UUPSUnauthorizedCallContext",
    "inputs": []
  },
  {
    "type": "error",
    "name": "UUPSUnsupportedProxiableUUID",
    "inputs": [
      {
        "name": "slot",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ]
  },
  {
    "type": "error",
    "name": "UnsupportedOperation",
    "inputs": []
  }
]
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod HCULimit {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x60a06040523073ffffffffffffffffffffffffffffffffffffffff1660809073ffffffffffffffffffffffffffffffffffffffff1681525034801562000043575f80fd5b50620000546200005a60201b60201c565b620001c4565b5f6200006b6200015e60201b60201c565b9050805f0160089054906101000a900460ff1615620000b6576040517ff92ee8a900000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b67ffffffffffffffff8016815f015f9054906101000a900467ffffffffffffffff1667ffffffffffffffff16146200015b5767ffffffffffffffff815f015f6101000a81548167ffffffffffffffff021916908367ffffffffffffffff1602179055507fc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d267ffffffffffffffff604051620001529190620001a9565b60405180910390a15b50565b5f7ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00905090565b5f67ffffffffffffffff82169050919050565b620001a38162000185565b82525050565b5f602082019050620001be5f83018462000198565b92915050565b6080516185a8620001eb5f395f81816171c10152818161721601526174b801526185a85ff3fe608060405260043610610266575f3560e01c80636fd65e4d11610143578063b59547b8116100b5578063c277a93611610079578063c277a9361461085f578063c8de435214610887578063d5b8b8f3146108af578063d633c96b146108d7578063ede8776e146108ff578063f7d198f81461093b57610266565b8063b59547b814610793578063b78bef59146107bd578063c0c5df7c146107e5578063c1390c341461080d578063c13c19711461083557610266565b80639b3f781a116101075780639b3f781a1461069e5780639f4b9937146106c65780639f9259bb146106f1578063a036ea2e14610719578063ab39475514610741578063ad3cb1cc1461076957610266565b80636fd65e4d146105d65780637748671a146105fe578063818f4d69146106265780638629f5451461064e578063968302d71461067657610266565b80633bb7d5a3116101dc5780635c414b57116101a05780635c414b57146104e65780635f76eb301461050e57806360e121891461053657806369931afb1461055e5780636bad18b6146105865780636cf0bd25146105ae57610266565b80633bb7d5a314610428578063458fb27714610450578063497c22c5146104785780634f1ef286146104a057806352d1902d146104bc57610266565b8063268d6d311161022e578063268d6d311461033657806328677ca7146103605780632dcbc5d1146103885780632e3c3906146103b05780633311b1bc146103d857806338bd17e51461040057610266565b806304553fb61461026a57806307ccdf61146102925780630d8e6e2c146102ba578063196a456d146102e45780631e24aa491461030c575b5f80fd5b348015610275575f80fd5b50610290600480360381019061028b9190617cfd565b610963565b005b34801561029d575f80fd5b506102b860048036038101906102b39190617cfd565b610cc4565b005b3480156102c5575f80fd5b506102ce61108f565b6040516102db9190617e10565b60405180910390f35b3480156102ef575f80fd5b5061030a60048036038101906103059190617e6b565b61110a565b005b348015610317575f80fd5b50610320611298565b60405161032d9190617eca565b60405180910390f35b348015610341575f80fd5b5061034a6112bb565b6040516103579190617ef2565b60405180910390f35b34801561036b575f80fd5b5061038660048036038101906103819190617f0b565b6112d6565b005b348015610393575f80fd5b506103ae60048036038101906103a99190617f36565b6114fb565b005b3480156103bb575f80fd5b506103d660048036038101906103d19190617f9a565b611732565b005b3480156103e3575f80fd5b506103fe60048036038101906103f99190617cfd565b6119ad565b005b34801561040b575f80fd5b5061042660048036038101906104219190617cfd565b611be4565b005b348015610433575f80fd5b5061044e60048036038101906104499190617cfd565b611f42565b005b34801561045b575f80fd5b5061047660048036038101906104719190617cfd565b6122a0565b005b348015610483575f80fd5b5061049e60048036038101906104999190617f36565b6125fe565b005b6104ba60048036038101906104b5919061814f565b61280c565b005b3480156104c7575f80fd5b506104d061282b565b6040516104dd91906181b8565b60405180910390f35b3480156104f1575f80fd5b5061050c600480360381019061050791906181d1565b61285c565b005b348015610519575f80fd5b50610534600480360381019061052f9190617cfd565b612958565b005b348015610541575f80fd5b5061055c60048036038101906105579190617cfd565b612d23565b005b348015610569575f80fd5b50610584600480360381019061057f9190617f36565b6131cd565b005b348015610591575f80fd5b506105ac60048036038101906105a79190617cfd565b613404565b005b3480156105b9575f80fd5b506105d460048036038101906105cf91906181fc565b6138ae565b005b3480156105e1575f80fd5b506105fc60048036038101906105f79190617f0b565b613abd565b005b348015610609575f80fd5b50610624600480360381019061061f9190617e6b565b613ce4565b005b348015610631575f80fd5b5061064c60048036038101906106479190617cfd565b613e27565b005b348015610659575f80fd5b50610674600480360381019061066f9190617cfd565b614188565b005b348015610681575f80fd5b5061069c60048036038101906106979190617cfd565b614553565b005b3480156106a9575f80fd5b506106c460048036038101906106bf9190617cfd565b6148b4565b005b3480156106d1575f80fd5b506106da614aeb565b6040516106e892919061824c565b60405180910390f35b3480156106fc575f80fd5b5061071760048036038101906107129190617cfd565b614b57565b005b348015610724575f80fd5b5061073f600480360381019061073a91906181d1565b614f88565b005b34801561074c575f80fd5b50610767600480360381019061076291906181d1565b615084565b005b348015610774575f80fd5b5061077d615180565b60405161078a9190617e10565b60405180910390f35b34801561079e575f80fd5b506107a76151b9565b6040516107b49190617eca565b60405180910390f35b3480156107c8575f80fd5b506107e360048036038101906107de91906181fc565b6151e0565b005b3480156107f0575f80fd5b5061080b60048036038101906108069190617cfd565b615454565b005b348015610818575f80fd5b50610833600480360381019061082e9190617cfd565b615885565b005b348015610840575f80fd5b50610849615be6565b6040516108569190617eca565b60405180910390f35b34801561086a575f80fd5b5061088560048036038101906108809190617cfd565b615c09565b005b348015610892575f80fd5b506108ad60048036038101906108a89190617cfd565b615f67565b005b3480156108ba575f80fd5b506108d560048036038101906108d091906181fc565b616398565b005b3480156108e2575f80fd5b506108fd60048036038101906108f89190617cfd565b6165dd565b005b34801561090a575f80fd5b5061092560048036038101906109209190617f0b565b61693e565b604051610932919061828d565b60405180910390f35b348015610946575f80fd5b50610961600480360381019061095c9190617cfd565b61699e565b005b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16146109dc576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f600160f81b867effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191603610b645760026053811115610a1e57610a1d6182a6565b5b876053811115610a3157610a306182a6565b5b03610a4157620148209050610b53565b60036053811115610a5557610a546182a6565b5b876053811115610a6857610a676182a6565b5b03610a7857620157c09050610b52565b60046053811115610a8c57610a8b6182a6565b5b876053811115610a9f57610a9e6182a6565b5b03610aaf576201c9089050610b51565b60056053811115610ac357610ac26182a6565b5b876053811115610ad657610ad56182a6565b5b03610ae657620249f09050610b50565b60066053811115610afa57610af96182a6565b5b876053811115610b0d57610b0c6182a6565b5b03610b1d576202d6909050610b4f565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b610b5f81838786616d69565b610cbb565b60026053811115610b7857610b776182a6565b5b876053811115610b8b57610b8a6182a6565b5b03610b9b576201d0d89050610cad565b60036053811115610baf57610bae6182a6565b5b876053811115610bc257610bc16182a6565b5b03610bd25762023a509050610cac565b60046053811115610be657610be56182a6565b5b876053811115610bf957610bf86182a6565b5b03610c09576202c6f09050610cab565b60056053811115610c1d57610c1c6182a6565b5b876053811115610c3057610c2f6182a6565b5b03610c4057620357789050610caa565b60066053811115610c5457610c536182a6565b5b876053811115610c6757610c666182a6565b5b03610c7757620468e89050610ca9565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b610cba8183878787616df9565b5b50505050505050565b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614610d3d576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f600160f81b867effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191603610ef75760026053811115610d7f57610d7e6182a6565b5b876053811115610d9257610d916182a6565b5b03610da157617d009050610ee6565b60036053811115610db557610db46182a6565b5b876053811115610dc857610dc76182a6565b5b03610dd757617d009050610ee5565b60046053811115610deb57610dea6182a6565b5b876053811115610dfe57610dfd6182a6565b5b03610e0d57617d009050610ee4565b60056053811115610e2157610e206182a6565b5b876053811115610e3457610e336182a6565b5b03610e43576184d09050610ee3565b60066053811115610e5757610e566182a6565b5b876053811115610e6a57610e696182a6565b5b03610e79576190889050610ee2565b60086053811115610e8d57610e8c6182a6565b5b876053811115610ea057610e9f6182a6565b5b03610eaf576194709050610ee1565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b5b610ef281838786616d69565b611086565b60026053811115610f0b57610f0a6182a6565b5b876053811115610f1e57610f1d6182a6565b5b03610f2e57620163789050611078565b60036053811115610f4257610f416182a6565b5b876053811115610f5557610f546182a6565b5b03610f65576201e0789050611077565b60046053811115610f7957610f786182a6565b5b876053811115610f8c57610f8b6182a6565b5b03610f9c5762027cb89050611076565b60056053811115610fb057610faf6182a6565b5b876053811115610fc357610fc26182a6565b5b03610fd357620330689050611075565b60066053811115610fe757610fe66182a6565b5b876053811115610ffa57610ff96182a6565b5b0361100a57620426809050611074565b6008605381111561101e5761101d6182a6565b5b876053811115611031576110306182a6565b5b03611041576205a1689050611073565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b5b6110858183878787616df9565b5b50505050505050565b60606040518060400160405280600881526020017f4843554c696d69740000000000000000000000000000000000000000000000008152506110d05f616e9b565b6110da6002616e9b565b6110e35f616e9b565b6040516020016110f694939291906183a1565b604051602081830303815290604052905090565b6001611114616f65565b67ffffffffffffffff1614611155576040517f6f4f731f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60035f611160616f89565b9050805f0160089054906101000a900460ff16806111a857508167ffffffffffffffff16815f015f9054906101000a900467ffffffffffffffff1667ffffffffffffffff1610155b156111df576040517ff92ee8a900000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b81815f015f6101000a81548167ffffffffffffffff021916908367ffffffffffffffff1602179055506001815f0160086101000a81548160ff02191690831515021790555061122d85616fb0565b61123684617016565b61123f8361707d565b5f815f0160086101000a81548160ff0219169083151502179055507fc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d2826040516112899190618421565b60405180910390a15050505050565b5f6112a16170e4565b5f0160129054906101000a900465ffffffffffff16905090565b5f73e3a9105a3a932253a70f126eb1e3b589c643dd24905090565b7350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff16638da5cb5b6040518163ffffffff1660e01b8152600401602060405180830381865afa158015611333573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190611357919061844e565b73ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16146113c657336040517f21bfda100000000000000000000000000000000000000000000000000000000081526004016113bd9190617ef2565b60405180910390fd5b5f6113cf6170e4565b9050806001015f8373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f9054906101000a900460ff1661145e57816040517fe3cc34180000000000000000000000000000000000000000000000000000000081526004016114559190617ef2565b60405180910390fd5b5f816001015f8473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f6101000a81548160ff0219169083151502179055508173ffffffffffffffffffffffffffffffffffffffff167f92fc97af15002646cea63c7633bb375b82db7cde7b480c75fe6341dacc292c8160405160405180910390a25050565b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614611574576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f806053811115611588576115876182a6565b5b85605381111561159b5761159a6182a6565b5b036115a9576002905061171f565b600260538111156115bd576115bc6182a6565b5b8560538111156115d0576115cf6182a6565b5b036115de576009905061171e565b600360538111156115f2576115f16182a6565b5b856053811115611605576116046182a6565b5b03611613576010905061171d565b60046053811115611627576116266182a6565b5b85605381111561163a576116396182a6565b5b03611648576020905061171c565b6005605381111561165c5761165b6182a6565b5b85605381111561166f5761166e6182a6565b5b0361167d57603f905061171b565b60066053811115611691576116906182a6565b5b8560538111156116a4576116a36182a6565b5b036116b2576082905061171a565b600860538111156116c6576116c56182a6565b5b8560538111156116d9576116d86182a6565b5b036116e75760829050611719565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b5b5b61172b81838686616d69565b5050505050565b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16146117ab576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f8060538111156117bf576117be6182a6565b5b8760538111156117d2576117d16182a6565b5b036117e15761d6d89050611996565b600260538111156117f5576117f46182a6565b5b876053811115611808576118076182a6565b5b036118175761d6d89050611995565b6003605381111561182b5761182a6182a6565b5b87605381111561183e5761183d6182a6565b5b0361184d5761d6d89050611994565b60046053811115611861576118606182a6565b5b876053811115611874576118736182a6565b5b036118835761d6d89050611993565b60056053811115611897576118966182a6565b5b8760538111156118aa576118a96182a6565b5b036118b95761d6d89050611992565b600660538111156118cd576118cc6182a6565b5b8760538111156118e0576118df6182a6565b5b036118ef5761dea89050611991565b60076053811115611903576119026182a6565b5b876053811115611916576119156182a6565b5b0361192657620144389050611990565b6008605381111561193a576119396182a6565b5b87605381111561194d5761194c6182a6565b5b0361195d576201a5e0905061198f565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b5b5b5b6119a481838888888861710b565b50505050505050565b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614611a26576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f600160f81b867effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191614611a86576040517f6aa9eb0500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60026053811115611a9a57611a996182a6565b5b876053811115611aad57611aac6182a6565b5b03611abd576206b6c09050611bcf565b60036053811115611ad157611ad06182a6565b5b876053811115611ae457611ae36182a6565b5b03611af4576208d9a09050611bce565b60046053811115611b0857611b076182a6565b5b876053811115611b1b57611b1a6182a6565b5b03611b2b57620c15c09050611bcd565b60056053811115611b3f57611b3e6182a6565b5b876053811115611b5257611b516182a6565b5b03611b6257621197e89050611bcc565b60066053811115611b7657611b756182a6565b5b876053811115611b8957611b886182a6565b5b03611b9957621da5d89050611bcb565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b611bdb81838786616d69565b50505050505050565b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614611c5d576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f600160f81b867effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191603611de35760026053811115611c9f57611c9e6182a6565b5b876053811115611cb257611cb16182a6565b5b03611cc15761e2909050611dd2565b60036053811115611cd557611cd46182a6565b5b876053811115611ce857611ce76182a6565b5b03611cf75761e2909050611dd1565b60046053811115611d0b57611d0a6182a6565b5b876053811115611d1e57611d1d6182a6565b5b03611d2e57620148209050611dd0565b60056053811115611d4257611d416182a6565b5b876053811115611d5557611d546182a6565b5b03611d65576201d0d89050611dcf565b60066053811115611d7957611d786182a6565b5b876053811115611d8c57611d8b6182a6565b5b03611d9c57620249f09050611dce565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b611dde81838786616d69565b611f39565b60026053811115611df757611df66182a6565b5b876053811115611e0a57611e096182a6565b5b03611e195761e2909050611f2b565b60036053811115611e2d57611e2c6182a6565b5b876053811115611e4057611e3f6182a6565b5b03611e5057620144389050611f2a565b60046053811115611e6457611e636182a6565b5b876053811115611e7757611e766182a6565b5b03611e87576201c9089050611f29565b60056053811115611e9b57611e9a6182a6565b5b876053811115611eae57611ead6182a6565b5b03611ebe57620246089050611f28565b60066053811115611ed257611ed16182a6565b5b876053811115611ee557611ee46182a6565b5b03611ef557620353909050611f27565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b611f388183878787616df9565b5b50505050505050565b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614611fbb576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f600160f81b867effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916036121415760026053811115611ffd57611ffc6182a6565b5b8760538111156120105761200f6182a6565b5b0361201f5761cb209050612130565b60036053811115612033576120326182a6565b5b876053811115612046576120456182a6565b5b036120555761e290905061212f565b60046053811115612069576120686182a6565b5b87605381111561207c5761207b6182a6565b5b0361208c5762014438905061212e565b600560538111156120a05761209f6182a6565b5b8760538111156120b3576120b26182a6565b5b036120c3576201ccf0905061212d565b600660538111156120d7576120d66182a6565b5b8760538111156120ea576120e96182a6565b5b036120fa5762024608905061212c565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b61213c81838786616d69565b612297565b60026053811115612155576121546182a6565b5b876053811115612168576121676182a6565b5b036121775761e6789050612289565b6003605381111561218b5761218a6182a6565b5b87605381111561219e5761219d6182a6565b5b036121ae57620148209050612288565b600460538111156121c2576121c16182a6565b5b8760538111156121d5576121d46182a6565b5b036121e5576201c9089050612287565b600560538111156121f9576121f86182a6565b5b87605381111561220c5761220b6182a6565b5b0361221c5762023a509050612286565b600660538111156122305761222f6182a6565b5b876053811115612243576122426182a6565b5b0361225357620347d89050612285565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b6122968183878787616df9565b5b50505050505050565b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614612319576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f600160f81b867effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff19160361249f576002605381111561235b5761235a6182a6565b5b87605381111561236e5761236d6182a6565b5b0361237d5761cb20905061248e565b60036053811115612391576123906182a6565b5b8760538111156123a4576123a36182a6565b5b036123b35761d6d8905061248d565b600460538111156123c7576123c66182a6565b5b8760538111156123da576123d96182a6565b5b036123ea5762014820905061248c565b600560538111156123fe576123fd6182a6565b5b876053811115612411576124106182a6565b5b03612421576201c908905061248b565b60066053811115612435576124346182a6565b5b876053811115612448576124476182a6565b5b0361245857620249f0905061248a565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b61249a81838786616d69565b6125f5565b600260538111156124b3576124b26182a6565b5b8760538111156124c6576124c56182a6565b5b036124d55761e67890506125e7565b600360538111156124e9576124e86182a6565b5b8760538111156124fc576124fb6182a6565b5b0361250c576201482090506125e6565b600460538111156125205761251f6182a6565b5b876053811115612533576125326182a6565b5b03612543576201ccf090506125e5565b60056053811115612557576125566182a6565b5b87605381111561256a576125696182a6565b5b0361257a57620251c090506125e4565b6006605381111561258e5761258d6182a6565b5b8760538111156125a1576125a06182a6565b5b036125b1576203539090506125e3565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b6125f48183878787616df9565b5b50505050505050565b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614612677576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f6002605381111561268c5761268b6182a6565b5b85605381111561269f5761269e6182a6565b5b036126af576201349890506127f9565b600360538111156126c3576126c26182a6565b5b8560538111156126d6576126d56182a6565b5b036126e65762016b4890506127f8565b600460538111156126fa576126f96182a6565b5b85605381111561270d5761270c6182a6565b5b0361271d576201731890506127f7565b60056053811115612731576127306182a6565b5b856053811115612744576127436182a6565b5b03612754576201ffb890506127f6565b60066053811115612768576127676182a6565b5b85605381111561277b5761277a6182a6565b5b0361278b576202904090506127f5565b6008605381111561279f5761279e6182a6565b5b8560538111156127b2576127b16182a6565b5b036127c25762041ac890506127f4565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b5b61280581838686616d69565b5050505050565b6128146171bf565b61281d826172a5565b6128278282617398565b5050565b5f6128346174b6565b7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5f1b905090565b7350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff16638da5cb5b6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156128b9573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906128dd919061844e565b73ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161461294c57336040517f21bfda100000000000000000000000000000000000000000000000000000000081526004016129439190617ef2565b60405180910390fd5b61295581617016565b50565b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16146129d1576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f600160f81b867effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191603612b8b5760026053811115612a1357612a126182a6565b5b876053811115612a2657612a256182a6565b5b03612a35576179189050612b7a565b60036053811115612a4957612a486182a6565b5b876053811115612a5c57612a5b6182a6565b5b03612a6b576179189050612b79565b60046053811115612a7f57612a7e6182a6565b5b876053811115612a9257612a916182a6565b5b03612aa157617d009050612b78565b60056053811115612ab557612ab46182a6565b5b876053811115612ac857612ac76182a6565b5b03612ad7576184d09050612b77565b60066053811115612aeb57612aea6182a6565b5b876053811115612afe57612afd6182a6565b5b03612b0d576190889050612b76565b60086053811115612b2157612b206182a6565b5b876053811115612b3457612b336182a6565b5b03612b43576194709050612b75565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b5b612b8681838786616d69565b612d1a565b60026053811115612b9f57612b9e6182a6565b5b876053811115612bb257612bb16182a6565b5b03612bc257620163789050612d0c565b60036053811115612bd657612bd56182a6565b5b876053811115612be957612be86182a6565b5b03612bf9576201e8489050612d0b565b60046053811115612c0d57612c0c6182a6565b5b876053811115612c2057612c1f6182a6565b5b03612c305762027cb89050612d0a565b60056053811115612c4457612c436182a6565b5b876053811115612c5757612c566182a6565b5b03612c6757620330689050612d09565b60066053811115612c7b57612c7a6182a6565b5b876053811115612c8e57612c8d6182a6565b5b03612c9e5762043df09050612d08565b60086053811115612cb257612cb16182a6565b5b876053811115612cc557612cc46182a6565b5b03612cd5576205c4909050612d07565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b5b612d198183878787616df9565b5b50505050505050565b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614612d9c576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f600160f81b867effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191603612fc8575f6053811115612ddd57612ddc6182a6565b5b876053811115612df057612def6182a6565b5b03612dff576161a89050612fb7565b60026053811115612e1357612e126182a6565b5b876053811115612e2657612e256182a6565b5b03612e355761d6d89050612fb6565b60036053811115612e4957612e486182a6565b5b876053811115612e5c57612e5b6182a6565b5b03612e6b5761d6d89050612fb5565b60046053811115612e7f57612e7e6182a6565b5b876053811115612e9257612e916182a6565b5b03612ea257620140509050612fb4565b60056053811115612eb657612eb56182a6565b5b876053811115612ec957612ec86182a6565b5b03612ed957620144389050612fb3565b60066053811115612eed57612eec6182a6565b5b876053811115612f0057612eff6182a6565b5b03612f10576201c9089050612fb2565b60076053811115612f2457612f236182a6565b5b876053811115612f3757612f366182a6565b5b03612f47576201c9089050612fb1565b60086053811115612f5b57612f5a6182a6565b5b876053811115612f6e57612f6d6182a6565b5b03612f7e576201ccf09050612fb0565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b5b5b5b612fc381838786616d69565b6131c4565b5f6053811115612fdb57612fda6182a6565b5b876053811115612fee57612fed6182a6565b5b03612ffd5761659090506131b6565b60026053811115613011576130106182a6565b5b876053811115613024576130236182a6565b5b036130335761d6d890506131b5565b60036053811115613047576130466182a6565b5b87605381111561305a576130596182a6565b5b0361306a576201443890506131b4565b6004605381111561307e5761307d6182a6565b5b876053811115613091576130906182a6565b5b036130a15762014ff090506131b3565b600560538111156130b5576130b46182a6565b5b8760538111156130c8576130c76182a6565b5b036130d8576201d4c090506131b2565b600660538111156130ec576130eb6182a6565b5b8760538111156130ff576130fe6182a6565b5b0361310f576201dc9090506131b1565b60076053811115613123576131226182a6565b5b876053811115613136576131356182a6565b5b03613146576202172890506131b0565b6008605381111561315a576131596182a6565b5b87605381111561316d5761316c6182a6565b5b0361317d57620251c090506131af565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b5b5b5b6131c38183878787616df9565b5b50505050505050565b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614613246576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f80605381111561325a576132596182a6565b5b85605381111561326d5761326c6182a6565b5b0361327b57602090506133f1565b6002605381111561328f5761328e6182a6565b5b8560538111156132a2576132a16182a6565b5b036132b057602090506133f0565b600360538111156132c4576132c36182a6565b5b8560538111156132d7576132d66182a6565b5b036132e557602090506133ef565b600460538111156132f9576132f86182a6565b5b85605381111561330c5761330b6182a6565b5b0361331a57602090506133ee565b6005605381111561332e5761332d6182a6565b5b856053811115613341576133406182a6565b5b0361334f57602090506133ed565b60066053811115613363576133626182a6565b5b856053811115613376576133756182a6565b5b0361338457602090506133ec565b60086053811115613398576133976182a6565b5b8560538111156133ab576133aa6182a6565b5b036133b957602090506133eb565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b5b5b6133fd81838686616d69565b5050505050565b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161461347d576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f600160f81b867effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916036136a9575f60538111156134be576134bd6182a6565b5b8760538111156134d1576134d06182a6565b5b036134e0576159d89050613698565b600260538111156134f4576134f36182a6565b5b876053811115613507576135066182a6565b5b036135165761d6d89050613697565b6003605381111561352a576135296182a6565b5b87605381111561353d5761353c6182a6565b5b0361354c5761d6d89050613696565b600460538111156135605761355f6182a6565b5b876053811115613573576135726182a6565b5b0361358357620144389050613695565b60056053811115613597576135966182a6565b5b8760538111156135aa576135a96182a6565b5b036135ba57620148209050613694565b600660538111156135ce576135cd6182a6565b5b8760538111156135e1576135e06182a6565b5b036135f1576201c9089050613693565b60076053811115613605576136046182a6565b5b876053811115613618576136176182a6565b5b03613628576201c9089050613692565b6008605381111561363c5761363b6182a6565b5b87605381111561364f5761364e6182a6565b5b0361365f576201c9089050613691565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b5b5b5b6136a481838786616d69565b6138a5565b5f60538111156136bc576136bb6182a6565b5b8760538111156136cf576136ce6182a6565b5b036136de576159d89050613897565b600260538111156136f2576136f16182a6565b5b876053811115613705576137046182a6565b5b036137145761d6d89050613896565b60036053811115613728576137276182a6565b5b87605381111561373b5761373a6182a6565b5b0361374b57620144389050613895565b6004605381111561375f5761375e6182a6565b5b876053811115613772576137716182a6565b5b036137825762014c089050613894565b60056053811115613796576137956182a6565b5b8760538111156137a9576137a86182a6565b5b036137b9576201ccf09050613893565b600660538111156137cd576137cc6182a6565b5b8760538111156137e0576137df6182a6565b5b036137f0576201dc909050613892565b60076053811115613804576138036182a6565b5b876053811115613817576138166182a6565b5b0361382757620213409050613891565b6008605381111561383b5761383a6182a6565b5b87605381111561384e5761384d6182a6565b5b0361385e57620249f09050613890565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b5b5b5b6138a48183878787616df9565b5b50505050505050565b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614613927576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f6002605381111561393c5761393b6182a6565b5b84605381111561394f5761394e6182a6565b5b0361395e576159d89050613aa3565b60036053811115613972576139716182a6565b5b846053811115613985576139846182a6565b5b03613994576159d89050613aa2565b600460538111156139a8576139a76182a6565b5b8460538111156139bb576139ba6182a6565b5b036139ca57615dc09050613aa1565b600560538111156139de576139dd6182a6565b5b8460538111156139f1576139f06182a6565b5b03613a0057615dc09050613aa0565b60066053811115613a1457613a136182a6565b5b846053811115613a2757613a266182a6565b5b03613a36576161a89050613a9f565b60086053811115613a4a57613a496182a6565b5b846053811115613a5d57613a5c6182a6565b5b03613a6c576175309050613a9e565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b5b613aad818361753d565b613ab783826175c9565b50505050565b7350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff16638da5cb5b6040518163ffffffff1660e01b8152600401602060405180830381865afa158015613b1a573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190613b3e919061844e565b73ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614613bad57336040517f21bfda10000000000000000000000000000000000000000000000000000000008152600401613ba49190617ef2565b60405180910390fd5b5f613bb66170e4565b9050806001015f8373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f9054906101000a900460ff1615613c4657816040517ff99c4fd1000000000000000000000000000000000000000000000000000000008152600401613c3d9190617ef2565b60405180910390fd5b6001816001015f8473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f6101000a81548160ff0219169083151502179055508173ffffffffffffffffffffffffffffffffffffffff167fcca1d46384cdbbeef2f9daddb76db138101c9905f818d867b630195c128d3c6660405160405180910390a25050565b60035f613cef616f89565b9050805f0160089054906101000a900460ff1680613d3757508167ffffffffffffffff16815f015f9054906101000a900467ffffffffffffffff1667ffffffffffffffff1610155b15613d6e576040517ff92ee8a900000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b81815f015f6101000a81548167ffffffffffffffff021916908367ffffffffffffffff1602179055506001815f0160086101000a81548160ff021916908315150217905550613dbc85616fb0565b613dc584617016565b613dce8361707d565b5f815f0160086101000a81548160ff0219169083151502179055507fc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d282604051613e189190618421565b60405180910390a15050505050565b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614613ea0576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f600160f81b867effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916036140285760026053811115613ee257613ee16182a6565b5b876053811115613ef557613ef46182a6565b5b03613f05576201dc909050614017565b60036053811115613f1957613f186182a6565b5b876053811115613f2c57613f2b6182a6565b5b03613f3c576202f1e89050614016565b60046053811115613f5057613f4f6182a6565b5b876053811115613f6357613f626182a6565b5b03613f735762040b289050614015565b60056053811115613f8757613f866182a6565b5b876053811115613f9a57613f996182a6565b5b03613faa57620591c89050614014565b60066053811115613fbe57613fbd6182a6565b5b876053811115613fd157613fd06182a6565b5b03613fe157620a9ec09050614013565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b61402381838786616d69565b61417f565b6002605381111561403c5761403b6182a6565b5b87605381111561404f5761404e6182a6565b5b0361405f57620249f09050614171565b60036053811115614073576140726182a6565b5b876053811115614086576140856182a6565b5b0361409657620363309050614170565b600460538111156140aa576140a96182a6565b5b8760538111156140bd576140bc6182a6565b5b036140cd5762050140905061416f565b600560538111156140e1576140e06182a6565b5b8760538111156140f4576140f36182a6565b5b036141045762091820905061416e565b60066053811115614118576141176182a6565b5b87605381111561412b5761412a6182a6565b5b0361413b576219b9f0905061416d565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b61417e8183878787616df9565b5b50505050505050565b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614614201576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f600160f81b867effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916036143bb5760026053811115614243576142426182a6565b5b876053811115614256576142556182a6565b5b036142655761791890506143aa565b60036053811115614279576142786182a6565b5b87605381111561428c5761428b6182a6565b5b0361429b5761791890506143a9565b600460538111156142af576142ae6182a6565b5b8760538111156142c2576142c16182a6565b5b036142d157617d0090506143a8565b600560538111156142e5576142e46182a6565b5b8760538111156142f8576142f76182a6565b5b03614307576184d090506143a7565b6006605381111561431b5761431a6182a6565b5b87605381111561432e5761432d6182a6565b5b0361433d5761908890506143a6565b60086053811115614351576143506182a6565b5b876053811115614364576143636182a6565b5b0361437357619c4090506143a5565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b5b6143b681838786616d69565b61454a565b600260538111156143cf576143ce6182a6565b5b8760538111156143e2576143e16182a6565b5b036143f25762016b48905061453c565b60036053811115614406576144056182a6565b5b876053811115614419576144186182a6565b5b03614429576201e848905061453b565b6004605381111561443d5761443c6182a6565b5b8760538111156144505761444f6182a6565b5b036144605762027100905061453a565b60056053811115614474576144736182a6565b5b876053811115614487576144866182a6565b5b0361449757620330689050614539565b600660538111156144ab576144aa6182a6565b5b8760538111156144be576144bd6182a6565b5b036144ce57620451789050614538565b600860538111156144e2576144e16182a6565b5b8760538111156144f5576144f46182a6565b5b03614505576205b8d89050614537565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b5b6145498183878787616df9565b5b50505050505050565b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16146145cc576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f600160f81b867effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191603614754576002605381111561460e5761460d6182a6565b5b876053811115614621576146206182a6565b5b036146315762015ba89050614743565b60036053811115614645576146446182a6565b5b876053811115614658576146576182a6565b5b036146685762015ba89050614742565b6004605381111561467c5761467b6182a6565b5b87605381111561468f5761468e6182a6565b5b0361469f576201c9089050614741565b600560538111156146b3576146b26182a6565b5b8760538111156146c6576146c56182a6565b5b036146d657620246089050614740565b600660538111156146ea576146e96182a6565b5b8760538111156146fd576146fc6182a6565b5b0361470d576202bf20905061473f565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b61474f81838786616d69565b6148ab565b60026053811115614768576147676182a6565b5b87605381111561477b5761477a6182a6565b5b0361478b576201d8a8905061489d565b6003605381111561479f5761479e6182a6565b5b8760538111156147b2576147b16182a6565b5b036147c25762023668905061489c565b600460538111156147d6576147d56182a6565b5b8760538111156147e9576147e86182a6565b5b036147f9576202bf20905061489b565b6005605381111561480d5761480c6182a6565b5b8760538111156148205761481f6182a6565b5b036148305762035390905061489a565b60066053811115614844576148436182a6565b5b876053811115614857576148566182a6565b5b036148675762046cd09050614899565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b6148aa8183878787616df9565b5b50505050505050565b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161461492d576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f600160f81b867effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff19161461498d576040517f6aa9eb0500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b600260538111156149a1576149a06182a6565b5b8760538111156149b4576149b36182a6565b5b036149c457620334509050614ad6565b600360538111156149d8576149d76182a6565b5b8760538111156149eb576149ea6182a6565b5b036149fb5762049bb09050614ad5565b60046053811115614a0f57614a0e6182a6565b5b876053811115614a2257614a216182a6565b5b03614a32576206aef09050614ad4565b60056053811115614a4657614a456182a6565b5b876053811115614a5957614a586182a6565b5b03614a6957620ae8f89050614ad3565b60066053811115614a7d57614a7c6182a6565b5b876053811115614a9057614a8f6182a6565b5b03614aa0576212b1289050614ad2565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b614ae281838786616d69565b50505050505050565b5f805f614af66170e4565b90505f4390508065ffffffffffff16825f01600c9054906101000a900465ffffffffffff1665ffffffffffff1614614b3557805f935093505050614b53565b80825f0160069054906101000a900465ffffffffffff169350935050505b9091565b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614614bd0576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f600160f81b867effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191603614dc0575f6053811115614c1157614c106182a6565b5b876053811115614c2457614c236182a6565b5b03614c33576155f09050614daf565b60026053811115614c4757614c466182a6565b5b876053811115614c5a57614c596182a6565b5b03614c69576179189050614dae565b60036053811115614c7d57614c7c6182a6565b5b876053811115614c9057614c8f6182a6565b5b03614c9f576179189050614dad565b60046053811115614cb357614cb26182a6565b5b876053811115614cc657614cc56182a6565b5b03614cd557617d009050614dac565b60056053811115614ce957614ce86182a6565b5b876053811115614cfc57614cfb6182a6565b5b03614d0b576184d09050614dab565b60066053811115614d1f57614d1e6182a6565b5b876053811115614d3257614d316182a6565b5b03614d41576190889050614daa565b60086053811115614d5557614d546182a6565b5b876053811115614d6857614d676182a6565b5b03614d77576198589050614da9565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b5b5b614dbb81838786616d69565b614f7f565b5f6053811115614dd357614dd26182a6565b5b876053811115614de657614de56182a6565b5b03614df5576155f09050614f71565b60026053811115614e0957614e086182a6565b5b876053811115614e1c57614e1b6182a6565b5b03614e2b576179189050614f70565b60036053811115614e3f57614e3e6182a6565b5b876053811115614e5257614e516182a6565b5b03614e61576179189050614f6f565b60046053811115614e7557614e746182a6565b5b876053811115614e8857614e876182a6565b5b03614e9757617d009050614f6e565b60056053811115614eab57614eaa6182a6565b5b876053811115614ebe57614ebd6182a6565b5b03614ecd576184d09050614f6d565b60066053811115614ee157614ee06182a6565b5b876053811115614ef457614ef36182a6565b5b03614f03576190889050614f6c565b60086053811115614f1757614f166182a6565b5b876053811115614f2a57614f296182a6565b5b03614f39576198589050614f6b565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b5b5b614f7e8183878787616df9565b5b50505050505050565b7350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff16638da5cb5b6040518163ffffffff1660e01b8152600401602060405180830381865afa158015614fe5573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190615009919061844e565b73ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161461507857336040517f21bfda1000000000000000000000000000000000000000000000000000000000815260040161506f9190617ef2565b60405180910390fd5b61508181616fb0565b50565b7350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff16638da5cb5b6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156150e1573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190615105919061844e565b73ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161461517457336040517f21bfda1000000000000000000000000000000000000000000000000000000000815260040161516b9190617ef2565b60405180910390fd5b61517d8161707d565b50565b6040518060400160405280600581526020017f352e302e3000000000000000000000000000000000000000000000000000000081525081565b5f806151c36170e4565b9050805f015f9054906101000a900465ffffffffffff1691505090565b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614615259576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f80605381111561526d5761526c6182a6565b5b8460538111156152805761527f6182a6565b5b0361528e576020905061543a565b600260538111156152a2576152a16182a6565b5b8460538111156152b5576152b46182a6565b5b036152c35760209050615439565b600360538111156152d7576152d66182a6565b5b8460538111156152ea576152e96182a6565b5b036152f85760209050615438565b6004605381111561530c5761530b6182a6565b5b84605381111561531f5761531e6182a6565b5b0361532d5760209050615437565b60056053811115615341576153406182a6565b5b846053811115615354576153536182a6565b5b036153625760209050615436565b60066053811115615376576153756182a6565b5b846053811115615389576153886182a6565b5b036153975760209050615435565b600760538111156153ab576153aa6182a6565b5b8460538111156153be576153bd6182a6565b5b036153cc5760209050615434565b600860538111156153e0576153df6182a6565b5b8460538111156153f3576153f26182a6565b5b036154015760209050615433565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b5b5b5b615444818361753d565b61544e83826175c9565b50505050565b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16146154cd576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f600160f81b867effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916036156bd575f605381111561550e5761550d6182a6565b5b876053811115615521576155206182a6565b5b03615530576155f090506156ac565b60026053811115615544576155436182a6565b5b876053811115615557576155566182a6565b5b036155665761753090506156ab565b6003605381111561557a576155796182a6565b5b87605381111561558d5761558c6182a6565b5b0361559c5761753090506156aa565b600460538111156155b0576155af6182a6565b5b8760538111156155c3576155c26182a6565b5b036155d257617d0090506156a9565b600560538111156155e6576155e56182a6565b5b8760538111156155f9576155f86182a6565b5b03615608576184d090506156a8565b6006605381111561561c5761561b6182a6565b5b87605381111561562f5761562e6182a6565b5b0361563e5761908890506156a7565b60086053811115615652576156516182a6565b5b876053811115615665576156646182a6565b5b036156745761947090506156a6565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b5b5b6156b881838786616d69565b61587c565b5f60538111156156d0576156cf6182a6565b5b8760538111156156e3576156e26182a6565b5b036156f257615dc0905061586e565b60026053811115615706576157056182a6565b5b876053811115615719576157186182a6565b5b0361572857617530905061586d565b6003605381111561573c5761573b6182a6565b5b87605381111561574f5761574e6182a6565b5b0361575e57617918905061586c565b60046053811115615772576157716182a6565b5b876053811115615785576157846182a6565b5b0361579457617d00905061586b565b600560538111156157a8576157a76182a6565b5b8760538111156157bb576157ba6182a6565b5b036157ca576184d0905061586a565b600660538111156157de576157dd6182a6565b5b8760538111156157f1576157f06182a6565b5b03615800576190889050615869565b60086053811115615814576158136182a6565b5b876053811115615827576158266182a6565b5b03615836576194709050615868565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b5b5b61587b8183878787616df9565b5b50505050505050565b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16146158fe576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f600160f81b867effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191603615a8657600260538111156159405761593f6182a6565b5b876053811115615953576159526182a6565b5b0361596357620148209050615a75565b60036053811115615977576159766182a6565b5b87605381111561598a576159896182a6565b5b0361599a5762016b489050615a74565b600460538111156159ae576159ad6182a6565b5b8760538111156159c1576159c06182a6565b5b036159d157620173189050615a73565b600560538111156159e5576159e46182a6565b5b8760538111156159f8576159f76182a6565b5b03615a0857620207889050615a72565b60066053811115615a1c57615a1b6182a6565b5b876053811115615a2f57615a2e6182a6565b5b03615a3f5762029fe09050615a71565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b615a8181838786616d69565b615bdd565b60026053811115615a9a57615a996182a6565b5b876053811115615aad57615aac6182a6565b5b03615abd57620157c09050615bcf565b60036053811115615ad157615ad06182a6565b5b876053811115615ae457615ae36182a6565b5b03615af45762016b489050615bce565b60046053811115615b0857615b076182a6565b5b876053811115615b1b57615b1a6182a6565b5b03615b2b576201e8489050615bcd565b60056053811115615b3f57615b3e6182a6565b5b876053811115615b5257615b516182a6565b5b03615b6257620278d09050615bcc565b60066053811115615b7657615b756182a6565b5b876053811115615b8957615b886182a6565b5b03615b99576203f3b89050615bcb565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b615bdc8183878787616df9565b5b50505050505050565b5f615bef6170e4565b5f0160189054906101000a900465ffffffffffff16905090565b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614615c82576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f600160f81b867effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191603615e085760026053811115615cc457615cc36182a6565b5b876053811115615cd757615cd66182a6565b5b03615ce65761cb209050615df7565b60036053811115615cfa57615cf96182a6565b5b876053811115615d0d57615d0c6182a6565b5b03615d1c5761d6d89050615df6565b60046053811115615d3057615d2f6182a6565b5b876053811115615d4357615d426182a6565b5b03615d5357620148209050615df5565b60056053811115615d6757615d666182a6565b5b876053811115615d7a57615d796182a6565b5b03615d8a576201c5209050615df4565b60066053811115615d9e57615d9d6182a6565b5b876053811115615db157615db06182a6565b5b03615dc157620246089050615df3565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b615e0381838786616d69565b615f5e565b60026053811115615e1c57615e1b6182a6565b5b876053811115615e2f57615e2e6182a6565b5b03615e3e5761f6189050615f50565b60036053811115615e5257615e516182a6565b5b876053811115615e6557615e646182a6565b5b03615e7557620148209050615f4f565b60046053811115615e8957615e886182a6565b5b876053811115615e9c57615e9b6182a6565b5b03615eac576201ccf09050615f4e565b60056053811115615ec057615ebf6182a6565b5b876053811115615ed357615ed26182a6565b5b03615ee357620251c09050615f4d565b60066053811115615ef757615ef66182a6565b5b876053811115615f0a57615f096182a6565b5b03615f1a57620334509050615f4c565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b615f5d8183878787616df9565b5b50505050505050565b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614615fe0576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f600160f81b867effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916036161d0575f6053811115616021576160206182a6565b5b876053811115616034576160336182a6565b5b03616043576155f090506161bf565b60026053811115616057576160566182a6565b5b87605381111561606a576160696182a6565b5b036160795761791890506161be565b6003605381111561608d5761608c6182a6565b5b8760538111156160a05761609f6182a6565b5b036160af5761791890506161bd565b600460538111156160c3576160c26182a6565b5b8760538111156160d6576160d56182a6565b5b036160e557617d0090506161bc565b600560538111156160f9576160f86182a6565b5b87605381111561610c5761610b6182a6565b5b0361611b576184d090506161bb565b6006605381111561612f5761612e6182a6565b5b876053811115616142576161416182a6565b5b036161515761908890506161ba565b60086053811115616165576161646182a6565b5b876053811115616178576161776182a6565b5b036161875761947090506161b9565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b5b5b6161cb81838786616d69565b61638f565b5f60538111156161e3576161e26182a6565b5b8760538111156161f6576161f56182a6565b5b03616205576161a89050616381565b60026053811115616219576162186182a6565b5b87605381111561622c5761622b6182a6565b5b0361623b576179189050616380565b6003605381111561624f5761624e6182a6565b5b876053811115616262576162616182a6565b5b0361627157617918905061637f565b60046053811115616285576162846182a6565b5b876053811115616298576162976182a6565b5b036162a757617d00905061637e565b600560538111156162bb576162ba6182a6565b5b8760538111156162ce576162cd6182a6565b5b036162dd576184d0905061637d565b600660538111156162f1576162f06182a6565b5b876053811115616304576163036182a6565b5b0361631357619088905061637c565b60086053811115616327576163266182a6565b5b87605381111561633a576163396182a6565b5b0361634957619470905061637b565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b5b5b61638e8183878787616df9565b5b50505050505050565b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614616411576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f806053811115616425576164246182a6565b5b846053811115616438576164376182a6565b5b0361644757614a3890506165c3565b6002605381111561645b5761645a6182a6565b5b84605381111561646e5761646d6182a6565b5b0361647d576159d890506165c2565b60036053811115616491576164906182a6565b5b8460538111156164a4576164a36182a6565b5b036164b3576159d890506165c1565b600460538111156164c7576164c66182a6565b5b8460538111156164da576164d96182a6565b5b036164e957615dc090506165c0565b600560538111156164fd576164fc6182a6565b5b8460538111156165105761650f6182a6565b5b0361651f57615dc090506165bf565b60066053811115616533576165326182a6565b5b846053811115616546576165456182a6565b5b03616555576161a890506165be565b60086053811115616569576165686182a6565b5b84605381111561657c5761657b6182a6565b5b0361658b5761753090506165bd565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b5b5b6165cd818361753d565b6165d783826175c9565b50505050565b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614616656576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f600160f81b867effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916036167de5760026053811115616698576166976182a6565b5b8760538111156166ab576166aa6182a6565b5b036166bb576201482090506167cd565b600360538111156166cf576166ce6182a6565b5b8760538111156166e2576166e16182a6565b5b036166f25762016b4890506167cc565b60046053811115616706576167056182a6565b5b876053811115616719576167186182a6565b5b03616729576201731890506167cb565b6005605381111561673d5761673c6182a6565b5b8760538111156167505761674f6182a6565b5b03616760576202078890506167ca565b60066053811115616774576167736182a6565b5b876053811115616787576167866182a6565b5b036167975762029fe090506167c9565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b6167d981838786616d69565b616935565b600260538111156167f2576167f16182a6565b5b876053811115616805576168046182a6565b5b0361681557620163789050616927565b60036053811115616829576168286182a6565b5b87605381111561683c5761683b6182a6565b5b0361684c5762016b489050616926565b600460538111156168605761685f6182a6565b5b876053811115616873576168726182a6565b5b03616883576201e8489050616925565b60056053811115616897576168966182a6565b5b8760538111156168aa576168a96182a6565b5b036168ba57620278d09050616924565b600660538111156168ce576168cd6182a6565b5b8760538111156168e1576168e06182a6565b5b036168f1576203f7a09050616923565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b6169348183878787616df9565b5b50505050505050565b5f806169486170e4565b9050806001015f8473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f9054906101000a900460ff16915050919050565b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614616a17576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f600160f81b867effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191603616bd15760026053811115616a5957616a586182a6565b5b876053811115616a6c57616a6b6182a6565b5b03616a7b57617d009050616bc0565b60036053811115616a8f57616a8e6182a6565b5b876053811115616aa257616aa16182a6565b5b03616ab157617d009050616bbf565b60046053811115616ac557616ac46182a6565b5b876053811115616ad857616ad76182a6565b5b03616ae757617d009050616bbe565b60056053811115616afb57616afa6182a6565b5b876053811115616b0e57616b0d6182a6565b5b03616b1d576184d09050616bbd565b60066053811115616b3157616b306182a6565b5b876053811115616b4457616b436182a6565b5b03616b53576190889050616bbc565b60086053811115616b6757616b666182a6565b5b876053811115616b7a57616b796182a6565b5b03616b89576198589050616bbb565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b5b616bcc81838786616d69565b616d60565b60026053811115616be557616be46182a6565b5b876053811115616bf857616bf76182a6565b5b03616c0857620167609050616d52565b60036053811115616c1c57616c1b6182a6565b5b876053811115616c2f57616c2e6182a6565b5b03616c3f576201e8489050616d51565b60046053811115616c5357616c526182a6565b5b876053811115616c6657616c656182a6565b5b03616c7657620278d09050616d50565b60056053811115616c8a57616c896182a6565b5b876053811115616c9d57616c9c6182a6565b5b03616cad5762032c809050616d4f565b60066053811115616cc157616cc06182a6565b5b876053811115616cd457616cd36182a6565b5b03616ce457620426809050616d4e565b60086053811115616cf857616cf76182a6565b5b876053811115616d0b57616d0a6182a6565b5b03616d1b576205c4909050616d4d565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b5b616d5f8183878787616df9565b5b50505050505050565b616d73848461753d565b5f616d7d836175d0565b85616d8891906184af565b9050616d926170e4565b5f0160129054906101000a900465ffffffffffff1665ffffffffffff16811115616de8576040517ffc34487000000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b616df282826175c9565b5050505050565b616e03858561753d565b5f616e1e616e10856175d0565b616e19856175d0565b6175da565b86616e2991906184af565b9050616e336170e4565b5f0160129054906101000a900465ffffffffffff1665ffffffffffff16811115616e89576040517ffc34487000000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b616e9382826175c9565b505050505050565b60605f6001616ea9846175f3565b0190505f8167ffffffffffffffff811115616ec757616ec661802b565b5b6040519080825280601f01601f191660200182016040528015616ef95781602001600182028036833780820191505090505b5090505f82602001820190505b600115616f5a578080600190039150507f3031323334353637383961626364656600000000000000000000000000000000600a86061a8153600a8581616f4f57616f4e6184e2565b5b0494505f8503616f06575b819350505050919050565b5f616f6e616f89565b5f015f9054906101000a900467ffffffffffffffff16905090565b5f7ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00905090565b80616fb96170e4565b5f015f6101000a81548165ffffffffffff021916908365ffffffffffff1602179055507fc1f1fcaa898aae2263dded712e1798083fca9272ff803ee4150ce48f8619891a8160405161700b9190617eca565b60405180910390a150565b8061701f6170e4565b5f0160126101000a81548165ffffffffffff021916908365ffffffffffff1602179055507f5511b1851fc40a2629c855bab7adce3276c470d8190eb01431e418dc2af13e8e816040516170729190617eca565b60405180910390a150565b806170866170e4565b5f0160186101000a81548165ffffffffffff021916908365ffffffffffff1602179055507f64cb9e7ae6497c59080cdbc048552e123d52aa4240e137758a173582786961ca816040516170d99190617eca565b60405180910390a150565b5f7fc13af6c514bff8997f30c90003baa82bd02aad978179d1ce58d85c4319ad6500905090565b617115868661753d565b5f617141617122866175d0565b61713c61712e876175d0565b617137876175d0565b6175da565b6175da565b8761714c91906184af565b90506171566170e4565b5f0160129054906101000a900465ffffffffffff1665ffffffffffff168111156171ac576040517ffc34487000000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6171b682826175c9565b50505050505050565b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff163073ffffffffffffffffffffffffffffffffffffffff16148061726c57507f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16617253617744565b73ffffffffffffffffffffffffffffffffffffffff1614155b156172a3576040517fe07c8dba00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b565b7350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff16638da5cb5b6040518163ffffffff1660e01b8152600401602060405180830381865afa158015617302573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190617326919061844e565b73ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161461739557336040517f21bfda1000000000000000000000000000000000000000000000000000000000815260040161738c9190617ef2565b60405180910390fd5b50565b8173ffffffffffffffffffffffffffffffffffffffff166352d1902d6040518163ffffffff1660e01b8152600401602060405180830381865afa92505050801561740057506040513d601f19601f820116820180604052508101906173fd9190618523565b60015b61744157816040517f4c9c8ce30000000000000000000000000000000000000000000000000000000081526004016174389190617ef2565b60405180910390fd5b7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5f1b81146174a757806040517faa1d49a400000000000000000000000000000000000000000000000000000000815260040161749e91906181b8565b60405180910390fd5b6174b18383617797565b505050565b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff163073ffffffffffffffffffffffffffffffffffffffff161461753b576040517fe07c8dba00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b565b6175478282617809565b5f61755061797a565b8361755b91906184af565b90506175656170e4565b5f0160189054906101000a900465ffffffffffff1665ffffffffffff168111156175bb576040517f77e3c29300000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6175c481617982565b505050565b80825d5050565b5f815c9050919050565b5f818310156175e957816175eb565b825b905092915050565b5f805f90507a184f03e93ff9f4daa797ed6e38ed64bf6a1f010000000000000000831061764f577a184f03e93ff9f4daa797ed6e38ed64bf6a1f0100000000000000008381617645576176446184e2565b5b0492506040810190505b6d04ee2d6d415b85acef8100000000831061768c576d04ee2d6d415b85acef81000000008381617682576176816184e2565b5b0492506020810190505b662386f26fc1000083106176bb57662386f26fc1000083816176b1576176b06184e2565b5b0492506010810190505b6305f5e10083106176e4576305f5e10083816176da576176d96184e2565b5b0492506008810190505b61271083106177095761271083816176ff576176fe6184e2565b5b0492506004810190505b6064831061772c5760648381617722576177216184e2565b5b0492506002810190505b600a831061773b576001810190505b80915050919050565b5f6177707f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5f1b617988565b5f015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905090565b6177a082617991565b8173ffffffffffffffffffffffffffffffffffffffff167fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b60405160405180910390a25f815111156177fc576177f68282617a5a565b50617805565b617804617ada565b5b5050565b5f6178126170e4565b9050806001015f8373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f9054906101000a900460ff161561786b5750617976565b5f4390505f825f0160069054906101000a900465ffffffffffff1690508165ffffffffffff16835f01600c9054906101000a900465ffffffffffff1665ffffffffffff16146178b8575f90505b5f858265ffffffffffff166178cd91906184af565b9050835f015f9054906101000a900465ffffffffffff1665ffffffffffff16811115617925576040517fad25117400000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b80845f0160066101000a81548165ffffffffffff021916908365ffffffffffff16021790555082845f01600c6101000a81548165ffffffffffff021916908365ffffffffffff160217905550505050505b5050565b5f805c905090565b805f5d50565b5f819050919050565b5f8173ffffffffffffffffffffffffffffffffffffffff163b036179ec57806040517f4c9c8ce30000000000000000000000000000000000000000000000000000000081526004016179e39190617ef2565b60405180910390fd5b80617a187f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5f1b617988565b5f015f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555050565b60605f808473ffffffffffffffffffffffffffffffffffffffff1684604051617a839190618592565b5f60405180830381855af49150503d805f8114617abb576040519150601f19603f3d011682016040523d82523d5f602084013e617ac0565b606091505b5091509150617ad0858383617b16565b9250505092915050565b5f341115617b14576040517fb398979f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b565b606082617b2b57617b2682617ba3565b617b9b565b5f8251148015617b5157505f8473ffffffffffffffffffffffffffffffffffffffff163b145b15617b9357836040517f9996b315000000000000000000000000000000000000000000000000000000008152600401617b8a9190617ef2565b60405180910390fd5b819050617b9c565b5b9392505050565b5f81511115617bb55780518082602001fd5b6040517fd6bda27500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f604051905090565b5f80fd5b5f80fd5b60548110617c04575f80fd5b50565b5f81359050617c1581617bf8565b92915050565b5f7fff0000000000000000000000000000000000000000000000000000000000000082169050919050565b617c4f81617c1b565b8114617c59575f80fd5b50565b5f81359050617c6a81617c46565b92915050565b5f819050919050565b617c8281617c70565b8114617c8c575f80fd5b50565b5f81359050617c9d81617c79565b92915050565b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f617ccc82617ca3565b9050919050565b617cdc81617cc2565b8114617ce6575f80fd5b50565b5f81359050617cf781617cd3565b92915050565b5f805f805f8060c08789031215617d1757617d16617bf0565b5b5f617d2489828a01617c07565b9650506020617d3589828a01617c5c565b9550506040617d4689828a01617c8f565b9450506060617d5789828a01617c8f565b9350506080617d6889828a01617c8f565b92505060a0617d7989828a01617ce9565b9150509295509295509295565b5f81519050919050565b5f82825260208201905092915050565b5f5b83811015617dbd578082015181840152602081019050617da2565b5f8484015250505050565b5f601f19601f8301169050919050565b5f617de282617d86565b617dec8185617d90565b9350617dfc818560208601617da0565b617e0581617dc8565b840191505092915050565b5f6020820190508181035f830152617e288184617dd8565b905092915050565b5f65ffffffffffff82169050919050565b617e4a81617e30565b8114617e54575f80fd5b50565b5f81359050617e6581617e41565b92915050565b5f805f60608486031215617e8257617e81617bf0565b5b5f617e8f86828701617e57565b9350506020617ea086828701617e57565b9250506040617eb186828701617e57565b9150509250925092565b617ec481617e30565b82525050565b5f602082019050617edd5f830184617ebb565b92915050565b617eec81617cc2565b82525050565b5f602082019050617f055f830184617ee3565b92915050565b5f60208284031215617f2057617f1f617bf0565b5b5f617f2d84828501617ce9565b91505092915050565b5f805f8060808587031215617f4e57617f4d617bf0565b5b5f617f5b87828801617c07565b9450506020617f6c87828801617c8f565b9350506040617f7d87828801617c8f565b9250506060617f8e87828801617ce9565b91505092959194509250565b5f805f805f8060c08789031215617fb457617fb3617bf0565b5b5f617fc189828a01617c07565b9650506020617fd289828a01617c8f565b9550506040617fe389828a01617c8f565b9450506060617ff489828a01617c8f565b935050608061800589828a01617c8f565b92505060a061801689828a01617ce9565b9150509295509295509295565b5f80fd5b5f80fd5b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b61806182617dc8565b810181811067ffffffffffffffff821117156180805761807f61802b565b5b80604052505050565b5f618092617be7565b905061809e8282618058565b919050565b5f67ffffffffffffffff8211156180bd576180bc61802b565b5b6180c682617dc8565b9050602081019050919050565b828183375f83830152505050565b5f6180f36180ee846180a3565b618089565b90508281526020810184848401111561810f5761810e618027565b5b61811a8482856180d3565b509392505050565b5f82601f83011261813657618135618023565b5b81356181468482602086016180e1565b91505092915050565b5f806040838503121561816557618164617bf0565b5b5f61817285828601617ce9565b925050602083013567ffffffffffffffff81111561819357618192617bf4565b5b61819f85828601618122565b9150509250929050565b6181b281617c70565b82525050565b5f6020820190506181cb5f8301846181a9565b92915050565b5f602082840312156181e6576181e5617bf0565b5b5f6181f384828501617e57565b91505092915050565b5f805f6060848603121561821357618212617bf0565b5b5f61822086828701617c07565b935050602061823186828701617c8f565b925050604061824286828701617ce9565b9150509250925092565b5f60408201905061825f5f830185617ebb565b61826c6020830184617ebb565b9392505050565b5f8115159050919050565b61828781618273565b82525050565b5f6020820190506182a05f83018461827e565b92915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52602160045260245ffd5b5f81905092915050565b5f6182e782617d86565b6182f181856182d3565b9350618301818560208601617da0565b80840191505092915050565b7f20760000000000000000000000000000000000000000000000000000000000005f82015250565b5f6183416002836182d3565b915061834c8261830d565b600282019050919050565b7f2e000000000000000000000000000000000000000000000000000000000000005f82015250565b5f61838b6001836182d3565b915061839682618357565b600182019050919050565b5f6183ac82876182dd565b91506183b782618335565b91506183c382866182dd565b91506183ce8261837f565b91506183da82856182dd565b91506183e58261837f565b91506183f182846182dd565b915081905095945050505050565b5f67ffffffffffffffff82169050919050565b61841b816183ff565b82525050565b5f6020820190506184345f830184618412565b92915050565b5f8151905061844881617cd3565b92915050565b5f6020828403121561846357618462617bf0565b5b5f6184708482850161843a565b91505092915050565b5f819050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5f6184b982618479565b91506184c483618479565b92508282019050808211156184dc576184db618482565b5b92915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601260045260245ffd5b5f8151905061851d81617c79565b92915050565b5f6020828403121561853857618537617bf0565b5b5f6185458482850161850f565b91505092915050565b5f81519050919050565b5f81905092915050565b5f61856c8261854e565b6185768185618558565b9350618586818560208601617da0565b80840191505092915050565b5f61859d8284618562565b91508190509291505056
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\xA0`@R0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`\x80\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81RP4\x80\x15b\0\0CW_\x80\xFD[Pb\0\0Tb\0\0Z` \x1B` \x1CV[b\0\x01\xC4V[_b\0\0kb\0\x01^` \x1B` \x1CV[\x90P\x80_\x01`\x08\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x15b\0\0\xB6W`@Q\x7F\xF9.\xE8\xA9\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\x16\x81_\x01_\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14b\0\x01[Wg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81_\x01_a\x01\0\n\x81T\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP\x7F\xC7\xF5\x05\xB2\xF3q\xAE!u\xEEI\x13\xF4I\x9E\x1F&3\xA7\xB5\x93c!\xEE\xD1\xCD\xAE\xB6\x11Q\x81\xD2g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@Qb\0\x01R\x91\x90b\0\x01\xA9V[`@Q\x80\x91\x03\x90\xA1[PV[_\x7F\xF0\xC5~\x16\x84\r\xF0@\xF1P\x88\xDC/\x81\xFE9\x1C9#\xBE\xC7>#\xA9f.\xFC\x9C\"\x9Cj\0\x90P\x90V[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[b\0\x01\xA3\x81b\0\x01\x85V[\x82RPPV[_` \x82\x01\x90Pb\0\x01\xBE_\x83\x01\x84b\0\x01\x98V[\x92\x91PPV[`\x80Qa\x85\xA8b\0\x01\xEB_9_\x81\x81aq\xC1\x01R\x81\x81ar\x16\x01Rat\xB8\x01Ra\x85\xA8_\xF3\xFE`\x80`@R`\x046\x10a\x02fW_5`\xE0\x1C\x80co\xD6^M\x11a\x01CW\x80c\xB5\x95G\xB8\x11a\0\xB5W\x80c\xC2w\xA96\x11a\0yW\x80c\xC2w\xA96\x14a\x08_W\x80c\xC8\xDECR\x14a\x08\x87W\x80c\xD5\xB8\xB8\xF3\x14a\x08\xAFW\x80c\xD63\xC9k\x14a\x08\xD7W\x80c\xED\xE8wn\x14a\x08\xFFW\x80c\xF7\xD1\x98\xF8\x14a\t;Wa\x02fV[\x80c\xB5\x95G\xB8\x14a\x07\x93W\x80c\xB7\x8B\xEFY\x14a\x07\xBDW\x80c\xC0\xC5\xDF|\x14a\x07\xE5W\x80c\xC19\x0C4\x14a\x08\rW\x80c\xC1<\x19q\x14a\x085Wa\x02fV[\x80c\x9B?x\x1A\x11a\x01\x07W\x80c\x9B?x\x1A\x14a\x06\x9EW\x80c\x9FK\x997\x14a\x06\xC6W\x80c\x9F\x92Y\xBB\x14a\x06\xF1W\x80c\xA06\xEA.\x14a\x07\x19W\x80c\xAB9GU\x14a\x07AW\x80c\xAD<\xB1\xCC\x14a\x07iWa\x02fV[\x80co\xD6^M\x14a\x05\xD6W\x80cwHg\x1A\x14a\x05\xFEW\x80c\x81\x8FMi\x14a\x06&W\x80c\x86)\xF5E\x14a\x06NW\x80c\x96\x83\x02\xD7\x14a\x06vWa\x02fV[\x80c;\xB7\xD5\xA3\x11a\x01\xDCW\x80c\\AKW\x11a\x01\xA0W\x80c\\AKW\x14a\x04\xE6W\x80c_v\xEB0\x14a\x05\x0EW\x80c`\xE1!\x89\x14a\x056W\x80ci\x93\x1A\xFB\x14a\x05^W\x80ck\xAD\x18\xB6\x14a\x05\x86W\x80cl\xF0\xBD%\x14a\x05\xAEWa\x02fV[\x80c;\xB7\xD5\xA3\x14a\x04(W\x80cE\x8F\xB2w\x14a\x04PW\x80cI|\"\xC5\x14a\x04xW\x80cO\x1E\xF2\x86\x14a\x04\xA0W\x80cR\xD1\x90-\x14a\x04\xBCWa\x02fV[\x80c&\x8Dm1\x11a\x02.W\x80c&\x8Dm1\x14a\x036W\x80c(g|\xA7\x14a\x03`W\x80c-\xCB\xC5\xD1\x14a\x03\x88W\x80c.<9\x06\x14a\x03\xB0W\x80c3\x11\xB1\xBC\x14a\x03\xD8W\x80c8\xBD\x17\xE5\x14a\x04\0Wa\x02fV[\x80c\x04U?\xB6\x14a\x02jW\x80c\x07\xCC\xDFa\x14a\x02\x92W\x80c\r\x8En,\x14a\x02\xBAW\x80c\x19jEm\x14a\x02\xE4W\x80c\x1E$\xAAI\x14a\x03\x0CW[_\x80\xFD[4\x80\x15a\x02uW_\x80\xFD[Pa\x02\x90`\x04\x806\x03\x81\x01\x90a\x02\x8B\x91\x90a|\xFDV[a\tcV[\0[4\x80\x15a\x02\x9DW_\x80\xFD[Pa\x02\xB8`\x04\x806\x03\x81\x01\x90a\x02\xB3\x91\x90a|\xFDV[a\x0C\xC4V[\0[4\x80\x15a\x02\xC5W_\x80\xFD[Pa\x02\xCEa\x10\x8FV[`@Qa\x02\xDB\x91\x90a~\x10V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x02\xEFW_\x80\xFD[Pa\x03\n`\x04\x806\x03\x81\x01\x90a\x03\x05\x91\x90a~kV[a\x11\nV[\0[4\x80\x15a\x03\x17W_\x80\xFD[Pa\x03 a\x12\x98V[`@Qa\x03-\x91\x90a~\xCAV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x03AW_\x80\xFD[Pa\x03Ja\x12\xBBV[`@Qa\x03W\x91\x90a~\xF2V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x03kW_\x80\xFD[Pa\x03\x86`\x04\x806\x03\x81\x01\x90a\x03\x81\x91\x90a\x7F\x0BV[a\x12\xD6V[\0[4\x80\x15a\x03\x93W_\x80\xFD[Pa\x03\xAE`\x04\x806\x03\x81\x01\x90a\x03\xA9\x91\x90a\x7F6V[a\x14\xFBV[\0[4\x80\x15a\x03\xBBW_\x80\xFD[Pa\x03\xD6`\x04\x806\x03\x81\x01\x90a\x03\xD1\x91\x90a\x7F\x9AV[a\x172V[\0[4\x80\x15a\x03\xE3W_\x80\xFD[Pa\x03\xFE`\x04\x806\x03\x81\x01\x90a\x03\xF9\x91\x90a|\xFDV[a\x19\xADV[\0[4\x80\x15a\x04\x0BW_\x80\xFD[Pa\x04&`\x04\x806\x03\x81\x01\x90a\x04!\x91\x90a|\xFDV[a\x1B\xE4V[\0[4\x80\x15a\x043W_\x80\xFD[Pa\x04N`\x04\x806\x03\x81\x01\x90a\x04I\x91\x90a|\xFDV[a\x1FBV[\0[4\x80\x15a\x04[W_\x80\xFD[Pa\x04v`\x04\x806\x03\x81\x01\x90a\x04q\x91\x90a|\xFDV[a\"\xA0V[\0[4\x80\x15a\x04\x83W_\x80\xFD[Pa\x04\x9E`\x04\x806\x03\x81\x01\x90a\x04\x99\x91\x90a\x7F6V[a%\xFEV[\0[a\x04\xBA`\x04\x806\x03\x81\x01\x90a\x04\xB5\x91\x90a\x81OV[a(\x0CV[\0[4\x80\x15a\x04\xC7W_\x80\xFD[Pa\x04\xD0a(+V[`@Qa\x04\xDD\x91\x90a\x81\xB8V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x04\xF1W_\x80\xFD[Pa\x05\x0C`\x04\x806\x03\x81\x01\x90a\x05\x07\x91\x90a\x81\xD1V[a(\\V[\0[4\x80\x15a\x05\x19W_\x80\xFD[Pa\x054`\x04\x806\x03\x81\x01\x90a\x05/\x91\x90a|\xFDV[a)XV[\0[4\x80\x15a\x05AW_\x80\xFD[Pa\x05\\`\x04\x806\x03\x81\x01\x90a\x05W\x91\x90a|\xFDV[a-#V[\0[4\x80\x15a\x05iW_\x80\xFD[Pa\x05\x84`\x04\x806\x03\x81\x01\x90a\x05\x7F\x91\x90a\x7F6V[a1\xCDV[\0[4\x80\x15a\x05\x91W_\x80\xFD[Pa\x05\xAC`\x04\x806\x03\x81\x01\x90a\x05\xA7\x91\x90a|\xFDV[a4\x04V[\0[4\x80\x15a\x05\xB9W_\x80\xFD[Pa\x05\xD4`\x04\x806\x03\x81\x01\x90a\x05\xCF\x91\x90a\x81\xFCV[a8\xAEV[\0[4\x80\x15a\x05\xE1W_\x80\xFD[Pa\x05\xFC`\x04\x806\x03\x81\x01\x90a\x05\xF7\x91\x90a\x7F\x0BV[a:\xBDV[\0[4\x80\x15a\x06\tW_\x80\xFD[Pa\x06$`\x04\x806\x03\x81\x01\x90a\x06\x1F\x91\x90a~kV[a<\xE4V[\0[4\x80\x15a\x061W_\x80\xFD[Pa\x06L`\x04\x806\x03\x81\x01\x90a\x06G\x91\x90a|\xFDV[a>'V[\0[4\x80\x15a\x06YW_\x80\xFD[Pa\x06t`\x04\x806\x03\x81\x01\x90a\x06o\x91\x90a|\xFDV[aA\x88V[\0[4\x80\x15a\x06\x81W_\x80\xFD[Pa\x06\x9C`\x04\x806\x03\x81\x01\x90a\x06\x97\x91\x90a|\xFDV[aESV[\0[4\x80\x15a\x06\xA9W_\x80\xFD[Pa\x06\xC4`\x04\x806\x03\x81\x01\x90a\x06\xBF\x91\x90a|\xFDV[aH\xB4V[\0[4\x80\x15a\x06\xD1W_\x80\xFD[Pa\x06\xDAaJ\xEBV[`@Qa\x06\xE8\x92\x91\x90a\x82LV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x06\xFCW_\x80\xFD[Pa\x07\x17`\x04\x806\x03\x81\x01\x90a\x07\x12\x91\x90a|\xFDV[aKWV[\0[4\x80\x15a\x07$W_\x80\xFD[Pa\x07?`\x04\x806\x03\x81\x01\x90a\x07:\x91\x90a\x81\xD1V[aO\x88V[\0[4\x80\x15a\x07LW_\x80\xFD[Pa\x07g`\x04\x806\x03\x81\x01\x90a\x07b\x91\x90a\x81\xD1V[aP\x84V[\0[4\x80\x15a\x07tW_\x80\xFD[Pa\x07}aQ\x80V[`@Qa\x07\x8A\x91\x90a~\x10V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x07\x9EW_\x80\xFD[Pa\x07\xA7aQ\xB9V[`@Qa\x07\xB4\x91\x90a~\xCAV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x07\xC8W_\x80\xFD[Pa\x07\xE3`\x04\x806\x03\x81\x01\x90a\x07\xDE\x91\x90a\x81\xFCV[aQ\xE0V[\0[4\x80\x15a\x07\xF0W_\x80\xFD[Pa\x08\x0B`\x04\x806\x03\x81\x01\x90a\x08\x06\x91\x90a|\xFDV[aTTV[\0[4\x80\x15a\x08\x18W_\x80\xFD[Pa\x083`\x04\x806\x03\x81\x01\x90a\x08.\x91\x90a|\xFDV[aX\x85V[\0[4\x80\x15a\x08@W_\x80\xFD[Pa\x08Ia[\xE6V[`@Qa\x08V\x91\x90a~\xCAV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x08jW_\x80\xFD[Pa\x08\x85`\x04\x806\x03\x81\x01\x90a\x08\x80\x91\x90a|\xFDV[a\\\tV[\0[4\x80\x15a\x08\x92W_\x80\xFD[Pa\x08\xAD`\x04\x806\x03\x81\x01\x90a\x08\xA8\x91\x90a|\xFDV[a_gV[\0[4\x80\x15a\x08\xBAW_\x80\xFD[Pa\x08\xD5`\x04\x806\x03\x81\x01\x90a\x08\xD0\x91\x90a\x81\xFCV[ac\x98V[\0[4\x80\x15a\x08\xE2W_\x80\xFD[Pa\x08\xFD`\x04\x806\x03\x81\x01\x90a\x08\xF8\x91\x90a|\xFDV[ae\xDDV[\0[4\x80\x15a\t\nW_\x80\xFD[Pa\t%`\x04\x806\x03\x81\x01\x90a\t \x91\x90a\x7F\x0BV[ai>V[`@Qa\t2\x91\x90a\x82\x8DV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\tFW_\x80\xFD[Pa\ta`\x04\x806\x03\x81\x01\x90a\t\\\x91\x90a|\xFDV[ai\x9EV[\0[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\t\xDCW`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\x01`\xF8\x1B\x86~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x03a\x0BdW`\x02`S\x81\x11\x15a\n\x1EWa\n\x1Da\x82\xA6V[[\x87`S\x81\x11\x15a\n1Wa\n0a\x82\xA6V[[\x03a\nAWb\x01H \x90Pa\x0BSV[`\x03`S\x81\x11\x15a\nUWa\nTa\x82\xA6V[[\x87`S\x81\x11\x15a\nhWa\nga\x82\xA6V[[\x03a\nxWb\x01W\xC0\x90Pa\x0BRV[`\x04`S\x81\x11\x15a\n\x8CWa\n\x8Ba\x82\xA6V[[\x87`S\x81\x11\x15a\n\x9FWa\n\x9Ea\x82\xA6V[[\x03a\n\xAFWb\x01\xC9\x08\x90Pa\x0BQV[`\x05`S\x81\x11\x15a\n\xC3Wa\n\xC2a\x82\xA6V[[\x87`S\x81\x11\x15a\n\xD6Wa\n\xD5a\x82\xA6V[[\x03a\n\xE6Wb\x02I\xF0\x90Pa\x0BPV[`\x06`S\x81\x11\x15a\n\xFAWa\n\xF9a\x82\xA6V[[\x87`S\x81\x11\x15a\x0B\rWa\x0B\x0Ca\x82\xA6V[[\x03a\x0B\x1DWb\x02\xD6\x90\x90Pa\x0BOV[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[a\x0B_\x81\x83\x87\x86amiV[a\x0C\xBBV[`\x02`S\x81\x11\x15a\x0BxWa\x0Bwa\x82\xA6V[[\x87`S\x81\x11\x15a\x0B\x8BWa\x0B\x8Aa\x82\xA6V[[\x03a\x0B\x9BWb\x01\xD0\xD8\x90Pa\x0C\xADV[`\x03`S\x81\x11\x15a\x0B\xAFWa\x0B\xAEa\x82\xA6V[[\x87`S\x81\x11\x15a\x0B\xC2Wa\x0B\xC1a\x82\xA6V[[\x03a\x0B\xD2Wb\x02:P\x90Pa\x0C\xACV[`\x04`S\x81\x11\x15a\x0B\xE6Wa\x0B\xE5a\x82\xA6V[[\x87`S\x81\x11\x15a\x0B\xF9Wa\x0B\xF8a\x82\xA6V[[\x03a\x0C\tWb\x02\xC6\xF0\x90Pa\x0C\xABV[`\x05`S\x81\x11\x15a\x0C\x1DWa\x0C\x1Ca\x82\xA6V[[\x87`S\x81\x11\x15a\x0C0Wa\x0C/a\x82\xA6V[[\x03a\x0C@Wb\x03Wx\x90Pa\x0C\xAAV[`\x06`S\x81\x11\x15a\x0CTWa\x0CSa\x82\xA6V[[\x87`S\x81\x11\x15a\x0CgWa\x0Cfa\x82\xA6V[[\x03a\x0CwWb\x04h\xE8\x90Pa\x0C\xA9V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[a\x0C\xBA\x81\x83\x87\x87\x87am\xF9V[[PPPPPPPV[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\r=W`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\x01`\xF8\x1B\x86~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x03a\x0E\xF7W`\x02`S\x81\x11\x15a\r\x7FWa\r~a\x82\xA6V[[\x87`S\x81\x11\x15a\r\x92Wa\r\x91a\x82\xA6V[[\x03a\r\xA1Wa}\0\x90Pa\x0E\xE6V[`\x03`S\x81\x11\x15a\r\xB5Wa\r\xB4a\x82\xA6V[[\x87`S\x81\x11\x15a\r\xC8Wa\r\xC7a\x82\xA6V[[\x03a\r\xD7Wa}\0\x90Pa\x0E\xE5V[`\x04`S\x81\x11\x15a\r\xEBWa\r\xEAa\x82\xA6V[[\x87`S\x81\x11\x15a\r\xFEWa\r\xFDa\x82\xA6V[[\x03a\x0E\rWa}\0\x90Pa\x0E\xE4V[`\x05`S\x81\x11\x15a\x0E!Wa\x0E a\x82\xA6V[[\x87`S\x81\x11\x15a\x0E4Wa\x0E3a\x82\xA6V[[\x03a\x0ECWa\x84\xD0\x90Pa\x0E\xE3V[`\x06`S\x81\x11\x15a\x0EWWa\x0EVa\x82\xA6V[[\x87`S\x81\x11\x15a\x0EjWa\x0Eia\x82\xA6V[[\x03a\x0EyWa\x90\x88\x90Pa\x0E\xE2V[`\x08`S\x81\x11\x15a\x0E\x8DWa\x0E\x8Ca\x82\xA6V[[\x87`S\x81\x11\x15a\x0E\xA0Wa\x0E\x9Fa\x82\xA6V[[\x03a\x0E\xAFWa\x94p\x90Pa\x0E\xE1V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[[a\x0E\xF2\x81\x83\x87\x86amiV[a\x10\x86V[`\x02`S\x81\x11\x15a\x0F\x0BWa\x0F\na\x82\xA6V[[\x87`S\x81\x11\x15a\x0F\x1EWa\x0F\x1Da\x82\xA6V[[\x03a\x0F.Wb\x01cx\x90Pa\x10xV[`\x03`S\x81\x11\x15a\x0FBWa\x0FAa\x82\xA6V[[\x87`S\x81\x11\x15a\x0FUWa\x0FTa\x82\xA6V[[\x03a\x0FeWb\x01\xE0x\x90Pa\x10wV[`\x04`S\x81\x11\x15a\x0FyWa\x0Fxa\x82\xA6V[[\x87`S\x81\x11\x15a\x0F\x8CWa\x0F\x8Ba\x82\xA6V[[\x03a\x0F\x9CWb\x02|\xB8\x90Pa\x10vV[`\x05`S\x81\x11\x15a\x0F\xB0Wa\x0F\xAFa\x82\xA6V[[\x87`S\x81\x11\x15a\x0F\xC3Wa\x0F\xC2a\x82\xA6V[[\x03a\x0F\xD3Wb\x030h\x90Pa\x10uV[`\x06`S\x81\x11\x15a\x0F\xE7Wa\x0F\xE6a\x82\xA6V[[\x87`S\x81\x11\x15a\x0F\xFAWa\x0F\xF9a\x82\xA6V[[\x03a\x10\nWb\x04&\x80\x90Pa\x10tV[`\x08`S\x81\x11\x15a\x10\x1EWa\x10\x1Da\x82\xA6V[[\x87`S\x81\x11\x15a\x101Wa\x100a\x82\xA6V[[\x03a\x10AWb\x05\xA1h\x90Pa\x10sV[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[[a\x10\x85\x81\x83\x87\x87\x87am\xF9V[[PPPPPPPV[```@Q\x80`@\x01`@R\x80`\x08\x81R` \x01\x7FHCULimit\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81RPa\x10\xD0_an\x9BV[a\x10\xDA`\x02an\x9BV[a\x10\xE3_an\x9BV[`@Q` \x01a\x10\xF6\x94\x93\x92\x91\x90a\x83\xA1V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x90P\x90V[`\x01a\x11\x14aoeV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x11UW`@Q\x7FoOs\x1F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x03_a\x11`ao\x89V[\x90P\x80_\x01`\x08\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x80a\x11\xA8WP\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81_\x01_\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x10\x15[\x15a\x11\xDFW`@Q\x7F\xF9.\xE8\xA9\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x81\x81_\x01_a\x01\0\n\x81T\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP`\x01\x81_\x01`\x08a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UPa\x12-\x85ao\xB0V[a\x126\x84ap\x16V[a\x12?\x83ap}V[_\x81_\x01`\x08a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP\x7F\xC7\xF5\x05\xB2\xF3q\xAE!u\xEEI\x13\xF4I\x9E\x1F&3\xA7\xB5\x93c!\xEE\xD1\xCD\xAE\xB6\x11Q\x81\xD2\x82`@Qa\x12\x89\x91\x90a\x84!V[`@Q\x80\x91\x03\x90\xA1PPPPPV[_a\x12\xA1ap\xE4V[_\x01`\x12\x90T\x90a\x01\0\n\x90\x04e\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P\x90V[_s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$\x90P\x90V[sP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x8D\xA5\xCB[`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x133W=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x13W\x91\x90a\x84NV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x13\xC6W3`@Q\x7F!\xBF\xDA\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x13\xBD\x91\x90a~\xF2V[`@Q\x80\x91\x03\x90\xFD[_a\x13\xCFap\xE4V[\x90P\x80`\x01\x01_\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16a\x14^W\x81`@Q\x7F\xE3\xCC4\x18\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x14U\x91\x90a~\xF2V[`@Q\x80\x91\x03\x90\xFD[_\x81`\x01\x01_\x84s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\x92\xFC\x97\xAF\x15\0&F\xCE\xA6<v3\xBB7[\x82\xDB|\xDE{H\x0Cu\xFEcA\xDA\xCC),\x81`@Q`@Q\x80\x91\x03\x90\xA2PPV[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x15tW`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x80`S\x81\x11\x15a\x15\x88Wa\x15\x87a\x82\xA6V[[\x85`S\x81\x11\x15a\x15\x9BWa\x15\x9Aa\x82\xA6V[[\x03a\x15\xA9W`\x02\x90Pa\x17\x1FV[`\x02`S\x81\x11\x15a\x15\xBDWa\x15\xBCa\x82\xA6V[[\x85`S\x81\x11\x15a\x15\xD0Wa\x15\xCFa\x82\xA6V[[\x03a\x15\xDEW`\t\x90Pa\x17\x1EV[`\x03`S\x81\x11\x15a\x15\xF2Wa\x15\xF1a\x82\xA6V[[\x85`S\x81\x11\x15a\x16\x05Wa\x16\x04a\x82\xA6V[[\x03a\x16\x13W`\x10\x90Pa\x17\x1DV[`\x04`S\x81\x11\x15a\x16'Wa\x16&a\x82\xA6V[[\x85`S\x81\x11\x15a\x16:Wa\x169a\x82\xA6V[[\x03a\x16HW` \x90Pa\x17\x1CV[`\x05`S\x81\x11\x15a\x16\\Wa\x16[a\x82\xA6V[[\x85`S\x81\x11\x15a\x16oWa\x16na\x82\xA6V[[\x03a\x16}W`?\x90Pa\x17\x1BV[`\x06`S\x81\x11\x15a\x16\x91Wa\x16\x90a\x82\xA6V[[\x85`S\x81\x11\x15a\x16\xA4Wa\x16\xA3a\x82\xA6V[[\x03a\x16\xB2W`\x82\x90Pa\x17\x1AV[`\x08`S\x81\x11\x15a\x16\xC6Wa\x16\xC5a\x82\xA6V[[\x85`S\x81\x11\x15a\x16\xD9Wa\x16\xD8a\x82\xA6V[[\x03a\x16\xE7W`\x82\x90Pa\x17\x19V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[[[a\x17+\x81\x83\x86\x86amiV[PPPPPV[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x17\xABW`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x80`S\x81\x11\x15a\x17\xBFWa\x17\xBEa\x82\xA6V[[\x87`S\x81\x11\x15a\x17\xD2Wa\x17\xD1a\x82\xA6V[[\x03a\x17\xE1Wa\xD6\xD8\x90Pa\x19\x96V[`\x02`S\x81\x11\x15a\x17\xF5Wa\x17\xF4a\x82\xA6V[[\x87`S\x81\x11\x15a\x18\x08Wa\x18\x07a\x82\xA6V[[\x03a\x18\x17Wa\xD6\xD8\x90Pa\x19\x95V[`\x03`S\x81\x11\x15a\x18+Wa\x18*a\x82\xA6V[[\x87`S\x81\x11\x15a\x18>Wa\x18=a\x82\xA6V[[\x03a\x18MWa\xD6\xD8\x90Pa\x19\x94V[`\x04`S\x81\x11\x15a\x18aWa\x18`a\x82\xA6V[[\x87`S\x81\x11\x15a\x18tWa\x18sa\x82\xA6V[[\x03a\x18\x83Wa\xD6\xD8\x90Pa\x19\x93V[`\x05`S\x81\x11\x15a\x18\x97Wa\x18\x96a\x82\xA6V[[\x87`S\x81\x11\x15a\x18\xAAWa\x18\xA9a\x82\xA6V[[\x03a\x18\xB9Wa\xD6\xD8\x90Pa\x19\x92V[`\x06`S\x81\x11\x15a\x18\xCDWa\x18\xCCa\x82\xA6V[[\x87`S\x81\x11\x15a\x18\xE0Wa\x18\xDFa\x82\xA6V[[\x03a\x18\xEFWa\xDE\xA8\x90Pa\x19\x91V[`\x07`S\x81\x11\x15a\x19\x03Wa\x19\x02a\x82\xA6V[[\x87`S\x81\x11\x15a\x19\x16Wa\x19\x15a\x82\xA6V[[\x03a\x19&Wb\x01D8\x90Pa\x19\x90V[`\x08`S\x81\x11\x15a\x19:Wa\x199a\x82\xA6V[[\x87`S\x81\x11\x15a\x19MWa\x19La\x82\xA6V[[\x03a\x19]Wb\x01\xA5\xE0\x90Pa\x19\x8FV[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[[[[a\x19\xA4\x81\x83\x88\x88\x88\x88aq\x0BV[PPPPPPPV[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x1A&W`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\x01`\xF8\x1B\x86~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x14a\x1A\x86W`@Q\x7Fj\xA9\xEB\x05\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x02`S\x81\x11\x15a\x1A\x9AWa\x1A\x99a\x82\xA6V[[\x87`S\x81\x11\x15a\x1A\xADWa\x1A\xACa\x82\xA6V[[\x03a\x1A\xBDWb\x06\xB6\xC0\x90Pa\x1B\xCFV[`\x03`S\x81\x11\x15a\x1A\xD1Wa\x1A\xD0a\x82\xA6V[[\x87`S\x81\x11\x15a\x1A\xE4Wa\x1A\xE3a\x82\xA6V[[\x03a\x1A\xF4Wb\x08\xD9\xA0\x90Pa\x1B\xCEV[`\x04`S\x81\x11\x15a\x1B\x08Wa\x1B\x07a\x82\xA6V[[\x87`S\x81\x11\x15a\x1B\x1BWa\x1B\x1Aa\x82\xA6V[[\x03a\x1B+Wb\x0C\x15\xC0\x90Pa\x1B\xCDV[`\x05`S\x81\x11\x15a\x1B?Wa\x1B>a\x82\xA6V[[\x87`S\x81\x11\x15a\x1BRWa\x1BQa\x82\xA6V[[\x03a\x1BbWb\x11\x97\xE8\x90Pa\x1B\xCCV[`\x06`S\x81\x11\x15a\x1BvWa\x1Bua\x82\xA6V[[\x87`S\x81\x11\x15a\x1B\x89Wa\x1B\x88a\x82\xA6V[[\x03a\x1B\x99Wb\x1D\xA5\xD8\x90Pa\x1B\xCBV[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[a\x1B\xDB\x81\x83\x87\x86amiV[PPPPPPPV[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x1C]W`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\x01`\xF8\x1B\x86~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x03a\x1D\xE3W`\x02`S\x81\x11\x15a\x1C\x9FWa\x1C\x9Ea\x82\xA6V[[\x87`S\x81\x11\x15a\x1C\xB2Wa\x1C\xB1a\x82\xA6V[[\x03a\x1C\xC1Wa\xE2\x90\x90Pa\x1D\xD2V[`\x03`S\x81\x11\x15a\x1C\xD5Wa\x1C\xD4a\x82\xA6V[[\x87`S\x81\x11\x15a\x1C\xE8Wa\x1C\xE7a\x82\xA6V[[\x03a\x1C\xF7Wa\xE2\x90\x90Pa\x1D\xD1V[`\x04`S\x81\x11\x15a\x1D\x0BWa\x1D\na\x82\xA6V[[\x87`S\x81\x11\x15a\x1D\x1EWa\x1D\x1Da\x82\xA6V[[\x03a\x1D.Wb\x01H \x90Pa\x1D\xD0V[`\x05`S\x81\x11\x15a\x1DBWa\x1DAa\x82\xA6V[[\x87`S\x81\x11\x15a\x1DUWa\x1DTa\x82\xA6V[[\x03a\x1DeWb\x01\xD0\xD8\x90Pa\x1D\xCFV[`\x06`S\x81\x11\x15a\x1DyWa\x1Dxa\x82\xA6V[[\x87`S\x81\x11\x15a\x1D\x8CWa\x1D\x8Ba\x82\xA6V[[\x03a\x1D\x9CWb\x02I\xF0\x90Pa\x1D\xCEV[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[a\x1D\xDE\x81\x83\x87\x86amiV[a\x1F9V[`\x02`S\x81\x11\x15a\x1D\xF7Wa\x1D\xF6a\x82\xA6V[[\x87`S\x81\x11\x15a\x1E\nWa\x1E\ta\x82\xA6V[[\x03a\x1E\x19Wa\xE2\x90\x90Pa\x1F+V[`\x03`S\x81\x11\x15a\x1E-Wa\x1E,a\x82\xA6V[[\x87`S\x81\x11\x15a\x1E@Wa\x1E?a\x82\xA6V[[\x03a\x1EPWb\x01D8\x90Pa\x1F*V[`\x04`S\x81\x11\x15a\x1EdWa\x1Eca\x82\xA6V[[\x87`S\x81\x11\x15a\x1EwWa\x1Eva\x82\xA6V[[\x03a\x1E\x87Wb\x01\xC9\x08\x90Pa\x1F)V[`\x05`S\x81\x11\x15a\x1E\x9BWa\x1E\x9Aa\x82\xA6V[[\x87`S\x81\x11\x15a\x1E\xAEWa\x1E\xADa\x82\xA6V[[\x03a\x1E\xBEWb\x02F\x08\x90Pa\x1F(V[`\x06`S\x81\x11\x15a\x1E\xD2Wa\x1E\xD1a\x82\xA6V[[\x87`S\x81\x11\x15a\x1E\xE5Wa\x1E\xE4a\x82\xA6V[[\x03a\x1E\xF5Wb\x03S\x90\x90Pa\x1F'V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[a\x1F8\x81\x83\x87\x87\x87am\xF9V[[PPPPPPPV[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x1F\xBBW`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\x01`\xF8\x1B\x86~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x03a!AW`\x02`S\x81\x11\x15a\x1F\xFDWa\x1F\xFCa\x82\xA6V[[\x87`S\x81\x11\x15a \x10Wa \x0Fa\x82\xA6V[[\x03a \x1FWa\xCB \x90Pa!0V[`\x03`S\x81\x11\x15a 3Wa 2a\x82\xA6V[[\x87`S\x81\x11\x15a FWa Ea\x82\xA6V[[\x03a UWa\xE2\x90\x90Pa!/V[`\x04`S\x81\x11\x15a iWa ha\x82\xA6V[[\x87`S\x81\x11\x15a |Wa {a\x82\xA6V[[\x03a \x8CWb\x01D8\x90Pa!.V[`\x05`S\x81\x11\x15a \xA0Wa \x9Fa\x82\xA6V[[\x87`S\x81\x11\x15a \xB3Wa \xB2a\x82\xA6V[[\x03a \xC3Wb\x01\xCC\xF0\x90Pa!-V[`\x06`S\x81\x11\x15a \xD7Wa \xD6a\x82\xA6V[[\x87`S\x81\x11\x15a \xEAWa \xE9a\x82\xA6V[[\x03a \xFAWb\x02F\x08\x90Pa!,V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[a!<\x81\x83\x87\x86amiV[a\"\x97V[`\x02`S\x81\x11\x15a!UWa!Ta\x82\xA6V[[\x87`S\x81\x11\x15a!hWa!ga\x82\xA6V[[\x03a!wWa\xE6x\x90Pa\"\x89V[`\x03`S\x81\x11\x15a!\x8BWa!\x8Aa\x82\xA6V[[\x87`S\x81\x11\x15a!\x9EWa!\x9Da\x82\xA6V[[\x03a!\xAEWb\x01H \x90Pa\"\x88V[`\x04`S\x81\x11\x15a!\xC2Wa!\xC1a\x82\xA6V[[\x87`S\x81\x11\x15a!\xD5Wa!\xD4a\x82\xA6V[[\x03a!\xE5Wb\x01\xC9\x08\x90Pa\"\x87V[`\x05`S\x81\x11\x15a!\xF9Wa!\xF8a\x82\xA6V[[\x87`S\x81\x11\x15a\"\x0CWa\"\x0Ba\x82\xA6V[[\x03a\"\x1CWb\x02:P\x90Pa\"\x86V[`\x06`S\x81\x11\x15a\"0Wa\"/a\x82\xA6V[[\x87`S\x81\x11\x15a\"CWa\"Ba\x82\xA6V[[\x03a\"SWb\x03G\xD8\x90Pa\"\x85V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[a\"\x96\x81\x83\x87\x87\x87am\xF9V[[PPPPPPPV[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a#\x19W`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\x01`\xF8\x1B\x86~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x03a$\x9FW`\x02`S\x81\x11\x15a#[Wa#Za\x82\xA6V[[\x87`S\x81\x11\x15a#nWa#ma\x82\xA6V[[\x03a#}Wa\xCB \x90Pa$\x8EV[`\x03`S\x81\x11\x15a#\x91Wa#\x90a\x82\xA6V[[\x87`S\x81\x11\x15a#\xA4Wa#\xA3a\x82\xA6V[[\x03a#\xB3Wa\xD6\xD8\x90Pa$\x8DV[`\x04`S\x81\x11\x15a#\xC7Wa#\xC6a\x82\xA6V[[\x87`S\x81\x11\x15a#\xDAWa#\xD9a\x82\xA6V[[\x03a#\xEAWb\x01H \x90Pa$\x8CV[`\x05`S\x81\x11\x15a#\xFEWa#\xFDa\x82\xA6V[[\x87`S\x81\x11\x15a$\x11Wa$\x10a\x82\xA6V[[\x03a$!Wb\x01\xC9\x08\x90Pa$\x8BV[`\x06`S\x81\x11\x15a$5Wa$4a\x82\xA6V[[\x87`S\x81\x11\x15a$HWa$Ga\x82\xA6V[[\x03a$XWb\x02I\xF0\x90Pa$\x8AV[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[a$\x9A\x81\x83\x87\x86amiV[a%\xF5V[`\x02`S\x81\x11\x15a$\xB3Wa$\xB2a\x82\xA6V[[\x87`S\x81\x11\x15a$\xC6Wa$\xC5a\x82\xA6V[[\x03a$\xD5Wa\xE6x\x90Pa%\xE7V[`\x03`S\x81\x11\x15a$\xE9Wa$\xE8a\x82\xA6V[[\x87`S\x81\x11\x15a$\xFCWa$\xFBa\x82\xA6V[[\x03a%\x0CWb\x01H \x90Pa%\xE6V[`\x04`S\x81\x11\x15a% Wa%\x1Fa\x82\xA6V[[\x87`S\x81\x11\x15a%3Wa%2a\x82\xA6V[[\x03a%CWb\x01\xCC\xF0\x90Pa%\xE5V[`\x05`S\x81\x11\x15a%WWa%Va\x82\xA6V[[\x87`S\x81\x11\x15a%jWa%ia\x82\xA6V[[\x03a%zWb\x02Q\xC0\x90Pa%\xE4V[`\x06`S\x81\x11\x15a%\x8EWa%\x8Da\x82\xA6V[[\x87`S\x81\x11\x15a%\xA1Wa%\xA0a\x82\xA6V[[\x03a%\xB1Wb\x03S\x90\x90Pa%\xE3V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[a%\xF4\x81\x83\x87\x87\x87am\xF9V[[PPPPPPPV[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a&wW`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\x02`S\x81\x11\x15a&\x8CWa&\x8Ba\x82\xA6V[[\x85`S\x81\x11\x15a&\x9FWa&\x9Ea\x82\xA6V[[\x03a&\xAFWb\x014\x98\x90Pa'\xF9V[`\x03`S\x81\x11\x15a&\xC3Wa&\xC2a\x82\xA6V[[\x85`S\x81\x11\x15a&\xD6Wa&\xD5a\x82\xA6V[[\x03a&\xE6Wb\x01kH\x90Pa'\xF8V[`\x04`S\x81\x11\x15a&\xFAWa&\xF9a\x82\xA6V[[\x85`S\x81\x11\x15a'\rWa'\x0Ca\x82\xA6V[[\x03a'\x1DWb\x01s\x18\x90Pa'\xF7V[`\x05`S\x81\x11\x15a'1Wa'0a\x82\xA6V[[\x85`S\x81\x11\x15a'DWa'Ca\x82\xA6V[[\x03a'TWb\x01\xFF\xB8\x90Pa'\xF6V[`\x06`S\x81\x11\x15a'hWa'ga\x82\xA6V[[\x85`S\x81\x11\x15a'{Wa'za\x82\xA6V[[\x03a'\x8BWb\x02\x90@\x90Pa'\xF5V[`\x08`S\x81\x11\x15a'\x9FWa'\x9Ea\x82\xA6V[[\x85`S\x81\x11\x15a'\xB2Wa'\xB1a\x82\xA6V[[\x03a'\xC2Wb\x04\x1A\xC8\x90Pa'\xF4V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[[a(\x05\x81\x83\x86\x86amiV[PPPPPV[a(\x14aq\xBFV[a(\x1D\x82ar\xA5V[a('\x82\x82as\x98V[PPV[_a(4at\xB6V[\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC_\x1B\x90P\x90V[sP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x8D\xA5\xCB[`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a(\xB9W=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a(\xDD\x91\x90a\x84NV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a)LW3`@Q\x7F!\xBF\xDA\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a)C\x91\x90a~\xF2V[`@Q\x80\x91\x03\x90\xFD[a)U\x81ap\x16V[PV[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a)\xD1W`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\x01`\xF8\x1B\x86~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x03a+\x8BW`\x02`S\x81\x11\x15a*\x13Wa*\x12a\x82\xA6V[[\x87`S\x81\x11\x15a*&Wa*%a\x82\xA6V[[\x03a*5Way\x18\x90Pa+zV[`\x03`S\x81\x11\x15a*IWa*Ha\x82\xA6V[[\x87`S\x81\x11\x15a*\\Wa*[a\x82\xA6V[[\x03a*kWay\x18\x90Pa+yV[`\x04`S\x81\x11\x15a*\x7FWa*~a\x82\xA6V[[\x87`S\x81\x11\x15a*\x92Wa*\x91a\x82\xA6V[[\x03a*\xA1Wa}\0\x90Pa+xV[`\x05`S\x81\x11\x15a*\xB5Wa*\xB4a\x82\xA6V[[\x87`S\x81\x11\x15a*\xC8Wa*\xC7a\x82\xA6V[[\x03a*\xD7Wa\x84\xD0\x90Pa+wV[`\x06`S\x81\x11\x15a*\xEBWa*\xEAa\x82\xA6V[[\x87`S\x81\x11\x15a*\xFEWa*\xFDa\x82\xA6V[[\x03a+\rWa\x90\x88\x90Pa+vV[`\x08`S\x81\x11\x15a+!Wa+ a\x82\xA6V[[\x87`S\x81\x11\x15a+4Wa+3a\x82\xA6V[[\x03a+CWa\x94p\x90Pa+uV[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[[a+\x86\x81\x83\x87\x86amiV[a-\x1AV[`\x02`S\x81\x11\x15a+\x9FWa+\x9Ea\x82\xA6V[[\x87`S\x81\x11\x15a+\xB2Wa+\xB1a\x82\xA6V[[\x03a+\xC2Wb\x01cx\x90Pa-\x0CV[`\x03`S\x81\x11\x15a+\xD6Wa+\xD5a\x82\xA6V[[\x87`S\x81\x11\x15a+\xE9Wa+\xE8a\x82\xA6V[[\x03a+\xF9Wb\x01\xE8H\x90Pa-\x0BV[`\x04`S\x81\x11\x15a,\rWa,\x0Ca\x82\xA6V[[\x87`S\x81\x11\x15a, Wa,\x1Fa\x82\xA6V[[\x03a,0Wb\x02|\xB8\x90Pa-\nV[`\x05`S\x81\x11\x15a,DWa,Ca\x82\xA6V[[\x87`S\x81\x11\x15a,WWa,Va\x82\xA6V[[\x03a,gWb\x030h\x90Pa-\tV[`\x06`S\x81\x11\x15a,{Wa,za\x82\xA6V[[\x87`S\x81\x11\x15a,\x8EWa,\x8Da\x82\xA6V[[\x03a,\x9EWb\x04=\xF0\x90Pa-\x08V[`\x08`S\x81\x11\x15a,\xB2Wa,\xB1a\x82\xA6V[[\x87`S\x81\x11\x15a,\xC5Wa,\xC4a\x82\xA6V[[\x03a,\xD5Wb\x05\xC4\x90\x90Pa-\x07V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[[a-\x19\x81\x83\x87\x87\x87am\xF9V[[PPPPPPPV[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a-\x9CW`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\x01`\xF8\x1B\x86~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x03a/\xC8W_`S\x81\x11\x15a-\xDDWa-\xDCa\x82\xA6V[[\x87`S\x81\x11\x15a-\xF0Wa-\xEFa\x82\xA6V[[\x03a-\xFFWaa\xA8\x90Pa/\xB7V[`\x02`S\x81\x11\x15a.\x13Wa.\x12a\x82\xA6V[[\x87`S\x81\x11\x15a.&Wa.%a\x82\xA6V[[\x03a.5Wa\xD6\xD8\x90Pa/\xB6V[`\x03`S\x81\x11\x15a.IWa.Ha\x82\xA6V[[\x87`S\x81\x11\x15a.\\Wa.[a\x82\xA6V[[\x03a.kWa\xD6\xD8\x90Pa/\xB5V[`\x04`S\x81\x11\x15a.\x7FWa.~a\x82\xA6V[[\x87`S\x81\x11\x15a.\x92Wa.\x91a\x82\xA6V[[\x03a.\xA2Wb\x01@P\x90Pa/\xB4V[`\x05`S\x81\x11\x15a.\xB6Wa.\xB5a\x82\xA6V[[\x87`S\x81\x11\x15a.\xC9Wa.\xC8a\x82\xA6V[[\x03a.\xD9Wb\x01D8\x90Pa/\xB3V[`\x06`S\x81\x11\x15a.\xEDWa.\xECa\x82\xA6V[[\x87`S\x81\x11\x15a/\0Wa.\xFFa\x82\xA6V[[\x03a/\x10Wb\x01\xC9\x08\x90Pa/\xB2V[`\x07`S\x81\x11\x15a/$Wa/#a\x82\xA6V[[\x87`S\x81\x11\x15a/7Wa/6a\x82\xA6V[[\x03a/GWb\x01\xC9\x08\x90Pa/\xB1V[`\x08`S\x81\x11\x15a/[Wa/Za\x82\xA6V[[\x87`S\x81\x11\x15a/nWa/ma\x82\xA6V[[\x03a/~Wb\x01\xCC\xF0\x90Pa/\xB0V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[[[[a/\xC3\x81\x83\x87\x86amiV[a1\xC4V[_`S\x81\x11\x15a/\xDBWa/\xDAa\x82\xA6V[[\x87`S\x81\x11\x15a/\xEEWa/\xEDa\x82\xA6V[[\x03a/\xFDWae\x90\x90Pa1\xB6V[`\x02`S\x81\x11\x15a0\x11Wa0\x10a\x82\xA6V[[\x87`S\x81\x11\x15a0$Wa0#a\x82\xA6V[[\x03a03Wa\xD6\xD8\x90Pa1\xB5V[`\x03`S\x81\x11\x15a0GWa0Fa\x82\xA6V[[\x87`S\x81\x11\x15a0ZWa0Ya\x82\xA6V[[\x03a0jWb\x01D8\x90Pa1\xB4V[`\x04`S\x81\x11\x15a0~Wa0}a\x82\xA6V[[\x87`S\x81\x11\x15a0\x91Wa0\x90a\x82\xA6V[[\x03a0\xA1Wb\x01O\xF0\x90Pa1\xB3V[`\x05`S\x81\x11\x15a0\xB5Wa0\xB4a\x82\xA6V[[\x87`S\x81\x11\x15a0\xC8Wa0\xC7a\x82\xA6V[[\x03a0\xD8Wb\x01\xD4\xC0\x90Pa1\xB2V[`\x06`S\x81\x11\x15a0\xECWa0\xEBa\x82\xA6V[[\x87`S\x81\x11\x15a0\xFFWa0\xFEa\x82\xA6V[[\x03a1\x0FWb\x01\xDC\x90\x90Pa1\xB1V[`\x07`S\x81\x11\x15a1#Wa1\"a\x82\xA6V[[\x87`S\x81\x11\x15a16Wa15a\x82\xA6V[[\x03a1FWb\x02\x17(\x90Pa1\xB0V[`\x08`S\x81\x11\x15a1ZWa1Ya\x82\xA6V[[\x87`S\x81\x11\x15a1mWa1la\x82\xA6V[[\x03a1}Wb\x02Q\xC0\x90Pa1\xAFV[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[[[[a1\xC3\x81\x83\x87\x87\x87am\xF9V[[PPPPPPPV[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a2FW`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x80`S\x81\x11\x15a2ZWa2Ya\x82\xA6V[[\x85`S\x81\x11\x15a2mWa2la\x82\xA6V[[\x03a2{W` \x90Pa3\xF1V[`\x02`S\x81\x11\x15a2\x8FWa2\x8Ea\x82\xA6V[[\x85`S\x81\x11\x15a2\xA2Wa2\xA1a\x82\xA6V[[\x03a2\xB0W` \x90Pa3\xF0V[`\x03`S\x81\x11\x15a2\xC4Wa2\xC3a\x82\xA6V[[\x85`S\x81\x11\x15a2\xD7Wa2\xD6a\x82\xA6V[[\x03a2\xE5W` \x90Pa3\xEFV[`\x04`S\x81\x11\x15a2\xF9Wa2\xF8a\x82\xA6V[[\x85`S\x81\x11\x15a3\x0CWa3\x0Ba\x82\xA6V[[\x03a3\x1AW` \x90Pa3\xEEV[`\x05`S\x81\x11\x15a3.Wa3-a\x82\xA6V[[\x85`S\x81\x11\x15a3AWa3@a\x82\xA6V[[\x03a3OW` \x90Pa3\xEDV[`\x06`S\x81\x11\x15a3cWa3ba\x82\xA6V[[\x85`S\x81\x11\x15a3vWa3ua\x82\xA6V[[\x03a3\x84W` \x90Pa3\xECV[`\x08`S\x81\x11\x15a3\x98Wa3\x97a\x82\xA6V[[\x85`S\x81\x11\x15a3\xABWa3\xAAa\x82\xA6V[[\x03a3\xB9W` \x90Pa3\xEBV[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[[[a3\xFD\x81\x83\x86\x86amiV[PPPPPV[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a4}W`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\x01`\xF8\x1B\x86~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x03a6\xA9W_`S\x81\x11\x15a4\xBEWa4\xBDa\x82\xA6V[[\x87`S\x81\x11\x15a4\xD1Wa4\xD0a\x82\xA6V[[\x03a4\xE0WaY\xD8\x90Pa6\x98V[`\x02`S\x81\x11\x15a4\xF4Wa4\xF3a\x82\xA6V[[\x87`S\x81\x11\x15a5\x07Wa5\x06a\x82\xA6V[[\x03a5\x16Wa\xD6\xD8\x90Pa6\x97V[`\x03`S\x81\x11\x15a5*Wa5)a\x82\xA6V[[\x87`S\x81\x11\x15a5=Wa5<a\x82\xA6V[[\x03a5LWa\xD6\xD8\x90Pa6\x96V[`\x04`S\x81\x11\x15a5`Wa5_a\x82\xA6V[[\x87`S\x81\x11\x15a5sWa5ra\x82\xA6V[[\x03a5\x83Wb\x01D8\x90Pa6\x95V[`\x05`S\x81\x11\x15a5\x97Wa5\x96a\x82\xA6V[[\x87`S\x81\x11\x15a5\xAAWa5\xA9a\x82\xA6V[[\x03a5\xBAWb\x01H \x90Pa6\x94V[`\x06`S\x81\x11\x15a5\xCEWa5\xCDa\x82\xA6V[[\x87`S\x81\x11\x15a5\xE1Wa5\xE0a\x82\xA6V[[\x03a5\xF1Wb\x01\xC9\x08\x90Pa6\x93V[`\x07`S\x81\x11\x15a6\x05Wa6\x04a\x82\xA6V[[\x87`S\x81\x11\x15a6\x18Wa6\x17a\x82\xA6V[[\x03a6(Wb\x01\xC9\x08\x90Pa6\x92V[`\x08`S\x81\x11\x15a6<Wa6;a\x82\xA6V[[\x87`S\x81\x11\x15a6OWa6Na\x82\xA6V[[\x03a6_Wb\x01\xC9\x08\x90Pa6\x91V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[[[[a6\xA4\x81\x83\x87\x86amiV[a8\xA5V[_`S\x81\x11\x15a6\xBCWa6\xBBa\x82\xA6V[[\x87`S\x81\x11\x15a6\xCFWa6\xCEa\x82\xA6V[[\x03a6\xDEWaY\xD8\x90Pa8\x97V[`\x02`S\x81\x11\x15a6\xF2Wa6\xF1a\x82\xA6V[[\x87`S\x81\x11\x15a7\x05Wa7\x04a\x82\xA6V[[\x03a7\x14Wa\xD6\xD8\x90Pa8\x96V[`\x03`S\x81\x11\x15a7(Wa7'a\x82\xA6V[[\x87`S\x81\x11\x15a7;Wa7:a\x82\xA6V[[\x03a7KWb\x01D8\x90Pa8\x95V[`\x04`S\x81\x11\x15a7_Wa7^a\x82\xA6V[[\x87`S\x81\x11\x15a7rWa7qa\x82\xA6V[[\x03a7\x82Wb\x01L\x08\x90Pa8\x94V[`\x05`S\x81\x11\x15a7\x96Wa7\x95a\x82\xA6V[[\x87`S\x81\x11\x15a7\xA9Wa7\xA8a\x82\xA6V[[\x03a7\xB9Wb\x01\xCC\xF0\x90Pa8\x93V[`\x06`S\x81\x11\x15a7\xCDWa7\xCCa\x82\xA6V[[\x87`S\x81\x11\x15a7\xE0Wa7\xDFa\x82\xA6V[[\x03a7\xF0Wb\x01\xDC\x90\x90Pa8\x92V[`\x07`S\x81\x11\x15a8\x04Wa8\x03a\x82\xA6V[[\x87`S\x81\x11\x15a8\x17Wa8\x16a\x82\xA6V[[\x03a8'Wb\x02\x13@\x90Pa8\x91V[`\x08`S\x81\x11\x15a8;Wa8:a\x82\xA6V[[\x87`S\x81\x11\x15a8NWa8Ma\x82\xA6V[[\x03a8^Wb\x02I\xF0\x90Pa8\x90V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[[[[a8\xA4\x81\x83\x87\x87\x87am\xF9V[[PPPPPPPV[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a9'W`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\x02`S\x81\x11\x15a9<Wa9;a\x82\xA6V[[\x84`S\x81\x11\x15a9OWa9Na\x82\xA6V[[\x03a9^WaY\xD8\x90Pa:\xA3V[`\x03`S\x81\x11\x15a9rWa9qa\x82\xA6V[[\x84`S\x81\x11\x15a9\x85Wa9\x84a\x82\xA6V[[\x03a9\x94WaY\xD8\x90Pa:\xA2V[`\x04`S\x81\x11\x15a9\xA8Wa9\xA7a\x82\xA6V[[\x84`S\x81\x11\x15a9\xBBWa9\xBAa\x82\xA6V[[\x03a9\xCAWa]\xC0\x90Pa:\xA1V[`\x05`S\x81\x11\x15a9\xDEWa9\xDDa\x82\xA6V[[\x84`S\x81\x11\x15a9\xF1Wa9\xF0a\x82\xA6V[[\x03a:\0Wa]\xC0\x90Pa:\xA0V[`\x06`S\x81\x11\x15a:\x14Wa:\x13a\x82\xA6V[[\x84`S\x81\x11\x15a:'Wa:&a\x82\xA6V[[\x03a:6Waa\xA8\x90Pa:\x9FV[`\x08`S\x81\x11\x15a:JWa:Ia\x82\xA6V[[\x84`S\x81\x11\x15a:]Wa:\\a\x82\xA6V[[\x03a:lWau0\x90Pa:\x9EV[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[[a:\xAD\x81\x83au=V[a:\xB7\x83\x82au\xC9V[PPPPV[sP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x8D\xA5\xCB[`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a;\x1AW=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a;>\x91\x90a\x84NV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a;\xADW3`@Q\x7F!\xBF\xDA\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a;\xA4\x91\x90a~\xF2V[`@Q\x80\x91\x03\x90\xFD[_a;\xB6ap\xE4V[\x90P\x80`\x01\x01_\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x15a<FW\x81`@Q\x7F\xF9\x9CO\xD1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a<=\x91\x90a~\xF2V[`@Q\x80\x91\x03\x90\xFD[`\x01\x81`\x01\x01_\x84s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xCC\xA1\xD4c\x84\xCD\xBB\xEE\xF2\xF9\xDA\xDD\xB7m\xB18\x10\x1C\x99\x05\xF8\x18\xD8g\xB60\x19\\\x12\x8D<f`@Q`@Q\x80\x91\x03\x90\xA2PPV[`\x03_a<\xEFao\x89V[\x90P\x80_\x01`\x08\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x80a=7WP\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81_\x01_\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x10\x15[\x15a=nW`@Q\x7F\xF9.\xE8\xA9\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x81\x81_\x01_a\x01\0\n\x81T\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP`\x01\x81_\x01`\x08a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UPa=\xBC\x85ao\xB0V[a=\xC5\x84ap\x16V[a=\xCE\x83ap}V[_\x81_\x01`\x08a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP\x7F\xC7\xF5\x05\xB2\xF3q\xAE!u\xEEI\x13\xF4I\x9E\x1F&3\xA7\xB5\x93c!\xEE\xD1\xCD\xAE\xB6\x11Q\x81\xD2\x82`@Qa>\x18\x91\x90a\x84!V[`@Q\x80\x91\x03\x90\xA1PPPPPV[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a>\xA0W`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\x01`\xF8\x1B\x86~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x03a@(W`\x02`S\x81\x11\x15a>\xE2Wa>\xE1a\x82\xA6V[[\x87`S\x81\x11\x15a>\xF5Wa>\xF4a\x82\xA6V[[\x03a?\x05Wb\x01\xDC\x90\x90Pa@\x17V[`\x03`S\x81\x11\x15a?\x19Wa?\x18a\x82\xA6V[[\x87`S\x81\x11\x15a?,Wa?+a\x82\xA6V[[\x03a?<Wb\x02\xF1\xE8\x90Pa@\x16V[`\x04`S\x81\x11\x15a?PWa?Oa\x82\xA6V[[\x87`S\x81\x11\x15a?cWa?ba\x82\xA6V[[\x03a?sWb\x04\x0B(\x90Pa@\x15V[`\x05`S\x81\x11\x15a?\x87Wa?\x86a\x82\xA6V[[\x87`S\x81\x11\x15a?\x9AWa?\x99a\x82\xA6V[[\x03a?\xAAWb\x05\x91\xC8\x90Pa@\x14V[`\x06`S\x81\x11\x15a?\xBEWa?\xBDa\x82\xA6V[[\x87`S\x81\x11\x15a?\xD1Wa?\xD0a\x82\xA6V[[\x03a?\xE1Wb\n\x9E\xC0\x90Pa@\x13V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[a@#\x81\x83\x87\x86amiV[aA\x7FV[`\x02`S\x81\x11\x15a@<Wa@;a\x82\xA6V[[\x87`S\x81\x11\x15a@OWa@Na\x82\xA6V[[\x03a@_Wb\x02I\xF0\x90PaAqV[`\x03`S\x81\x11\x15a@sWa@ra\x82\xA6V[[\x87`S\x81\x11\x15a@\x86Wa@\x85a\x82\xA6V[[\x03a@\x96Wb\x03c0\x90PaApV[`\x04`S\x81\x11\x15a@\xAAWa@\xA9a\x82\xA6V[[\x87`S\x81\x11\x15a@\xBDWa@\xBCa\x82\xA6V[[\x03a@\xCDWb\x05\x01@\x90PaAoV[`\x05`S\x81\x11\x15a@\xE1Wa@\xE0a\x82\xA6V[[\x87`S\x81\x11\x15a@\xF4Wa@\xF3a\x82\xA6V[[\x03aA\x04Wb\t\x18 \x90PaAnV[`\x06`S\x81\x11\x15aA\x18WaA\x17a\x82\xA6V[[\x87`S\x81\x11\x15aA+WaA*a\x82\xA6V[[\x03aA;Wb\x19\xB9\xF0\x90PaAmV[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[aA~\x81\x83\x87\x87\x87am\xF9V[[PPPPPPPV[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14aB\x01W`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\x01`\xF8\x1B\x86~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x03aC\xBBW`\x02`S\x81\x11\x15aBCWaBBa\x82\xA6V[[\x87`S\x81\x11\x15aBVWaBUa\x82\xA6V[[\x03aBeWay\x18\x90PaC\xAAV[`\x03`S\x81\x11\x15aByWaBxa\x82\xA6V[[\x87`S\x81\x11\x15aB\x8CWaB\x8Ba\x82\xA6V[[\x03aB\x9BWay\x18\x90PaC\xA9V[`\x04`S\x81\x11\x15aB\xAFWaB\xAEa\x82\xA6V[[\x87`S\x81\x11\x15aB\xC2WaB\xC1a\x82\xA6V[[\x03aB\xD1Wa}\0\x90PaC\xA8V[`\x05`S\x81\x11\x15aB\xE5WaB\xE4a\x82\xA6V[[\x87`S\x81\x11\x15aB\xF8WaB\xF7a\x82\xA6V[[\x03aC\x07Wa\x84\xD0\x90PaC\xA7V[`\x06`S\x81\x11\x15aC\x1BWaC\x1Aa\x82\xA6V[[\x87`S\x81\x11\x15aC.WaC-a\x82\xA6V[[\x03aC=Wa\x90\x88\x90PaC\xA6V[`\x08`S\x81\x11\x15aCQWaCPa\x82\xA6V[[\x87`S\x81\x11\x15aCdWaCca\x82\xA6V[[\x03aCsWa\x9C@\x90PaC\xA5V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[[aC\xB6\x81\x83\x87\x86amiV[aEJV[`\x02`S\x81\x11\x15aC\xCFWaC\xCEa\x82\xA6V[[\x87`S\x81\x11\x15aC\xE2WaC\xE1a\x82\xA6V[[\x03aC\xF2Wb\x01kH\x90PaE<V[`\x03`S\x81\x11\x15aD\x06WaD\x05a\x82\xA6V[[\x87`S\x81\x11\x15aD\x19WaD\x18a\x82\xA6V[[\x03aD)Wb\x01\xE8H\x90PaE;V[`\x04`S\x81\x11\x15aD=WaD<a\x82\xA6V[[\x87`S\x81\x11\x15aDPWaDOa\x82\xA6V[[\x03aD`Wb\x02q\0\x90PaE:V[`\x05`S\x81\x11\x15aDtWaDsa\x82\xA6V[[\x87`S\x81\x11\x15aD\x87WaD\x86a\x82\xA6V[[\x03aD\x97Wb\x030h\x90PaE9V[`\x06`S\x81\x11\x15aD\xABWaD\xAAa\x82\xA6V[[\x87`S\x81\x11\x15aD\xBEWaD\xBDa\x82\xA6V[[\x03aD\xCEWb\x04Qx\x90PaE8V[`\x08`S\x81\x11\x15aD\xE2WaD\xE1a\x82\xA6V[[\x87`S\x81\x11\x15aD\xF5WaD\xF4a\x82\xA6V[[\x03aE\x05Wb\x05\xB8\xD8\x90PaE7V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[[aEI\x81\x83\x87\x87\x87am\xF9V[[PPPPPPPV[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14aE\xCCW`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\x01`\xF8\x1B\x86~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x03aGTW`\x02`S\x81\x11\x15aF\x0EWaF\ra\x82\xA6V[[\x87`S\x81\x11\x15aF!WaF a\x82\xA6V[[\x03aF1Wb\x01[\xA8\x90PaGCV[`\x03`S\x81\x11\x15aFEWaFDa\x82\xA6V[[\x87`S\x81\x11\x15aFXWaFWa\x82\xA6V[[\x03aFhWb\x01[\xA8\x90PaGBV[`\x04`S\x81\x11\x15aF|WaF{a\x82\xA6V[[\x87`S\x81\x11\x15aF\x8FWaF\x8Ea\x82\xA6V[[\x03aF\x9FWb\x01\xC9\x08\x90PaGAV[`\x05`S\x81\x11\x15aF\xB3WaF\xB2a\x82\xA6V[[\x87`S\x81\x11\x15aF\xC6WaF\xC5a\x82\xA6V[[\x03aF\xD6Wb\x02F\x08\x90PaG@V[`\x06`S\x81\x11\x15aF\xEAWaF\xE9a\x82\xA6V[[\x87`S\x81\x11\x15aF\xFDWaF\xFCa\x82\xA6V[[\x03aG\rWb\x02\xBF \x90PaG?V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[aGO\x81\x83\x87\x86amiV[aH\xABV[`\x02`S\x81\x11\x15aGhWaGga\x82\xA6V[[\x87`S\x81\x11\x15aG{WaGza\x82\xA6V[[\x03aG\x8BWb\x01\xD8\xA8\x90PaH\x9DV[`\x03`S\x81\x11\x15aG\x9FWaG\x9Ea\x82\xA6V[[\x87`S\x81\x11\x15aG\xB2WaG\xB1a\x82\xA6V[[\x03aG\xC2Wb\x026h\x90PaH\x9CV[`\x04`S\x81\x11\x15aG\xD6WaG\xD5a\x82\xA6V[[\x87`S\x81\x11\x15aG\xE9WaG\xE8a\x82\xA6V[[\x03aG\xF9Wb\x02\xBF \x90PaH\x9BV[`\x05`S\x81\x11\x15aH\rWaH\x0Ca\x82\xA6V[[\x87`S\x81\x11\x15aH WaH\x1Fa\x82\xA6V[[\x03aH0Wb\x03S\x90\x90PaH\x9AV[`\x06`S\x81\x11\x15aHDWaHCa\x82\xA6V[[\x87`S\x81\x11\x15aHWWaHVa\x82\xA6V[[\x03aHgWb\x04l\xD0\x90PaH\x99V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[aH\xAA\x81\x83\x87\x87\x87am\xF9V[[PPPPPPPV[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14aI-W`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\x01`\xF8\x1B\x86~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x14aI\x8DW`@Q\x7Fj\xA9\xEB\x05\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x02`S\x81\x11\x15aI\xA1WaI\xA0a\x82\xA6V[[\x87`S\x81\x11\x15aI\xB4WaI\xB3a\x82\xA6V[[\x03aI\xC4Wb\x034P\x90PaJ\xD6V[`\x03`S\x81\x11\x15aI\xD8WaI\xD7a\x82\xA6V[[\x87`S\x81\x11\x15aI\xEBWaI\xEAa\x82\xA6V[[\x03aI\xFBWb\x04\x9B\xB0\x90PaJ\xD5V[`\x04`S\x81\x11\x15aJ\x0FWaJ\x0Ea\x82\xA6V[[\x87`S\x81\x11\x15aJ\"WaJ!a\x82\xA6V[[\x03aJ2Wb\x06\xAE\xF0\x90PaJ\xD4V[`\x05`S\x81\x11\x15aJFWaJEa\x82\xA6V[[\x87`S\x81\x11\x15aJYWaJXa\x82\xA6V[[\x03aJiWb\n\xE8\xF8\x90PaJ\xD3V[`\x06`S\x81\x11\x15aJ}WaJ|a\x82\xA6V[[\x87`S\x81\x11\x15aJ\x90WaJ\x8Fa\x82\xA6V[[\x03aJ\xA0Wb\x12\xB1(\x90PaJ\xD2V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[aJ\xE2\x81\x83\x87\x86amiV[PPPPPPPV[_\x80_aJ\xF6ap\xE4V[\x90P_C\x90P\x80e\xFF\xFF\xFF\xFF\xFF\xFF\x16\x82_\x01`\x0C\x90T\x90a\x01\0\n\x90\x04e\xFF\xFF\xFF\xFF\xFF\xFF\x16e\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14aK5W\x80_\x93P\x93PPPaKSV[\x80\x82_\x01`\x06\x90T\x90a\x01\0\n\x90\x04e\xFF\xFF\xFF\xFF\xFF\xFF\x16\x93P\x93PPP[\x90\x91V[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14aK\xD0W`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\x01`\xF8\x1B\x86~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x03aM\xC0W_`S\x81\x11\x15aL\x11WaL\x10a\x82\xA6V[[\x87`S\x81\x11\x15aL$WaL#a\x82\xA6V[[\x03aL3WaU\xF0\x90PaM\xAFV[`\x02`S\x81\x11\x15aLGWaLFa\x82\xA6V[[\x87`S\x81\x11\x15aLZWaLYa\x82\xA6V[[\x03aLiWay\x18\x90PaM\xAEV[`\x03`S\x81\x11\x15aL}WaL|a\x82\xA6V[[\x87`S\x81\x11\x15aL\x90WaL\x8Fa\x82\xA6V[[\x03aL\x9FWay\x18\x90PaM\xADV[`\x04`S\x81\x11\x15aL\xB3WaL\xB2a\x82\xA6V[[\x87`S\x81\x11\x15aL\xC6WaL\xC5a\x82\xA6V[[\x03aL\xD5Wa}\0\x90PaM\xACV[`\x05`S\x81\x11\x15aL\xE9WaL\xE8a\x82\xA6V[[\x87`S\x81\x11\x15aL\xFCWaL\xFBa\x82\xA6V[[\x03aM\x0BWa\x84\xD0\x90PaM\xABV[`\x06`S\x81\x11\x15aM\x1FWaM\x1Ea\x82\xA6V[[\x87`S\x81\x11\x15aM2WaM1a\x82\xA6V[[\x03aMAWa\x90\x88\x90PaM\xAAV[`\x08`S\x81\x11\x15aMUWaMTa\x82\xA6V[[\x87`S\x81\x11\x15aMhWaMga\x82\xA6V[[\x03aMwWa\x98X\x90PaM\xA9V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[[[aM\xBB\x81\x83\x87\x86amiV[aO\x7FV[_`S\x81\x11\x15aM\xD3WaM\xD2a\x82\xA6V[[\x87`S\x81\x11\x15aM\xE6WaM\xE5a\x82\xA6V[[\x03aM\xF5WaU\xF0\x90PaOqV[`\x02`S\x81\x11\x15aN\tWaN\x08a\x82\xA6V[[\x87`S\x81\x11\x15aN\x1CWaN\x1Ba\x82\xA6V[[\x03aN+Way\x18\x90PaOpV[`\x03`S\x81\x11\x15aN?WaN>a\x82\xA6V[[\x87`S\x81\x11\x15aNRWaNQa\x82\xA6V[[\x03aNaWay\x18\x90PaOoV[`\x04`S\x81\x11\x15aNuWaNta\x82\xA6V[[\x87`S\x81\x11\x15aN\x88WaN\x87a\x82\xA6V[[\x03aN\x97Wa}\0\x90PaOnV[`\x05`S\x81\x11\x15aN\xABWaN\xAAa\x82\xA6V[[\x87`S\x81\x11\x15aN\xBEWaN\xBDa\x82\xA6V[[\x03aN\xCDWa\x84\xD0\x90PaOmV[`\x06`S\x81\x11\x15aN\xE1WaN\xE0a\x82\xA6V[[\x87`S\x81\x11\x15aN\xF4WaN\xF3a\x82\xA6V[[\x03aO\x03Wa\x90\x88\x90PaOlV[`\x08`S\x81\x11\x15aO\x17WaO\x16a\x82\xA6V[[\x87`S\x81\x11\x15aO*WaO)a\x82\xA6V[[\x03aO9Wa\x98X\x90PaOkV[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[[[aO~\x81\x83\x87\x87\x87am\xF9V[[PPPPPPPV[sP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x8D\xA5\xCB[`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15aO\xE5W=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90aP\t\x91\x90a\x84NV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14aPxW3`@Q\x7F!\xBF\xDA\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aPo\x91\x90a~\xF2V[`@Q\x80\x91\x03\x90\xFD[aP\x81\x81ao\xB0V[PV[sP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x8D\xA5\xCB[`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15aP\xE1W=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90aQ\x05\x91\x90a\x84NV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14aQtW3`@Q\x7F!\xBF\xDA\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aQk\x91\x90a~\xF2V[`@Q\x80\x91\x03\x90\xFD[aQ}\x81ap}V[PV[`@Q\x80`@\x01`@R\x80`\x05\x81R` \x01\x7F5.0.0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81RP\x81V[_\x80aQ\xC3ap\xE4V[\x90P\x80_\x01_\x90T\x90a\x01\0\n\x90\x04e\xFF\xFF\xFF\xFF\xFF\xFF\x16\x91PP\x90V[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14aRYW`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x80`S\x81\x11\x15aRmWaRla\x82\xA6V[[\x84`S\x81\x11\x15aR\x80WaR\x7Fa\x82\xA6V[[\x03aR\x8EW` \x90PaT:V[`\x02`S\x81\x11\x15aR\xA2WaR\xA1a\x82\xA6V[[\x84`S\x81\x11\x15aR\xB5WaR\xB4a\x82\xA6V[[\x03aR\xC3W` \x90PaT9V[`\x03`S\x81\x11\x15aR\xD7WaR\xD6a\x82\xA6V[[\x84`S\x81\x11\x15aR\xEAWaR\xE9a\x82\xA6V[[\x03aR\xF8W` \x90PaT8V[`\x04`S\x81\x11\x15aS\x0CWaS\x0Ba\x82\xA6V[[\x84`S\x81\x11\x15aS\x1FWaS\x1Ea\x82\xA6V[[\x03aS-W` \x90PaT7V[`\x05`S\x81\x11\x15aSAWaS@a\x82\xA6V[[\x84`S\x81\x11\x15aSTWaSSa\x82\xA6V[[\x03aSbW` \x90PaT6V[`\x06`S\x81\x11\x15aSvWaSua\x82\xA6V[[\x84`S\x81\x11\x15aS\x89WaS\x88a\x82\xA6V[[\x03aS\x97W` \x90PaT5V[`\x07`S\x81\x11\x15aS\xABWaS\xAAa\x82\xA6V[[\x84`S\x81\x11\x15aS\xBEWaS\xBDa\x82\xA6V[[\x03aS\xCCW` \x90PaT4V[`\x08`S\x81\x11\x15aS\xE0WaS\xDFa\x82\xA6V[[\x84`S\x81\x11\x15aS\xF3WaS\xF2a\x82\xA6V[[\x03aT\x01W` \x90PaT3V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[[[[aTD\x81\x83au=V[aTN\x83\x82au\xC9V[PPPPV[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14aT\xCDW`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\x01`\xF8\x1B\x86~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x03aV\xBDW_`S\x81\x11\x15aU\x0EWaU\ra\x82\xA6V[[\x87`S\x81\x11\x15aU!WaU a\x82\xA6V[[\x03aU0WaU\xF0\x90PaV\xACV[`\x02`S\x81\x11\x15aUDWaUCa\x82\xA6V[[\x87`S\x81\x11\x15aUWWaUVa\x82\xA6V[[\x03aUfWau0\x90PaV\xABV[`\x03`S\x81\x11\x15aUzWaUya\x82\xA6V[[\x87`S\x81\x11\x15aU\x8DWaU\x8Ca\x82\xA6V[[\x03aU\x9CWau0\x90PaV\xAAV[`\x04`S\x81\x11\x15aU\xB0WaU\xAFa\x82\xA6V[[\x87`S\x81\x11\x15aU\xC3WaU\xC2a\x82\xA6V[[\x03aU\xD2Wa}\0\x90PaV\xA9V[`\x05`S\x81\x11\x15aU\xE6WaU\xE5a\x82\xA6V[[\x87`S\x81\x11\x15aU\xF9WaU\xF8a\x82\xA6V[[\x03aV\x08Wa\x84\xD0\x90PaV\xA8V[`\x06`S\x81\x11\x15aV\x1CWaV\x1Ba\x82\xA6V[[\x87`S\x81\x11\x15aV/WaV.a\x82\xA6V[[\x03aV>Wa\x90\x88\x90PaV\xA7V[`\x08`S\x81\x11\x15aVRWaVQa\x82\xA6V[[\x87`S\x81\x11\x15aVeWaVda\x82\xA6V[[\x03aVtWa\x94p\x90PaV\xA6V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[[[aV\xB8\x81\x83\x87\x86amiV[aX|V[_`S\x81\x11\x15aV\xD0WaV\xCFa\x82\xA6V[[\x87`S\x81\x11\x15aV\xE3WaV\xE2a\x82\xA6V[[\x03aV\xF2Wa]\xC0\x90PaXnV[`\x02`S\x81\x11\x15aW\x06WaW\x05a\x82\xA6V[[\x87`S\x81\x11\x15aW\x19WaW\x18a\x82\xA6V[[\x03aW(Wau0\x90PaXmV[`\x03`S\x81\x11\x15aW<WaW;a\x82\xA6V[[\x87`S\x81\x11\x15aWOWaWNa\x82\xA6V[[\x03aW^Way\x18\x90PaXlV[`\x04`S\x81\x11\x15aWrWaWqa\x82\xA6V[[\x87`S\x81\x11\x15aW\x85WaW\x84a\x82\xA6V[[\x03aW\x94Wa}\0\x90PaXkV[`\x05`S\x81\x11\x15aW\xA8WaW\xA7a\x82\xA6V[[\x87`S\x81\x11\x15aW\xBBWaW\xBAa\x82\xA6V[[\x03aW\xCAWa\x84\xD0\x90PaXjV[`\x06`S\x81\x11\x15aW\xDEWaW\xDDa\x82\xA6V[[\x87`S\x81\x11\x15aW\xF1WaW\xF0a\x82\xA6V[[\x03aX\0Wa\x90\x88\x90PaXiV[`\x08`S\x81\x11\x15aX\x14WaX\x13a\x82\xA6V[[\x87`S\x81\x11\x15aX'WaX&a\x82\xA6V[[\x03aX6Wa\x94p\x90PaXhV[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[[[aX{\x81\x83\x87\x87\x87am\xF9V[[PPPPPPPV[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14aX\xFEW`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\x01`\xF8\x1B\x86~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x03aZ\x86W`\x02`S\x81\x11\x15aY@WaY?a\x82\xA6V[[\x87`S\x81\x11\x15aYSWaYRa\x82\xA6V[[\x03aYcWb\x01H \x90PaZuV[`\x03`S\x81\x11\x15aYwWaYva\x82\xA6V[[\x87`S\x81\x11\x15aY\x8AWaY\x89a\x82\xA6V[[\x03aY\x9AWb\x01kH\x90PaZtV[`\x04`S\x81\x11\x15aY\xAEWaY\xADa\x82\xA6V[[\x87`S\x81\x11\x15aY\xC1WaY\xC0a\x82\xA6V[[\x03aY\xD1Wb\x01s\x18\x90PaZsV[`\x05`S\x81\x11\x15aY\xE5WaY\xE4a\x82\xA6V[[\x87`S\x81\x11\x15aY\xF8WaY\xF7a\x82\xA6V[[\x03aZ\x08Wb\x02\x07\x88\x90PaZrV[`\x06`S\x81\x11\x15aZ\x1CWaZ\x1Ba\x82\xA6V[[\x87`S\x81\x11\x15aZ/WaZ.a\x82\xA6V[[\x03aZ?Wb\x02\x9F\xE0\x90PaZqV[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[aZ\x81\x81\x83\x87\x86amiV[a[\xDDV[`\x02`S\x81\x11\x15aZ\x9AWaZ\x99a\x82\xA6V[[\x87`S\x81\x11\x15aZ\xADWaZ\xACa\x82\xA6V[[\x03aZ\xBDWb\x01W\xC0\x90Pa[\xCFV[`\x03`S\x81\x11\x15aZ\xD1WaZ\xD0a\x82\xA6V[[\x87`S\x81\x11\x15aZ\xE4WaZ\xE3a\x82\xA6V[[\x03aZ\xF4Wb\x01kH\x90Pa[\xCEV[`\x04`S\x81\x11\x15a[\x08Wa[\x07a\x82\xA6V[[\x87`S\x81\x11\x15a[\x1BWa[\x1Aa\x82\xA6V[[\x03a[+Wb\x01\xE8H\x90Pa[\xCDV[`\x05`S\x81\x11\x15a[?Wa[>a\x82\xA6V[[\x87`S\x81\x11\x15a[RWa[Qa\x82\xA6V[[\x03a[bWb\x02x\xD0\x90Pa[\xCCV[`\x06`S\x81\x11\x15a[vWa[ua\x82\xA6V[[\x87`S\x81\x11\x15a[\x89Wa[\x88a\x82\xA6V[[\x03a[\x99Wb\x03\xF3\xB8\x90Pa[\xCBV[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[a[\xDC\x81\x83\x87\x87\x87am\xF9V[[PPPPPPPV[_a[\xEFap\xE4V[_\x01`\x18\x90T\x90a\x01\0\n\x90\x04e\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P\x90V[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\\\x82W`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\x01`\xF8\x1B\x86~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x03a^\x08W`\x02`S\x81\x11\x15a\\\xC4Wa\\\xC3a\x82\xA6V[[\x87`S\x81\x11\x15a\\\xD7Wa\\\xD6a\x82\xA6V[[\x03a\\\xE6Wa\xCB \x90Pa]\xF7V[`\x03`S\x81\x11\x15a\\\xFAWa\\\xF9a\x82\xA6V[[\x87`S\x81\x11\x15a]\rWa]\x0Ca\x82\xA6V[[\x03a]\x1CWa\xD6\xD8\x90Pa]\xF6V[`\x04`S\x81\x11\x15a]0Wa]/a\x82\xA6V[[\x87`S\x81\x11\x15a]CWa]Ba\x82\xA6V[[\x03a]SWb\x01H \x90Pa]\xF5V[`\x05`S\x81\x11\x15a]gWa]fa\x82\xA6V[[\x87`S\x81\x11\x15a]zWa]ya\x82\xA6V[[\x03a]\x8AWb\x01\xC5 \x90Pa]\xF4V[`\x06`S\x81\x11\x15a]\x9EWa]\x9Da\x82\xA6V[[\x87`S\x81\x11\x15a]\xB1Wa]\xB0a\x82\xA6V[[\x03a]\xC1Wb\x02F\x08\x90Pa]\xF3V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[a^\x03\x81\x83\x87\x86amiV[a_^V[`\x02`S\x81\x11\x15a^\x1CWa^\x1Ba\x82\xA6V[[\x87`S\x81\x11\x15a^/Wa^.a\x82\xA6V[[\x03a^>Wa\xF6\x18\x90Pa_PV[`\x03`S\x81\x11\x15a^RWa^Qa\x82\xA6V[[\x87`S\x81\x11\x15a^eWa^da\x82\xA6V[[\x03a^uWb\x01H \x90Pa_OV[`\x04`S\x81\x11\x15a^\x89Wa^\x88a\x82\xA6V[[\x87`S\x81\x11\x15a^\x9CWa^\x9Ba\x82\xA6V[[\x03a^\xACWb\x01\xCC\xF0\x90Pa_NV[`\x05`S\x81\x11\x15a^\xC0Wa^\xBFa\x82\xA6V[[\x87`S\x81\x11\x15a^\xD3Wa^\xD2a\x82\xA6V[[\x03a^\xE3Wb\x02Q\xC0\x90Pa_MV[`\x06`S\x81\x11\x15a^\xF7Wa^\xF6a\x82\xA6V[[\x87`S\x81\x11\x15a_\nWa_\ta\x82\xA6V[[\x03a_\x1AWb\x034P\x90Pa_LV[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[a_]\x81\x83\x87\x87\x87am\xF9V[[PPPPPPPV[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a_\xE0W`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\x01`\xF8\x1B\x86~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x03aa\xD0W_`S\x81\x11\x15a`!Wa` a\x82\xA6V[[\x87`S\x81\x11\x15a`4Wa`3a\x82\xA6V[[\x03a`CWaU\xF0\x90Paa\xBFV[`\x02`S\x81\x11\x15a`WWa`Va\x82\xA6V[[\x87`S\x81\x11\x15a`jWa`ia\x82\xA6V[[\x03a`yWay\x18\x90Paa\xBEV[`\x03`S\x81\x11\x15a`\x8DWa`\x8Ca\x82\xA6V[[\x87`S\x81\x11\x15a`\xA0Wa`\x9Fa\x82\xA6V[[\x03a`\xAFWay\x18\x90Paa\xBDV[`\x04`S\x81\x11\x15a`\xC3Wa`\xC2a\x82\xA6V[[\x87`S\x81\x11\x15a`\xD6Wa`\xD5a\x82\xA6V[[\x03a`\xE5Wa}\0\x90Paa\xBCV[`\x05`S\x81\x11\x15a`\xF9Wa`\xF8a\x82\xA6V[[\x87`S\x81\x11\x15aa\x0CWaa\x0Ba\x82\xA6V[[\x03aa\x1BWa\x84\xD0\x90Paa\xBBV[`\x06`S\x81\x11\x15aa/Waa.a\x82\xA6V[[\x87`S\x81\x11\x15aaBWaaAa\x82\xA6V[[\x03aaQWa\x90\x88\x90Paa\xBAV[`\x08`S\x81\x11\x15aaeWaada\x82\xA6V[[\x87`S\x81\x11\x15aaxWaawa\x82\xA6V[[\x03aa\x87Wa\x94p\x90Paa\xB9V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[[[aa\xCB\x81\x83\x87\x86amiV[ac\x8FV[_`S\x81\x11\x15aa\xE3Waa\xE2a\x82\xA6V[[\x87`S\x81\x11\x15aa\xF6Waa\xF5a\x82\xA6V[[\x03ab\x05Waa\xA8\x90Pac\x81V[`\x02`S\x81\x11\x15ab\x19Wab\x18a\x82\xA6V[[\x87`S\x81\x11\x15ab,Wab+a\x82\xA6V[[\x03ab;Way\x18\x90Pac\x80V[`\x03`S\x81\x11\x15abOWabNa\x82\xA6V[[\x87`S\x81\x11\x15abbWabaa\x82\xA6V[[\x03abqWay\x18\x90Pac\x7FV[`\x04`S\x81\x11\x15ab\x85Wab\x84a\x82\xA6V[[\x87`S\x81\x11\x15ab\x98Wab\x97a\x82\xA6V[[\x03ab\xA7Wa}\0\x90Pac~V[`\x05`S\x81\x11\x15ab\xBBWab\xBAa\x82\xA6V[[\x87`S\x81\x11\x15ab\xCEWab\xCDa\x82\xA6V[[\x03ab\xDDWa\x84\xD0\x90Pac}V[`\x06`S\x81\x11\x15ab\xF1Wab\xF0a\x82\xA6V[[\x87`S\x81\x11\x15ac\x04Wac\x03a\x82\xA6V[[\x03ac\x13Wa\x90\x88\x90Pac|V[`\x08`S\x81\x11\x15ac'Wac&a\x82\xA6V[[\x87`S\x81\x11\x15ac:Wac9a\x82\xA6V[[\x03acIWa\x94p\x90Pac{V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[[[ac\x8E\x81\x83\x87\x87\x87am\xF9V[[PPPPPPPV[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14ad\x11W`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x80`S\x81\x11\x15ad%Wad$a\x82\xA6V[[\x84`S\x81\x11\x15ad8Wad7a\x82\xA6V[[\x03adGWaJ8\x90Pae\xC3V[`\x02`S\x81\x11\x15ad[WadZa\x82\xA6V[[\x84`S\x81\x11\x15adnWadma\x82\xA6V[[\x03ad}WaY\xD8\x90Pae\xC2V[`\x03`S\x81\x11\x15ad\x91Wad\x90a\x82\xA6V[[\x84`S\x81\x11\x15ad\xA4Wad\xA3a\x82\xA6V[[\x03ad\xB3WaY\xD8\x90Pae\xC1V[`\x04`S\x81\x11\x15ad\xC7Wad\xC6a\x82\xA6V[[\x84`S\x81\x11\x15ad\xDAWad\xD9a\x82\xA6V[[\x03ad\xE9Wa]\xC0\x90Pae\xC0V[`\x05`S\x81\x11\x15ad\xFDWad\xFCa\x82\xA6V[[\x84`S\x81\x11\x15ae\x10Wae\x0Fa\x82\xA6V[[\x03ae\x1FWa]\xC0\x90Pae\xBFV[`\x06`S\x81\x11\x15ae3Wae2a\x82\xA6V[[\x84`S\x81\x11\x15aeFWaeEa\x82\xA6V[[\x03aeUWaa\xA8\x90Pae\xBEV[`\x08`S\x81\x11\x15aeiWaeha\x82\xA6V[[\x84`S\x81\x11\x15ae|Wae{a\x82\xA6V[[\x03ae\x8BWau0\x90Pae\xBDV[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[[[ae\xCD\x81\x83au=V[ae\xD7\x83\x82au\xC9V[PPPPV[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14afVW`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\x01`\xF8\x1B\x86~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x03ag\xDEW`\x02`S\x81\x11\x15af\x98Waf\x97a\x82\xA6V[[\x87`S\x81\x11\x15af\xABWaf\xAAa\x82\xA6V[[\x03af\xBBWb\x01H \x90Pag\xCDV[`\x03`S\x81\x11\x15af\xCFWaf\xCEa\x82\xA6V[[\x87`S\x81\x11\x15af\xE2Waf\xE1a\x82\xA6V[[\x03af\xF2Wb\x01kH\x90Pag\xCCV[`\x04`S\x81\x11\x15ag\x06Wag\x05a\x82\xA6V[[\x87`S\x81\x11\x15ag\x19Wag\x18a\x82\xA6V[[\x03ag)Wb\x01s\x18\x90Pag\xCBV[`\x05`S\x81\x11\x15ag=Wag<a\x82\xA6V[[\x87`S\x81\x11\x15agPWagOa\x82\xA6V[[\x03ag`Wb\x02\x07\x88\x90Pag\xCAV[`\x06`S\x81\x11\x15agtWagsa\x82\xA6V[[\x87`S\x81\x11\x15ag\x87Wag\x86a\x82\xA6V[[\x03ag\x97Wb\x02\x9F\xE0\x90Pag\xC9V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[ag\xD9\x81\x83\x87\x86amiV[ai5V[`\x02`S\x81\x11\x15ag\xF2Wag\xF1a\x82\xA6V[[\x87`S\x81\x11\x15ah\x05Wah\x04a\x82\xA6V[[\x03ah\x15Wb\x01cx\x90Pai'V[`\x03`S\x81\x11\x15ah)Wah(a\x82\xA6V[[\x87`S\x81\x11\x15ah<Wah;a\x82\xA6V[[\x03ahLWb\x01kH\x90Pai&V[`\x04`S\x81\x11\x15ah`Wah_a\x82\xA6V[[\x87`S\x81\x11\x15ahsWahra\x82\xA6V[[\x03ah\x83Wb\x01\xE8H\x90Pai%V[`\x05`S\x81\x11\x15ah\x97Wah\x96a\x82\xA6V[[\x87`S\x81\x11\x15ah\xAAWah\xA9a\x82\xA6V[[\x03ah\xBAWb\x02x\xD0\x90Pai$V[`\x06`S\x81\x11\x15ah\xCEWah\xCDa\x82\xA6V[[\x87`S\x81\x11\x15ah\xE1Wah\xE0a\x82\xA6V[[\x03ah\xF1Wb\x03\xF7\xA0\x90Pai#V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[ai4\x81\x83\x87\x87\x87am\xF9V[[PPPPPPPV[_\x80aiHap\xE4V[\x90P\x80`\x01\x01_\x84s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x91PP\x91\x90PV[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14aj\x17W`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\x01`\xF8\x1B\x86~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x03ak\xD1W`\x02`S\x81\x11\x15ajYWajXa\x82\xA6V[[\x87`S\x81\x11\x15ajlWajka\x82\xA6V[[\x03aj{Wa}\0\x90Pak\xC0V[`\x03`S\x81\x11\x15aj\x8FWaj\x8Ea\x82\xA6V[[\x87`S\x81\x11\x15aj\xA2Waj\xA1a\x82\xA6V[[\x03aj\xB1Wa}\0\x90Pak\xBFV[`\x04`S\x81\x11\x15aj\xC5Waj\xC4a\x82\xA6V[[\x87`S\x81\x11\x15aj\xD8Waj\xD7a\x82\xA6V[[\x03aj\xE7Wa}\0\x90Pak\xBEV[`\x05`S\x81\x11\x15aj\xFBWaj\xFAa\x82\xA6V[[\x87`S\x81\x11\x15ak\x0EWak\ra\x82\xA6V[[\x03ak\x1DWa\x84\xD0\x90Pak\xBDV[`\x06`S\x81\x11\x15ak1Wak0a\x82\xA6V[[\x87`S\x81\x11\x15akDWakCa\x82\xA6V[[\x03akSWa\x90\x88\x90Pak\xBCV[`\x08`S\x81\x11\x15akgWakfa\x82\xA6V[[\x87`S\x81\x11\x15akzWakya\x82\xA6V[[\x03ak\x89Wa\x98X\x90Pak\xBBV[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[[ak\xCC\x81\x83\x87\x86amiV[am`V[`\x02`S\x81\x11\x15ak\xE5Wak\xE4a\x82\xA6V[[\x87`S\x81\x11\x15ak\xF8Wak\xF7a\x82\xA6V[[\x03al\x08Wb\x01g`\x90PamRV[`\x03`S\x81\x11\x15al\x1CWal\x1Ba\x82\xA6V[[\x87`S\x81\x11\x15al/Wal.a\x82\xA6V[[\x03al?Wb\x01\xE8H\x90PamQV[`\x04`S\x81\x11\x15alSWalRa\x82\xA6V[[\x87`S\x81\x11\x15alfWalea\x82\xA6V[[\x03alvWb\x02x\xD0\x90PamPV[`\x05`S\x81\x11\x15al\x8AWal\x89a\x82\xA6V[[\x87`S\x81\x11\x15al\x9DWal\x9Ca\x82\xA6V[[\x03al\xADWb\x03,\x80\x90PamOV[`\x06`S\x81\x11\x15al\xC1Wal\xC0a\x82\xA6V[[\x87`S\x81\x11\x15al\xD4Wal\xD3a\x82\xA6V[[\x03al\xE4Wb\x04&\x80\x90PamNV[`\x08`S\x81\x11\x15al\xF8Wal\xF7a\x82\xA6V[[\x87`S\x81\x11\x15am\x0BWam\na\x82\xA6V[[\x03am\x1BWb\x05\xC4\x90\x90PamMV[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[[am_\x81\x83\x87\x87\x87am\xF9V[[PPPPPPPV[ams\x84\x84au=V[_am}\x83au\xD0V[\x85am\x88\x91\x90a\x84\xAFV[\x90Pam\x92ap\xE4V[_\x01`\x12\x90T\x90a\x01\0\n\x90\x04e\xFF\xFF\xFF\xFF\xFF\xFF\x16e\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81\x11\x15am\xE8W`@Q\x7F\xFC4Hp\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[am\xF2\x82\x82au\xC9V[PPPPPV[an\x03\x85\x85au=V[_an\x1Ean\x10\x85au\xD0V[an\x19\x85au\xD0V[au\xDAV[\x86an)\x91\x90a\x84\xAFV[\x90Pan3ap\xE4V[_\x01`\x12\x90T\x90a\x01\0\n\x90\x04e\xFF\xFF\xFF\xFF\xFF\xFF\x16e\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81\x11\x15an\x89W`@Q\x7F\xFC4Hp\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[an\x93\x82\x82au\xC9V[PPPPPPV[``_`\x01an\xA9\x84au\xF3V[\x01\x90P_\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15an\xC7Wan\xC6a\x80+V[[`@Q\x90\x80\x82R\x80`\x1F\x01`\x1F\x19\x16` \x01\x82\x01`@R\x80\x15an\xF9W\x81` \x01`\x01\x82\x02\x806\x837\x80\x82\x01\x91PP\x90P[P\x90P_\x82` \x01\x82\x01\x90P[`\x01\x15aoZW\x80\x80`\x01\x90\x03\x91PP\x7F0123456789abcdef\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\n\x86\x06\x1A\x81S`\n\x85\x81aoOWaoNa\x84\xE2V[[\x04\x94P_\x85\x03ao\x06W[\x81\x93PPPP\x91\x90PV[_aonao\x89V[_\x01_\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P\x90V[_\x7F\xF0\xC5~\x16\x84\r\xF0@\xF1P\x88\xDC/\x81\xFE9\x1C9#\xBE\xC7>#\xA9f.\xFC\x9C\"\x9Cj\0\x90P\x90V[\x80ao\xB9ap\xE4V[_\x01_a\x01\0\n\x81T\x81e\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83e\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP\x7F\xC1\xF1\xFC\xAA\x89\x8A\xAE\"c\xDD\xEDq.\x17\x98\x08?\xCA\x92r\xFF\x80>\xE4\x15\x0C\xE4\x8F\x86\x19\x89\x1A\x81`@Qap\x0B\x91\x90a~\xCAV[`@Q\x80\x91\x03\x90\xA1PV[\x80ap\x1Fap\xE4V[_\x01`\x12a\x01\0\n\x81T\x81e\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83e\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP\x7FU\x11\xB1\x85\x1F\xC4\n&)\xC8U\xBA\xB7\xAD\xCE2v\xC4p\xD8\x19\x0E\xB0\x141\xE4\x18\xDC*\xF1>\x8E\x81`@Qapr\x91\x90a~\xCAV[`@Q\x80\x91\x03\x90\xA1PV[\x80ap\x86ap\xE4V[_\x01`\x18a\x01\0\n\x81T\x81e\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83e\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP\x7Fd\xCB\x9Ez\xE6I|Y\x08\x0C\xDB\xC0HU.\x12=R\xAAB@\xE17u\x8A\x175\x82xia\xCA\x81`@Qap\xD9\x91\x90a~\xCAV[`@Q\x80\x91\x03\x90\xA1PV[_\x7F\xC1:\xF6\xC5\x14\xBF\xF8\x99\x7F0\xC9\0\x03\xBA\xA8+\xD0*\xAD\x97\x81y\xD1\xCEX\xD8\\C\x19\xADe\0\x90P\x90V[aq\x15\x86\x86au=V[_aqAaq\"\x86au\xD0V[aq<aq.\x87au\xD0V[aq7\x87au\xD0V[au\xDAV[au\xDAV[\x87aqL\x91\x90a\x84\xAFV[\x90PaqVap\xE4V[_\x01`\x12\x90T\x90a\x01\0\n\x90\x04e\xFF\xFF\xFF\xFF\xFF\xFF\x16e\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81\x11\x15aq\xACW`@Q\x7F\xFC4Hp\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[aq\xB6\x82\x82au\xC9V[PPPPPPPV[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x160s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14\x80arlWP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16arSawDV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14\x15[\x15ar\xA3W`@Q\x7F\xE0|\x8D\xBA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[V[sP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x8D\xA5\xCB[`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15as\x02W=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90as&\x91\x90a\x84NV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14as\x95W3`@Q\x7F!\xBF\xDA\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01as\x8C\x91\x90a~\xF2V[`@Q\x80\x91\x03\x90\xFD[PV[\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16cR\xD1\x90-`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x92PPP\x80\x15at\0WP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90as\xFD\x91\x90a\x85#V[`\x01[atAW\x81`@Q\x7FL\x9C\x8C\xE3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01at8\x91\x90a~\xF2V[`@Q\x80\x91\x03\x90\xFD[\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC_\x1B\x81\x14at\xA7W\x80`@Q\x7F\xAA\x1DI\xA4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01at\x9E\x91\x90a\x81\xB8V[`@Q\x80\x91\x03\x90\xFD[at\xB1\x83\x83aw\x97V[PPPV[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x160s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14au;W`@Q\x7F\xE0|\x8D\xBA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[V[auG\x82\x82ax\tV[_auPayzV[\x83au[\x91\x90a\x84\xAFV[\x90Paueap\xE4V[_\x01`\x18\x90T\x90a\x01\0\n\x90\x04e\xFF\xFF\xFF\xFF\xFF\xFF\x16e\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81\x11\x15au\xBBW`@Q\x7Fw\xE3\xC2\x93\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[au\xC4\x81ay\x82V[PPPV[\x80\x82]PPV[_\x81\\\x90P\x91\x90PV[_\x81\x83\x10\x15au\xE9W\x81au\xEBV[\x82[\x90P\x92\x91PPV[_\x80_\x90Pz\x18O\x03\xE9?\xF9\xF4\xDA\xA7\x97\xEDn8\xEDd\xBFj\x1F\x01\0\0\0\0\0\0\0\0\x83\x10avOWz\x18O\x03\xE9?\xF9\xF4\xDA\xA7\x97\xEDn8\xEDd\xBFj\x1F\x01\0\0\0\0\0\0\0\0\x83\x81avEWavDa\x84\xE2V[[\x04\x92P`@\x81\x01\x90P[m\x04\xEE-mA[\x85\xAC\xEF\x81\0\0\0\0\x83\x10av\x8CWm\x04\xEE-mA[\x85\xAC\xEF\x81\0\0\0\0\x83\x81av\x82Wav\x81a\x84\xE2V[[\x04\x92P` \x81\x01\x90P[f#\x86\xF2o\xC1\0\0\x83\x10av\xBBWf#\x86\xF2o\xC1\0\0\x83\x81av\xB1Wav\xB0a\x84\xE2V[[\x04\x92P`\x10\x81\x01\x90P[c\x05\xF5\xE1\0\x83\x10av\xE4Wc\x05\xF5\xE1\0\x83\x81av\xDAWav\xD9a\x84\xE2V[[\x04\x92P`\x08\x81\x01\x90P[a'\x10\x83\x10aw\tWa'\x10\x83\x81av\xFFWav\xFEa\x84\xE2V[[\x04\x92P`\x04\x81\x01\x90P[`d\x83\x10aw,W`d\x83\x81aw\"Waw!a\x84\xE2V[[\x04\x92P`\x02\x81\x01\x90P[`\n\x83\x10aw;W`\x01\x81\x01\x90P[\x80\x91PP\x91\x90PV[_awp\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC_\x1Bay\x88V[_\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P\x90V[aw\xA0\x82ay\x91V[\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xBC|\xD7Z \xEE'\xFD\x9A\xDE\xBA\xB3 A\xF7U!M\xBCk\xFF\xA9\x0C\xC0\"[9\xDA.\\-;`@Q`@Q\x80\x91\x03\x90\xA2_\x81Q\x11\x15aw\xFCWaw\xF6\x82\x82azZV[Pax\x05V[ax\x04az\xDAV[[PPV[_ax\x12ap\xE4V[\x90P\x80`\x01\x01_\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x15axkWPayvV[_C\x90P_\x82_\x01`\x06\x90T\x90a\x01\0\n\x90\x04e\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P\x81e\xFF\xFF\xFF\xFF\xFF\xFF\x16\x83_\x01`\x0C\x90T\x90a\x01\0\n\x90\x04e\xFF\xFF\xFF\xFF\xFF\xFF\x16e\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14ax\xB8W_\x90P[_\x85\x82e\xFF\xFF\xFF\xFF\xFF\xFF\x16ax\xCD\x91\x90a\x84\xAFV[\x90P\x83_\x01_\x90T\x90a\x01\0\n\x90\x04e\xFF\xFF\xFF\xFF\xFF\xFF\x16e\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81\x11\x15ay%W`@Q\x7F\xAD%\x11t\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x80\x84_\x01`\x06a\x01\0\n\x81T\x81e\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83e\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP\x82\x84_\x01`\x0Ca\x01\0\n\x81T\x81e\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83e\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UPPPPP[PPV[_\x80\\\x90P\x90V[\x80_]PV[_\x81\x90P\x91\x90PV[_\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16;\x03ay\xECW\x80`@Q\x7FL\x9C\x8C\xE3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01ay\xE3\x91\x90a~\xF2V[`@Q\x80\x91\x03\x90\xFD[\x80az\x18\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC_\x1Bay\x88V[_\x01_a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UPPV[``_\x80\x84s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x84`@Qaz\x83\x91\x90a\x85\x92V[_`@Q\x80\x83\x03\x81\x85Z\xF4\x91PP=\x80_\x81\x14az\xBBW`@Q\x91P`\x1F\x19`?=\x01\x16\x82\x01`@R=\x82R=_` \x84\x01>az\xC0V[``\x91P[P\x91P\x91Paz\xD0\x85\x83\x83a{\x16V[\x92PPP\x92\x91PPV[_4\x11\x15a{\x14W`@Q\x7F\xB3\x98\x97\x9F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[V[``\x82a{+Wa{&\x82a{\xA3V[a{\x9BV[_\x82Q\x14\x80\x15a{QWP_\x84s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16;\x14[\x15a{\x93W\x83`@Q\x7F\x99\x96\xB3\x15\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a{\x8A\x91\x90a~\xF2V[`@Q\x80\x91\x03\x90\xFD[\x81\x90Pa{\x9CV[[\x93\x92PPPV[_\x81Q\x11\x15a{\xB5W\x80Q\x80\x82` \x01\xFD[`@Q\x7F\xD6\xBD\xA2u\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`@Q\x90P\x90V[_\x80\xFD[_\x80\xFD[`T\x81\x10a|\x04W_\x80\xFD[PV[_\x815\x90Pa|\x15\x81a{\xF8V[\x92\x91PPV[_\x7F\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\x16\x90P\x91\x90PV[a|O\x81a|\x1BV[\x81\x14a|YW_\x80\xFD[PV[_\x815\x90Pa|j\x81a|FV[\x92\x91PPV[_\x81\x90P\x91\x90PV[a|\x82\x81a|pV[\x81\x14a|\x8CW_\x80\xFD[PV[_\x815\x90Pa|\x9D\x81a|yV[\x92\x91PPV[_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[_a|\xCC\x82a|\xA3V[\x90P\x91\x90PV[a|\xDC\x81a|\xC2V[\x81\x14a|\xE6W_\x80\xFD[PV[_\x815\x90Pa|\xF7\x81a|\xD3V[\x92\x91PPV[_\x80_\x80_\x80`\xC0\x87\x89\x03\x12\x15a}\x17Wa}\x16a{\xF0V[[_a}$\x89\x82\x8A\x01a|\x07V[\x96PP` a}5\x89\x82\x8A\x01a|\\V[\x95PP`@a}F\x89\x82\x8A\x01a|\x8FV[\x94PP``a}W\x89\x82\x8A\x01a|\x8FV[\x93PP`\x80a}h\x89\x82\x8A\x01a|\x8FV[\x92PP`\xA0a}y\x89\x82\x8A\x01a|\xE9V[\x91PP\x92\x95P\x92\x95P\x92\x95V[_\x81Q\x90P\x91\x90PV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[_[\x83\x81\x10\x15a}\xBDW\x80\x82\x01Q\x81\x84\x01R` \x81\x01\x90Pa}\xA2V[_\x84\x84\x01RPPPPV[_`\x1F\x19`\x1F\x83\x01\x16\x90P\x91\x90PV[_a}\xE2\x82a}\x86V[a}\xEC\x81\x85a}\x90V[\x93Pa}\xFC\x81\x85` \x86\x01a}\xA0V[a~\x05\x81a}\xC8V[\x84\x01\x91PP\x92\x91PPV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra~(\x81\x84a}\xD8V[\x90P\x92\x91PPV[_e\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[a~J\x81a~0V[\x81\x14a~TW_\x80\xFD[PV[_\x815\x90Pa~e\x81a~AV[\x92\x91PPV[_\x80_``\x84\x86\x03\x12\x15a~\x82Wa~\x81a{\xF0V[[_a~\x8F\x86\x82\x87\x01a~WV[\x93PP` a~\xA0\x86\x82\x87\x01a~WV[\x92PP`@a~\xB1\x86\x82\x87\x01a~WV[\x91PP\x92P\x92P\x92V[a~\xC4\x81a~0V[\x82RPPV[_` \x82\x01\x90Pa~\xDD_\x83\x01\x84a~\xBBV[\x92\x91PPV[a~\xEC\x81a|\xC2V[\x82RPPV[_` \x82\x01\x90Pa\x7F\x05_\x83\x01\x84a~\xE3V[\x92\x91PPV[_` \x82\x84\x03\x12\x15a\x7F Wa\x7F\x1Fa{\xF0V[[_a\x7F-\x84\x82\x85\x01a|\xE9V[\x91PP\x92\x91PPV[_\x80_\x80`\x80\x85\x87\x03\x12\x15a\x7FNWa\x7FMa{\xF0V[[_a\x7F[\x87\x82\x88\x01a|\x07V[\x94PP` a\x7Fl\x87\x82\x88\x01a|\x8FV[\x93PP`@a\x7F}\x87\x82\x88\x01a|\x8FV[\x92PP``a\x7F\x8E\x87\x82\x88\x01a|\xE9V[\x91PP\x92\x95\x91\x94P\x92PV[_\x80_\x80_\x80`\xC0\x87\x89\x03\x12\x15a\x7F\xB4Wa\x7F\xB3a{\xF0V[[_a\x7F\xC1\x89\x82\x8A\x01a|\x07V[\x96PP` a\x7F\xD2\x89\x82\x8A\x01a|\x8FV[\x95PP`@a\x7F\xE3\x89\x82\x8A\x01a|\x8FV[\x94PP``a\x7F\xF4\x89\x82\x8A\x01a|\x8FV[\x93PP`\x80a\x80\x05\x89\x82\x8A\x01a|\x8FV[\x92PP`\xA0a\x80\x16\x89\x82\x8A\x01a|\xE9V[\x91PP\x92\x95P\x92\x95P\x92\x95V[_\x80\xFD[_\x80\xFD[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`A`\x04R`$_\xFD[a\x80a\x82a}\xC8V[\x81\x01\x81\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17\x15a\x80\x80Wa\x80\x7Fa\x80+V[[\x80`@RPPPV[_a\x80\x92a{\xE7V[\x90Pa\x80\x9E\x82\x82a\x80XV[\x91\x90PV[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15a\x80\xBDWa\x80\xBCa\x80+V[[a\x80\xC6\x82a}\xC8V[\x90P` \x81\x01\x90P\x91\x90PV[\x82\x81\x837_\x83\x83\x01RPPPV[_a\x80\xF3a\x80\xEE\x84a\x80\xA3V[a\x80\x89V[\x90P\x82\x81R` \x81\x01\x84\x84\x84\x01\x11\x15a\x81\x0FWa\x81\x0Ea\x80'V[[a\x81\x1A\x84\x82\x85a\x80\xD3V[P\x93\x92PPPV[_\x82`\x1F\x83\x01\x12a\x816Wa\x815a\x80#V[[\x815a\x81F\x84\x82` \x86\x01a\x80\xE1V[\x91PP\x92\x91PPV[_\x80`@\x83\x85\x03\x12\x15a\x81eWa\x81da{\xF0V[[_a\x81r\x85\x82\x86\x01a|\xE9V[\x92PP` \x83\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x81\x93Wa\x81\x92a{\xF4V[[a\x81\x9F\x85\x82\x86\x01a\x81\"V[\x91PP\x92P\x92\x90PV[a\x81\xB2\x81a|pV[\x82RPPV[_` \x82\x01\x90Pa\x81\xCB_\x83\x01\x84a\x81\xA9V[\x92\x91PPV[_` \x82\x84\x03\x12\x15a\x81\xE6Wa\x81\xE5a{\xF0V[[_a\x81\xF3\x84\x82\x85\x01a~WV[\x91PP\x92\x91PPV[_\x80_``\x84\x86\x03\x12\x15a\x82\x13Wa\x82\x12a{\xF0V[[_a\x82 \x86\x82\x87\x01a|\x07V[\x93PP` a\x821\x86\x82\x87\x01a|\x8FV[\x92PP`@a\x82B\x86\x82\x87\x01a|\xE9V[\x91PP\x92P\x92P\x92V[_`@\x82\x01\x90Pa\x82__\x83\x01\x85a~\xBBV[a\x82l` \x83\x01\x84a~\xBBV[\x93\x92PPPV[_\x81\x15\x15\x90P\x91\x90PV[a\x82\x87\x81a\x82sV[\x82RPPV[_` \x82\x01\x90Pa\x82\xA0_\x83\x01\x84a\x82~V[\x92\x91PPV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`!`\x04R`$_\xFD[_\x81\x90P\x92\x91PPV[_a\x82\xE7\x82a}\x86V[a\x82\xF1\x81\x85a\x82\xD3V[\x93Pa\x83\x01\x81\x85` \x86\x01a}\xA0V[\x80\x84\x01\x91PP\x92\x91PPV[\x7F v\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_a\x83A`\x02\x83a\x82\xD3V[\x91Pa\x83L\x82a\x83\rV[`\x02\x82\x01\x90P\x91\x90PV[\x7F.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_a\x83\x8B`\x01\x83a\x82\xD3V[\x91Pa\x83\x96\x82a\x83WV[`\x01\x82\x01\x90P\x91\x90PV[_a\x83\xAC\x82\x87a\x82\xDDV[\x91Pa\x83\xB7\x82a\x835V[\x91Pa\x83\xC3\x82\x86a\x82\xDDV[\x91Pa\x83\xCE\x82a\x83\x7FV[\x91Pa\x83\xDA\x82\x85a\x82\xDDV[\x91Pa\x83\xE5\x82a\x83\x7FV[\x91Pa\x83\xF1\x82\x84a\x82\xDDV[\x91P\x81\x90P\x95\x94PPPPPV[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[a\x84\x1B\x81a\x83\xFFV[\x82RPPV[_` \x82\x01\x90Pa\x844_\x83\x01\x84a\x84\x12V[\x92\x91PPV[_\x81Q\x90Pa\x84H\x81a|\xD3V[\x92\x91PPV[_` \x82\x84\x03\x12\x15a\x84cWa\x84ba{\xF0V[[_a\x84p\x84\x82\x85\x01a\x84:V[\x91PP\x92\x91PPV[_\x81\x90P\x91\x90PV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x11`\x04R`$_\xFD[_a\x84\xB9\x82a\x84yV[\x91Pa\x84\xC4\x83a\x84yV[\x92P\x82\x82\x01\x90P\x80\x82\x11\x15a\x84\xDCWa\x84\xDBa\x84\x82V[[\x92\x91PPV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x12`\x04R`$_\xFD[_\x81Q\x90Pa\x85\x1D\x81a|yV[\x92\x91PPV[_` \x82\x84\x03\x12\x15a\x858Wa\x857a{\xF0V[[_a\x85E\x84\x82\x85\x01a\x85\x0FV[\x91PP\x92\x91PPV[_\x81Q\x90P\x91\x90PV[_\x81\x90P\x92\x91PPV[_a\x85l\x82a\x85NV[a\x85v\x81\x85a\x85XV[\x93Pa\x85\x86\x81\x85` \x86\x01a}\xA0V[\x80\x84\x01\x91PP\x92\x91PPV[_a\x85\x9D\x82\x84a\x85bV[\x91P\x81\x90P\x92\x91PPV",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x608060405260043610610266575f3560e01c80636fd65e4d11610143578063b59547b8116100b5578063c277a93611610079578063c277a9361461085f578063c8de435214610887578063d5b8b8f3146108af578063d633c96b146108d7578063ede8776e146108ff578063f7d198f81461093b57610266565b8063b59547b814610793578063b78bef59146107bd578063c0c5df7c146107e5578063c1390c341461080d578063c13c19711461083557610266565b80639b3f781a116101075780639b3f781a1461069e5780639f4b9937146106c65780639f9259bb146106f1578063a036ea2e14610719578063ab39475514610741578063ad3cb1cc1461076957610266565b80636fd65e4d146105d65780637748671a146105fe578063818f4d69146106265780638629f5451461064e578063968302d71461067657610266565b80633bb7d5a3116101dc5780635c414b57116101a05780635c414b57146104e65780635f76eb301461050e57806360e121891461053657806369931afb1461055e5780636bad18b6146105865780636cf0bd25146105ae57610266565b80633bb7d5a314610428578063458fb27714610450578063497c22c5146104785780634f1ef286146104a057806352d1902d146104bc57610266565b8063268d6d311161022e578063268d6d311461033657806328677ca7146103605780632dcbc5d1146103885780632e3c3906146103b05780633311b1bc146103d857806338bd17e51461040057610266565b806304553fb61461026a57806307ccdf61146102925780630d8e6e2c146102ba578063196a456d146102e45780631e24aa491461030c575b5f80fd5b348015610275575f80fd5b50610290600480360381019061028b9190617cfd565b610963565b005b34801561029d575f80fd5b506102b860048036038101906102b39190617cfd565b610cc4565b005b3480156102c5575f80fd5b506102ce61108f565b6040516102db9190617e10565b60405180910390f35b3480156102ef575f80fd5b5061030a60048036038101906103059190617e6b565b61110a565b005b348015610317575f80fd5b50610320611298565b60405161032d9190617eca565b60405180910390f35b348015610341575f80fd5b5061034a6112bb565b6040516103579190617ef2565b60405180910390f35b34801561036b575f80fd5b5061038660048036038101906103819190617f0b565b6112d6565b005b348015610393575f80fd5b506103ae60048036038101906103a99190617f36565b6114fb565b005b3480156103bb575f80fd5b506103d660048036038101906103d19190617f9a565b611732565b005b3480156103e3575f80fd5b506103fe60048036038101906103f99190617cfd565b6119ad565b005b34801561040b575f80fd5b5061042660048036038101906104219190617cfd565b611be4565b005b348015610433575f80fd5b5061044e60048036038101906104499190617cfd565b611f42565b005b34801561045b575f80fd5b5061047660048036038101906104719190617cfd565b6122a0565b005b348015610483575f80fd5b5061049e60048036038101906104999190617f36565b6125fe565b005b6104ba60048036038101906104b5919061814f565b61280c565b005b3480156104c7575f80fd5b506104d061282b565b6040516104dd91906181b8565b60405180910390f35b3480156104f1575f80fd5b5061050c600480360381019061050791906181d1565b61285c565b005b348015610519575f80fd5b50610534600480360381019061052f9190617cfd565b612958565b005b348015610541575f80fd5b5061055c60048036038101906105579190617cfd565b612d23565b005b348015610569575f80fd5b50610584600480360381019061057f9190617f36565b6131cd565b005b348015610591575f80fd5b506105ac60048036038101906105a79190617cfd565b613404565b005b3480156105b9575f80fd5b506105d460048036038101906105cf91906181fc565b6138ae565b005b3480156105e1575f80fd5b506105fc60048036038101906105f79190617f0b565b613abd565b005b348015610609575f80fd5b50610624600480360381019061061f9190617e6b565b613ce4565b005b348015610631575f80fd5b5061064c60048036038101906106479190617cfd565b613e27565b005b348015610659575f80fd5b50610674600480360381019061066f9190617cfd565b614188565b005b348015610681575f80fd5b5061069c60048036038101906106979190617cfd565b614553565b005b3480156106a9575f80fd5b506106c460048036038101906106bf9190617cfd565b6148b4565b005b3480156106d1575f80fd5b506106da614aeb565b6040516106e892919061824c565b60405180910390f35b3480156106fc575f80fd5b5061071760048036038101906107129190617cfd565b614b57565b005b348015610724575f80fd5b5061073f600480360381019061073a91906181d1565b614f88565b005b34801561074c575f80fd5b50610767600480360381019061076291906181d1565b615084565b005b348015610774575f80fd5b5061077d615180565b60405161078a9190617e10565b60405180910390f35b34801561079e575f80fd5b506107a76151b9565b6040516107b49190617eca565b60405180910390f35b3480156107c8575f80fd5b506107e360048036038101906107de91906181fc565b6151e0565b005b3480156107f0575f80fd5b5061080b60048036038101906108069190617cfd565b615454565b005b348015610818575f80fd5b50610833600480360381019061082e9190617cfd565b615885565b005b348015610840575f80fd5b50610849615be6565b6040516108569190617eca565b60405180910390f35b34801561086a575f80fd5b5061088560048036038101906108809190617cfd565b615c09565b005b348015610892575f80fd5b506108ad60048036038101906108a89190617cfd565b615f67565b005b3480156108ba575f80fd5b506108d560048036038101906108d091906181fc565b616398565b005b3480156108e2575f80fd5b506108fd60048036038101906108f89190617cfd565b6165dd565b005b34801561090a575f80fd5b5061092560048036038101906109209190617f0b565b61693e565b604051610932919061828d565b60405180910390f35b348015610946575f80fd5b50610961600480360381019061095c9190617cfd565b61699e565b005b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16146109dc576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f600160f81b867effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191603610b645760026053811115610a1e57610a1d6182a6565b5b876053811115610a3157610a306182a6565b5b03610a4157620148209050610b53565b60036053811115610a5557610a546182a6565b5b876053811115610a6857610a676182a6565b5b03610a7857620157c09050610b52565b60046053811115610a8c57610a8b6182a6565b5b876053811115610a9f57610a9e6182a6565b5b03610aaf576201c9089050610b51565b60056053811115610ac357610ac26182a6565b5b876053811115610ad657610ad56182a6565b5b03610ae657620249f09050610b50565b60066053811115610afa57610af96182a6565b5b876053811115610b0d57610b0c6182a6565b5b03610b1d576202d6909050610b4f565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b610b5f81838786616d69565b610cbb565b60026053811115610b7857610b776182a6565b5b876053811115610b8b57610b8a6182a6565b5b03610b9b576201d0d89050610cad565b60036053811115610baf57610bae6182a6565b5b876053811115610bc257610bc16182a6565b5b03610bd25762023a509050610cac565b60046053811115610be657610be56182a6565b5b876053811115610bf957610bf86182a6565b5b03610c09576202c6f09050610cab565b60056053811115610c1d57610c1c6182a6565b5b876053811115610c3057610c2f6182a6565b5b03610c4057620357789050610caa565b60066053811115610c5457610c536182a6565b5b876053811115610c6757610c666182a6565b5b03610c7757620468e89050610ca9565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b610cba8183878787616df9565b5b50505050505050565b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614610d3d576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f600160f81b867effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191603610ef75760026053811115610d7f57610d7e6182a6565b5b876053811115610d9257610d916182a6565b5b03610da157617d009050610ee6565b60036053811115610db557610db46182a6565b5b876053811115610dc857610dc76182a6565b5b03610dd757617d009050610ee5565b60046053811115610deb57610dea6182a6565b5b876053811115610dfe57610dfd6182a6565b5b03610e0d57617d009050610ee4565b60056053811115610e2157610e206182a6565b5b876053811115610e3457610e336182a6565b5b03610e43576184d09050610ee3565b60066053811115610e5757610e566182a6565b5b876053811115610e6a57610e696182a6565b5b03610e79576190889050610ee2565b60086053811115610e8d57610e8c6182a6565b5b876053811115610ea057610e9f6182a6565b5b03610eaf576194709050610ee1565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b5b610ef281838786616d69565b611086565b60026053811115610f0b57610f0a6182a6565b5b876053811115610f1e57610f1d6182a6565b5b03610f2e57620163789050611078565b60036053811115610f4257610f416182a6565b5b876053811115610f5557610f546182a6565b5b03610f65576201e0789050611077565b60046053811115610f7957610f786182a6565b5b876053811115610f8c57610f8b6182a6565b5b03610f9c5762027cb89050611076565b60056053811115610fb057610faf6182a6565b5b876053811115610fc357610fc26182a6565b5b03610fd357620330689050611075565b60066053811115610fe757610fe66182a6565b5b876053811115610ffa57610ff96182a6565b5b0361100a57620426809050611074565b6008605381111561101e5761101d6182a6565b5b876053811115611031576110306182a6565b5b03611041576205a1689050611073565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b5b6110858183878787616df9565b5b50505050505050565b60606040518060400160405280600881526020017f4843554c696d69740000000000000000000000000000000000000000000000008152506110d05f616e9b565b6110da6002616e9b565b6110e35f616e9b565b6040516020016110f694939291906183a1565b604051602081830303815290604052905090565b6001611114616f65565b67ffffffffffffffff1614611155576040517f6f4f731f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60035f611160616f89565b9050805f0160089054906101000a900460ff16806111a857508167ffffffffffffffff16815f015f9054906101000a900467ffffffffffffffff1667ffffffffffffffff1610155b156111df576040517ff92ee8a900000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b81815f015f6101000a81548167ffffffffffffffff021916908367ffffffffffffffff1602179055506001815f0160086101000a81548160ff02191690831515021790555061122d85616fb0565b61123684617016565b61123f8361707d565b5f815f0160086101000a81548160ff0219169083151502179055507fc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d2826040516112899190618421565b60405180910390a15050505050565b5f6112a16170e4565b5f0160129054906101000a900465ffffffffffff16905090565b5f73e3a9105a3a932253a70f126eb1e3b589c643dd24905090565b7350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff16638da5cb5b6040518163ffffffff1660e01b8152600401602060405180830381865afa158015611333573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190611357919061844e565b73ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16146113c657336040517f21bfda100000000000000000000000000000000000000000000000000000000081526004016113bd9190617ef2565b60405180910390fd5b5f6113cf6170e4565b9050806001015f8373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f9054906101000a900460ff1661145e57816040517fe3cc34180000000000000000000000000000000000000000000000000000000081526004016114559190617ef2565b60405180910390fd5b5f816001015f8473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f6101000a81548160ff0219169083151502179055508173ffffffffffffffffffffffffffffffffffffffff167f92fc97af15002646cea63c7633bb375b82db7cde7b480c75fe6341dacc292c8160405160405180910390a25050565b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614611574576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f806053811115611588576115876182a6565b5b85605381111561159b5761159a6182a6565b5b036115a9576002905061171f565b600260538111156115bd576115bc6182a6565b5b8560538111156115d0576115cf6182a6565b5b036115de576009905061171e565b600360538111156115f2576115f16182a6565b5b856053811115611605576116046182a6565b5b03611613576010905061171d565b60046053811115611627576116266182a6565b5b85605381111561163a576116396182a6565b5b03611648576020905061171c565b6005605381111561165c5761165b6182a6565b5b85605381111561166f5761166e6182a6565b5b0361167d57603f905061171b565b60066053811115611691576116906182a6565b5b8560538111156116a4576116a36182a6565b5b036116b2576082905061171a565b600860538111156116c6576116c56182a6565b5b8560538111156116d9576116d86182a6565b5b036116e75760829050611719565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b5b5b61172b81838686616d69565b5050505050565b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16146117ab576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f8060538111156117bf576117be6182a6565b5b8760538111156117d2576117d16182a6565b5b036117e15761d6d89050611996565b600260538111156117f5576117f46182a6565b5b876053811115611808576118076182a6565b5b036118175761d6d89050611995565b6003605381111561182b5761182a6182a6565b5b87605381111561183e5761183d6182a6565b5b0361184d5761d6d89050611994565b60046053811115611861576118606182a6565b5b876053811115611874576118736182a6565b5b036118835761d6d89050611993565b60056053811115611897576118966182a6565b5b8760538111156118aa576118a96182a6565b5b036118b95761d6d89050611992565b600660538111156118cd576118cc6182a6565b5b8760538111156118e0576118df6182a6565b5b036118ef5761dea89050611991565b60076053811115611903576119026182a6565b5b876053811115611916576119156182a6565b5b0361192657620144389050611990565b6008605381111561193a576119396182a6565b5b87605381111561194d5761194c6182a6565b5b0361195d576201a5e0905061198f565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b5b5b5b6119a481838888888861710b565b50505050505050565b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614611a26576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f600160f81b867effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191614611a86576040517f6aa9eb0500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60026053811115611a9a57611a996182a6565b5b876053811115611aad57611aac6182a6565b5b03611abd576206b6c09050611bcf565b60036053811115611ad157611ad06182a6565b5b876053811115611ae457611ae36182a6565b5b03611af4576208d9a09050611bce565b60046053811115611b0857611b076182a6565b5b876053811115611b1b57611b1a6182a6565b5b03611b2b57620c15c09050611bcd565b60056053811115611b3f57611b3e6182a6565b5b876053811115611b5257611b516182a6565b5b03611b6257621197e89050611bcc565b60066053811115611b7657611b756182a6565b5b876053811115611b8957611b886182a6565b5b03611b9957621da5d89050611bcb565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b611bdb81838786616d69565b50505050505050565b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614611c5d576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f600160f81b867effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191603611de35760026053811115611c9f57611c9e6182a6565b5b876053811115611cb257611cb16182a6565b5b03611cc15761e2909050611dd2565b60036053811115611cd557611cd46182a6565b5b876053811115611ce857611ce76182a6565b5b03611cf75761e2909050611dd1565b60046053811115611d0b57611d0a6182a6565b5b876053811115611d1e57611d1d6182a6565b5b03611d2e57620148209050611dd0565b60056053811115611d4257611d416182a6565b5b876053811115611d5557611d546182a6565b5b03611d65576201d0d89050611dcf565b60066053811115611d7957611d786182a6565b5b876053811115611d8c57611d8b6182a6565b5b03611d9c57620249f09050611dce565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b611dde81838786616d69565b611f39565b60026053811115611df757611df66182a6565b5b876053811115611e0a57611e096182a6565b5b03611e195761e2909050611f2b565b60036053811115611e2d57611e2c6182a6565b5b876053811115611e4057611e3f6182a6565b5b03611e5057620144389050611f2a565b60046053811115611e6457611e636182a6565b5b876053811115611e7757611e766182a6565b5b03611e87576201c9089050611f29565b60056053811115611e9b57611e9a6182a6565b5b876053811115611eae57611ead6182a6565b5b03611ebe57620246089050611f28565b60066053811115611ed257611ed16182a6565b5b876053811115611ee557611ee46182a6565b5b03611ef557620353909050611f27565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b611f388183878787616df9565b5b50505050505050565b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614611fbb576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f600160f81b867effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916036121415760026053811115611ffd57611ffc6182a6565b5b8760538111156120105761200f6182a6565b5b0361201f5761cb209050612130565b60036053811115612033576120326182a6565b5b876053811115612046576120456182a6565b5b036120555761e290905061212f565b60046053811115612069576120686182a6565b5b87605381111561207c5761207b6182a6565b5b0361208c5762014438905061212e565b600560538111156120a05761209f6182a6565b5b8760538111156120b3576120b26182a6565b5b036120c3576201ccf0905061212d565b600660538111156120d7576120d66182a6565b5b8760538111156120ea576120e96182a6565b5b036120fa5762024608905061212c565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b61213c81838786616d69565b612297565b60026053811115612155576121546182a6565b5b876053811115612168576121676182a6565b5b036121775761e6789050612289565b6003605381111561218b5761218a6182a6565b5b87605381111561219e5761219d6182a6565b5b036121ae57620148209050612288565b600460538111156121c2576121c16182a6565b5b8760538111156121d5576121d46182a6565b5b036121e5576201c9089050612287565b600560538111156121f9576121f86182a6565b5b87605381111561220c5761220b6182a6565b5b0361221c5762023a509050612286565b600660538111156122305761222f6182a6565b5b876053811115612243576122426182a6565b5b0361225357620347d89050612285565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b6122968183878787616df9565b5b50505050505050565b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614612319576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f600160f81b867effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff19160361249f576002605381111561235b5761235a6182a6565b5b87605381111561236e5761236d6182a6565b5b0361237d5761cb20905061248e565b60036053811115612391576123906182a6565b5b8760538111156123a4576123a36182a6565b5b036123b35761d6d8905061248d565b600460538111156123c7576123c66182a6565b5b8760538111156123da576123d96182a6565b5b036123ea5762014820905061248c565b600560538111156123fe576123fd6182a6565b5b876053811115612411576124106182a6565b5b03612421576201c908905061248b565b60066053811115612435576124346182a6565b5b876053811115612448576124476182a6565b5b0361245857620249f0905061248a565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b61249a81838786616d69565b6125f5565b600260538111156124b3576124b26182a6565b5b8760538111156124c6576124c56182a6565b5b036124d55761e67890506125e7565b600360538111156124e9576124e86182a6565b5b8760538111156124fc576124fb6182a6565b5b0361250c576201482090506125e6565b600460538111156125205761251f6182a6565b5b876053811115612533576125326182a6565b5b03612543576201ccf090506125e5565b60056053811115612557576125566182a6565b5b87605381111561256a576125696182a6565b5b0361257a57620251c090506125e4565b6006605381111561258e5761258d6182a6565b5b8760538111156125a1576125a06182a6565b5b036125b1576203539090506125e3565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b6125f48183878787616df9565b5b50505050505050565b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614612677576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f6002605381111561268c5761268b6182a6565b5b85605381111561269f5761269e6182a6565b5b036126af576201349890506127f9565b600360538111156126c3576126c26182a6565b5b8560538111156126d6576126d56182a6565b5b036126e65762016b4890506127f8565b600460538111156126fa576126f96182a6565b5b85605381111561270d5761270c6182a6565b5b0361271d576201731890506127f7565b60056053811115612731576127306182a6565b5b856053811115612744576127436182a6565b5b03612754576201ffb890506127f6565b60066053811115612768576127676182a6565b5b85605381111561277b5761277a6182a6565b5b0361278b576202904090506127f5565b6008605381111561279f5761279e6182a6565b5b8560538111156127b2576127b16182a6565b5b036127c25762041ac890506127f4565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b5b61280581838686616d69565b5050505050565b6128146171bf565b61281d826172a5565b6128278282617398565b5050565b5f6128346174b6565b7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5f1b905090565b7350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff16638da5cb5b6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156128b9573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906128dd919061844e565b73ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161461294c57336040517f21bfda100000000000000000000000000000000000000000000000000000000081526004016129439190617ef2565b60405180910390fd5b61295581617016565b50565b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16146129d1576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f600160f81b867effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191603612b8b5760026053811115612a1357612a126182a6565b5b876053811115612a2657612a256182a6565b5b03612a35576179189050612b7a565b60036053811115612a4957612a486182a6565b5b876053811115612a5c57612a5b6182a6565b5b03612a6b576179189050612b79565b60046053811115612a7f57612a7e6182a6565b5b876053811115612a9257612a916182a6565b5b03612aa157617d009050612b78565b60056053811115612ab557612ab46182a6565b5b876053811115612ac857612ac76182a6565b5b03612ad7576184d09050612b77565b60066053811115612aeb57612aea6182a6565b5b876053811115612afe57612afd6182a6565b5b03612b0d576190889050612b76565b60086053811115612b2157612b206182a6565b5b876053811115612b3457612b336182a6565b5b03612b43576194709050612b75565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b5b612b8681838786616d69565b612d1a565b60026053811115612b9f57612b9e6182a6565b5b876053811115612bb257612bb16182a6565b5b03612bc257620163789050612d0c565b60036053811115612bd657612bd56182a6565b5b876053811115612be957612be86182a6565b5b03612bf9576201e8489050612d0b565b60046053811115612c0d57612c0c6182a6565b5b876053811115612c2057612c1f6182a6565b5b03612c305762027cb89050612d0a565b60056053811115612c4457612c436182a6565b5b876053811115612c5757612c566182a6565b5b03612c6757620330689050612d09565b60066053811115612c7b57612c7a6182a6565b5b876053811115612c8e57612c8d6182a6565b5b03612c9e5762043df09050612d08565b60086053811115612cb257612cb16182a6565b5b876053811115612cc557612cc46182a6565b5b03612cd5576205c4909050612d07565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b5b612d198183878787616df9565b5b50505050505050565b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614612d9c576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f600160f81b867effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191603612fc8575f6053811115612ddd57612ddc6182a6565b5b876053811115612df057612def6182a6565b5b03612dff576161a89050612fb7565b60026053811115612e1357612e126182a6565b5b876053811115612e2657612e256182a6565b5b03612e355761d6d89050612fb6565b60036053811115612e4957612e486182a6565b5b876053811115612e5c57612e5b6182a6565b5b03612e6b5761d6d89050612fb5565b60046053811115612e7f57612e7e6182a6565b5b876053811115612e9257612e916182a6565b5b03612ea257620140509050612fb4565b60056053811115612eb657612eb56182a6565b5b876053811115612ec957612ec86182a6565b5b03612ed957620144389050612fb3565b60066053811115612eed57612eec6182a6565b5b876053811115612f0057612eff6182a6565b5b03612f10576201c9089050612fb2565b60076053811115612f2457612f236182a6565b5b876053811115612f3757612f366182a6565b5b03612f47576201c9089050612fb1565b60086053811115612f5b57612f5a6182a6565b5b876053811115612f6e57612f6d6182a6565b5b03612f7e576201ccf09050612fb0565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b5b5b5b612fc381838786616d69565b6131c4565b5f6053811115612fdb57612fda6182a6565b5b876053811115612fee57612fed6182a6565b5b03612ffd5761659090506131b6565b60026053811115613011576130106182a6565b5b876053811115613024576130236182a6565b5b036130335761d6d890506131b5565b60036053811115613047576130466182a6565b5b87605381111561305a576130596182a6565b5b0361306a576201443890506131b4565b6004605381111561307e5761307d6182a6565b5b876053811115613091576130906182a6565b5b036130a15762014ff090506131b3565b600560538111156130b5576130b46182a6565b5b8760538111156130c8576130c76182a6565b5b036130d8576201d4c090506131b2565b600660538111156130ec576130eb6182a6565b5b8760538111156130ff576130fe6182a6565b5b0361310f576201dc9090506131b1565b60076053811115613123576131226182a6565b5b876053811115613136576131356182a6565b5b03613146576202172890506131b0565b6008605381111561315a576131596182a6565b5b87605381111561316d5761316c6182a6565b5b0361317d57620251c090506131af565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b5b5b5b6131c38183878787616df9565b5b50505050505050565b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614613246576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f80605381111561325a576132596182a6565b5b85605381111561326d5761326c6182a6565b5b0361327b57602090506133f1565b6002605381111561328f5761328e6182a6565b5b8560538111156132a2576132a16182a6565b5b036132b057602090506133f0565b600360538111156132c4576132c36182a6565b5b8560538111156132d7576132d66182a6565b5b036132e557602090506133ef565b600460538111156132f9576132f86182a6565b5b85605381111561330c5761330b6182a6565b5b0361331a57602090506133ee565b6005605381111561332e5761332d6182a6565b5b856053811115613341576133406182a6565b5b0361334f57602090506133ed565b60066053811115613363576133626182a6565b5b856053811115613376576133756182a6565b5b0361338457602090506133ec565b60086053811115613398576133976182a6565b5b8560538111156133ab576133aa6182a6565b5b036133b957602090506133eb565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b5b5b6133fd81838686616d69565b5050505050565b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161461347d576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f600160f81b867effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916036136a9575f60538111156134be576134bd6182a6565b5b8760538111156134d1576134d06182a6565b5b036134e0576159d89050613698565b600260538111156134f4576134f36182a6565b5b876053811115613507576135066182a6565b5b036135165761d6d89050613697565b6003605381111561352a576135296182a6565b5b87605381111561353d5761353c6182a6565b5b0361354c5761d6d89050613696565b600460538111156135605761355f6182a6565b5b876053811115613573576135726182a6565b5b0361358357620144389050613695565b60056053811115613597576135966182a6565b5b8760538111156135aa576135a96182a6565b5b036135ba57620148209050613694565b600660538111156135ce576135cd6182a6565b5b8760538111156135e1576135e06182a6565b5b036135f1576201c9089050613693565b60076053811115613605576136046182a6565b5b876053811115613618576136176182a6565b5b03613628576201c9089050613692565b6008605381111561363c5761363b6182a6565b5b87605381111561364f5761364e6182a6565b5b0361365f576201c9089050613691565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b5b5b5b6136a481838786616d69565b6138a5565b5f60538111156136bc576136bb6182a6565b5b8760538111156136cf576136ce6182a6565b5b036136de576159d89050613897565b600260538111156136f2576136f16182a6565b5b876053811115613705576137046182a6565b5b036137145761d6d89050613896565b60036053811115613728576137276182a6565b5b87605381111561373b5761373a6182a6565b5b0361374b57620144389050613895565b6004605381111561375f5761375e6182a6565b5b876053811115613772576137716182a6565b5b036137825762014c089050613894565b60056053811115613796576137956182a6565b5b8760538111156137a9576137a86182a6565b5b036137b9576201ccf09050613893565b600660538111156137cd576137cc6182a6565b5b8760538111156137e0576137df6182a6565b5b036137f0576201dc909050613892565b60076053811115613804576138036182a6565b5b876053811115613817576138166182a6565b5b0361382757620213409050613891565b6008605381111561383b5761383a6182a6565b5b87605381111561384e5761384d6182a6565b5b0361385e57620249f09050613890565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b5b5b5b6138a48183878787616df9565b5b50505050505050565b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614613927576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f6002605381111561393c5761393b6182a6565b5b84605381111561394f5761394e6182a6565b5b0361395e576159d89050613aa3565b60036053811115613972576139716182a6565b5b846053811115613985576139846182a6565b5b03613994576159d89050613aa2565b600460538111156139a8576139a76182a6565b5b8460538111156139bb576139ba6182a6565b5b036139ca57615dc09050613aa1565b600560538111156139de576139dd6182a6565b5b8460538111156139f1576139f06182a6565b5b03613a0057615dc09050613aa0565b60066053811115613a1457613a136182a6565b5b846053811115613a2757613a266182a6565b5b03613a36576161a89050613a9f565b60086053811115613a4a57613a496182a6565b5b846053811115613a5d57613a5c6182a6565b5b03613a6c576175309050613a9e565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b5b613aad818361753d565b613ab783826175c9565b50505050565b7350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff16638da5cb5b6040518163ffffffff1660e01b8152600401602060405180830381865afa158015613b1a573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190613b3e919061844e565b73ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614613bad57336040517f21bfda10000000000000000000000000000000000000000000000000000000008152600401613ba49190617ef2565b60405180910390fd5b5f613bb66170e4565b9050806001015f8373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f9054906101000a900460ff1615613c4657816040517ff99c4fd1000000000000000000000000000000000000000000000000000000008152600401613c3d9190617ef2565b60405180910390fd5b6001816001015f8473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f6101000a81548160ff0219169083151502179055508173ffffffffffffffffffffffffffffffffffffffff167fcca1d46384cdbbeef2f9daddb76db138101c9905f818d867b630195c128d3c6660405160405180910390a25050565b60035f613cef616f89565b9050805f0160089054906101000a900460ff1680613d3757508167ffffffffffffffff16815f015f9054906101000a900467ffffffffffffffff1667ffffffffffffffff1610155b15613d6e576040517ff92ee8a900000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b81815f015f6101000a81548167ffffffffffffffff021916908367ffffffffffffffff1602179055506001815f0160086101000a81548160ff021916908315150217905550613dbc85616fb0565b613dc584617016565b613dce8361707d565b5f815f0160086101000a81548160ff0219169083151502179055507fc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d282604051613e189190618421565b60405180910390a15050505050565b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614613ea0576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f600160f81b867effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916036140285760026053811115613ee257613ee16182a6565b5b876053811115613ef557613ef46182a6565b5b03613f05576201dc909050614017565b60036053811115613f1957613f186182a6565b5b876053811115613f2c57613f2b6182a6565b5b03613f3c576202f1e89050614016565b60046053811115613f5057613f4f6182a6565b5b876053811115613f6357613f626182a6565b5b03613f735762040b289050614015565b60056053811115613f8757613f866182a6565b5b876053811115613f9a57613f996182a6565b5b03613faa57620591c89050614014565b60066053811115613fbe57613fbd6182a6565b5b876053811115613fd157613fd06182a6565b5b03613fe157620a9ec09050614013565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b61402381838786616d69565b61417f565b6002605381111561403c5761403b6182a6565b5b87605381111561404f5761404e6182a6565b5b0361405f57620249f09050614171565b60036053811115614073576140726182a6565b5b876053811115614086576140856182a6565b5b0361409657620363309050614170565b600460538111156140aa576140a96182a6565b5b8760538111156140bd576140bc6182a6565b5b036140cd5762050140905061416f565b600560538111156140e1576140e06182a6565b5b8760538111156140f4576140f36182a6565b5b036141045762091820905061416e565b60066053811115614118576141176182a6565b5b87605381111561412b5761412a6182a6565b5b0361413b576219b9f0905061416d565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b61417e8183878787616df9565b5b50505050505050565b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614614201576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f600160f81b867effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916036143bb5760026053811115614243576142426182a6565b5b876053811115614256576142556182a6565b5b036142655761791890506143aa565b60036053811115614279576142786182a6565b5b87605381111561428c5761428b6182a6565b5b0361429b5761791890506143a9565b600460538111156142af576142ae6182a6565b5b8760538111156142c2576142c16182a6565b5b036142d157617d0090506143a8565b600560538111156142e5576142e46182a6565b5b8760538111156142f8576142f76182a6565b5b03614307576184d090506143a7565b6006605381111561431b5761431a6182a6565b5b87605381111561432e5761432d6182a6565b5b0361433d5761908890506143a6565b60086053811115614351576143506182a6565b5b876053811115614364576143636182a6565b5b0361437357619c4090506143a5565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b5b6143b681838786616d69565b61454a565b600260538111156143cf576143ce6182a6565b5b8760538111156143e2576143e16182a6565b5b036143f25762016b48905061453c565b60036053811115614406576144056182a6565b5b876053811115614419576144186182a6565b5b03614429576201e848905061453b565b6004605381111561443d5761443c6182a6565b5b8760538111156144505761444f6182a6565b5b036144605762027100905061453a565b60056053811115614474576144736182a6565b5b876053811115614487576144866182a6565b5b0361449757620330689050614539565b600660538111156144ab576144aa6182a6565b5b8760538111156144be576144bd6182a6565b5b036144ce57620451789050614538565b600860538111156144e2576144e16182a6565b5b8760538111156144f5576144f46182a6565b5b03614505576205b8d89050614537565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b5b6145498183878787616df9565b5b50505050505050565b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16146145cc576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f600160f81b867effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191603614754576002605381111561460e5761460d6182a6565b5b876053811115614621576146206182a6565b5b036146315762015ba89050614743565b60036053811115614645576146446182a6565b5b876053811115614658576146576182a6565b5b036146685762015ba89050614742565b6004605381111561467c5761467b6182a6565b5b87605381111561468f5761468e6182a6565b5b0361469f576201c9089050614741565b600560538111156146b3576146b26182a6565b5b8760538111156146c6576146c56182a6565b5b036146d657620246089050614740565b600660538111156146ea576146e96182a6565b5b8760538111156146fd576146fc6182a6565b5b0361470d576202bf20905061473f565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b61474f81838786616d69565b6148ab565b60026053811115614768576147676182a6565b5b87605381111561477b5761477a6182a6565b5b0361478b576201d8a8905061489d565b6003605381111561479f5761479e6182a6565b5b8760538111156147b2576147b16182a6565b5b036147c25762023668905061489c565b600460538111156147d6576147d56182a6565b5b8760538111156147e9576147e86182a6565b5b036147f9576202bf20905061489b565b6005605381111561480d5761480c6182a6565b5b8760538111156148205761481f6182a6565b5b036148305762035390905061489a565b60066053811115614844576148436182a6565b5b876053811115614857576148566182a6565b5b036148675762046cd09050614899565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b6148aa8183878787616df9565b5b50505050505050565b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161461492d576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f600160f81b867effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff19161461498d576040517f6aa9eb0500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b600260538111156149a1576149a06182a6565b5b8760538111156149b4576149b36182a6565b5b036149c457620334509050614ad6565b600360538111156149d8576149d76182a6565b5b8760538111156149eb576149ea6182a6565b5b036149fb5762049bb09050614ad5565b60046053811115614a0f57614a0e6182a6565b5b876053811115614a2257614a216182a6565b5b03614a32576206aef09050614ad4565b60056053811115614a4657614a456182a6565b5b876053811115614a5957614a586182a6565b5b03614a6957620ae8f89050614ad3565b60066053811115614a7d57614a7c6182a6565b5b876053811115614a9057614a8f6182a6565b5b03614aa0576212b1289050614ad2565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b614ae281838786616d69565b50505050505050565b5f805f614af66170e4565b90505f4390508065ffffffffffff16825f01600c9054906101000a900465ffffffffffff1665ffffffffffff1614614b3557805f935093505050614b53565b80825f0160069054906101000a900465ffffffffffff169350935050505b9091565b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614614bd0576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f600160f81b867effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191603614dc0575f6053811115614c1157614c106182a6565b5b876053811115614c2457614c236182a6565b5b03614c33576155f09050614daf565b60026053811115614c4757614c466182a6565b5b876053811115614c5a57614c596182a6565b5b03614c69576179189050614dae565b60036053811115614c7d57614c7c6182a6565b5b876053811115614c9057614c8f6182a6565b5b03614c9f576179189050614dad565b60046053811115614cb357614cb26182a6565b5b876053811115614cc657614cc56182a6565b5b03614cd557617d009050614dac565b60056053811115614ce957614ce86182a6565b5b876053811115614cfc57614cfb6182a6565b5b03614d0b576184d09050614dab565b60066053811115614d1f57614d1e6182a6565b5b876053811115614d3257614d316182a6565b5b03614d41576190889050614daa565b60086053811115614d5557614d546182a6565b5b876053811115614d6857614d676182a6565b5b03614d77576198589050614da9565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b5b5b614dbb81838786616d69565b614f7f565b5f6053811115614dd357614dd26182a6565b5b876053811115614de657614de56182a6565b5b03614df5576155f09050614f71565b60026053811115614e0957614e086182a6565b5b876053811115614e1c57614e1b6182a6565b5b03614e2b576179189050614f70565b60036053811115614e3f57614e3e6182a6565b5b876053811115614e5257614e516182a6565b5b03614e61576179189050614f6f565b60046053811115614e7557614e746182a6565b5b876053811115614e8857614e876182a6565b5b03614e9757617d009050614f6e565b60056053811115614eab57614eaa6182a6565b5b876053811115614ebe57614ebd6182a6565b5b03614ecd576184d09050614f6d565b60066053811115614ee157614ee06182a6565b5b876053811115614ef457614ef36182a6565b5b03614f03576190889050614f6c565b60086053811115614f1757614f166182a6565b5b876053811115614f2a57614f296182a6565b5b03614f39576198589050614f6b565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b5b5b614f7e8183878787616df9565b5b50505050505050565b7350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff16638da5cb5b6040518163ffffffff1660e01b8152600401602060405180830381865afa158015614fe5573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190615009919061844e565b73ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161461507857336040517f21bfda1000000000000000000000000000000000000000000000000000000000815260040161506f9190617ef2565b60405180910390fd5b61508181616fb0565b50565b7350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff16638da5cb5b6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156150e1573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190615105919061844e565b73ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161461517457336040517f21bfda1000000000000000000000000000000000000000000000000000000000815260040161516b9190617ef2565b60405180910390fd5b61517d8161707d565b50565b6040518060400160405280600581526020017f352e302e3000000000000000000000000000000000000000000000000000000081525081565b5f806151c36170e4565b9050805f015f9054906101000a900465ffffffffffff1691505090565b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614615259576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f80605381111561526d5761526c6182a6565b5b8460538111156152805761527f6182a6565b5b0361528e576020905061543a565b600260538111156152a2576152a16182a6565b5b8460538111156152b5576152b46182a6565b5b036152c35760209050615439565b600360538111156152d7576152d66182a6565b5b8460538111156152ea576152e96182a6565b5b036152f85760209050615438565b6004605381111561530c5761530b6182a6565b5b84605381111561531f5761531e6182a6565b5b0361532d5760209050615437565b60056053811115615341576153406182a6565b5b846053811115615354576153536182a6565b5b036153625760209050615436565b60066053811115615376576153756182a6565b5b846053811115615389576153886182a6565b5b036153975760209050615435565b600760538111156153ab576153aa6182a6565b5b8460538111156153be576153bd6182a6565b5b036153cc5760209050615434565b600860538111156153e0576153df6182a6565b5b8460538111156153f3576153f26182a6565b5b036154015760209050615433565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b5b5b5b615444818361753d565b61544e83826175c9565b50505050565b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16146154cd576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f600160f81b867effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916036156bd575f605381111561550e5761550d6182a6565b5b876053811115615521576155206182a6565b5b03615530576155f090506156ac565b60026053811115615544576155436182a6565b5b876053811115615557576155566182a6565b5b036155665761753090506156ab565b6003605381111561557a576155796182a6565b5b87605381111561558d5761558c6182a6565b5b0361559c5761753090506156aa565b600460538111156155b0576155af6182a6565b5b8760538111156155c3576155c26182a6565b5b036155d257617d0090506156a9565b600560538111156155e6576155e56182a6565b5b8760538111156155f9576155f86182a6565b5b03615608576184d090506156a8565b6006605381111561561c5761561b6182a6565b5b87605381111561562f5761562e6182a6565b5b0361563e5761908890506156a7565b60086053811115615652576156516182a6565b5b876053811115615665576156646182a6565b5b036156745761947090506156a6565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b5b5b6156b881838786616d69565b61587c565b5f60538111156156d0576156cf6182a6565b5b8760538111156156e3576156e26182a6565b5b036156f257615dc0905061586e565b60026053811115615706576157056182a6565b5b876053811115615719576157186182a6565b5b0361572857617530905061586d565b6003605381111561573c5761573b6182a6565b5b87605381111561574f5761574e6182a6565b5b0361575e57617918905061586c565b60046053811115615772576157716182a6565b5b876053811115615785576157846182a6565b5b0361579457617d00905061586b565b600560538111156157a8576157a76182a6565b5b8760538111156157bb576157ba6182a6565b5b036157ca576184d0905061586a565b600660538111156157de576157dd6182a6565b5b8760538111156157f1576157f06182a6565b5b03615800576190889050615869565b60086053811115615814576158136182a6565b5b876053811115615827576158266182a6565b5b03615836576194709050615868565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b5b5b61587b8183878787616df9565b5b50505050505050565b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16146158fe576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f600160f81b867effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191603615a8657600260538111156159405761593f6182a6565b5b876053811115615953576159526182a6565b5b0361596357620148209050615a75565b60036053811115615977576159766182a6565b5b87605381111561598a576159896182a6565b5b0361599a5762016b489050615a74565b600460538111156159ae576159ad6182a6565b5b8760538111156159c1576159c06182a6565b5b036159d157620173189050615a73565b600560538111156159e5576159e46182a6565b5b8760538111156159f8576159f76182a6565b5b03615a0857620207889050615a72565b60066053811115615a1c57615a1b6182a6565b5b876053811115615a2f57615a2e6182a6565b5b03615a3f5762029fe09050615a71565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b615a8181838786616d69565b615bdd565b60026053811115615a9a57615a996182a6565b5b876053811115615aad57615aac6182a6565b5b03615abd57620157c09050615bcf565b60036053811115615ad157615ad06182a6565b5b876053811115615ae457615ae36182a6565b5b03615af45762016b489050615bce565b60046053811115615b0857615b076182a6565b5b876053811115615b1b57615b1a6182a6565b5b03615b2b576201e8489050615bcd565b60056053811115615b3f57615b3e6182a6565b5b876053811115615b5257615b516182a6565b5b03615b6257620278d09050615bcc565b60066053811115615b7657615b756182a6565b5b876053811115615b8957615b886182a6565b5b03615b99576203f3b89050615bcb565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b615bdc8183878787616df9565b5b50505050505050565b5f615bef6170e4565b5f0160189054906101000a900465ffffffffffff16905090565b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614615c82576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f600160f81b867effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191603615e085760026053811115615cc457615cc36182a6565b5b876053811115615cd757615cd66182a6565b5b03615ce65761cb209050615df7565b60036053811115615cfa57615cf96182a6565b5b876053811115615d0d57615d0c6182a6565b5b03615d1c5761d6d89050615df6565b60046053811115615d3057615d2f6182a6565b5b876053811115615d4357615d426182a6565b5b03615d5357620148209050615df5565b60056053811115615d6757615d666182a6565b5b876053811115615d7a57615d796182a6565b5b03615d8a576201c5209050615df4565b60066053811115615d9e57615d9d6182a6565b5b876053811115615db157615db06182a6565b5b03615dc157620246089050615df3565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b615e0381838786616d69565b615f5e565b60026053811115615e1c57615e1b6182a6565b5b876053811115615e2f57615e2e6182a6565b5b03615e3e5761f6189050615f50565b60036053811115615e5257615e516182a6565b5b876053811115615e6557615e646182a6565b5b03615e7557620148209050615f4f565b60046053811115615e8957615e886182a6565b5b876053811115615e9c57615e9b6182a6565b5b03615eac576201ccf09050615f4e565b60056053811115615ec057615ebf6182a6565b5b876053811115615ed357615ed26182a6565b5b03615ee357620251c09050615f4d565b60066053811115615ef757615ef66182a6565b5b876053811115615f0a57615f096182a6565b5b03615f1a57620334509050615f4c565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b615f5d8183878787616df9565b5b50505050505050565b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614615fe0576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f600160f81b867effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916036161d0575f6053811115616021576160206182a6565b5b876053811115616034576160336182a6565b5b03616043576155f090506161bf565b60026053811115616057576160566182a6565b5b87605381111561606a576160696182a6565b5b036160795761791890506161be565b6003605381111561608d5761608c6182a6565b5b8760538111156160a05761609f6182a6565b5b036160af5761791890506161bd565b600460538111156160c3576160c26182a6565b5b8760538111156160d6576160d56182a6565b5b036160e557617d0090506161bc565b600560538111156160f9576160f86182a6565b5b87605381111561610c5761610b6182a6565b5b0361611b576184d090506161bb565b6006605381111561612f5761612e6182a6565b5b876053811115616142576161416182a6565b5b036161515761908890506161ba565b60086053811115616165576161646182a6565b5b876053811115616178576161776182a6565b5b036161875761947090506161b9565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b5b5b6161cb81838786616d69565b61638f565b5f60538111156161e3576161e26182a6565b5b8760538111156161f6576161f56182a6565b5b03616205576161a89050616381565b60026053811115616219576162186182a6565b5b87605381111561622c5761622b6182a6565b5b0361623b576179189050616380565b6003605381111561624f5761624e6182a6565b5b876053811115616262576162616182a6565b5b0361627157617918905061637f565b60046053811115616285576162846182a6565b5b876053811115616298576162976182a6565b5b036162a757617d00905061637e565b600560538111156162bb576162ba6182a6565b5b8760538111156162ce576162cd6182a6565b5b036162dd576184d0905061637d565b600660538111156162f1576162f06182a6565b5b876053811115616304576163036182a6565b5b0361631357619088905061637c565b60086053811115616327576163266182a6565b5b87605381111561633a576163396182a6565b5b0361634957619470905061637b565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b5b5b61638e8183878787616df9565b5b50505050505050565b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614616411576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f806053811115616425576164246182a6565b5b846053811115616438576164376182a6565b5b0361644757614a3890506165c3565b6002605381111561645b5761645a6182a6565b5b84605381111561646e5761646d6182a6565b5b0361647d576159d890506165c2565b60036053811115616491576164906182a6565b5b8460538111156164a4576164a36182a6565b5b036164b3576159d890506165c1565b600460538111156164c7576164c66182a6565b5b8460538111156164da576164d96182a6565b5b036164e957615dc090506165c0565b600560538111156164fd576164fc6182a6565b5b8460538111156165105761650f6182a6565b5b0361651f57615dc090506165bf565b60066053811115616533576165326182a6565b5b846053811115616546576165456182a6565b5b03616555576161a890506165be565b60086053811115616569576165686182a6565b5b84605381111561657c5761657b6182a6565b5b0361658b5761753090506165bd565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b5b5b6165cd818361753d565b6165d783826175c9565b50505050565b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614616656576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f600160f81b867effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916036167de5760026053811115616698576166976182a6565b5b8760538111156166ab576166aa6182a6565b5b036166bb576201482090506167cd565b600360538111156166cf576166ce6182a6565b5b8760538111156166e2576166e16182a6565b5b036166f25762016b4890506167cc565b60046053811115616706576167056182a6565b5b876053811115616719576167186182a6565b5b03616729576201731890506167cb565b6005605381111561673d5761673c6182a6565b5b8760538111156167505761674f6182a6565b5b03616760576202078890506167ca565b60066053811115616774576167736182a6565b5b876053811115616787576167866182a6565b5b036167975762029fe090506167c9565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b6167d981838786616d69565b616935565b600260538111156167f2576167f16182a6565b5b876053811115616805576168046182a6565b5b0361681557620163789050616927565b60036053811115616829576168286182a6565b5b87605381111561683c5761683b6182a6565b5b0361684c5762016b489050616926565b600460538111156168605761685f6182a6565b5b876053811115616873576168726182a6565b5b03616883576201e8489050616925565b60056053811115616897576168966182a6565b5b8760538111156168aa576168a96182a6565b5b036168ba57620278d09050616924565b600660538111156168ce576168cd6182a6565b5b8760538111156168e1576168e06182a6565b5b036168f1576203f7a09050616923565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b6169348183878787616df9565b5b50505050505050565b5f806169486170e4565b9050806001015f8473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f9054906101000a900460ff16915050919050565b73e3a9105a3a932253a70f126eb1e3b589c643dd2473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614616a17576040517f31a81a8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f600160f81b867effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191603616bd15760026053811115616a5957616a586182a6565b5b876053811115616a6c57616a6b6182a6565b5b03616a7b57617d009050616bc0565b60036053811115616a8f57616a8e6182a6565b5b876053811115616aa257616aa16182a6565b5b03616ab157617d009050616bbf565b60046053811115616ac557616ac46182a6565b5b876053811115616ad857616ad76182a6565b5b03616ae757617d009050616bbe565b60056053811115616afb57616afa6182a6565b5b876053811115616b0e57616b0d6182a6565b5b03616b1d576184d09050616bbd565b60066053811115616b3157616b306182a6565b5b876053811115616b4457616b436182a6565b5b03616b53576190889050616bbc565b60086053811115616b6757616b666182a6565b5b876053811115616b7a57616b796182a6565b5b03616b89576198589050616bbb565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b5b616bcc81838786616d69565b616d60565b60026053811115616be557616be46182a6565b5b876053811115616bf857616bf76182a6565b5b03616c0857620167609050616d52565b60036053811115616c1c57616c1b6182a6565b5b876053811115616c2f57616c2e6182a6565b5b03616c3f576201e8489050616d51565b60046053811115616c5357616c526182a6565b5b876053811115616c6657616c656182a6565b5b03616c7657620278d09050616d50565b60056053811115616c8a57616c896182a6565b5b876053811115616c9d57616c9c6182a6565b5b03616cad5762032c809050616d4f565b60066053811115616cc157616cc06182a6565b5b876053811115616cd457616cd36182a6565b5b03616ce457620426809050616d4e565b60086053811115616cf857616cf76182a6565b5b876053811115616d0b57616d0a6182a6565b5b03616d1b576205c4909050616d4d565b6040517f9ba6061b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5b5b5b5b5b616d5f8183878787616df9565b5b50505050505050565b616d73848461753d565b5f616d7d836175d0565b85616d8891906184af565b9050616d926170e4565b5f0160129054906101000a900465ffffffffffff1665ffffffffffff16811115616de8576040517ffc34487000000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b616df282826175c9565b5050505050565b616e03858561753d565b5f616e1e616e10856175d0565b616e19856175d0565b6175da565b86616e2991906184af565b9050616e336170e4565b5f0160129054906101000a900465ffffffffffff1665ffffffffffff16811115616e89576040517ffc34487000000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b616e9382826175c9565b505050505050565b60605f6001616ea9846175f3565b0190505f8167ffffffffffffffff811115616ec757616ec661802b565b5b6040519080825280601f01601f191660200182016040528015616ef95781602001600182028036833780820191505090505b5090505f82602001820190505b600115616f5a578080600190039150507f3031323334353637383961626364656600000000000000000000000000000000600a86061a8153600a8581616f4f57616f4e6184e2565b5b0494505f8503616f06575b819350505050919050565b5f616f6e616f89565b5f015f9054906101000a900467ffffffffffffffff16905090565b5f7ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00905090565b80616fb96170e4565b5f015f6101000a81548165ffffffffffff021916908365ffffffffffff1602179055507fc1f1fcaa898aae2263dded712e1798083fca9272ff803ee4150ce48f8619891a8160405161700b9190617eca565b60405180910390a150565b8061701f6170e4565b5f0160126101000a81548165ffffffffffff021916908365ffffffffffff1602179055507f5511b1851fc40a2629c855bab7adce3276c470d8190eb01431e418dc2af13e8e816040516170729190617eca565b60405180910390a150565b806170866170e4565b5f0160186101000a81548165ffffffffffff021916908365ffffffffffff1602179055507f64cb9e7ae6497c59080cdbc048552e123d52aa4240e137758a173582786961ca816040516170d99190617eca565b60405180910390a150565b5f7fc13af6c514bff8997f30c90003baa82bd02aad978179d1ce58d85c4319ad6500905090565b617115868661753d565b5f617141617122866175d0565b61713c61712e876175d0565b617137876175d0565b6175da565b6175da565b8761714c91906184af565b90506171566170e4565b5f0160129054906101000a900465ffffffffffff1665ffffffffffff168111156171ac576040517ffc34487000000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6171b682826175c9565b50505050505050565b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff163073ffffffffffffffffffffffffffffffffffffffff16148061726c57507f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16617253617744565b73ffffffffffffffffffffffffffffffffffffffff1614155b156172a3576040517fe07c8dba00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b565b7350157cffd6bbfa2dece204a89ec419c23ef5755d73ffffffffffffffffffffffffffffffffffffffff16638da5cb5b6040518163ffffffff1660e01b8152600401602060405180830381865afa158015617302573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190617326919061844e565b73ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161461739557336040517f21bfda1000000000000000000000000000000000000000000000000000000000815260040161738c9190617ef2565b60405180910390fd5b50565b8173ffffffffffffffffffffffffffffffffffffffff166352d1902d6040518163ffffffff1660e01b8152600401602060405180830381865afa92505050801561740057506040513d601f19601f820116820180604052508101906173fd9190618523565b60015b61744157816040517f4c9c8ce30000000000000000000000000000000000000000000000000000000081526004016174389190617ef2565b60405180910390fd5b7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5f1b81146174a757806040517faa1d49a400000000000000000000000000000000000000000000000000000000815260040161749e91906181b8565b60405180910390fd5b6174b18383617797565b505050565b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff163073ffffffffffffffffffffffffffffffffffffffff161461753b576040517fe07c8dba00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b565b6175478282617809565b5f61755061797a565b8361755b91906184af565b90506175656170e4565b5f0160189054906101000a900465ffffffffffff1665ffffffffffff168111156175bb576040517f77e3c29300000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6175c481617982565b505050565b80825d5050565b5f815c9050919050565b5f818310156175e957816175eb565b825b905092915050565b5f805f90507a184f03e93ff9f4daa797ed6e38ed64bf6a1f010000000000000000831061764f577a184f03e93ff9f4daa797ed6e38ed64bf6a1f0100000000000000008381617645576176446184e2565b5b0492506040810190505b6d04ee2d6d415b85acef8100000000831061768c576d04ee2d6d415b85acef81000000008381617682576176816184e2565b5b0492506020810190505b662386f26fc1000083106176bb57662386f26fc1000083816176b1576176b06184e2565b5b0492506010810190505b6305f5e10083106176e4576305f5e10083816176da576176d96184e2565b5b0492506008810190505b61271083106177095761271083816176ff576176fe6184e2565b5b0492506004810190505b6064831061772c5760648381617722576177216184e2565b5b0492506002810190505b600a831061773b576001810190505b80915050919050565b5f6177707f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5f1b617988565b5f015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905090565b6177a082617991565b8173ffffffffffffffffffffffffffffffffffffffff167fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b60405160405180910390a25f815111156177fc576177f68282617a5a565b50617805565b617804617ada565b5b5050565b5f6178126170e4565b9050806001015f8373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f9054906101000a900460ff161561786b5750617976565b5f4390505f825f0160069054906101000a900465ffffffffffff1690508165ffffffffffff16835f01600c9054906101000a900465ffffffffffff1665ffffffffffff16146178b8575f90505b5f858265ffffffffffff166178cd91906184af565b9050835f015f9054906101000a900465ffffffffffff1665ffffffffffff16811115617925576040517fad25117400000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b80845f0160066101000a81548165ffffffffffff021916908365ffffffffffff16021790555082845f01600c6101000a81548165ffffffffffff021916908365ffffffffffff160217905550505050505b5050565b5f805c905090565b805f5d50565b5f819050919050565b5f8173ffffffffffffffffffffffffffffffffffffffff163b036179ec57806040517f4c9c8ce30000000000000000000000000000000000000000000000000000000081526004016179e39190617ef2565b60405180910390fd5b80617a187f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5f1b617988565b5f015f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555050565b60605f808473ffffffffffffffffffffffffffffffffffffffff1684604051617a839190618592565b5f60405180830381855af49150503d805f8114617abb576040519150601f19603f3d011682016040523d82523d5f602084013e617ac0565b606091505b5091509150617ad0858383617b16565b9250505092915050565b5f341115617b14576040517fb398979f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b565b606082617b2b57617b2682617ba3565b617b9b565b5f8251148015617b5157505f8473ffffffffffffffffffffffffffffffffffffffff163b145b15617b9357836040517f9996b315000000000000000000000000000000000000000000000000000000008152600401617b8a9190617ef2565b60405180910390fd5b819050617b9c565b5b9392505050565b5f81511115617bb55780518082602001fd5b6040517fd6bda27500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f604051905090565b5f80fd5b5f80fd5b60548110617c04575f80fd5b50565b5f81359050617c1581617bf8565b92915050565b5f7fff0000000000000000000000000000000000000000000000000000000000000082169050919050565b617c4f81617c1b565b8114617c59575f80fd5b50565b5f81359050617c6a81617c46565b92915050565b5f819050919050565b617c8281617c70565b8114617c8c575f80fd5b50565b5f81359050617c9d81617c79565b92915050565b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f617ccc82617ca3565b9050919050565b617cdc81617cc2565b8114617ce6575f80fd5b50565b5f81359050617cf781617cd3565b92915050565b5f805f805f8060c08789031215617d1757617d16617bf0565b5b5f617d2489828a01617c07565b9650506020617d3589828a01617c5c565b9550506040617d4689828a01617c8f565b9450506060617d5789828a01617c8f565b9350506080617d6889828a01617c8f565b92505060a0617d7989828a01617ce9565b9150509295509295509295565b5f81519050919050565b5f82825260208201905092915050565b5f5b83811015617dbd578082015181840152602081019050617da2565b5f8484015250505050565b5f601f19601f8301169050919050565b5f617de282617d86565b617dec8185617d90565b9350617dfc818560208601617da0565b617e0581617dc8565b840191505092915050565b5f6020820190508181035f830152617e288184617dd8565b905092915050565b5f65ffffffffffff82169050919050565b617e4a81617e30565b8114617e54575f80fd5b50565b5f81359050617e6581617e41565b92915050565b5f805f60608486031215617e8257617e81617bf0565b5b5f617e8f86828701617e57565b9350506020617ea086828701617e57565b9250506040617eb186828701617e57565b9150509250925092565b617ec481617e30565b82525050565b5f602082019050617edd5f830184617ebb565b92915050565b617eec81617cc2565b82525050565b5f602082019050617f055f830184617ee3565b92915050565b5f60208284031215617f2057617f1f617bf0565b5b5f617f2d84828501617ce9565b91505092915050565b5f805f8060808587031215617f4e57617f4d617bf0565b5b5f617f5b87828801617c07565b9450506020617f6c87828801617c8f565b9350506040617f7d87828801617c8f565b9250506060617f8e87828801617ce9565b91505092959194509250565b5f805f805f8060c08789031215617fb457617fb3617bf0565b5b5f617fc189828a01617c07565b9650506020617fd289828a01617c8f565b9550506040617fe389828a01617c8f565b9450506060617ff489828a01617c8f565b935050608061800589828a01617c8f565b92505060a061801689828a01617ce9565b9150509295509295509295565b5f80fd5b5f80fd5b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b61806182617dc8565b810181811067ffffffffffffffff821117156180805761807f61802b565b5b80604052505050565b5f618092617be7565b905061809e8282618058565b919050565b5f67ffffffffffffffff8211156180bd576180bc61802b565b5b6180c682617dc8565b9050602081019050919050565b828183375f83830152505050565b5f6180f36180ee846180a3565b618089565b90508281526020810184848401111561810f5761810e618027565b5b61811a8482856180d3565b509392505050565b5f82601f83011261813657618135618023565b5b81356181468482602086016180e1565b91505092915050565b5f806040838503121561816557618164617bf0565b5b5f61817285828601617ce9565b925050602083013567ffffffffffffffff81111561819357618192617bf4565b5b61819f85828601618122565b9150509250929050565b6181b281617c70565b82525050565b5f6020820190506181cb5f8301846181a9565b92915050565b5f602082840312156181e6576181e5617bf0565b5b5f6181f384828501617e57565b91505092915050565b5f805f6060848603121561821357618212617bf0565b5b5f61822086828701617c07565b935050602061823186828701617c8f565b925050604061824286828701617ce9565b9150509250925092565b5f60408201905061825f5f830185617ebb565b61826c6020830184617ebb565b9392505050565b5f8115159050919050565b61828781618273565b82525050565b5f6020820190506182a05f83018461827e565b92915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52602160045260245ffd5b5f81905092915050565b5f6182e782617d86565b6182f181856182d3565b9350618301818560208601617da0565b80840191505092915050565b7f20760000000000000000000000000000000000000000000000000000000000005f82015250565b5f6183416002836182d3565b915061834c8261830d565b600282019050919050565b7f2e000000000000000000000000000000000000000000000000000000000000005f82015250565b5f61838b6001836182d3565b915061839682618357565b600182019050919050565b5f6183ac82876182dd565b91506183b782618335565b91506183c382866182dd565b91506183ce8261837f565b91506183da82856182dd565b91506183e58261837f565b91506183f182846182dd565b915081905095945050505050565b5f67ffffffffffffffff82169050919050565b61841b816183ff565b82525050565b5f6020820190506184345f830184618412565b92915050565b5f8151905061844881617cd3565b92915050565b5f6020828403121561846357618462617bf0565b5b5f6184708482850161843a565b91505092915050565b5f819050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5f6184b982618479565b91506184c483618479565b92508282019050808211156184dc576184db618482565b5b92915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601260045260245ffd5b5f8151905061851d81617c79565b92915050565b5f6020828403121561853857618537617bf0565b5b5f6185458482850161850f565b91505092915050565b5f81519050919050565b5f81905092915050565b5f61856c8261854e565b6185768185618558565b9350618586818560208601617da0565b80840191505092915050565b5f61859d8284618562565b91508190509291505056
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R`\x046\x10a\x02fW_5`\xE0\x1C\x80co\xD6^M\x11a\x01CW\x80c\xB5\x95G\xB8\x11a\0\xB5W\x80c\xC2w\xA96\x11a\0yW\x80c\xC2w\xA96\x14a\x08_W\x80c\xC8\xDECR\x14a\x08\x87W\x80c\xD5\xB8\xB8\xF3\x14a\x08\xAFW\x80c\xD63\xC9k\x14a\x08\xD7W\x80c\xED\xE8wn\x14a\x08\xFFW\x80c\xF7\xD1\x98\xF8\x14a\t;Wa\x02fV[\x80c\xB5\x95G\xB8\x14a\x07\x93W\x80c\xB7\x8B\xEFY\x14a\x07\xBDW\x80c\xC0\xC5\xDF|\x14a\x07\xE5W\x80c\xC19\x0C4\x14a\x08\rW\x80c\xC1<\x19q\x14a\x085Wa\x02fV[\x80c\x9B?x\x1A\x11a\x01\x07W\x80c\x9B?x\x1A\x14a\x06\x9EW\x80c\x9FK\x997\x14a\x06\xC6W\x80c\x9F\x92Y\xBB\x14a\x06\xF1W\x80c\xA06\xEA.\x14a\x07\x19W\x80c\xAB9GU\x14a\x07AW\x80c\xAD<\xB1\xCC\x14a\x07iWa\x02fV[\x80co\xD6^M\x14a\x05\xD6W\x80cwHg\x1A\x14a\x05\xFEW\x80c\x81\x8FMi\x14a\x06&W\x80c\x86)\xF5E\x14a\x06NW\x80c\x96\x83\x02\xD7\x14a\x06vWa\x02fV[\x80c;\xB7\xD5\xA3\x11a\x01\xDCW\x80c\\AKW\x11a\x01\xA0W\x80c\\AKW\x14a\x04\xE6W\x80c_v\xEB0\x14a\x05\x0EW\x80c`\xE1!\x89\x14a\x056W\x80ci\x93\x1A\xFB\x14a\x05^W\x80ck\xAD\x18\xB6\x14a\x05\x86W\x80cl\xF0\xBD%\x14a\x05\xAEWa\x02fV[\x80c;\xB7\xD5\xA3\x14a\x04(W\x80cE\x8F\xB2w\x14a\x04PW\x80cI|\"\xC5\x14a\x04xW\x80cO\x1E\xF2\x86\x14a\x04\xA0W\x80cR\xD1\x90-\x14a\x04\xBCWa\x02fV[\x80c&\x8Dm1\x11a\x02.W\x80c&\x8Dm1\x14a\x036W\x80c(g|\xA7\x14a\x03`W\x80c-\xCB\xC5\xD1\x14a\x03\x88W\x80c.<9\x06\x14a\x03\xB0W\x80c3\x11\xB1\xBC\x14a\x03\xD8W\x80c8\xBD\x17\xE5\x14a\x04\0Wa\x02fV[\x80c\x04U?\xB6\x14a\x02jW\x80c\x07\xCC\xDFa\x14a\x02\x92W\x80c\r\x8En,\x14a\x02\xBAW\x80c\x19jEm\x14a\x02\xE4W\x80c\x1E$\xAAI\x14a\x03\x0CW[_\x80\xFD[4\x80\x15a\x02uW_\x80\xFD[Pa\x02\x90`\x04\x806\x03\x81\x01\x90a\x02\x8B\x91\x90a|\xFDV[a\tcV[\0[4\x80\x15a\x02\x9DW_\x80\xFD[Pa\x02\xB8`\x04\x806\x03\x81\x01\x90a\x02\xB3\x91\x90a|\xFDV[a\x0C\xC4V[\0[4\x80\x15a\x02\xC5W_\x80\xFD[Pa\x02\xCEa\x10\x8FV[`@Qa\x02\xDB\x91\x90a~\x10V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x02\xEFW_\x80\xFD[Pa\x03\n`\x04\x806\x03\x81\x01\x90a\x03\x05\x91\x90a~kV[a\x11\nV[\0[4\x80\x15a\x03\x17W_\x80\xFD[Pa\x03 a\x12\x98V[`@Qa\x03-\x91\x90a~\xCAV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x03AW_\x80\xFD[Pa\x03Ja\x12\xBBV[`@Qa\x03W\x91\x90a~\xF2V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x03kW_\x80\xFD[Pa\x03\x86`\x04\x806\x03\x81\x01\x90a\x03\x81\x91\x90a\x7F\x0BV[a\x12\xD6V[\0[4\x80\x15a\x03\x93W_\x80\xFD[Pa\x03\xAE`\x04\x806\x03\x81\x01\x90a\x03\xA9\x91\x90a\x7F6V[a\x14\xFBV[\0[4\x80\x15a\x03\xBBW_\x80\xFD[Pa\x03\xD6`\x04\x806\x03\x81\x01\x90a\x03\xD1\x91\x90a\x7F\x9AV[a\x172V[\0[4\x80\x15a\x03\xE3W_\x80\xFD[Pa\x03\xFE`\x04\x806\x03\x81\x01\x90a\x03\xF9\x91\x90a|\xFDV[a\x19\xADV[\0[4\x80\x15a\x04\x0BW_\x80\xFD[Pa\x04&`\x04\x806\x03\x81\x01\x90a\x04!\x91\x90a|\xFDV[a\x1B\xE4V[\0[4\x80\x15a\x043W_\x80\xFD[Pa\x04N`\x04\x806\x03\x81\x01\x90a\x04I\x91\x90a|\xFDV[a\x1FBV[\0[4\x80\x15a\x04[W_\x80\xFD[Pa\x04v`\x04\x806\x03\x81\x01\x90a\x04q\x91\x90a|\xFDV[a\"\xA0V[\0[4\x80\x15a\x04\x83W_\x80\xFD[Pa\x04\x9E`\x04\x806\x03\x81\x01\x90a\x04\x99\x91\x90a\x7F6V[a%\xFEV[\0[a\x04\xBA`\x04\x806\x03\x81\x01\x90a\x04\xB5\x91\x90a\x81OV[a(\x0CV[\0[4\x80\x15a\x04\xC7W_\x80\xFD[Pa\x04\xD0a(+V[`@Qa\x04\xDD\x91\x90a\x81\xB8V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x04\xF1W_\x80\xFD[Pa\x05\x0C`\x04\x806\x03\x81\x01\x90a\x05\x07\x91\x90a\x81\xD1V[a(\\V[\0[4\x80\x15a\x05\x19W_\x80\xFD[Pa\x054`\x04\x806\x03\x81\x01\x90a\x05/\x91\x90a|\xFDV[a)XV[\0[4\x80\x15a\x05AW_\x80\xFD[Pa\x05\\`\x04\x806\x03\x81\x01\x90a\x05W\x91\x90a|\xFDV[a-#V[\0[4\x80\x15a\x05iW_\x80\xFD[Pa\x05\x84`\x04\x806\x03\x81\x01\x90a\x05\x7F\x91\x90a\x7F6V[a1\xCDV[\0[4\x80\x15a\x05\x91W_\x80\xFD[Pa\x05\xAC`\x04\x806\x03\x81\x01\x90a\x05\xA7\x91\x90a|\xFDV[a4\x04V[\0[4\x80\x15a\x05\xB9W_\x80\xFD[Pa\x05\xD4`\x04\x806\x03\x81\x01\x90a\x05\xCF\x91\x90a\x81\xFCV[a8\xAEV[\0[4\x80\x15a\x05\xE1W_\x80\xFD[Pa\x05\xFC`\x04\x806\x03\x81\x01\x90a\x05\xF7\x91\x90a\x7F\x0BV[a:\xBDV[\0[4\x80\x15a\x06\tW_\x80\xFD[Pa\x06$`\x04\x806\x03\x81\x01\x90a\x06\x1F\x91\x90a~kV[a<\xE4V[\0[4\x80\x15a\x061W_\x80\xFD[Pa\x06L`\x04\x806\x03\x81\x01\x90a\x06G\x91\x90a|\xFDV[a>'V[\0[4\x80\x15a\x06YW_\x80\xFD[Pa\x06t`\x04\x806\x03\x81\x01\x90a\x06o\x91\x90a|\xFDV[aA\x88V[\0[4\x80\x15a\x06\x81W_\x80\xFD[Pa\x06\x9C`\x04\x806\x03\x81\x01\x90a\x06\x97\x91\x90a|\xFDV[aESV[\0[4\x80\x15a\x06\xA9W_\x80\xFD[Pa\x06\xC4`\x04\x806\x03\x81\x01\x90a\x06\xBF\x91\x90a|\xFDV[aH\xB4V[\0[4\x80\x15a\x06\xD1W_\x80\xFD[Pa\x06\xDAaJ\xEBV[`@Qa\x06\xE8\x92\x91\x90a\x82LV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x06\xFCW_\x80\xFD[Pa\x07\x17`\x04\x806\x03\x81\x01\x90a\x07\x12\x91\x90a|\xFDV[aKWV[\0[4\x80\x15a\x07$W_\x80\xFD[Pa\x07?`\x04\x806\x03\x81\x01\x90a\x07:\x91\x90a\x81\xD1V[aO\x88V[\0[4\x80\x15a\x07LW_\x80\xFD[Pa\x07g`\x04\x806\x03\x81\x01\x90a\x07b\x91\x90a\x81\xD1V[aP\x84V[\0[4\x80\x15a\x07tW_\x80\xFD[Pa\x07}aQ\x80V[`@Qa\x07\x8A\x91\x90a~\x10V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x07\x9EW_\x80\xFD[Pa\x07\xA7aQ\xB9V[`@Qa\x07\xB4\x91\x90a~\xCAV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x07\xC8W_\x80\xFD[Pa\x07\xE3`\x04\x806\x03\x81\x01\x90a\x07\xDE\x91\x90a\x81\xFCV[aQ\xE0V[\0[4\x80\x15a\x07\xF0W_\x80\xFD[Pa\x08\x0B`\x04\x806\x03\x81\x01\x90a\x08\x06\x91\x90a|\xFDV[aTTV[\0[4\x80\x15a\x08\x18W_\x80\xFD[Pa\x083`\x04\x806\x03\x81\x01\x90a\x08.\x91\x90a|\xFDV[aX\x85V[\0[4\x80\x15a\x08@W_\x80\xFD[Pa\x08Ia[\xE6V[`@Qa\x08V\x91\x90a~\xCAV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x08jW_\x80\xFD[Pa\x08\x85`\x04\x806\x03\x81\x01\x90a\x08\x80\x91\x90a|\xFDV[a\\\tV[\0[4\x80\x15a\x08\x92W_\x80\xFD[Pa\x08\xAD`\x04\x806\x03\x81\x01\x90a\x08\xA8\x91\x90a|\xFDV[a_gV[\0[4\x80\x15a\x08\xBAW_\x80\xFD[Pa\x08\xD5`\x04\x806\x03\x81\x01\x90a\x08\xD0\x91\x90a\x81\xFCV[ac\x98V[\0[4\x80\x15a\x08\xE2W_\x80\xFD[Pa\x08\xFD`\x04\x806\x03\x81\x01\x90a\x08\xF8\x91\x90a|\xFDV[ae\xDDV[\0[4\x80\x15a\t\nW_\x80\xFD[Pa\t%`\x04\x806\x03\x81\x01\x90a\t \x91\x90a\x7F\x0BV[ai>V[`@Qa\t2\x91\x90a\x82\x8DV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\tFW_\x80\xFD[Pa\ta`\x04\x806\x03\x81\x01\x90a\t\\\x91\x90a|\xFDV[ai\x9EV[\0[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\t\xDCW`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\x01`\xF8\x1B\x86~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x03a\x0BdW`\x02`S\x81\x11\x15a\n\x1EWa\n\x1Da\x82\xA6V[[\x87`S\x81\x11\x15a\n1Wa\n0a\x82\xA6V[[\x03a\nAWb\x01H \x90Pa\x0BSV[`\x03`S\x81\x11\x15a\nUWa\nTa\x82\xA6V[[\x87`S\x81\x11\x15a\nhWa\nga\x82\xA6V[[\x03a\nxWb\x01W\xC0\x90Pa\x0BRV[`\x04`S\x81\x11\x15a\n\x8CWa\n\x8Ba\x82\xA6V[[\x87`S\x81\x11\x15a\n\x9FWa\n\x9Ea\x82\xA6V[[\x03a\n\xAFWb\x01\xC9\x08\x90Pa\x0BQV[`\x05`S\x81\x11\x15a\n\xC3Wa\n\xC2a\x82\xA6V[[\x87`S\x81\x11\x15a\n\xD6Wa\n\xD5a\x82\xA6V[[\x03a\n\xE6Wb\x02I\xF0\x90Pa\x0BPV[`\x06`S\x81\x11\x15a\n\xFAWa\n\xF9a\x82\xA6V[[\x87`S\x81\x11\x15a\x0B\rWa\x0B\x0Ca\x82\xA6V[[\x03a\x0B\x1DWb\x02\xD6\x90\x90Pa\x0BOV[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[a\x0B_\x81\x83\x87\x86amiV[a\x0C\xBBV[`\x02`S\x81\x11\x15a\x0BxWa\x0Bwa\x82\xA6V[[\x87`S\x81\x11\x15a\x0B\x8BWa\x0B\x8Aa\x82\xA6V[[\x03a\x0B\x9BWb\x01\xD0\xD8\x90Pa\x0C\xADV[`\x03`S\x81\x11\x15a\x0B\xAFWa\x0B\xAEa\x82\xA6V[[\x87`S\x81\x11\x15a\x0B\xC2Wa\x0B\xC1a\x82\xA6V[[\x03a\x0B\xD2Wb\x02:P\x90Pa\x0C\xACV[`\x04`S\x81\x11\x15a\x0B\xE6Wa\x0B\xE5a\x82\xA6V[[\x87`S\x81\x11\x15a\x0B\xF9Wa\x0B\xF8a\x82\xA6V[[\x03a\x0C\tWb\x02\xC6\xF0\x90Pa\x0C\xABV[`\x05`S\x81\x11\x15a\x0C\x1DWa\x0C\x1Ca\x82\xA6V[[\x87`S\x81\x11\x15a\x0C0Wa\x0C/a\x82\xA6V[[\x03a\x0C@Wb\x03Wx\x90Pa\x0C\xAAV[`\x06`S\x81\x11\x15a\x0CTWa\x0CSa\x82\xA6V[[\x87`S\x81\x11\x15a\x0CgWa\x0Cfa\x82\xA6V[[\x03a\x0CwWb\x04h\xE8\x90Pa\x0C\xA9V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[a\x0C\xBA\x81\x83\x87\x87\x87am\xF9V[[PPPPPPPV[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\r=W`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\x01`\xF8\x1B\x86~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x03a\x0E\xF7W`\x02`S\x81\x11\x15a\r\x7FWa\r~a\x82\xA6V[[\x87`S\x81\x11\x15a\r\x92Wa\r\x91a\x82\xA6V[[\x03a\r\xA1Wa}\0\x90Pa\x0E\xE6V[`\x03`S\x81\x11\x15a\r\xB5Wa\r\xB4a\x82\xA6V[[\x87`S\x81\x11\x15a\r\xC8Wa\r\xC7a\x82\xA6V[[\x03a\r\xD7Wa}\0\x90Pa\x0E\xE5V[`\x04`S\x81\x11\x15a\r\xEBWa\r\xEAa\x82\xA6V[[\x87`S\x81\x11\x15a\r\xFEWa\r\xFDa\x82\xA6V[[\x03a\x0E\rWa}\0\x90Pa\x0E\xE4V[`\x05`S\x81\x11\x15a\x0E!Wa\x0E a\x82\xA6V[[\x87`S\x81\x11\x15a\x0E4Wa\x0E3a\x82\xA6V[[\x03a\x0ECWa\x84\xD0\x90Pa\x0E\xE3V[`\x06`S\x81\x11\x15a\x0EWWa\x0EVa\x82\xA6V[[\x87`S\x81\x11\x15a\x0EjWa\x0Eia\x82\xA6V[[\x03a\x0EyWa\x90\x88\x90Pa\x0E\xE2V[`\x08`S\x81\x11\x15a\x0E\x8DWa\x0E\x8Ca\x82\xA6V[[\x87`S\x81\x11\x15a\x0E\xA0Wa\x0E\x9Fa\x82\xA6V[[\x03a\x0E\xAFWa\x94p\x90Pa\x0E\xE1V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[[a\x0E\xF2\x81\x83\x87\x86amiV[a\x10\x86V[`\x02`S\x81\x11\x15a\x0F\x0BWa\x0F\na\x82\xA6V[[\x87`S\x81\x11\x15a\x0F\x1EWa\x0F\x1Da\x82\xA6V[[\x03a\x0F.Wb\x01cx\x90Pa\x10xV[`\x03`S\x81\x11\x15a\x0FBWa\x0FAa\x82\xA6V[[\x87`S\x81\x11\x15a\x0FUWa\x0FTa\x82\xA6V[[\x03a\x0FeWb\x01\xE0x\x90Pa\x10wV[`\x04`S\x81\x11\x15a\x0FyWa\x0Fxa\x82\xA6V[[\x87`S\x81\x11\x15a\x0F\x8CWa\x0F\x8Ba\x82\xA6V[[\x03a\x0F\x9CWb\x02|\xB8\x90Pa\x10vV[`\x05`S\x81\x11\x15a\x0F\xB0Wa\x0F\xAFa\x82\xA6V[[\x87`S\x81\x11\x15a\x0F\xC3Wa\x0F\xC2a\x82\xA6V[[\x03a\x0F\xD3Wb\x030h\x90Pa\x10uV[`\x06`S\x81\x11\x15a\x0F\xE7Wa\x0F\xE6a\x82\xA6V[[\x87`S\x81\x11\x15a\x0F\xFAWa\x0F\xF9a\x82\xA6V[[\x03a\x10\nWb\x04&\x80\x90Pa\x10tV[`\x08`S\x81\x11\x15a\x10\x1EWa\x10\x1Da\x82\xA6V[[\x87`S\x81\x11\x15a\x101Wa\x100a\x82\xA6V[[\x03a\x10AWb\x05\xA1h\x90Pa\x10sV[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[[a\x10\x85\x81\x83\x87\x87\x87am\xF9V[[PPPPPPPV[```@Q\x80`@\x01`@R\x80`\x08\x81R` \x01\x7FHCULimit\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81RPa\x10\xD0_an\x9BV[a\x10\xDA`\x02an\x9BV[a\x10\xE3_an\x9BV[`@Q` \x01a\x10\xF6\x94\x93\x92\x91\x90a\x83\xA1V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x90P\x90V[`\x01a\x11\x14aoeV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x11UW`@Q\x7FoOs\x1F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x03_a\x11`ao\x89V[\x90P\x80_\x01`\x08\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x80a\x11\xA8WP\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81_\x01_\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x10\x15[\x15a\x11\xDFW`@Q\x7F\xF9.\xE8\xA9\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x81\x81_\x01_a\x01\0\n\x81T\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP`\x01\x81_\x01`\x08a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UPa\x12-\x85ao\xB0V[a\x126\x84ap\x16V[a\x12?\x83ap}V[_\x81_\x01`\x08a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP\x7F\xC7\xF5\x05\xB2\xF3q\xAE!u\xEEI\x13\xF4I\x9E\x1F&3\xA7\xB5\x93c!\xEE\xD1\xCD\xAE\xB6\x11Q\x81\xD2\x82`@Qa\x12\x89\x91\x90a\x84!V[`@Q\x80\x91\x03\x90\xA1PPPPPV[_a\x12\xA1ap\xE4V[_\x01`\x12\x90T\x90a\x01\0\n\x90\x04e\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P\x90V[_s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$\x90P\x90V[sP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x8D\xA5\xCB[`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x133W=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x13W\x91\x90a\x84NV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x13\xC6W3`@Q\x7F!\xBF\xDA\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x13\xBD\x91\x90a~\xF2V[`@Q\x80\x91\x03\x90\xFD[_a\x13\xCFap\xE4V[\x90P\x80`\x01\x01_\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16a\x14^W\x81`@Q\x7F\xE3\xCC4\x18\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x14U\x91\x90a~\xF2V[`@Q\x80\x91\x03\x90\xFD[_\x81`\x01\x01_\x84s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\x92\xFC\x97\xAF\x15\0&F\xCE\xA6<v3\xBB7[\x82\xDB|\xDE{H\x0Cu\xFEcA\xDA\xCC),\x81`@Q`@Q\x80\x91\x03\x90\xA2PPV[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x15tW`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x80`S\x81\x11\x15a\x15\x88Wa\x15\x87a\x82\xA6V[[\x85`S\x81\x11\x15a\x15\x9BWa\x15\x9Aa\x82\xA6V[[\x03a\x15\xA9W`\x02\x90Pa\x17\x1FV[`\x02`S\x81\x11\x15a\x15\xBDWa\x15\xBCa\x82\xA6V[[\x85`S\x81\x11\x15a\x15\xD0Wa\x15\xCFa\x82\xA6V[[\x03a\x15\xDEW`\t\x90Pa\x17\x1EV[`\x03`S\x81\x11\x15a\x15\xF2Wa\x15\xF1a\x82\xA6V[[\x85`S\x81\x11\x15a\x16\x05Wa\x16\x04a\x82\xA6V[[\x03a\x16\x13W`\x10\x90Pa\x17\x1DV[`\x04`S\x81\x11\x15a\x16'Wa\x16&a\x82\xA6V[[\x85`S\x81\x11\x15a\x16:Wa\x169a\x82\xA6V[[\x03a\x16HW` \x90Pa\x17\x1CV[`\x05`S\x81\x11\x15a\x16\\Wa\x16[a\x82\xA6V[[\x85`S\x81\x11\x15a\x16oWa\x16na\x82\xA6V[[\x03a\x16}W`?\x90Pa\x17\x1BV[`\x06`S\x81\x11\x15a\x16\x91Wa\x16\x90a\x82\xA6V[[\x85`S\x81\x11\x15a\x16\xA4Wa\x16\xA3a\x82\xA6V[[\x03a\x16\xB2W`\x82\x90Pa\x17\x1AV[`\x08`S\x81\x11\x15a\x16\xC6Wa\x16\xC5a\x82\xA6V[[\x85`S\x81\x11\x15a\x16\xD9Wa\x16\xD8a\x82\xA6V[[\x03a\x16\xE7W`\x82\x90Pa\x17\x19V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[[[a\x17+\x81\x83\x86\x86amiV[PPPPPV[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x17\xABW`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x80`S\x81\x11\x15a\x17\xBFWa\x17\xBEa\x82\xA6V[[\x87`S\x81\x11\x15a\x17\xD2Wa\x17\xD1a\x82\xA6V[[\x03a\x17\xE1Wa\xD6\xD8\x90Pa\x19\x96V[`\x02`S\x81\x11\x15a\x17\xF5Wa\x17\xF4a\x82\xA6V[[\x87`S\x81\x11\x15a\x18\x08Wa\x18\x07a\x82\xA6V[[\x03a\x18\x17Wa\xD6\xD8\x90Pa\x19\x95V[`\x03`S\x81\x11\x15a\x18+Wa\x18*a\x82\xA6V[[\x87`S\x81\x11\x15a\x18>Wa\x18=a\x82\xA6V[[\x03a\x18MWa\xD6\xD8\x90Pa\x19\x94V[`\x04`S\x81\x11\x15a\x18aWa\x18`a\x82\xA6V[[\x87`S\x81\x11\x15a\x18tWa\x18sa\x82\xA6V[[\x03a\x18\x83Wa\xD6\xD8\x90Pa\x19\x93V[`\x05`S\x81\x11\x15a\x18\x97Wa\x18\x96a\x82\xA6V[[\x87`S\x81\x11\x15a\x18\xAAWa\x18\xA9a\x82\xA6V[[\x03a\x18\xB9Wa\xD6\xD8\x90Pa\x19\x92V[`\x06`S\x81\x11\x15a\x18\xCDWa\x18\xCCa\x82\xA6V[[\x87`S\x81\x11\x15a\x18\xE0Wa\x18\xDFa\x82\xA6V[[\x03a\x18\xEFWa\xDE\xA8\x90Pa\x19\x91V[`\x07`S\x81\x11\x15a\x19\x03Wa\x19\x02a\x82\xA6V[[\x87`S\x81\x11\x15a\x19\x16Wa\x19\x15a\x82\xA6V[[\x03a\x19&Wb\x01D8\x90Pa\x19\x90V[`\x08`S\x81\x11\x15a\x19:Wa\x199a\x82\xA6V[[\x87`S\x81\x11\x15a\x19MWa\x19La\x82\xA6V[[\x03a\x19]Wb\x01\xA5\xE0\x90Pa\x19\x8FV[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[[[[a\x19\xA4\x81\x83\x88\x88\x88\x88aq\x0BV[PPPPPPPV[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x1A&W`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\x01`\xF8\x1B\x86~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x14a\x1A\x86W`@Q\x7Fj\xA9\xEB\x05\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x02`S\x81\x11\x15a\x1A\x9AWa\x1A\x99a\x82\xA6V[[\x87`S\x81\x11\x15a\x1A\xADWa\x1A\xACa\x82\xA6V[[\x03a\x1A\xBDWb\x06\xB6\xC0\x90Pa\x1B\xCFV[`\x03`S\x81\x11\x15a\x1A\xD1Wa\x1A\xD0a\x82\xA6V[[\x87`S\x81\x11\x15a\x1A\xE4Wa\x1A\xE3a\x82\xA6V[[\x03a\x1A\xF4Wb\x08\xD9\xA0\x90Pa\x1B\xCEV[`\x04`S\x81\x11\x15a\x1B\x08Wa\x1B\x07a\x82\xA6V[[\x87`S\x81\x11\x15a\x1B\x1BWa\x1B\x1Aa\x82\xA6V[[\x03a\x1B+Wb\x0C\x15\xC0\x90Pa\x1B\xCDV[`\x05`S\x81\x11\x15a\x1B?Wa\x1B>a\x82\xA6V[[\x87`S\x81\x11\x15a\x1BRWa\x1BQa\x82\xA6V[[\x03a\x1BbWb\x11\x97\xE8\x90Pa\x1B\xCCV[`\x06`S\x81\x11\x15a\x1BvWa\x1Bua\x82\xA6V[[\x87`S\x81\x11\x15a\x1B\x89Wa\x1B\x88a\x82\xA6V[[\x03a\x1B\x99Wb\x1D\xA5\xD8\x90Pa\x1B\xCBV[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[a\x1B\xDB\x81\x83\x87\x86amiV[PPPPPPPV[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x1C]W`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\x01`\xF8\x1B\x86~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x03a\x1D\xE3W`\x02`S\x81\x11\x15a\x1C\x9FWa\x1C\x9Ea\x82\xA6V[[\x87`S\x81\x11\x15a\x1C\xB2Wa\x1C\xB1a\x82\xA6V[[\x03a\x1C\xC1Wa\xE2\x90\x90Pa\x1D\xD2V[`\x03`S\x81\x11\x15a\x1C\xD5Wa\x1C\xD4a\x82\xA6V[[\x87`S\x81\x11\x15a\x1C\xE8Wa\x1C\xE7a\x82\xA6V[[\x03a\x1C\xF7Wa\xE2\x90\x90Pa\x1D\xD1V[`\x04`S\x81\x11\x15a\x1D\x0BWa\x1D\na\x82\xA6V[[\x87`S\x81\x11\x15a\x1D\x1EWa\x1D\x1Da\x82\xA6V[[\x03a\x1D.Wb\x01H \x90Pa\x1D\xD0V[`\x05`S\x81\x11\x15a\x1DBWa\x1DAa\x82\xA6V[[\x87`S\x81\x11\x15a\x1DUWa\x1DTa\x82\xA6V[[\x03a\x1DeWb\x01\xD0\xD8\x90Pa\x1D\xCFV[`\x06`S\x81\x11\x15a\x1DyWa\x1Dxa\x82\xA6V[[\x87`S\x81\x11\x15a\x1D\x8CWa\x1D\x8Ba\x82\xA6V[[\x03a\x1D\x9CWb\x02I\xF0\x90Pa\x1D\xCEV[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[a\x1D\xDE\x81\x83\x87\x86amiV[a\x1F9V[`\x02`S\x81\x11\x15a\x1D\xF7Wa\x1D\xF6a\x82\xA6V[[\x87`S\x81\x11\x15a\x1E\nWa\x1E\ta\x82\xA6V[[\x03a\x1E\x19Wa\xE2\x90\x90Pa\x1F+V[`\x03`S\x81\x11\x15a\x1E-Wa\x1E,a\x82\xA6V[[\x87`S\x81\x11\x15a\x1E@Wa\x1E?a\x82\xA6V[[\x03a\x1EPWb\x01D8\x90Pa\x1F*V[`\x04`S\x81\x11\x15a\x1EdWa\x1Eca\x82\xA6V[[\x87`S\x81\x11\x15a\x1EwWa\x1Eva\x82\xA6V[[\x03a\x1E\x87Wb\x01\xC9\x08\x90Pa\x1F)V[`\x05`S\x81\x11\x15a\x1E\x9BWa\x1E\x9Aa\x82\xA6V[[\x87`S\x81\x11\x15a\x1E\xAEWa\x1E\xADa\x82\xA6V[[\x03a\x1E\xBEWb\x02F\x08\x90Pa\x1F(V[`\x06`S\x81\x11\x15a\x1E\xD2Wa\x1E\xD1a\x82\xA6V[[\x87`S\x81\x11\x15a\x1E\xE5Wa\x1E\xE4a\x82\xA6V[[\x03a\x1E\xF5Wb\x03S\x90\x90Pa\x1F'V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[a\x1F8\x81\x83\x87\x87\x87am\xF9V[[PPPPPPPV[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x1F\xBBW`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\x01`\xF8\x1B\x86~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x03a!AW`\x02`S\x81\x11\x15a\x1F\xFDWa\x1F\xFCa\x82\xA6V[[\x87`S\x81\x11\x15a \x10Wa \x0Fa\x82\xA6V[[\x03a \x1FWa\xCB \x90Pa!0V[`\x03`S\x81\x11\x15a 3Wa 2a\x82\xA6V[[\x87`S\x81\x11\x15a FWa Ea\x82\xA6V[[\x03a UWa\xE2\x90\x90Pa!/V[`\x04`S\x81\x11\x15a iWa ha\x82\xA6V[[\x87`S\x81\x11\x15a |Wa {a\x82\xA6V[[\x03a \x8CWb\x01D8\x90Pa!.V[`\x05`S\x81\x11\x15a \xA0Wa \x9Fa\x82\xA6V[[\x87`S\x81\x11\x15a \xB3Wa \xB2a\x82\xA6V[[\x03a \xC3Wb\x01\xCC\xF0\x90Pa!-V[`\x06`S\x81\x11\x15a \xD7Wa \xD6a\x82\xA6V[[\x87`S\x81\x11\x15a \xEAWa \xE9a\x82\xA6V[[\x03a \xFAWb\x02F\x08\x90Pa!,V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[a!<\x81\x83\x87\x86amiV[a\"\x97V[`\x02`S\x81\x11\x15a!UWa!Ta\x82\xA6V[[\x87`S\x81\x11\x15a!hWa!ga\x82\xA6V[[\x03a!wWa\xE6x\x90Pa\"\x89V[`\x03`S\x81\x11\x15a!\x8BWa!\x8Aa\x82\xA6V[[\x87`S\x81\x11\x15a!\x9EWa!\x9Da\x82\xA6V[[\x03a!\xAEWb\x01H \x90Pa\"\x88V[`\x04`S\x81\x11\x15a!\xC2Wa!\xC1a\x82\xA6V[[\x87`S\x81\x11\x15a!\xD5Wa!\xD4a\x82\xA6V[[\x03a!\xE5Wb\x01\xC9\x08\x90Pa\"\x87V[`\x05`S\x81\x11\x15a!\xF9Wa!\xF8a\x82\xA6V[[\x87`S\x81\x11\x15a\"\x0CWa\"\x0Ba\x82\xA6V[[\x03a\"\x1CWb\x02:P\x90Pa\"\x86V[`\x06`S\x81\x11\x15a\"0Wa\"/a\x82\xA6V[[\x87`S\x81\x11\x15a\"CWa\"Ba\x82\xA6V[[\x03a\"SWb\x03G\xD8\x90Pa\"\x85V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[a\"\x96\x81\x83\x87\x87\x87am\xF9V[[PPPPPPPV[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a#\x19W`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\x01`\xF8\x1B\x86~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x03a$\x9FW`\x02`S\x81\x11\x15a#[Wa#Za\x82\xA6V[[\x87`S\x81\x11\x15a#nWa#ma\x82\xA6V[[\x03a#}Wa\xCB \x90Pa$\x8EV[`\x03`S\x81\x11\x15a#\x91Wa#\x90a\x82\xA6V[[\x87`S\x81\x11\x15a#\xA4Wa#\xA3a\x82\xA6V[[\x03a#\xB3Wa\xD6\xD8\x90Pa$\x8DV[`\x04`S\x81\x11\x15a#\xC7Wa#\xC6a\x82\xA6V[[\x87`S\x81\x11\x15a#\xDAWa#\xD9a\x82\xA6V[[\x03a#\xEAWb\x01H \x90Pa$\x8CV[`\x05`S\x81\x11\x15a#\xFEWa#\xFDa\x82\xA6V[[\x87`S\x81\x11\x15a$\x11Wa$\x10a\x82\xA6V[[\x03a$!Wb\x01\xC9\x08\x90Pa$\x8BV[`\x06`S\x81\x11\x15a$5Wa$4a\x82\xA6V[[\x87`S\x81\x11\x15a$HWa$Ga\x82\xA6V[[\x03a$XWb\x02I\xF0\x90Pa$\x8AV[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[a$\x9A\x81\x83\x87\x86amiV[a%\xF5V[`\x02`S\x81\x11\x15a$\xB3Wa$\xB2a\x82\xA6V[[\x87`S\x81\x11\x15a$\xC6Wa$\xC5a\x82\xA6V[[\x03a$\xD5Wa\xE6x\x90Pa%\xE7V[`\x03`S\x81\x11\x15a$\xE9Wa$\xE8a\x82\xA6V[[\x87`S\x81\x11\x15a$\xFCWa$\xFBa\x82\xA6V[[\x03a%\x0CWb\x01H \x90Pa%\xE6V[`\x04`S\x81\x11\x15a% Wa%\x1Fa\x82\xA6V[[\x87`S\x81\x11\x15a%3Wa%2a\x82\xA6V[[\x03a%CWb\x01\xCC\xF0\x90Pa%\xE5V[`\x05`S\x81\x11\x15a%WWa%Va\x82\xA6V[[\x87`S\x81\x11\x15a%jWa%ia\x82\xA6V[[\x03a%zWb\x02Q\xC0\x90Pa%\xE4V[`\x06`S\x81\x11\x15a%\x8EWa%\x8Da\x82\xA6V[[\x87`S\x81\x11\x15a%\xA1Wa%\xA0a\x82\xA6V[[\x03a%\xB1Wb\x03S\x90\x90Pa%\xE3V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[a%\xF4\x81\x83\x87\x87\x87am\xF9V[[PPPPPPPV[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a&wW`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\x02`S\x81\x11\x15a&\x8CWa&\x8Ba\x82\xA6V[[\x85`S\x81\x11\x15a&\x9FWa&\x9Ea\x82\xA6V[[\x03a&\xAFWb\x014\x98\x90Pa'\xF9V[`\x03`S\x81\x11\x15a&\xC3Wa&\xC2a\x82\xA6V[[\x85`S\x81\x11\x15a&\xD6Wa&\xD5a\x82\xA6V[[\x03a&\xE6Wb\x01kH\x90Pa'\xF8V[`\x04`S\x81\x11\x15a&\xFAWa&\xF9a\x82\xA6V[[\x85`S\x81\x11\x15a'\rWa'\x0Ca\x82\xA6V[[\x03a'\x1DWb\x01s\x18\x90Pa'\xF7V[`\x05`S\x81\x11\x15a'1Wa'0a\x82\xA6V[[\x85`S\x81\x11\x15a'DWa'Ca\x82\xA6V[[\x03a'TWb\x01\xFF\xB8\x90Pa'\xF6V[`\x06`S\x81\x11\x15a'hWa'ga\x82\xA6V[[\x85`S\x81\x11\x15a'{Wa'za\x82\xA6V[[\x03a'\x8BWb\x02\x90@\x90Pa'\xF5V[`\x08`S\x81\x11\x15a'\x9FWa'\x9Ea\x82\xA6V[[\x85`S\x81\x11\x15a'\xB2Wa'\xB1a\x82\xA6V[[\x03a'\xC2Wb\x04\x1A\xC8\x90Pa'\xF4V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[[a(\x05\x81\x83\x86\x86amiV[PPPPPV[a(\x14aq\xBFV[a(\x1D\x82ar\xA5V[a('\x82\x82as\x98V[PPV[_a(4at\xB6V[\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC_\x1B\x90P\x90V[sP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x8D\xA5\xCB[`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a(\xB9W=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a(\xDD\x91\x90a\x84NV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a)LW3`@Q\x7F!\xBF\xDA\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a)C\x91\x90a~\xF2V[`@Q\x80\x91\x03\x90\xFD[a)U\x81ap\x16V[PV[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a)\xD1W`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\x01`\xF8\x1B\x86~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x03a+\x8BW`\x02`S\x81\x11\x15a*\x13Wa*\x12a\x82\xA6V[[\x87`S\x81\x11\x15a*&Wa*%a\x82\xA6V[[\x03a*5Way\x18\x90Pa+zV[`\x03`S\x81\x11\x15a*IWa*Ha\x82\xA6V[[\x87`S\x81\x11\x15a*\\Wa*[a\x82\xA6V[[\x03a*kWay\x18\x90Pa+yV[`\x04`S\x81\x11\x15a*\x7FWa*~a\x82\xA6V[[\x87`S\x81\x11\x15a*\x92Wa*\x91a\x82\xA6V[[\x03a*\xA1Wa}\0\x90Pa+xV[`\x05`S\x81\x11\x15a*\xB5Wa*\xB4a\x82\xA6V[[\x87`S\x81\x11\x15a*\xC8Wa*\xC7a\x82\xA6V[[\x03a*\xD7Wa\x84\xD0\x90Pa+wV[`\x06`S\x81\x11\x15a*\xEBWa*\xEAa\x82\xA6V[[\x87`S\x81\x11\x15a*\xFEWa*\xFDa\x82\xA6V[[\x03a+\rWa\x90\x88\x90Pa+vV[`\x08`S\x81\x11\x15a+!Wa+ a\x82\xA6V[[\x87`S\x81\x11\x15a+4Wa+3a\x82\xA6V[[\x03a+CWa\x94p\x90Pa+uV[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[[a+\x86\x81\x83\x87\x86amiV[a-\x1AV[`\x02`S\x81\x11\x15a+\x9FWa+\x9Ea\x82\xA6V[[\x87`S\x81\x11\x15a+\xB2Wa+\xB1a\x82\xA6V[[\x03a+\xC2Wb\x01cx\x90Pa-\x0CV[`\x03`S\x81\x11\x15a+\xD6Wa+\xD5a\x82\xA6V[[\x87`S\x81\x11\x15a+\xE9Wa+\xE8a\x82\xA6V[[\x03a+\xF9Wb\x01\xE8H\x90Pa-\x0BV[`\x04`S\x81\x11\x15a,\rWa,\x0Ca\x82\xA6V[[\x87`S\x81\x11\x15a, Wa,\x1Fa\x82\xA6V[[\x03a,0Wb\x02|\xB8\x90Pa-\nV[`\x05`S\x81\x11\x15a,DWa,Ca\x82\xA6V[[\x87`S\x81\x11\x15a,WWa,Va\x82\xA6V[[\x03a,gWb\x030h\x90Pa-\tV[`\x06`S\x81\x11\x15a,{Wa,za\x82\xA6V[[\x87`S\x81\x11\x15a,\x8EWa,\x8Da\x82\xA6V[[\x03a,\x9EWb\x04=\xF0\x90Pa-\x08V[`\x08`S\x81\x11\x15a,\xB2Wa,\xB1a\x82\xA6V[[\x87`S\x81\x11\x15a,\xC5Wa,\xC4a\x82\xA6V[[\x03a,\xD5Wb\x05\xC4\x90\x90Pa-\x07V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[[a-\x19\x81\x83\x87\x87\x87am\xF9V[[PPPPPPPV[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a-\x9CW`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\x01`\xF8\x1B\x86~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x03a/\xC8W_`S\x81\x11\x15a-\xDDWa-\xDCa\x82\xA6V[[\x87`S\x81\x11\x15a-\xF0Wa-\xEFa\x82\xA6V[[\x03a-\xFFWaa\xA8\x90Pa/\xB7V[`\x02`S\x81\x11\x15a.\x13Wa.\x12a\x82\xA6V[[\x87`S\x81\x11\x15a.&Wa.%a\x82\xA6V[[\x03a.5Wa\xD6\xD8\x90Pa/\xB6V[`\x03`S\x81\x11\x15a.IWa.Ha\x82\xA6V[[\x87`S\x81\x11\x15a.\\Wa.[a\x82\xA6V[[\x03a.kWa\xD6\xD8\x90Pa/\xB5V[`\x04`S\x81\x11\x15a.\x7FWa.~a\x82\xA6V[[\x87`S\x81\x11\x15a.\x92Wa.\x91a\x82\xA6V[[\x03a.\xA2Wb\x01@P\x90Pa/\xB4V[`\x05`S\x81\x11\x15a.\xB6Wa.\xB5a\x82\xA6V[[\x87`S\x81\x11\x15a.\xC9Wa.\xC8a\x82\xA6V[[\x03a.\xD9Wb\x01D8\x90Pa/\xB3V[`\x06`S\x81\x11\x15a.\xEDWa.\xECa\x82\xA6V[[\x87`S\x81\x11\x15a/\0Wa.\xFFa\x82\xA6V[[\x03a/\x10Wb\x01\xC9\x08\x90Pa/\xB2V[`\x07`S\x81\x11\x15a/$Wa/#a\x82\xA6V[[\x87`S\x81\x11\x15a/7Wa/6a\x82\xA6V[[\x03a/GWb\x01\xC9\x08\x90Pa/\xB1V[`\x08`S\x81\x11\x15a/[Wa/Za\x82\xA6V[[\x87`S\x81\x11\x15a/nWa/ma\x82\xA6V[[\x03a/~Wb\x01\xCC\xF0\x90Pa/\xB0V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[[[[a/\xC3\x81\x83\x87\x86amiV[a1\xC4V[_`S\x81\x11\x15a/\xDBWa/\xDAa\x82\xA6V[[\x87`S\x81\x11\x15a/\xEEWa/\xEDa\x82\xA6V[[\x03a/\xFDWae\x90\x90Pa1\xB6V[`\x02`S\x81\x11\x15a0\x11Wa0\x10a\x82\xA6V[[\x87`S\x81\x11\x15a0$Wa0#a\x82\xA6V[[\x03a03Wa\xD6\xD8\x90Pa1\xB5V[`\x03`S\x81\x11\x15a0GWa0Fa\x82\xA6V[[\x87`S\x81\x11\x15a0ZWa0Ya\x82\xA6V[[\x03a0jWb\x01D8\x90Pa1\xB4V[`\x04`S\x81\x11\x15a0~Wa0}a\x82\xA6V[[\x87`S\x81\x11\x15a0\x91Wa0\x90a\x82\xA6V[[\x03a0\xA1Wb\x01O\xF0\x90Pa1\xB3V[`\x05`S\x81\x11\x15a0\xB5Wa0\xB4a\x82\xA6V[[\x87`S\x81\x11\x15a0\xC8Wa0\xC7a\x82\xA6V[[\x03a0\xD8Wb\x01\xD4\xC0\x90Pa1\xB2V[`\x06`S\x81\x11\x15a0\xECWa0\xEBa\x82\xA6V[[\x87`S\x81\x11\x15a0\xFFWa0\xFEa\x82\xA6V[[\x03a1\x0FWb\x01\xDC\x90\x90Pa1\xB1V[`\x07`S\x81\x11\x15a1#Wa1\"a\x82\xA6V[[\x87`S\x81\x11\x15a16Wa15a\x82\xA6V[[\x03a1FWb\x02\x17(\x90Pa1\xB0V[`\x08`S\x81\x11\x15a1ZWa1Ya\x82\xA6V[[\x87`S\x81\x11\x15a1mWa1la\x82\xA6V[[\x03a1}Wb\x02Q\xC0\x90Pa1\xAFV[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[[[[a1\xC3\x81\x83\x87\x87\x87am\xF9V[[PPPPPPPV[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a2FW`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x80`S\x81\x11\x15a2ZWa2Ya\x82\xA6V[[\x85`S\x81\x11\x15a2mWa2la\x82\xA6V[[\x03a2{W` \x90Pa3\xF1V[`\x02`S\x81\x11\x15a2\x8FWa2\x8Ea\x82\xA6V[[\x85`S\x81\x11\x15a2\xA2Wa2\xA1a\x82\xA6V[[\x03a2\xB0W` \x90Pa3\xF0V[`\x03`S\x81\x11\x15a2\xC4Wa2\xC3a\x82\xA6V[[\x85`S\x81\x11\x15a2\xD7Wa2\xD6a\x82\xA6V[[\x03a2\xE5W` \x90Pa3\xEFV[`\x04`S\x81\x11\x15a2\xF9Wa2\xF8a\x82\xA6V[[\x85`S\x81\x11\x15a3\x0CWa3\x0Ba\x82\xA6V[[\x03a3\x1AW` \x90Pa3\xEEV[`\x05`S\x81\x11\x15a3.Wa3-a\x82\xA6V[[\x85`S\x81\x11\x15a3AWa3@a\x82\xA6V[[\x03a3OW` \x90Pa3\xEDV[`\x06`S\x81\x11\x15a3cWa3ba\x82\xA6V[[\x85`S\x81\x11\x15a3vWa3ua\x82\xA6V[[\x03a3\x84W` \x90Pa3\xECV[`\x08`S\x81\x11\x15a3\x98Wa3\x97a\x82\xA6V[[\x85`S\x81\x11\x15a3\xABWa3\xAAa\x82\xA6V[[\x03a3\xB9W` \x90Pa3\xEBV[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[[[a3\xFD\x81\x83\x86\x86amiV[PPPPPV[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a4}W`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\x01`\xF8\x1B\x86~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x03a6\xA9W_`S\x81\x11\x15a4\xBEWa4\xBDa\x82\xA6V[[\x87`S\x81\x11\x15a4\xD1Wa4\xD0a\x82\xA6V[[\x03a4\xE0WaY\xD8\x90Pa6\x98V[`\x02`S\x81\x11\x15a4\xF4Wa4\xF3a\x82\xA6V[[\x87`S\x81\x11\x15a5\x07Wa5\x06a\x82\xA6V[[\x03a5\x16Wa\xD6\xD8\x90Pa6\x97V[`\x03`S\x81\x11\x15a5*Wa5)a\x82\xA6V[[\x87`S\x81\x11\x15a5=Wa5<a\x82\xA6V[[\x03a5LWa\xD6\xD8\x90Pa6\x96V[`\x04`S\x81\x11\x15a5`Wa5_a\x82\xA6V[[\x87`S\x81\x11\x15a5sWa5ra\x82\xA6V[[\x03a5\x83Wb\x01D8\x90Pa6\x95V[`\x05`S\x81\x11\x15a5\x97Wa5\x96a\x82\xA6V[[\x87`S\x81\x11\x15a5\xAAWa5\xA9a\x82\xA6V[[\x03a5\xBAWb\x01H \x90Pa6\x94V[`\x06`S\x81\x11\x15a5\xCEWa5\xCDa\x82\xA6V[[\x87`S\x81\x11\x15a5\xE1Wa5\xE0a\x82\xA6V[[\x03a5\xF1Wb\x01\xC9\x08\x90Pa6\x93V[`\x07`S\x81\x11\x15a6\x05Wa6\x04a\x82\xA6V[[\x87`S\x81\x11\x15a6\x18Wa6\x17a\x82\xA6V[[\x03a6(Wb\x01\xC9\x08\x90Pa6\x92V[`\x08`S\x81\x11\x15a6<Wa6;a\x82\xA6V[[\x87`S\x81\x11\x15a6OWa6Na\x82\xA6V[[\x03a6_Wb\x01\xC9\x08\x90Pa6\x91V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[[[[a6\xA4\x81\x83\x87\x86amiV[a8\xA5V[_`S\x81\x11\x15a6\xBCWa6\xBBa\x82\xA6V[[\x87`S\x81\x11\x15a6\xCFWa6\xCEa\x82\xA6V[[\x03a6\xDEWaY\xD8\x90Pa8\x97V[`\x02`S\x81\x11\x15a6\xF2Wa6\xF1a\x82\xA6V[[\x87`S\x81\x11\x15a7\x05Wa7\x04a\x82\xA6V[[\x03a7\x14Wa\xD6\xD8\x90Pa8\x96V[`\x03`S\x81\x11\x15a7(Wa7'a\x82\xA6V[[\x87`S\x81\x11\x15a7;Wa7:a\x82\xA6V[[\x03a7KWb\x01D8\x90Pa8\x95V[`\x04`S\x81\x11\x15a7_Wa7^a\x82\xA6V[[\x87`S\x81\x11\x15a7rWa7qa\x82\xA6V[[\x03a7\x82Wb\x01L\x08\x90Pa8\x94V[`\x05`S\x81\x11\x15a7\x96Wa7\x95a\x82\xA6V[[\x87`S\x81\x11\x15a7\xA9Wa7\xA8a\x82\xA6V[[\x03a7\xB9Wb\x01\xCC\xF0\x90Pa8\x93V[`\x06`S\x81\x11\x15a7\xCDWa7\xCCa\x82\xA6V[[\x87`S\x81\x11\x15a7\xE0Wa7\xDFa\x82\xA6V[[\x03a7\xF0Wb\x01\xDC\x90\x90Pa8\x92V[`\x07`S\x81\x11\x15a8\x04Wa8\x03a\x82\xA6V[[\x87`S\x81\x11\x15a8\x17Wa8\x16a\x82\xA6V[[\x03a8'Wb\x02\x13@\x90Pa8\x91V[`\x08`S\x81\x11\x15a8;Wa8:a\x82\xA6V[[\x87`S\x81\x11\x15a8NWa8Ma\x82\xA6V[[\x03a8^Wb\x02I\xF0\x90Pa8\x90V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[[[[a8\xA4\x81\x83\x87\x87\x87am\xF9V[[PPPPPPPV[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a9'W`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\x02`S\x81\x11\x15a9<Wa9;a\x82\xA6V[[\x84`S\x81\x11\x15a9OWa9Na\x82\xA6V[[\x03a9^WaY\xD8\x90Pa:\xA3V[`\x03`S\x81\x11\x15a9rWa9qa\x82\xA6V[[\x84`S\x81\x11\x15a9\x85Wa9\x84a\x82\xA6V[[\x03a9\x94WaY\xD8\x90Pa:\xA2V[`\x04`S\x81\x11\x15a9\xA8Wa9\xA7a\x82\xA6V[[\x84`S\x81\x11\x15a9\xBBWa9\xBAa\x82\xA6V[[\x03a9\xCAWa]\xC0\x90Pa:\xA1V[`\x05`S\x81\x11\x15a9\xDEWa9\xDDa\x82\xA6V[[\x84`S\x81\x11\x15a9\xF1Wa9\xF0a\x82\xA6V[[\x03a:\0Wa]\xC0\x90Pa:\xA0V[`\x06`S\x81\x11\x15a:\x14Wa:\x13a\x82\xA6V[[\x84`S\x81\x11\x15a:'Wa:&a\x82\xA6V[[\x03a:6Waa\xA8\x90Pa:\x9FV[`\x08`S\x81\x11\x15a:JWa:Ia\x82\xA6V[[\x84`S\x81\x11\x15a:]Wa:\\a\x82\xA6V[[\x03a:lWau0\x90Pa:\x9EV[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[[a:\xAD\x81\x83au=V[a:\xB7\x83\x82au\xC9V[PPPPV[sP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x8D\xA5\xCB[`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a;\x1AW=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a;>\x91\x90a\x84NV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a;\xADW3`@Q\x7F!\xBF\xDA\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a;\xA4\x91\x90a~\xF2V[`@Q\x80\x91\x03\x90\xFD[_a;\xB6ap\xE4V[\x90P\x80`\x01\x01_\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x15a<FW\x81`@Q\x7F\xF9\x9CO\xD1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a<=\x91\x90a~\xF2V[`@Q\x80\x91\x03\x90\xFD[`\x01\x81`\x01\x01_\x84s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xCC\xA1\xD4c\x84\xCD\xBB\xEE\xF2\xF9\xDA\xDD\xB7m\xB18\x10\x1C\x99\x05\xF8\x18\xD8g\xB60\x19\\\x12\x8D<f`@Q`@Q\x80\x91\x03\x90\xA2PPV[`\x03_a<\xEFao\x89V[\x90P\x80_\x01`\x08\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x80a=7WP\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81_\x01_\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x10\x15[\x15a=nW`@Q\x7F\xF9.\xE8\xA9\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x81\x81_\x01_a\x01\0\n\x81T\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP`\x01\x81_\x01`\x08a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UPa=\xBC\x85ao\xB0V[a=\xC5\x84ap\x16V[a=\xCE\x83ap}V[_\x81_\x01`\x08a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP\x7F\xC7\xF5\x05\xB2\xF3q\xAE!u\xEEI\x13\xF4I\x9E\x1F&3\xA7\xB5\x93c!\xEE\xD1\xCD\xAE\xB6\x11Q\x81\xD2\x82`@Qa>\x18\x91\x90a\x84!V[`@Q\x80\x91\x03\x90\xA1PPPPPV[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a>\xA0W`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\x01`\xF8\x1B\x86~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x03a@(W`\x02`S\x81\x11\x15a>\xE2Wa>\xE1a\x82\xA6V[[\x87`S\x81\x11\x15a>\xF5Wa>\xF4a\x82\xA6V[[\x03a?\x05Wb\x01\xDC\x90\x90Pa@\x17V[`\x03`S\x81\x11\x15a?\x19Wa?\x18a\x82\xA6V[[\x87`S\x81\x11\x15a?,Wa?+a\x82\xA6V[[\x03a?<Wb\x02\xF1\xE8\x90Pa@\x16V[`\x04`S\x81\x11\x15a?PWa?Oa\x82\xA6V[[\x87`S\x81\x11\x15a?cWa?ba\x82\xA6V[[\x03a?sWb\x04\x0B(\x90Pa@\x15V[`\x05`S\x81\x11\x15a?\x87Wa?\x86a\x82\xA6V[[\x87`S\x81\x11\x15a?\x9AWa?\x99a\x82\xA6V[[\x03a?\xAAWb\x05\x91\xC8\x90Pa@\x14V[`\x06`S\x81\x11\x15a?\xBEWa?\xBDa\x82\xA6V[[\x87`S\x81\x11\x15a?\xD1Wa?\xD0a\x82\xA6V[[\x03a?\xE1Wb\n\x9E\xC0\x90Pa@\x13V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[a@#\x81\x83\x87\x86amiV[aA\x7FV[`\x02`S\x81\x11\x15a@<Wa@;a\x82\xA6V[[\x87`S\x81\x11\x15a@OWa@Na\x82\xA6V[[\x03a@_Wb\x02I\xF0\x90PaAqV[`\x03`S\x81\x11\x15a@sWa@ra\x82\xA6V[[\x87`S\x81\x11\x15a@\x86Wa@\x85a\x82\xA6V[[\x03a@\x96Wb\x03c0\x90PaApV[`\x04`S\x81\x11\x15a@\xAAWa@\xA9a\x82\xA6V[[\x87`S\x81\x11\x15a@\xBDWa@\xBCa\x82\xA6V[[\x03a@\xCDWb\x05\x01@\x90PaAoV[`\x05`S\x81\x11\x15a@\xE1Wa@\xE0a\x82\xA6V[[\x87`S\x81\x11\x15a@\xF4Wa@\xF3a\x82\xA6V[[\x03aA\x04Wb\t\x18 \x90PaAnV[`\x06`S\x81\x11\x15aA\x18WaA\x17a\x82\xA6V[[\x87`S\x81\x11\x15aA+WaA*a\x82\xA6V[[\x03aA;Wb\x19\xB9\xF0\x90PaAmV[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[aA~\x81\x83\x87\x87\x87am\xF9V[[PPPPPPPV[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14aB\x01W`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\x01`\xF8\x1B\x86~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x03aC\xBBW`\x02`S\x81\x11\x15aBCWaBBa\x82\xA6V[[\x87`S\x81\x11\x15aBVWaBUa\x82\xA6V[[\x03aBeWay\x18\x90PaC\xAAV[`\x03`S\x81\x11\x15aByWaBxa\x82\xA6V[[\x87`S\x81\x11\x15aB\x8CWaB\x8Ba\x82\xA6V[[\x03aB\x9BWay\x18\x90PaC\xA9V[`\x04`S\x81\x11\x15aB\xAFWaB\xAEa\x82\xA6V[[\x87`S\x81\x11\x15aB\xC2WaB\xC1a\x82\xA6V[[\x03aB\xD1Wa}\0\x90PaC\xA8V[`\x05`S\x81\x11\x15aB\xE5WaB\xE4a\x82\xA6V[[\x87`S\x81\x11\x15aB\xF8WaB\xF7a\x82\xA6V[[\x03aC\x07Wa\x84\xD0\x90PaC\xA7V[`\x06`S\x81\x11\x15aC\x1BWaC\x1Aa\x82\xA6V[[\x87`S\x81\x11\x15aC.WaC-a\x82\xA6V[[\x03aC=Wa\x90\x88\x90PaC\xA6V[`\x08`S\x81\x11\x15aCQWaCPa\x82\xA6V[[\x87`S\x81\x11\x15aCdWaCca\x82\xA6V[[\x03aCsWa\x9C@\x90PaC\xA5V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[[aC\xB6\x81\x83\x87\x86amiV[aEJV[`\x02`S\x81\x11\x15aC\xCFWaC\xCEa\x82\xA6V[[\x87`S\x81\x11\x15aC\xE2WaC\xE1a\x82\xA6V[[\x03aC\xF2Wb\x01kH\x90PaE<V[`\x03`S\x81\x11\x15aD\x06WaD\x05a\x82\xA6V[[\x87`S\x81\x11\x15aD\x19WaD\x18a\x82\xA6V[[\x03aD)Wb\x01\xE8H\x90PaE;V[`\x04`S\x81\x11\x15aD=WaD<a\x82\xA6V[[\x87`S\x81\x11\x15aDPWaDOa\x82\xA6V[[\x03aD`Wb\x02q\0\x90PaE:V[`\x05`S\x81\x11\x15aDtWaDsa\x82\xA6V[[\x87`S\x81\x11\x15aD\x87WaD\x86a\x82\xA6V[[\x03aD\x97Wb\x030h\x90PaE9V[`\x06`S\x81\x11\x15aD\xABWaD\xAAa\x82\xA6V[[\x87`S\x81\x11\x15aD\xBEWaD\xBDa\x82\xA6V[[\x03aD\xCEWb\x04Qx\x90PaE8V[`\x08`S\x81\x11\x15aD\xE2WaD\xE1a\x82\xA6V[[\x87`S\x81\x11\x15aD\xF5WaD\xF4a\x82\xA6V[[\x03aE\x05Wb\x05\xB8\xD8\x90PaE7V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[[aEI\x81\x83\x87\x87\x87am\xF9V[[PPPPPPPV[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14aE\xCCW`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\x01`\xF8\x1B\x86~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x03aGTW`\x02`S\x81\x11\x15aF\x0EWaF\ra\x82\xA6V[[\x87`S\x81\x11\x15aF!WaF a\x82\xA6V[[\x03aF1Wb\x01[\xA8\x90PaGCV[`\x03`S\x81\x11\x15aFEWaFDa\x82\xA6V[[\x87`S\x81\x11\x15aFXWaFWa\x82\xA6V[[\x03aFhWb\x01[\xA8\x90PaGBV[`\x04`S\x81\x11\x15aF|WaF{a\x82\xA6V[[\x87`S\x81\x11\x15aF\x8FWaF\x8Ea\x82\xA6V[[\x03aF\x9FWb\x01\xC9\x08\x90PaGAV[`\x05`S\x81\x11\x15aF\xB3WaF\xB2a\x82\xA6V[[\x87`S\x81\x11\x15aF\xC6WaF\xC5a\x82\xA6V[[\x03aF\xD6Wb\x02F\x08\x90PaG@V[`\x06`S\x81\x11\x15aF\xEAWaF\xE9a\x82\xA6V[[\x87`S\x81\x11\x15aF\xFDWaF\xFCa\x82\xA6V[[\x03aG\rWb\x02\xBF \x90PaG?V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[aGO\x81\x83\x87\x86amiV[aH\xABV[`\x02`S\x81\x11\x15aGhWaGga\x82\xA6V[[\x87`S\x81\x11\x15aG{WaGza\x82\xA6V[[\x03aG\x8BWb\x01\xD8\xA8\x90PaH\x9DV[`\x03`S\x81\x11\x15aG\x9FWaG\x9Ea\x82\xA6V[[\x87`S\x81\x11\x15aG\xB2WaG\xB1a\x82\xA6V[[\x03aG\xC2Wb\x026h\x90PaH\x9CV[`\x04`S\x81\x11\x15aG\xD6WaG\xD5a\x82\xA6V[[\x87`S\x81\x11\x15aG\xE9WaG\xE8a\x82\xA6V[[\x03aG\xF9Wb\x02\xBF \x90PaH\x9BV[`\x05`S\x81\x11\x15aH\rWaH\x0Ca\x82\xA6V[[\x87`S\x81\x11\x15aH WaH\x1Fa\x82\xA6V[[\x03aH0Wb\x03S\x90\x90PaH\x9AV[`\x06`S\x81\x11\x15aHDWaHCa\x82\xA6V[[\x87`S\x81\x11\x15aHWWaHVa\x82\xA6V[[\x03aHgWb\x04l\xD0\x90PaH\x99V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[aH\xAA\x81\x83\x87\x87\x87am\xF9V[[PPPPPPPV[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14aI-W`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\x01`\xF8\x1B\x86~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x14aI\x8DW`@Q\x7Fj\xA9\xEB\x05\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x02`S\x81\x11\x15aI\xA1WaI\xA0a\x82\xA6V[[\x87`S\x81\x11\x15aI\xB4WaI\xB3a\x82\xA6V[[\x03aI\xC4Wb\x034P\x90PaJ\xD6V[`\x03`S\x81\x11\x15aI\xD8WaI\xD7a\x82\xA6V[[\x87`S\x81\x11\x15aI\xEBWaI\xEAa\x82\xA6V[[\x03aI\xFBWb\x04\x9B\xB0\x90PaJ\xD5V[`\x04`S\x81\x11\x15aJ\x0FWaJ\x0Ea\x82\xA6V[[\x87`S\x81\x11\x15aJ\"WaJ!a\x82\xA6V[[\x03aJ2Wb\x06\xAE\xF0\x90PaJ\xD4V[`\x05`S\x81\x11\x15aJFWaJEa\x82\xA6V[[\x87`S\x81\x11\x15aJYWaJXa\x82\xA6V[[\x03aJiWb\n\xE8\xF8\x90PaJ\xD3V[`\x06`S\x81\x11\x15aJ}WaJ|a\x82\xA6V[[\x87`S\x81\x11\x15aJ\x90WaJ\x8Fa\x82\xA6V[[\x03aJ\xA0Wb\x12\xB1(\x90PaJ\xD2V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[aJ\xE2\x81\x83\x87\x86amiV[PPPPPPPV[_\x80_aJ\xF6ap\xE4V[\x90P_C\x90P\x80e\xFF\xFF\xFF\xFF\xFF\xFF\x16\x82_\x01`\x0C\x90T\x90a\x01\0\n\x90\x04e\xFF\xFF\xFF\xFF\xFF\xFF\x16e\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14aK5W\x80_\x93P\x93PPPaKSV[\x80\x82_\x01`\x06\x90T\x90a\x01\0\n\x90\x04e\xFF\xFF\xFF\xFF\xFF\xFF\x16\x93P\x93PPP[\x90\x91V[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14aK\xD0W`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\x01`\xF8\x1B\x86~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x03aM\xC0W_`S\x81\x11\x15aL\x11WaL\x10a\x82\xA6V[[\x87`S\x81\x11\x15aL$WaL#a\x82\xA6V[[\x03aL3WaU\xF0\x90PaM\xAFV[`\x02`S\x81\x11\x15aLGWaLFa\x82\xA6V[[\x87`S\x81\x11\x15aLZWaLYa\x82\xA6V[[\x03aLiWay\x18\x90PaM\xAEV[`\x03`S\x81\x11\x15aL}WaL|a\x82\xA6V[[\x87`S\x81\x11\x15aL\x90WaL\x8Fa\x82\xA6V[[\x03aL\x9FWay\x18\x90PaM\xADV[`\x04`S\x81\x11\x15aL\xB3WaL\xB2a\x82\xA6V[[\x87`S\x81\x11\x15aL\xC6WaL\xC5a\x82\xA6V[[\x03aL\xD5Wa}\0\x90PaM\xACV[`\x05`S\x81\x11\x15aL\xE9WaL\xE8a\x82\xA6V[[\x87`S\x81\x11\x15aL\xFCWaL\xFBa\x82\xA6V[[\x03aM\x0BWa\x84\xD0\x90PaM\xABV[`\x06`S\x81\x11\x15aM\x1FWaM\x1Ea\x82\xA6V[[\x87`S\x81\x11\x15aM2WaM1a\x82\xA6V[[\x03aMAWa\x90\x88\x90PaM\xAAV[`\x08`S\x81\x11\x15aMUWaMTa\x82\xA6V[[\x87`S\x81\x11\x15aMhWaMga\x82\xA6V[[\x03aMwWa\x98X\x90PaM\xA9V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[[[aM\xBB\x81\x83\x87\x86amiV[aO\x7FV[_`S\x81\x11\x15aM\xD3WaM\xD2a\x82\xA6V[[\x87`S\x81\x11\x15aM\xE6WaM\xE5a\x82\xA6V[[\x03aM\xF5WaU\xF0\x90PaOqV[`\x02`S\x81\x11\x15aN\tWaN\x08a\x82\xA6V[[\x87`S\x81\x11\x15aN\x1CWaN\x1Ba\x82\xA6V[[\x03aN+Way\x18\x90PaOpV[`\x03`S\x81\x11\x15aN?WaN>a\x82\xA6V[[\x87`S\x81\x11\x15aNRWaNQa\x82\xA6V[[\x03aNaWay\x18\x90PaOoV[`\x04`S\x81\x11\x15aNuWaNta\x82\xA6V[[\x87`S\x81\x11\x15aN\x88WaN\x87a\x82\xA6V[[\x03aN\x97Wa}\0\x90PaOnV[`\x05`S\x81\x11\x15aN\xABWaN\xAAa\x82\xA6V[[\x87`S\x81\x11\x15aN\xBEWaN\xBDa\x82\xA6V[[\x03aN\xCDWa\x84\xD0\x90PaOmV[`\x06`S\x81\x11\x15aN\xE1WaN\xE0a\x82\xA6V[[\x87`S\x81\x11\x15aN\xF4WaN\xF3a\x82\xA6V[[\x03aO\x03Wa\x90\x88\x90PaOlV[`\x08`S\x81\x11\x15aO\x17WaO\x16a\x82\xA6V[[\x87`S\x81\x11\x15aO*WaO)a\x82\xA6V[[\x03aO9Wa\x98X\x90PaOkV[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[[[aO~\x81\x83\x87\x87\x87am\xF9V[[PPPPPPPV[sP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x8D\xA5\xCB[`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15aO\xE5W=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90aP\t\x91\x90a\x84NV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14aPxW3`@Q\x7F!\xBF\xDA\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aPo\x91\x90a~\xF2V[`@Q\x80\x91\x03\x90\xFD[aP\x81\x81ao\xB0V[PV[sP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x8D\xA5\xCB[`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15aP\xE1W=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90aQ\x05\x91\x90a\x84NV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14aQtW3`@Q\x7F!\xBF\xDA\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aQk\x91\x90a~\xF2V[`@Q\x80\x91\x03\x90\xFD[aQ}\x81ap}V[PV[`@Q\x80`@\x01`@R\x80`\x05\x81R` \x01\x7F5.0.0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81RP\x81V[_\x80aQ\xC3ap\xE4V[\x90P\x80_\x01_\x90T\x90a\x01\0\n\x90\x04e\xFF\xFF\xFF\xFF\xFF\xFF\x16\x91PP\x90V[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14aRYW`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x80`S\x81\x11\x15aRmWaRla\x82\xA6V[[\x84`S\x81\x11\x15aR\x80WaR\x7Fa\x82\xA6V[[\x03aR\x8EW` \x90PaT:V[`\x02`S\x81\x11\x15aR\xA2WaR\xA1a\x82\xA6V[[\x84`S\x81\x11\x15aR\xB5WaR\xB4a\x82\xA6V[[\x03aR\xC3W` \x90PaT9V[`\x03`S\x81\x11\x15aR\xD7WaR\xD6a\x82\xA6V[[\x84`S\x81\x11\x15aR\xEAWaR\xE9a\x82\xA6V[[\x03aR\xF8W` \x90PaT8V[`\x04`S\x81\x11\x15aS\x0CWaS\x0Ba\x82\xA6V[[\x84`S\x81\x11\x15aS\x1FWaS\x1Ea\x82\xA6V[[\x03aS-W` \x90PaT7V[`\x05`S\x81\x11\x15aSAWaS@a\x82\xA6V[[\x84`S\x81\x11\x15aSTWaSSa\x82\xA6V[[\x03aSbW` \x90PaT6V[`\x06`S\x81\x11\x15aSvWaSua\x82\xA6V[[\x84`S\x81\x11\x15aS\x89WaS\x88a\x82\xA6V[[\x03aS\x97W` \x90PaT5V[`\x07`S\x81\x11\x15aS\xABWaS\xAAa\x82\xA6V[[\x84`S\x81\x11\x15aS\xBEWaS\xBDa\x82\xA6V[[\x03aS\xCCW` \x90PaT4V[`\x08`S\x81\x11\x15aS\xE0WaS\xDFa\x82\xA6V[[\x84`S\x81\x11\x15aS\xF3WaS\xF2a\x82\xA6V[[\x03aT\x01W` \x90PaT3V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[[[[aTD\x81\x83au=V[aTN\x83\x82au\xC9V[PPPPV[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14aT\xCDW`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\x01`\xF8\x1B\x86~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x03aV\xBDW_`S\x81\x11\x15aU\x0EWaU\ra\x82\xA6V[[\x87`S\x81\x11\x15aU!WaU a\x82\xA6V[[\x03aU0WaU\xF0\x90PaV\xACV[`\x02`S\x81\x11\x15aUDWaUCa\x82\xA6V[[\x87`S\x81\x11\x15aUWWaUVa\x82\xA6V[[\x03aUfWau0\x90PaV\xABV[`\x03`S\x81\x11\x15aUzWaUya\x82\xA6V[[\x87`S\x81\x11\x15aU\x8DWaU\x8Ca\x82\xA6V[[\x03aU\x9CWau0\x90PaV\xAAV[`\x04`S\x81\x11\x15aU\xB0WaU\xAFa\x82\xA6V[[\x87`S\x81\x11\x15aU\xC3WaU\xC2a\x82\xA6V[[\x03aU\xD2Wa}\0\x90PaV\xA9V[`\x05`S\x81\x11\x15aU\xE6WaU\xE5a\x82\xA6V[[\x87`S\x81\x11\x15aU\xF9WaU\xF8a\x82\xA6V[[\x03aV\x08Wa\x84\xD0\x90PaV\xA8V[`\x06`S\x81\x11\x15aV\x1CWaV\x1Ba\x82\xA6V[[\x87`S\x81\x11\x15aV/WaV.a\x82\xA6V[[\x03aV>Wa\x90\x88\x90PaV\xA7V[`\x08`S\x81\x11\x15aVRWaVQa\x82\xA6V[[\x87`S\x81\x11\x15aVeWaVda\x82\xA6V[[\x03aVtWa\x94p\x90PaV\xA6V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[[[aV\xB8\x81\x83\x87\x86amiV[aX|V[_`S\x81\x11\x15aV\xD0WaV\xCFa\x82\xA6V[[\x87`S\x81\x11\x15aV\xE3WaV\xE2a\x82\xA6V[[\x03aV\xF2Wa]\xC0\x90PaXnV[`\x02`S\x81\x11\x15aW\x06WaW\x05a\x82\xA6V[[\x87`S\x81\x11\x15aW\x19WaW\x18a\x82\xA6V[[\x03aW(Wau0\x90PaXmV[`\x03`S\x81\x11\x15aW<WaW;a\x82\xA6V[[\x87`S\x81\x11\x15aWOWaWNa\x82\xA6V[[\x03aW^Way\x18\x90PaXlV[`\x04`S\x81\x11\x15aWrWaWqa\x82\xA6V[[\x87`S\x81\x11\x15aW\x85WaW\x84a\x82\xA6V[[\x03aW\x94Wa}\0\x90PaXkV[`\x05`S\x81\x11\x15aW\xA8WaW\xA7a\x82\xA6V[[\x87`S\x81\x11\x15aW\xBBWaW\xBAa\x82\xA6V[[\x03aW\xCAWa\x84\xD0\x90PaXjV[`\x06`S\x81\x11\x15aW\xDEWaW\xDDa\x82\xA6V[[\x87`S\x81\x11\x15aW\xF1WaW\xF0a\x82\xA6V[[\x03aX\0Wa\x90\x88\x90PaXiV[`\x08`S\x81\x11\x15aX\x14WaX\x13a\x82\xA6V[[\x87`S\x81\x11\x15aX'WaX&a\x82\xA6V[[\x03aX6Wa\x94p\x90PaXhV[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[[[aX{\x81\x83\x87\x87\x87am\xF9V[[PPPPPPPV[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14aX\xFEW`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\x01`\xF8\x1B\x86~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x03aZ\x86W`\x02`S\x81\x11\x15aY@WaY?a\x82\xA6V[[\x87`S\x81\x11\x15aYSWaYRa\x82\xA6V[[\x03aYcWb\x01H \x90PaZuV[`\x03`S\x81\x11\x15aYwWaYva\x82\xA6V[[\x87`S\x81\x11\x15aY\x8AWaY\x89a\x82\xA6V[[\x03aY\x9AWb\x01kH\x90PaZtV[`\x04`S\x81\x11\x15aY\xAEWaY\xADa\x82\xA6V[[\x87`S\x81\x11\x15aY\xC1WaY\xC0a\x82\xA6V[[\x03aY\xD1Wb\x01s\x18\x90PaZsV[`\x05`S\x81\x11\x15aY\xE5WaY\xE4a\x82\xA6V[[\x87`S\x81\x11\x15aY\xF8WaY\xF7a\x82\xA6V[[\x03aZ\x08Wb\x02\x07\x88\x90PaZrV[`\x06`S\x81\x11\x15aZ\x1CWaZ\x1Ba\x82\xA6V[[\x87`S\x81\x11\x15aZ/WaZ.a\x82\xA6V[[\x03aZ?Wb\x02\x9F\xE0\x90PaZqV[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[aZ\x81\x81\x83\x87\x86amiV[a[\xDDV[`\x02`S\x81\x11\x15aZ\x9AWaZ\x99a\x82\xA6V[[\x87`S\x81\x11\x15aZ\xADWaZ\xACa\x82\xA6V[[\x03aZ\xBDWb\x01W\xC0\x90Pa[\xCFV[`\x03`S\x81\x11\x15aZ\xD1WaZ\xD0a\x82\xA6V[[\x87`S\x81\x11\x15aZ\xE4WaZ\xE3a\x82\xA6V[[\x03aZ\xF4Wb\x01kH\x90Pa[\xCEV[`\x04`S\x81\x11\x15a[\x08Wa[\x07a\x82\xA6V[[\x87`S\x81\x11\x15a[\x1BWa[\x1Aa\x82\xA6V[[\x03a[+Wb\x01\xE8H\x90Pa[\xCDV[`\x05`S\x81\x11\x15a[?Wa[>a\x82\xA6V[[\x87`S\x81\x11\x15a[RWa[Qa\x82\xA6V[[\x03a[bWb\x02x\xD0\x90Pa[\xCCV[`\x06`S\x81\x11\x15a[vWa[ua\x82\xA6V[[\x87`S\x81\x11\x15a[\x89Wa[\x88a\x82\xA6V[[\x03a[\x99Wb\x03\xF3\xB8\x90Pa[\xCBV[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[a[\xDC\x81\x83\x87\x87\x87am\xF9V[[PPPPPPPV[_a[\xEFap\xE4V[_\x01`\x18\x90T\x90a\x01\0\n\x90\x04e\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P\x90V[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\\\x82W`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\x01`\xF8\x1B\x86~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x03a^\x08W`\x02`S\x81\x11\x15a\\\xC4Wa\\\xC3a\x82\xA6V[[\x87`S\x81\x11\x15a\\\xD7Wa\\\xD6a\x82\xA6V[[\x03a\\\xE6Wa\xCB \x90Pa]\xF7V[`\x03`S\x81\x11\x15a\\\xFAWa\\\xF9a\x82\xA6V[[\x87`S\x81\x11\x15a]\rWa]\x0Ca\x82\xA6V[[\x03a]\x1CWa\xD6\xD8\x90Pa]\xF6V[`\x04`S\x81\x11\x15a]0Wa]/a\x82\xA6V[[\x87`S\x81\x11\x15a]CWa]Ba\x82\xA6V[[\x03a]SWb\x01H \x90Pa]\xF5V[`\x05`S\x81\x11\x15a]gWa]fa\x82\xA6V[[\x87`S\x81\x11\x15a]zWa]ya\x82\xA6V[[\x03a]\x8AWb\x01\xC5 \x90Pa]\xF4V[`\x06`S\x81\x11\x15a]\x9EWa]\x9Da\x82\xA6V[[\x87`S\x81\x11\x15a]\xB1Wa]\xB0a\x82\xA6V[[\x03a]\xC1Wb\x02F\x08\x90Pa]\xF3V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[a^\x03\x81\x83\x87\x86amiV[a_^V[`\x02`S\x81\x11\x15a^\x1CWa^\x1Ba\x82\xA6V[[\x87`S\x81\x11\x15a^/Wa^.a\x82\xA6V[[\x03a^>Wa\xF6\x18\x90Pa_PV[`\x03`S\x81\x11\x15a^RWa^Qa\x82\xA6V[[\x87`S\x81\x11\x15a^eWa^da\x82\xA6V[[\x03a^uWb\x01H \x90Pa_OV[`\x04`S\x81\x11\x15a^\x89Wa^\x88a\x82\xA6V[[\x87`S\x81\x11\x15a^\x9CWa^\x9Ba\x82\xA6V[[\x03a^\xACWb\x01\xCC\xF0\x90Pa_NV[`\x05`S\x81\x11\x15a^\xC0Wa^\xBFa\x82\xA6V[[\x87`S\x81\x11\x15a^\xD3Wa^\xD2a\x82\xA6V[[\x03a^\xE3Wb\x02Q\xC0\x90Pa_MV[`\x06`S\x81\x11\x15a^\xF7Wa^\xF6a\x82\xA6V[[\x87`S\x81\x11\x15a_\nWa_\ta\x82\xA6V[[\x03a_\x1AWb\x034P\x90Pa_LV[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[a_]\x81\x83\x87\x87\x87am\xF9V[[PPPPPPPV[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a_\xE0W`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\x01`\xF8\x1B\x86~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x03aa\xD0W_`S\x81\x11\x15a`!Wa` a\x82\xA6V[[\x87`S\x81\x11\x15a`4Wa`3a\x82\xA6V[[\x03a`CWaU\xF0\x90Paa\xBFV[`\x02`S\x81\x11\x15a`WWa`Va\x82\xA6V[[\x87`S\x81\x11\x15a`jWa`ia\x82\xA6V[[\x03a`yWay\x18\x90Paa\xBEV[`\x03`S\x81\x11\x15a`\x8DWa`\x8Ca\x82\xA6V[[\x87`S\x81\x11\x15a`\xA0Wa`\x9Fa\x82\xA6V[[\x03a`\xAFWay\x18\x90Paa\xBDV[`\x04`S\x81\x11\x15a`\xC3Wa`\xC2a\x82\xA6V[[\x87`S\x81\x11\x15a`\xD6Wa`\xD5a\x82\xA6V[[\x03a`\xE5Wa}\0\x90Paa\xBCV[`\x05`S\x81\x11\x15a`\xF9Wa`\xF8a\x82\xA6V[[\x87`S\x81\x11\x15aa\x0CWaa\x0Ba\x82\xA6V[[\x03aa\x1BWa\x84\xD0\x90Paa\xBBV[`\x06`S\x81\x11\x15aa/Waa.a\x82\xA6V[[\x87`S\x81\x11\x15aaBWaaAa\x82\xA6V[[\x03aaQWa\x90\x88\x90Paa\xBAV[`\x08`S\x81\x11\x15aaeWaada\x82\xA6V[[\x87`S\x81\x11\x15aaxWaawa\x82\xA6V[[\x03aa\x87Wa\x94p\x90Paa\xB9V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[[[aa\xCB\x81\x83\x87\x86amiV[ac\x8FV[_`S\x81\x11\x15aa\xE3Waa\xE2a\x82\xA6V[[\x87`S\x81\x11\x15aa\xF6Waa\xF5a\x82\xA6V[[\x03ab\x05Waa\xA8\x90Pac\x81V[`\x02`S\x81\x11\x15ab\x19Wab\x18a\x82\xA6V[[\x87`S\x81\x11\x15ab,Wab+a\x82\xA6V[[\x03ab;Way\x18\x90Pac\x80V[`\x03`S\x81\x11\x15abOWabNa\x82\xA6V[[\x87`S\x81\x11\x15abbWabaa\x82\xA6V[[\x03abqWay\x18\x90Pac\x7FV[`\x04`S\x81\x11\x15ab\x85Wab\x84a\x82\xA6V[[\x87`S\x81\x11\x15ab\x98Wab\x97a\x82\xA6V[[\x03ab\xA7Wa}\0\x90Pac~V[`\x05`S\x81\x11\x15ab\xBBWab\xBAa\x82\xA6V[[\x87`S\x81\x11\x15ab\xCEWab\xCDa\x82\xA6V[[\x03ab\xDDWa\x84\xD0\x90Pac}V[`\x06`S\x81\x11\x15ab\xF1Wab\xF0a\x82\xA6V[[\x87`S\x81\x11\x15ac\x04Wac\x03a\x82\xA6V[[\x03ac\x13Wa\x90\x88\x90Pac|V[`\x08`S\x81\x11\x15ac'Wac&a\x82\xA6V[[\x87`S\x81\x11\x15ac:Wac9a\x82\xA6V[[\x03acIWa\x94p\x90Pac{V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[[[ac\x8E\x81\x83\x87\x87\x87am\xF9V[[PPPPPPPV[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14ad\x11W`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x80`S\x81\x11\x15ad%Wad$a\x82\xA6V[[\x84`S\x81\x11\x15ad8Wad7a\x82\xA6V[[\x03adGWaJ8\x90Pae\xC3V[`\x02`S\x81\x11\x15ad[WadZa\x82\xA6V[[\x84`S\x81\x11\x15adnWadma\x82\xA6V[[\x03ad}WaY\xD8\x90Pae\xC2V[`\x03`S\x81\x11\x15ad\x91Wad\x90a\x82\xA6V[[\x84`S\x81\x11\x15ad\xA4Wad\xA3a\x82\xA6V[[\x03ad\xB3WaY\xD8\x90Pae\xC1V[`\x04`S\x81\x11\x15ad\xC7Wad\xC6a\x82\xA6V[[\x84`S\x81\x11\x15ad\xDAWad\xD9a\x82\xA6V[[\x03ad\xE9Wa]\xC0\x90Pae\xC0V[`\x05`S\x81\x11\x15ad\xFDWad\xFCa\x82\xA6V[[\x84`S\x81\x11\x15ae\x10Wae\x0Fa\x82\xA6V[[\x03ae\x1FWa]\xC0\x90Pae\xBFV[`\x06`S\x81\x11\x15ae3Wae2a\x82\xA6V[[\x84`S\x81\x11\x15aeFWaeEa\x82\xA6V[[\x03aeUWaa\xA8\x90Pae\xBEV[`\x08`S\x81\x11\x15aeiWaeha\x82\xA6V[[\x84`S\x81\x11\x15ae|Wae{a\x82\xA6V[[\x03ae\x8BWau0\x90Pae\xBDV[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[[[ae\xCD\x81\x83au=V[ae\xD7\x83\x82au\xC9V[PPPPV[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14afVW`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\x01`\xF8\x1B\x86~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x03ag\xDEW`\x02`S\x81\x11\x15af\x98Waf\x97a\x82\xA6V[[\x87`S\x81\x11\x15af\xABWaf\xAAa\x82\xA6V[[\x03af\xBBWb\x01H \x90Pag\xCDV[`\x03`S\x81\x11\x15af\xCFWaf\xCEa\x82\xA6V[[\x87`S\x81\x11\x15af\xE2Waf\xE1a\x82\xA6V[[\x03af\xF2Wb\x01kH\x90Pag\xCCV[`\x04`S\x81\x11\x15ag\x06Wag\x05a\x82\xA6V[[\x87`S\x81\x11\x15ag\x19Wag\x18a\x82\xA6V[[\x03ag)Wb\x01s\x18\x90Pag\xCBV[`\x05`S\x81\x11\x15ag=Wag<a\x82\xA6V[[\x87`S\x81\x11\x15agPWagOa\x82\xA6V[[\x03ag`Wb\x02\x07\x88\x90Pag\xCAV[`\x06`S\x81\x11\x15agtWagsa\x82\xA6V[[\x87`S\x81\x11\x15ag\x87Wag\x86a\x82\xA6V[[\x03ag\x97Wb\x02\x9F\xE0\x90Pag\xC9V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[ag\xD9\x81\x83\x87\x86amiV[ai5V[`\x02`S\x81\x11\x15ag\xF2Wag\xF1a\x82\xA6V[[\x87`S\x81\x11\x15ah\x05Wah\x04a\x82\xA6V[[\x03ah\x15Wb\x01cx\x90Pai'V[`\x03`S\x81\x11\x15ah)Wah(a\x82\xA6V[[\x87`S\x81\x11\x15ah<Wah;a\x82\xA6V[[\x03ahLWb\x01kH\x90Pai&V[`\x04`S\x81\x11\x15ah`Wah_a\x82\xA6V[[\x87`S\x81\x11\x15ahsWahra\x82\xA6V[[\x03ah\x83Wb\x01\xE8H\x90Pai%V[`\x05`S\x81\x11\x15ah\x97Wah\x96a\x82\xA6V[[\x87`S\x81\x11\x15ah\xAAWah\xA9a\x82\xA6V[[\x03ah\xBAWb\x02x\xD0\x90Pai$V[`\x06`S\x81\x11\x15ah\xCEWah\xCDa\x82\xA6V[[\x87`S\x81\x11\x15ah\xE1Wah\xE0a\x82\xA6V[[\x03ah\xF1Wb\x03\xF7\xA0\x90Pai#V[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[ai4\x81\x83\x87\x87\x87am\xF9V[[PPPPPPPV[_\x80aiHap\xE4V[\x90P\x80`\x01\x01_\x84s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x91PP\x91\x90PV[s\xE3\xA9\x10Z:\x93\"S\xA7\x0F\x12n\xB1\xE3\xB5\x89\xC6C\xDD$s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14aj\x17W`@Q\x7F1\xA8\x1A\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\x01`\xF8\x1B\x86~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x03ak\xD1W`\x02`S\x81\x11\x15ajYWajXa\x82\xA6V[[\x87`S\x81\x11\x15ajlWajka\x82\xA6V[[\x03aj{Wa}\0\x90Pak\xC0V[`\x03`S\x81\x11\x15aj\x8FWaj\x8Ea\x82\xA6V[[\x87`S\x81\x11\x15aj\xA2Waj\xA1a\x82\xA6V[[\x03aj\xB1Wa}\0\x90Pak\xBFV[`\x04`S\x81\x11\x15aj\xC5Waj\xC4a\x82\xA6V[[\x87`S\x81\x11\x15aj\xD8Waj\xD7a\x82\xA6V[[\x03aj\xE7Wa}\0\x90Pak\xBEV[`\x05`S\x81\x11\x15aj\xFBWaj\xFAa\x82\xA6V[[\x87`S\x81\x11\x15ak\x0EWak\ra\x82\xA6V[[\x03ak\x1DWa\x84\xD0\x90Pak\xBDV[`\x06`S\x81\x11\x15ak1Wak0a\x82\xA6V[[\x87`S\x81\x11\x15akDWakCa\x82\xA6V[[\x03akSWa\x90\x88\x90Pak\xBCV[`\x08`S\x81\x11\x15akgWakfa\x82\xA6V[[\x87`S\x81\x11\x15akzWakya\x82\xA6V[[\x03ak\x89Wa\x98X\x90Pak\xBBV[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[[ak\xCC\x81\x83\x87\x86amiV[am`V[`\x02`S\x81\x11\x15ak\xE5Wak\xE4a\x82\xA6V[[\x87`S\x81\x11\x15ak\xF8Wak\xF7a\x82\xA6V[[\x03al\x08Wb\x01g`\x90PamRV[`\x03`S\x81\x11\x15al\x1CWal\x1Ba\x82\xA6V[[\x87`S\x81\x11\x15al/Wal.a\x82\xA6V[[\x03al?Wb\x01\xE8H\x90PamQV[`\x04`S\x81\x11\x15alSWalRa\x82\xA6V[[\x87`S\x81\x11\x15alfWalea\x82\xA6V[[\x03alvWb\x02x\xD0\x90PamPV[`\x05`S\x81\x11\x15al\x8AWal\x89a\x82\xA6V[[\x87`S\x81\x11\x15al\x9DWal\x9Ca\x82\xA6V[[\x03al\xADWb\x03,\x80\x90PamOV[`\x06`S\x81\x11\x15al\xC1Wal\xC0a\x82\xA6V[[\x87`S\x81\x11\x15al\xD4Wal\xD3a\x82\xA6V[[\x03al\xE4Wb\x04&\x80\x90PamNV[`\x08`S\x81\x11\x15al\xF8Wal\xF7a\x82\xA6V[[\x87`S\x81\x11\x15am\x0BWam\na\x82\xA6V[[\x03am\x1BWb\x05\xC4\x90\x90PamMV[`@Q\x7F\x9B\xA6\x06\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[[[[[[am_\x81\x83\x87\x87\x87am\xF9V[[PPPPPPPV[ams\x84\x84au=V[_am}\x83au\xD0V[\x85am\x88\x91\x90a\x84\xAFV[\x90Pam\x92ap\xE4V[_\x01`\x12\x90T\x90a\x01\0\n\x90\x04e\xFF\xFF\xFF\xFF\xFF\xFF\x16e\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81\x11\x15am\xE8W`@Q\x7F\xFC4Hp\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[am\xF2\x82\x82au\xC9V[PPPPPV[an\x03\x85\x85au=V[_an\x1Ean\x10\x85au\xD0V[an\x19\x85au\xD0V[au\xDAV[\x86an)\x91\x90a\x84\xAFV[\x90Pan3ap\xE4V[_\x01`\x12\x90T\x90a\x01\0\n\x90\x04e\xFF\xFF\xFF\xFF\xFF\xFF\x16e\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81\x11\x15an\x89W`@Q\x7F\xFC4Hp\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[an\x93\x82\x82au\xC9V[PPPPPPV[``_`\x01an\xA9\x84au\xF3V[\x01\x90P_\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15an\xC7Wan\xC6a\x80+V[[`@Q\x90\x80\x82R\x80`\x1F\x01`\x1F\x19\x16` \x01\x82\x01`@R\x80\x15an\xF9W\x81` \x01`\x01\x82\x02\x806\x837\x80\x82\x01\x91PP\x90P[P\x90P_\x82` \x01\x82\x01\x90P[`\x01\x15aoZW\x80\x80`\x01\x90\x03\x91PP\x7F0123456789abcdef\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\n\x86\x06\x1A\x81S`\n\x85\x81aoOWaoNa\x84\xE2V[[\x04\x94P_\x85\x03ao\x06W[\x81\x93PPPP\x91\x90PV[_aonao\x89V[_\x01_\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P\x90V[_\x7F\xF0\xC5~\x16\x84\r\xF0@\xF1P\x88\xDC/\x81\xFE9\x1C9#\xBE\xC7>#\xA9f.\xFC\x9C\"\x9Cj\0\x90P\x90V[\x80ao\xB9ap\xE4V[_\x01_a\x01\0\n\x81T\x81e\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83e\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP\x7F\xC1\xF1\xFC\xAA\x89\x8A\xAE\"c\xDD\xEDq.\x17\x98\x08?\xCA\x92r\xFF\x80>\xE4\x15\x0C\xE4\x8F\x86\x19\x89\x1A\x81`@Qap\x0B\x91\x90a~\xCAV[`@Q\x80\x91\x03\x90\xA1PV[\x80ap\x1Fap\xE4V[_\x01`\x12a\x01\0\n\x81T\x81e\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83e\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP\x7FU\x11\xB1\x85\x1F\xC4\n&)\xC8U\xBA\xB7\xAD\xCE2v\xC4p\xD8\x19\x0E\xB0\x141\xE4\x18\xDC*\xF1>\x8E\x81`@Qapr\x91\x90a~\xCAV[`@Q\x80\x91\x03\x90\xA1PV[\x80ap\x86ap\xE4V[_\x01`\x18a\x01\0\n\x81T\x81e\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83e\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP\x7Fd\xCB\x9Ez\xE6I|Y\x08\x0C\xDB\xC0HU.\x12=R\xAAB@\xE17u\x8A\x175\x82xia\xCA\x81`@Qap\xD9\x91\x90a~\xCAV[`@Q\x80\x91\x03\x90\xA1PV[_\x7F\xC1:\xF6\xC5\x14\xBF\xF8\x99\x7F0\xC9\0\x03\xBA\xA8+\xD0*\xAD\x97\x81y\xD1\xCEX\xD8\\C\x19\xADe\0\x90P\x90V[aq\x15\x86\x86au=V[_aqAaq\"\x86au\xD0V[aq<aq.\x87au\xD0V[aq7\x87au\xD0V[au\xDAV[au\xDAV[\x87aqL\x91\x90a\x84\xAFV[\x90PaqVap\xE4V[_\x01`\x12\x90T\x90a\x01\0\n\x90\x04e\xFF\xFF\xFF\xFF\xFF\xFF\x16e\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81\x11\x15aq\xACW`@Q\x7F\xFC4Hp\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[aq\xB6\x82\x82au\xC9V[PPPPPPPV[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x160s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14\x80arlWP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16arSawDV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14\x15[\x15ar\xA3W`@Q\x7F\xE0|\x8D\xBA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[V[sP\x15|\xFF\xD6\xBB\xFA-\xEC\xE2\x04\xA8\x9E\xC4\x19\xC2>\xF5u]s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x8D\xA5\xCB[`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15as\x02W=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90as&\x91\x90a\x84NV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14as\x95W3`@Q\x7F!\xBF\xDA\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01as\x8C\x91\x90a~\xF2V[`@Q\x80\x91\x03\x90\xFD[PV[\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16cR\xD1\x90-`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x92PPP\x80\x15at\0WP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90as\xFD\x91\x90a\x85#V[`\x01[atAW\x81`@Q\x7FL\x9C\x8C\xE3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01at8\x91\x90a~\xF2V[`@Q\x80\x91\x03\x90\xFD[\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC_\x1B\x81\x14at\xA7W\x80`@Q\x7F\xAA\x1DI\xA4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01at\x9E\x91\x90a\x81\xB8V[`@Q\x80\x91\x03\x90\xFD[at\xB1\x83\x83aw\x97V[PPPV[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x160s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14au;W`@Q\x7F\xE0|\x8D\xBA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[V[auG\x82\x82ax\tV[_auPayzV[\x83au[\x91\x90a\x84\xAFV[\x90Paueap\xE4V[_\x01`\x18\x90T\x90a\x01\0\n\x90\x04e\xFF\xFF\xFF\xFF\xFF\xFF\x16e\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81\x11\x15au\xBBW`@Q\x7Fw\xE3\xC2\x93\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[au\xC4\x81ay\x82V[PPPV[\x80\x82]PPV[_\x81\\\x90P\x91\x90PV[_\x81\x83\x10\x15au\xE9W\x81au\xEBV[\x82[\x90P\x92\x91PPV[_\x80_\x90Pz\x18O\x03\xE9?\xF9\xF4\xDA\xA7\x97\xEDn8\xEDd\xBFj\x1F\x01\0\0\0\0\0\0\0\0\x83\x10avOWz\x18O\x03\xE9?\xF9\xF4\xDA\xA7\x97\xEDn8\xEDd\xBFj\x1F\x01\0\0\0\0\0\0\0\0\x83\x81avEWavDa\x84\xE2V[[\x04\x92P`@\x81\x01\x90P[m\x04\xEE-mA[\x85\xAC\xEF\x81\0\0\0\0\x83\x10av\x8CWm\x04\xEE-mA[\x85\xAC\xEF\x81\0\0\0\0\x83\x81av\x82Wav\x81a\x84\xE2V[[\x04\x92P` \x81\x01\x90P[f#\x86\xF2o\xC1\0\0\x83\x10av\xBBWf#\x86\xF2o\xC1\0\0\x83\x81av\xB1Wav\xB0a\x84\xE2V[[\x04\x92P`\x10\x81\x01\x90P[c\x05\xF5\xE1\0\x83\x10av\xE4Wc\x05\xF5\xE1\0\x83\x81av\xDAWav\xD9a\x84\xE2V[[\x04\x92P`\x08\x81\x01\x90P[a'\x10\x83\x10aw\tWa'\x10\x83\x81av\xFFWav\xFEa\x84\xE2V[[\x04\x92P`\x04\x81\x01\x90P[`d\x83\x10aw,W`d\x83\x81aw\"Waw!a\x84\xE2V[[\x04\x92P`\x02\x81\x01\x90P[`\n\x83\x10aw;W`\x01\x81\x01\x90P[\x80\x91PP\x91\x90PV[_awp\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC_\x1Bay\x88V[_\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P\x90V[aw\xA0\x82ay\x91V[\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xBC|\xD7Z \xEE'\xFD\x9A\xDE\xBA\xB3 A\xF7U!M\xBCk\xFF\xA9\x0C\xC0\"[9\xDA.\\-;`@Q`@Q\x80\x91\x03\x90\xA2_\x81Q\x11\x15aw\xFCWaw\xF6\x82\x82azZV[Pax\x05V[ax\x04az\xDAV[[PPV[_ax\x12ap\xE4V[\x90P\x80`\x01\x01_\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x15axkWPayvV[_C\x90P_\x82_\x01`\x06\x90T\x90a\x01\0\n\x90\x04e\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P\x81e\xFF\xFF\xFF\xFF\xFF\xFF\x16\x83_\x01`\x0C\x90T\x90a\x01\0\n\x90\x04e\xFF\xFF\xFF\xFF\xFF\xFF\x16e\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14ax\xB8W_\x90P[_\x85\x82e\xFF\xFF\xFF\xFF\xFF\xFF\x16ax\xCD\x91\x90a\x84\xAFV[\x90P\x83_\x01_\x90T\x90a\x01\0\n\x90\x04e\xFF\xFF\xFF\xFF\xFF\xFF\x16e\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81\x11\x15ay%W`@Q\x7F\xAD%\x11t\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x80\x84_\x01`\x06a\x01\0\n\x81T\x81e\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83e\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP\x82\x84_\x01`\x0Ca\x01\0\n\x81T\x81e\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83e\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UPPPPP[PPV[_\x80\\\x90P\x90V[\x80_]PV[_\x81\x90P\x91\x90PV[_\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16;\x03ay\xECW\x80`@Q\x7FL\x9C\x8C\xE3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01ay\xE3\x91\x90a~\xF2V[`@Q\x80\x91\x03\x90\xFD[\x80az\x18\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC_\x1Bay\x88V[_\x01_a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UPPV[``_\x80\x84s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x84`@Qaz\x83\x91\x90a\x85\x92V[_`@Q\x80\x83\x03\x81\x85Z\xF4\x91PP=\x80_\x81\x14az\xBBW`@Q\x91P`\x1F\x19`?=\x01\x16\x82\x01`@R=\x82R=_` \x84\x01>az\xC0V[``\x91P[P\x91P\x91Paz\xD0\x85\x83\x83a{\x16V[\x92PPP\x92\x91PPV[_4\x11\x15a{\x14W`@Q\x7F\xB3\x98\x97\x9F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[V[``\x82a{+Wa{&\x82a{\xA3V[a{\x9BV[_\x82Q\x14\x80\x15a{QWP_\x84s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16;\x14[\x15a{\x93W\x83`@Q\x7F\x99\x96\xB3\x15\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a{\x8A\x91\x90a~\xF2V[`@Q\x80\x91\x03\x90\xFD[\x81\x90Pa{\x9CV[[\x93\x92PPPV[_\x81Q\x11\x15a{\xB5W\x80Q\x80\x82` \x01\xFD[`@Q\x7F\xD6\xBD\xA2u\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`@Q\x90P\x90V[_\x80\xFD[_\x80\xFD[`T\x81\x10a|\x04W_\x80\xFD[PV[_\x815\x90Pa|\x15\x81a{\xF8V[\x92\x91PPV[_\x7F\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\x16\x90P\x91\x90PV[a|O\x81a|\x1BV[\x81\x14a|YW_\x80\xFD[PV[_\x815\x90Pa|j\x81a|FV[\x92\x91PPV[_\x81\x90P\x91\x90PV[a|\x82\x81a|pV[\x81\x14a|\x8CW_\x80\xFD[PV[_\x815\x90Pa|\x9D\x81a|yV[\x92\x91PPV[_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[_a|\xCC\x82a|\xA3V[\x90P\x91\x90PV[a|\xDC\x81a|\xC2V[\x81\x14a|\xE6W_\x80\xFD[PV[_\x815\x90Pa|\xF7\x81a|\xD3V[\x92\x91PPV[_\x80_\x80_\x80`\xC0\x87\x89\x03\x12\x15a}\x17Wa}\x16a{\xF0V[[_a}$\x89\x82\x8A\x01a|\x07V[\x96PP` a}5\x89\x82\x8A\x01a|\\V[\x95PP`@a}F\x89\x82\x8A\x01a|\x8FV[\x94PP``a}W\x89\x82\x8A\x01a|\x8FV[\x93PP`\x80a}h\x89\x82\x8A\x01a|\x8FV[\x92PP`\xA0a}y\x89\x82\x8A\x01a|\xE9V[\x91PP\x92\x95P\x92\x95P\x92\x95V[_\x81Q\x90P\x91\x90PV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[_[\x83\x81\x10\x15a}\xBDW\x80\x82\x01Q\x81\x84\x01R` \x81\x01\x90Pa}\xA2V[_\x84\x84\x01RPPPPV[_`\x1F\x19`\x1F\x83\x01\x16\x90P\x91\x90PV[_a}\xE2\x82a}\x86V[a}\xEC\x81\x85a}\x90V[\x93Pa}\xFC\x81\x85` \x86\x01a}\xA0V[a~\x05\x81a}\xC8V[\x84\x01\x91PP\x92\x91PPV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra~(\x81\x84a}\xD8V[\x90P\x92\x91PPV[_e\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[a~J\x81a~0V[\x81\x14a~TW_\x80\xFD[PV[_\x815\x90Pa~e\x81a~AV[\x92\x91PPV[_\x80_``\x84\x86\x03\x12\x15a~\x82Wa~\x81a{\xF0V[[_a~\x8F\x86\x82\x87\x01a~WV[\x93PP` a~\xA0\x86\x82\x87\x01a~WV[\x92PP`@a~\xB1\x86\x82\x87\x01a~WV[\x91PP\x92P\x92P\x92V[a~\xC4\x81a~0V[\x82RPPV[_` \x82\x01\x90Pa~\xDD_\x83\x01\x84a~\xBBV[\x92\x91PPV[a~\xEC\x81a|\xC2V[\x82RPPV[_` \x82\x01\x90Pa\x7F\x05_\x83\x01\x84a~\xE3V[\x92\x91PPV[_` \x82\x84\x03\x12\x15a\x7F Wa\x7F\x1Fa{\xF0V[[_a\x7F-\x84\x82\x85\x01a|\xE9V[\x91PP\x92\x91PPV[_\x80_\x80`\x80\x85\x87\x03\x12\x15a\x7FNWa\x7FMa{\xF0V[[_a\x7F[\x87\x82\x88\x01a|\x07V[\x94PP` a\x7Fl\x87\x82\x88\x01a|\x8FV[\x93PP`@a\x7F}\x87\x82\x88\x01a|\x8FV[\x92PP``a\x7F\x8E\x87\x82\x88\x01a|\xE9V[\x91PP\x92\x95\x91\x94P\x92PV[_\x80_\x80_\x80`\xC0\x87\x89\x03\x12\x15a\x7F\xB4Wa\x7F\xB3a{\xF0V[[_a\x7F\xC1\x89\x82\x8A\x01a|\x07V[\x96PP` a\x7F\xD2\x89\x82\x8A\x01a|\x8FV[\x95PP`@a\x7F\xE3\x89\x82\x8A\x01a|\x8FV[\x94PP``a\x7F\xF4\x89\x82\x8A\x01a|\x8FV[\x93PP`\x80a\x80\x05\x89\x82\x8A\x01a|\x8FV[\x92PP`\xA0a\x80\x16\x89\x82\x8A\x01a|\xE9V[\x91PP\x92\x95P\x92\x95P\x92\x95V[_\x80\xFD[_\x80\xFD[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`A`\x04R`$_\xFD[a\x80a\x82a}\xC8V[\x81\x01\x81\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17\x15a\x80\x80Wa\x80\x7Fa\x80+V[[\x80`@RPPPV[_a\x80\x92a{\xE7V[\x90Pa\x80\x9E\x82\x82a\x80XV[\x91\x90PV[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15a\x80\xBDWa\x80\xBCa\x80+V[[a\x80\xC6\x82a}\xC8V[\x90P` \x81\x01\x90P\x91\x90PV[\x82\x81\x837_\x83\x83\x01RPPPV[_a\x80\xF3a\x80\xEE\x84a\x80\xA3V[a\x80\x89V[\x90P\x82\x81R` \x81\x01\x84\x84\x84\x01\x11\x15a\x81\x0FWa\x81\x0Ea\x80'V[[a\x81\x1A\x84\x82\x85a\x80\xD3V[P\x93\x92PPPV[_\x82`\x1F\x83\x01\x12a\x816Wa\x815a\x80#V[[\x815a\x81F\x84\x82` \x86\x01a\x80\xE1V[\x91PP\x92\x91PPV[_\x80`@\x83\x85\x03\x12\x15a\x81eWa\x81da{\xF0V[[_a\x81r\x85\x82\x86\x01a|\xE9V[\x92PP` \x83\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x81\x93Wa\x81\x92a{\xF4V[[a\x81\x9F\x85\x82\x86\x01a\x81\"V[\x91PP\x92P\x92\x90PV[a\x81\xB2\x81a|pV[\x82RPPV[_` \x82\x01\x90Pa\x81\xCB_\x83\x01\x84a\x81\xA9V[\x92\x91PPV[_` \x82\x84\x03\x12\x15a\x81\xE6Wa\x81\xE5a{\xF0V[[_a\x81\xF3\x84\x82\x85\x01a~WV[\x91PP\x92\x91PPV[_\x80_``\x84\x86\x03\x12\x15a\x82\x13Wa\x82\x12a{\xF0V[[_a\x82 \x86\x82\x87\x01a|\x07V[\x93PP` a\x821\x86\x82\x87\x01a|\x8FV[\x92PP`@a\x82B\x86\x82\x87\x01a|\xE9V[\x91PP\x92P\x92P\x92V[_`@\x82\x01\x90Pa\x82__\x83\x01\x85a~\xBBV[a\x82l` \x83\x01\x84a~\xBBV[\x93\x92PPPV[_\x81\x15\x15\x90P\x91\x90PV[a\x82\x87\x81a\x82sV[\x82RPPV[_` \x82\x01\x90Pa\x82\xA0_\x83\x01\x84a\x82~V[\x92\x91PPV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`!`\x04R`$_\xFD[_\x81\x90P\x92\x91PPV[_a\x82\xE7\x82a}\x86V[a\x82\xF1\x81\x85a\x82\xD3V[\x93Pa\x83\x01\x81\x85` \x86\x01a}\xA0V[\x80\x84\x01\x91PP\x92\x91PPV[\x7F v\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_a\x83A`\x02\x83a\x82\xD3V[\x91Pa\x83L\x82a\x83\rV[`\x02\x82\x01\x90P\x91\x90PV[\x7F.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_a\x83\x8B`\x01\x83a\x82\xD3V[\x91Pa\x83\x96\x82a\x83WV[`\x01\x82\x01\x90P\x91\x90PV[_a\x83\xAC\x82\x87a\x82\xDDV[\x91Pa\x83\xB7\x82a\x835V[\x91Pa\x83\xC3\x82\x86a\x82\xDDV[\x91Pa\x83\xCE\x82a\x83\x7FV[\x91Pa\x83\xDA\x82\x85a\x82\xDDV[\x91Pa\x83\xE5\x82a\x83\x7FV[\x91Pa\x83\xF1\x82\x84a\x82\xDDV[\x91P\x81\x90P\x95\x94PPPPPV[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[a\x84\x1B\x81a\x83\xFFV[\x82RPPV[_` \x82\x01\x90Pa\x844_\x83\x01\x84a\x84\x12V[\x92\x91PPV[_\x81Q\x90Pa\x84H\x81a|\xD3V[\x92\x91PPV[_` \x82\x84\x03\x12\x15a\x84cWa\x84ba{\xF0V[[_a\x84p\x84\x82\x85\x01a\x84:V[\x91PP\x92\x91PPV[_\x81\x90P\x91\x90PV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x11`\x04R`$_\xFD[_a\x84\xB9\x82a\x84yV[\x91Pa\x84\xC4\x83a\x84yV[\x92P\x82\x82\x01\x90P\x80\x82\x11\x15a\x84\xDCWa\x84\xDBa\x84\x82V[[\x92\x91PPV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x12`\x04R`$_\xFD[_\x81Q\x90Pa\x85\x1D\x81a|yV[\x92\x91PPV[_` \x82\x84\x03\x12\x15a\x858Wa\x857a{\xF0V[[_a\x85E\x84\x82\x85\x01a\x85\x0FV[\x91PP\x92\x91PPV[_\x81Q\x90P\x91\x90PV[_\x81\x90P\x92\x91PPV[_a\x85l\x82a\x85NV[a\x85v\x81\x85a\x85XV[\x93Pa\x85\x86\x81\x85` \x86\x01a}\xA0V[\x80\x84\x01\x91PP\x92\x91PPV[_a\x85\x9D\x82\x84a\x85bV[\x91P\x81\x90P\x92\x91PPV",
    );
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct FheType(u8);
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<FheType> for u8 {
            #[inline]
            fn stv_to_tokens(
                &self,
            ) -> <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::Token<'_> {
                alloy_sol_types::private::SolTypeValue::<
                    alloy::sol_types::sol_data::Uint<8>,
                >::stv_to_tokens(self)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::tokenize(self)
                    .0
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(self, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::abi_encoded_size(self)
            }
        }
        #[automatically_derived]
        impl FheType {
            /// The Solidity type name.
            pub const NAME: &'static str = stringify!(@ name);
            /// Convert from the underlying value type.
            #[inline]
            pub const fn from_underlying(value: u8) -> Self {
                Self(value)
            }
            /// Return the underlying value.
            #[inline]
            pub const fn into_underlying(self) -> u8 {
                self.0
            }
            /// Return the single encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode(&self.0)
            }
            /// Return the packed encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode_packed(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode_packed(&self.0)
            }
        }
        #[automatically_derived]
        impl From<u8> for FheType {
            fn from(value: u8) -> Self {
                Self::from_underlying(value)
            }
        }
        #[automatically_derived]
        impl From<FheType> for u8 {
            fn from(value: FheType) -> Self {
                value.into_underlying()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for FheType {
            type RustType = u8;
            type Token<'a> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = Self::NAME;
            const ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                Self::type_check(token).is_ok()
            }
            #[inline]
            fn type_check(token: &Self::Token<'_>) -> alloy_sol_types::Result<()> {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::type_check(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::detokenize(token)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for FheType {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::topic_preimage_length(rust)
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(rust, out)
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic(rust)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `AddressEmptyCode(address)` and selector `0x9996b315`.
```solidity
error AddressEmptyCode(address target);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AddressEmptyCode {
        #[allow(missing_docs)]
        pub target: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AddressEmptyCode> for UnderlyingRustTuple<'_> {
            fn from(value: AddressEmptyCode) -> Self {
                (value.target,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for AddressEmptyCode {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { target: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AddressEmptyCode {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AddressEmptyCode(address)";
            const SELECTOR: [u8; 4] = [153u8, 150u8, 179u8, 21u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.target,
                    ),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `AlreadyBlockHCUWhitelisted(address)` and selector `0xf99c4fd1`.
```solidity
error AlreadyBlockHCUWhitelisted(address account);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AlreadyBlockHCUWhitelisted {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AlreadyBlockHCUWhitelisted>
        for UnderlyingRustTuple<'_> {
            fn from(value: AlreadyBlockHCUWhitelisted) -> Self {
                (value.account,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for AlreadyBlockHCUWhitelisted {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { account: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AlreadyBlockHCUWhitelisted {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AlreadyBlockHCUWhitelisted(address)";
            const SELECTOR: [u8; 4] = [249u8, 156u8, 79u8, 209u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `CallerMustBeFHEVMExecutorContract()` and selector `0x31a81a81`.
```solidity
error CallerMustBeFHEVMExecutorContract();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct CallerMustBeFHEVMExecutorContract;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<CallerMustBeFHEVMExecutorContract>
        for UnderlyingRustTuple<'_> {
            fn from(value: CallerMustBeFHEVMExecutorContract) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for CallerMustBeFHEVMExecutorContract {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for CallerMustBeFHEVMExecutorContract {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "CallerMustBeFHEVMExecutorContract()";
            const SELECTOR: [u8; 4] = [49u8, 168u8, 26u8, 129u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `ERC1967InvalidImplementation(address)` and selector `0x4c9c8ce3`.
```solidity
error ERC1967InvalidImplementation(address implementation);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC1967InvalidImplementation {
        #[allow(missing_docs)]
        pub implementation: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC1967InvalidImplementation>
        for UnderlyingRustTuple<'_> {
            fn from(value: ERC1967InvalidImplementation) -> Self {
                (value.implementation,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ERC1967InvalidImplementation {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { implementation: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC1967InvalidImplementation {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC1967InvalidImplementation(address)";
            const SELECTOR: [u8; 4] = [76u8, 156u8, 140u8, 227u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.implementation,
                    ),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `ERC1967NonPayable()` and selector `0xb398979f`.
```solidity
error ERC1967NonPayable();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC1967NonPayable;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC1967NonPayable> for UnderlyingRustTuple<'_> {
            fn from(value: ERC1967NonPayable) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ERC1967NonPayable {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC1967NonPayable {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC1967NonPayable()";
            const SELECTOR: [u8; 4] = [179u8, 152u8, 151u8, 159u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `FailedCall()` and selector `0xd6bda275`.
```solidity
error FailedCall();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct FailedCall;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<FailedCall> for UnderlyingRustTuple<'_> {
            fn from(value: FailedCall) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for FailedCall {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for FailedCall {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "FailedCall()";
            const SELECTOR: [u8; 4] = [214u8, 189u8, 162u8, 117u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `HCUBlockLimitExceeded()` and selector `0xad251174`.
```solidity
error HCUBlockLimitExceeded();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct HCUBlockLimitExceeded;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<HCUBlockLimitExceeded> for UnderlyingRustTuple<'_> {
            fn from(value: HCUBlockLimitExceeded) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for HCUBlockLimitExceeded {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for HCUBlockLimitExceeded {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "HCUBlockLimitExceeded()";
            const SELECTOR: [u8; 4] = [173u8, 37u8, 17u8, 116u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `HCUTransactionDepthLimitExceeded()` and selector `0xfc344870`.
```solidity
error HCUTransactionDepthLimitExceeded();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct HCUTransactionDepthLimitExceeded;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<HCUTransactionDepthLimitExceeded>
        for UnderlyingRustTuple<'_> {
            fn from(value: HCUTransactionDepthLimitExceeded) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for HCUTransactionDepthLimitExceeded {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for HCUTransactionDepthLimitExceeded {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "HCUTransactionDepthLimitExceeded()";
            const SELECTOR: [u8; 4] = [252u8, 52u8, 72u8, 112u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `HCUTransactionLimitExceeded()` and selector `0x77e3c293`.
```solidity
error HCUTransactionLimitExceeded();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct HCUTransactionLimitExceeded;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<HCUTransactionLimitExceeded>
        for UnderlyingRustTuple<'_> {
            fn from(value: HCUTransactionLimitExceeded) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for HCUTransactionLimitExceeded {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for HCUTransactionLimitExceeded {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "HCUTransactionLimitExceeded()";
            const SELECTOR: [u8; 4] = [119u8, 227u8, 194u8, 147u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidInitialization()` and selector `0xf92ee8a9`.
```solidity
error InvalidInitialization();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidInitialization;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidInitialization> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidInitialization) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidInitialization {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidInitialization {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidInitialization()";
            const SELECTOR: [u8; 4] = [249u8, 46u8, 232u8, 169u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `NotBlockHCUWhitelisted(address)` and selector `0xe3cc3418`.
```solidity
error NotBlockHCUWhitelisted(address account);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NotBlockHCUWhitelisted {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NotBlockHCUWhitelisted> for UnderlyingRustTuple<'_> {
            fn from(value: NotBlockHCUWhitelisted) -> Self {
                (value.account,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NotBlockHCUWhitelisted {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { account: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NotBlockHCUWhitelisted {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NotBlockHCUWhitelisted(address)";
            const SELECTOR: [u8; 4] = [227u8, 204u8, 52u8, 24u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `NotHostOwner(address)` and selector `0x21bfda10`.
```solidity
error NotHostOwner(address sender);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NotHostOwner {
        #[allow(missing_docs)]
        pub sender: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NotHostOwner> for UnderlyingRustTuple<'_> {
            fn from(value: NotHostOwner) -> Self {
                (value.sender,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NotHostOwner {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { sender: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NotHostOwner {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NotHostOwner(address)";
            const SELECTOR: [u8; 4] = [33u8, 191u8, 218u8, 16u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sender,
                    ),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `NotInitializing()` and selector `0xd7e6bcf8`.
```solidity
error NotInitializing();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NotInitializing;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NotInitializing> for UnderlyingRustTuple<'_> {
            fn from(value: NotInitializing) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NotInitializing {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NotInitializing {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NotInitializing()";
            const SELECTOR: [u8; 4] = [215u8, 230u8, 188u8, 248u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `NotInitializingFromEmptyProxy()` and selector `0x6f4f731f`.
```solidity
error NotInitializingFromEmptyProxy();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NotInitializingFromEmptyProxy;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NotInitializingFromEmptyProxy>
        for UnderlyingRustTuple<'_> {
            fn from(value: NotInitializingFromEmptyProxy) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for NotInitializingFromEmptyProxy {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NotInitializingFromEmptyProxy {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NotInitializingFromEmptyProxy()";
            const SELECTOR: [u8; 4] = [111u8, 79u8, 115u8, 31u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `OnlyScalarOperationsAreSupported()` and selector `0x6aa9eb05`.
```solidity
error OnlyScalarOperationsAreSupported();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct OnlyScalarOperationsAreSupported;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<OnlyScalarOperationsAreSupported>
        for UnderlyingRustTuple<'_> {
            fn from(value: OnlyScalarOperationsAreSupported) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for OnlyScalarOperationsAreSupported {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for OnlyScalarOperationsAreSupported {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "OnlyScalarOperationsAreSupported()";
            const SELECTOR: [u8; 4] = [106u8, 169u8, 235u8, 5u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `UUPSUnauthorizedCallContext()` and selector `0xe07c8dba`.
```solidity
error UUPSUnauthorizedCallContext();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct UUPSUnauthorizedCallContext;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UUPSUnauthorizedCallContext>
        for UnderlyingRustTuple<'_> {
            fn from(value: UUPSUnauthorizedCallContext) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for UUPSUnauthorizedCallContext {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for UUPSUnauthorizedCallContext {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "UUPSUnauthorizedCallContext()";
            const SELECTOR: [u8; 4] = [224u8, 124u8, 141u8, 186u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `UUPSUnsupportedProxiableUUID(bytes32)` and selector `0xaa1d49a4`.
```solidity
error UUPSUnsupportedProxiableUUID(bytes32 slot);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct UUPSUnsupportedProxiableUUID {
        #[allow(missing_docs)]
        pub slot: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UUPSUnsupportedProxiableUUID>
        for UnderlyingRustTuple<'_> {
            fn from(value: UUPSUnsupportedProxiableUUID) -> Self {
                (value.slot,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for UUPSUnsupportedProxiableUUID {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { slot: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for UUPSUnsupportedProxiableUUID {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "UUPSUnsupportedProxiableUUID(bytes32)";
            const SELECTOR: [u8; 4] = [170u8, 29u8, 73u8, 164u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.slot),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `UnsupportedOperation()` and selector `0x9ba6061b`.
```solidity
error UnsupportedOperation();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct UnsupportedOperation;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnsupportedOperation> for UnderlyingRustTuple<'_> {
            fn from(value: UnsupportedOperation) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for UnsupportedOperation {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for UnsupportedOperation {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "UnsupportedOperation()";
            const SELECTOR: [u8; 4] = [155u8, 166u8, 6u8, 27u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `BlockHCUWhitelistAdded(address)` and selector `0xcca1d46384cdbbeef2f9daddb76db138101c9905f818d867b630195c128d3c66`.
```solidity
event BlockHCUWhitelistAdded(address indexed account);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct BlockHCUWhitelistAdded {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for BlockHCUWhitelistAdded {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "BlockHCUWhitelistAdded(address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                204u8, 161u8, 212u8, 99u8, 132u8, 205u8, 187u8, 238u8, 242u8, 249u8,
                218u8, 221u8, 183u8, 109u8, 177u8, 56u8, 16u8, 28u8, 153u8, 5u8, 248u8,
                24u8, 216u8, 103u8, 182u8, 48u8, 25u8, 92u8, 18u8, 141u8, 60u8, 102u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { account: topics.1 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.account.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.account,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for BlockHCUWhitelistAdded {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&BlockHCUWhitelistAdded> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &BlockHCUWhitelistAdded) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `BlockHCUWhitelistRemoved(address)` and selector `0x92fc97af15002646cea63c7633bb375b82db7cde7b480c75fe6341dacc292c81`.
```solidity
event BlockHCUWhitelistRemoved(address indexed account);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct BlockHCUWhitelistRemoved {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for BlockHCUWhitelistRemoved {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "BlockHCUWhitelistRemoved(address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                146u8, 252u8, 151u8, 175u8, 21u8, 0u8, 38u8, 70u8, 206u8, 166u8, 60u8,
                118u8, 51u8, 187u8, 55u8, 91u8, 130u8, 219u8, 124u8, 222u8, 123u8, 72u8,
                12u8, 117u8, 254u8, 99u8, 65u8, 218u8, 204u8, 41u8, 44u8, 129u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { account: topics.1 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.account.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.account,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for BlockHCUWhitelistRemoved {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&BlockHCUWhitelistRemoved> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(
                this: &BlockHCUWhitelistRemoved,
            ) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `HCUPerBlockSet(uint48)` and selector `0xc1f1fcaa898aae2263dded712e1798083fca9272ff803ee4150ce48f8619891a`.
```solidity
event HCUPerBlockSet(uint48 hcuPerBlock);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct HCUPerBlockSet {
        #[allow(missing_docs)]
        pub hcuPerBlock: alloy::sol_types::private::primitives::aliases::U48,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for HCUPerBlockSet {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<48>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "HCUPerBlockSet(uint48)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                193u8, 241u8, 252u8, 170u8, 137u8, 138u8, 174u8, 34u8, 99u8, 221u8,
                237u8, 113u8, 46u8, 23u8, 152u8, 8u8, 63u8, 202u8, 146u8, 114u8, 255u8,
                128u8, 62u8, 228u8, 21u8, 12u8, 228u8, 143u8, 134u8, 25u8, 137u8, 26u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { hcuPerBlock: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        48,
                    > as alloy_sol_types::SolType>::tokenize(&self.hcuPerBlock),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for HCUPerBlockSet {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&HCUPerBlockSet> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &HCUPerBlockSet) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `Initialized(uint64)` and selector `0xc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d2`.
```solidity
event Initialized(uint64 version);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Initialized {
        #[allow(missing_docs)]
        pub version: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Initialized {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "Initialized(uint64)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                199u8, 245u8, 5u8, 178u8, 243u8, 113u8, 174u8, 33u8, 117u8, 238u8, 73u8,
                19u8, 244u8, 73u8, 158u8, 31u8, 38u8, 51u8, 167u8, 181u8, 147u8, 99u8,
                33u8, 238u8, 209u8, 205u8, 174u8, 182u8, 17u8, 81u8, 129u8, 210u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { version: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.version),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Initialized {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Initialized> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Initialized) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `MaxHCUDepthPerTxSet(uint48)` and selector `0x5511b1851fc40a2629c855bab7adce3276c470d8190eb01431e418dc2af13e8e`.
```solidity
event MaxHCUDepthPerTxSet(uint48 maxHCUDepthPerTx);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct MaxHCUDepthPerTxSet {
        #[allow(missing_docs)]
        pub maxHCUDepthPerTx: alloy::sol_types::private::primitives::aliases::U48,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for MaxHCUDepthPerTxSet {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<48>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "MaxHCUDepthPerTxSet(uint48)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                85u8, 17u8, 177u8, 133u8, 31u8, 196u8, 10u8, 38u8, 41u8, 200u8, 85u8,
                186u8, 183u8, 173u8, 206u8, 50u8, 118u8, 196u8, 112u8, 216u8, 25u8, 14u8,
                176u8, 20u8, 49u8, 228u8, 24u8, 220u8, 42u8, 241u8, 62u8, 142u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { maxHCUDepthPerTx: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        48,
                    > as alloy_sol_types::SolType>::tokenize(&self.maxHCUDepthPerTx),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for MaxHCUDepthPerTxSet {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&MaxHCUDepthPerTxSet> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &MaxHCUDepthPerTxSet) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `MaxHCUPerTxSet(uint48)` and selector `0x64cb9e7ae6497c59080cdbc048552e123d52aa4240e137758a173582786961ca`.
```solidity
event MaxHCUPerTxSet(uint48 maxHCUPerTx);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct MaxHCUPerTxSet {
        #[allow(missing_docs)]
        pub maxHCUPerTx: alloy::sol_types::private::primitives::aliases::U48,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for MaxHCUPerTxSet {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<48>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "MaxHCUPerTxSet(uint48)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                100u8, 203u8, 158u8, 122u8, 230u8, 73u8, 124u8, 89u8, 8u8, 12u8, 219u8,
                192u8, 72u8, 85u8, 46u8, 18u8, 61u8, 82u8, 170u8, 66u8, 64u8, 225u8,
                55u8, 117u8, 138u8, 23u8, 53u8, 130u8, 120u8, 105u8, 97u8, 202u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { maxHCUPerTx: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        48,
                    > as alloy_sol_types::SolType>::tokenize(&self.maxHCUPerTx),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for MaxHCUPerTxSet {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&MaxHCUPerTxSet> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &MaxHCUPerTxSet) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `Upgraded(address)` and selector `0xbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b`.
```solidity
event Upgraded(address indexed implementation);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Upgraded {
        #[allow(missing_docs)]
        pub implementation: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Upgraded {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "Upgraded(address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                188u8, 124u8, 215u8, 90u8, 32u8, 238u8, 39u8, 253u8, 154u8, 222u8, 186u8,
                179u8, 32u8, 65u8, 247u8, 85u8, 33u8, 77u8, 188u8, 107u8, 255u8, 169u8,
                12u8, 192u8, 34u8, 91u8, 57u8, 218u8, 46u8, 92u8, 45u8, 59u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { implementation: topics.1 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.implementation.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.implementation,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Upgraded {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Upgraded> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Upgraded) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Constructor`.
```solidity
constructor();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct constructorCall {}
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<constructorCall> for UnderlyingRustTuple<'_> {
                fn from(value: constructorCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for constructorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolConstructor for constructorCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `UPGRADE_INTERFACE_VERSION()` and selector `0xad3cb1cc`.
```solidity
function UPGRADE_INTERFACE_VERSION() external view returns (string memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct UPGRADE_INTERFACE_VERSIONCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`UPGRADE_INTERFACE_VERSION()`](UPGRADE_INTERFACE_VERSIONCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct UPGRADE_INTERFACE_VERSIONReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UPGRADE_INTERFACE_VERSIONCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: UPGRADE_INTERFACE_VERSIONCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for UPGRADE_INTERFACE_VERSIONCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UPGRADE_INTERFACE_VERSIONReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: UPGRADE_INTERFACE_VERSIONReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for UPGRADE_INTERFACE_VERSIONReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for UPGRADE_INTERFACE_VERSIONCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::String;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "UPGRADE_INTERFACE_VERSION()";
            const SELECTOR: [u8; 4] = [173u8, 60u8, 177u8, 204u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: UPGRADE_INTERFACE_VERSIONReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: UPGRADE_INTERFACE_VERSIONReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `addToBlockHCUWhitelist(address)` and selector `0x6fd65e4d`.
```solidity
function addToBlockHCUWhitelist(address account) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct addToBlockHCUWhitelistCall {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`addToBlockHCUWhitelist(address)`](addToBlockHCUWhitelistCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct addToBlockHCUWhitelistReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<addToBlockHCUWhitelistCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: addToBlockHCUWhitelistCall) -> Self {
                    (value.account,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for addToBlockHCUWhitelistCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { account: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<addToBlockHCUWhitelistReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: addToBlockHCUWhitelistReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for addToBlockHCUWhitelistReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl addToBlockHCUWhitelistReturn {
            fn _tokenize(
                &self,
            ) -> <addToBlockHCUWhitelistCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for addToBlockHCUWhitelistCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = addToBlockHCUWhitelistReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "addToBlockHCUWhitelist(address)";
            const SELECTOR: [u8; 4] = [111u8, 214u8, 94u8, 77u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                addToBlockHCUWhitelistReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `checkHCUForCast(uint8,bytes32,bytes32,address)` and selector `0x69931afb`.
```solidity
function checkHCUForCast(FheType resultType, bytes32 ct, bytes32 result, address caller) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForCastCall {
        #[allow(missing_docs)]
        pub resultType: <FheType as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub ct: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`checkHCUForCast(uint8,bytes32,bytes32,address)`](checkHCUForCastCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForCastReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <FheType as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForCastCall> for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForCastCall) -> Self {
                    (value.resultType, value.ct, value.result, value.caller)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for checkHCUForCastCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        resultType: tuple.0,
                        ct: tuple.1,
                        result: tuple.2,
                        caller: tuple.3,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForCastReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForCastReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForCastReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl checkHCUForCastReturn {
            fn _tokenize(
                &self,
            ) -> <checkHCUForCastCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for checkHCUForCastCall {
            type Parameters<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = checkHCUForCastReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "checkHCUForCast(uint8,bytes32,bytes32,address)";
            const SELECTOR: [u8; 4] = [105u8, 147u8, 26u8, 251u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <FheType as alloy_sol_types::SolType>::tokenize(&self.resultType),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.ct),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.caller,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                checkHCUForCastReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `checkHCUForFheAdd(uint8,bytes1,bytes32,bytes32,bytes32,address)` and selector `0xc1390c34`.
```solidity
function checkHCUForFheAdd(FheType resultType, bytes1 scalarByte, bytes32 lhs, bytes32 rhs, bytes32 result, address caller) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForFheAddCall {
        #[allow(missing_docs)]
        pub resultType: <FheType as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`checkHCUForFheAdd(uint8,bytes1,bytes32,bytes32,bytes32,address)`](checkHCUForFheAddCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForFheAddReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <FheType as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::FixedBytes<1>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForFheAddCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForFheAddCall) -> Self {
                    (
                        value.resultType,
                        value.scalarByte,
                        value.lhs,
                        value.rhs,
                        value.result,
                        value.caller,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForFheAddCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        resultType: tuple.0,
                        scalarByte: tuple.1,
                        lhs: tuple.2,
                        rhs: tuple.3,
                        result: tuple.4,
                        caller: tuple.5,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForFheAddReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForFheAddReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForFheAddReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl checkHCUForFheAddReturn {
            fn _tokenize(
                &self,
            ) -> <checkHCUForFheAddCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for checkHCUForFheAddCall {
            type Parameters<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = checkHCUForFheAddReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "checkHCUForFheAdd(uint8,bytes1,bytes32,bytes32,bytes32,address)";
            const SELECTOR: [u8; 4] = [193u8, 57u8, 12u8, 52u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <FheType as alloy_sol_types::SolType>::tokenize(&self.resultType),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.caller,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                checkHCUForFheAddReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `checkHCUForFheBitAnd(uint8,bytes1,bytes32,bytes32,bytes32,address)` and selector `0xc8de4352`.
```solidity
function checkHCUForFheBitAnd(FheType resultType, bytes1 scalarByte, bytes32 lhs, bytes32 rhs, bytes32 result, address caller) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForFheBitAndCall {
        #[allow(missing_docs)]
        pub resultType: <FheType as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`checkHCUForFheBitAnd(uint8,bytes1,bytes32,bytes32,bytes32,address)`](checkHCUForFheBitAndCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForFheBitAndReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <FheType as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::FixedBytes<1>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForFheBitAndCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForFheBitAndCall) -> Self {
                    (
                        value.resultType,
                        value.scalarByte,
                        value.lhs,
                        value.rhs,
                        value.result,
                        value.caller,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForFheBitAndCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        resultType: tuple.0,
                        scalarByte: tuple.1,
                        lhs: tuple.2,
                        rhs: tuple.3,
                        result: tuple.4,
                        caller: tuple.5,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForFheBitAndReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForFheBitAndReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForFheBitAndReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl checkHCUForFheBitAndReturn {
            fn _tokenize(
                &self,
            ) -> <checkHCUForFheBitAndCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for checkHCUForFheBitAndCall {
            type Parameters<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = checkHCUForFheBitAndReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "checkHCUForFheBitAnd(uint8,bytes1,bytes32,bytes32,bytes32,address)";
            const SELECTOR: [u8; 4] = [200u8, 222u8, 67u8, 82u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <FheType as alloy_sol_types::SolType>::tokenize(&self.resultType),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.caller,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                checkHCUForFheBitAndReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `checkHCUForFheBitOr(uint8,bytes1,bytes32,bytes32,bytes32,address)` and selector `0xc0c5df7c`.
```solidity
function checkHCUForFheBitOr(FheType resultType, bytes1 scalarByte, bytes32 lhs, bytes32 rhs, bytes32 result, address caller) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForFheBitOrCall {
        #[allow(missing_docs)]
        pub resultType: <FheType as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`checkHCUForFheBitOr(uint8,bytes1,bytes32,bytes32,bytes32,address)`](checkHCUForFheBitOrCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForFheBitOrReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <FheType as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::FixedBytes<1>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForFheBitOrCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForFheBitOrCall) -> Self {
                    (
                        value.resultType,
                        value.scalarByte,
                        value.lhs,
                        value.rhs,
                        value.result,
                        value.caller,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForFheBitOrCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        resultType: tuple.0,
                        scalarByte: tuple.1,
                        lhs: tuple.2,
                        rhs: tuple.3,
                        result: tuple.4,
                        caller: tuple.5,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForFheBitOrReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForFheBitOrReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForFheBitOrReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl checkHCUForFheBitOrReturn {
            fn _tokenize(
                &self,
            ) -> <checkHCUForFheBitOrCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for checkHCUForFheBitOrCall {
            type Parameters<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = checkHCUForFheBitOrReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "checkHCUForFheBitOr(uint8,bytes1,bytes32,bytes32,bytes32,address)";
            const SELECTOR: [u8; 4] = [192u8, 197u8, 223u8, 124u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <FheType as alloy_sol_types::SolType>::tokenize(&self.resultType),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.caller,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                checkHCUForFheBitOrReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `checkHCUForFheBitXor(uint8,bytes1,bytes32,bytes32,bytes32,address)` and selector `0x9f9259bb`.
```solidity
function checkHCUForFheBitXor(FheType resultType, bytes1 scalarByte, bytes32 lhs, bytes32 rhs, bytes32 result, address caller) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForFheBitXorCall {
        #[allow(missing_docs)]
        pub resultType: <FheType as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`checkHCUForFheBitXor(uint8,bytes1,bytes32,bytes32,bytes32,address)`](checkHCUForFheBitXorCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForFheBitXorReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <FheType as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::FixedBytes<1>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForFheBitXorCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForFheBitXorCall) -> Self {
                    (
                        value.resultType,
                        value.scalarByte,
                        value.lhs,
                        value.rhs,
                        value.result,
                        value.caller,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForFheBitXorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        resultType: tuple.0,
                        scalarByte: tuple.1,
                        lhs: tuple.2,
                        rhs: tuple.3,
                        result: tuple.4,
                        caller: tuple.5,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForFheBitXorReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForFheBitXorReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForFheBitXorReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl checkHCUForFheBitXorReturn {
            fn _tokenize(
                &self,
            ) -> <checkHCUForFheBitXorCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for checkHCUForFheBitXorCall {
            type Parameters<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = checkHCUForFheBitXorReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "checkHCUForFheBitXor(uint8,bytes1,bytes32,bytes32,bytes32,address)";
            const SELECTOR: [u8; 4] = [159u8, 146u8, 89u8, 187u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <FheType as alloy_sol_types::SolType>::tokenize(&self.resultType),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.caller,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                checkHCUForFheBitXorReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `checkHCUForFheDiv(uint8,bytes1,bytes32,bytes32,bytes32,address)` and selector `0x9b3f781a`.
```solidity
function checkHCUForFheDiv(FheType resultType, bytes1 scalarByte, bytes32 lhs, bytes32, bytes32 result, address caller) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForFheDivCall {
        #[allow(missing_docs)]
        pub resultType: <FheType as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub _3: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`checkHCUForFheDiv(uint8,bytes1,bytes32,bytes32,bytes32,address)`](checkHCUForFheDivCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForFheDivReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <FheType as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::FixedBytes<1>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForFheDivCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForFheDivCall) -> Self {
                    (
                        value.resultType,
                        value.scalarByte,
                        value.lhs,
                        value._3,
                        value.result,
                        value.caller,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForFheDivCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        resultType: tuple.0,
                        scalarByte: tuple.1,
                        lhs: tuple.2,
                        _3: tuple.3,
                        result: tuple.4,
                        caller: tuple.5,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForFheDivReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForFheDivReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForFheDivReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl checkHCUForFheDivReturn {
            fn _tokenize(
                &self,
            ) -> <checkHCUForFheDivCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for checkHCUForFheDivCall {
            type Parameters<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = checkHCUForFheDivReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "checkHCUForFheDiv(uint8,bytes1,bytes32,bytes32,bytes32,address)";
            const SELECTOR: [u8; 4] = [155u8, 63u8, 120u8, 26u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <FheType as alloy_sol_types::SolType>::tokenize(&self.resultType),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self._3),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.caller,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                checkHCUForFheDivReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `checkHCUForFheEq(uint8,bytes1,bytes32,bytes32,bytes32,address)` and selector `0x60e12189`.
```solidity
function checkHCUForFheEq(FheType resultType, bytes1 scalarByte, bytes32 lhs, bytes32 rhs, bytes32 result, address caller) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForFheEqCall {
        #[allow(missing_docs)]
        pub resultType: <FheType as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`checkHCUForFheEq(uint8,bytes1,bytes32,bytes32,bytes32,address)`](checkHCUForFheEqCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForFheEqReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <FheType as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::FixedBytes<1>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForFheEqCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForFheEqCall) -> Self {
                    (
                        value.resultType,
                        value.scalarByte,
                        value.lhs,
                        value.rhs,
                        value.result,
                        value.caller,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForFheEqCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        resultType: tuple.0,
                        scalarByte: tuple.1,
                        lhs: tuple.2,
                        rhs: tuple.3,
                        result: tuple.4,
                        caller: tuple.5,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForFheEqReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForFheEqReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForFheEqReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl checkHCUForFheEqReturn {
            fn _tokenize(
                &self,
            ) -> <checkHCUForFheEqCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for checkHCUForFheEqCall {
            type Parameters<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = checkHCUForFheEqReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "checkHCUForFheEq(uint8,bytes1,bytes32,bytes32,bytes32,address)";
            const SELECTOR: [u8; 4] = [96u8, 225u8, 33u8, 137u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <FheType as alloy_sol_types::SolType>::tokenize(&self.resultType),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.caller,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                checkHCUForFheEqReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `checkHCUForFheGe(uint8,bytes1,bytes32,bytes32,bytes32,address)` and selector `0xc277a936`.
```solidity
function checkHCUForFheGe(FheType resultType, bytes1 scalarByte, bytes32 lhs, bytes32 rhs, bytes32 result, address caller) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForFheGeCall {
        #[allow(missing_docs)]
        pub resultType: <FheType as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`checkHCUForFheGe(uint8,bytes1,bytes32,bytes32,bytes32,address)`](checkHCUForFheGeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForFheGeReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <FheType as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::FixedBytes<1>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForFheGeCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForFheGeCall) -> Self {
                    (
                        value.resultType,
                        value.scalarByte,
                        value.lhs,
                        value.rhs,
                        value.result,
                        value.caller,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForFheGeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        resultType: tuple.0,
                        scalarByte: tuple.1,
                        lhs: tuple.2,
                        rhs: tuple.3,
                        result: tuple.4,
                        caller: tuple.5,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForFheGeReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForFheGeReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForFheGeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl checkHCUForFheGeReturn {
            fn _tokenize(
                &self,
            ) -> <checkHCUForFheGeCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for checkHCUForFheGeCall {
            type Parameters<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = checkHCUForFheGeReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "checkHCUForFheGe(uint8,bytes1,bytes32,bytes32,bytes32,address)";
            const SELECTOR: [u8; 4] = [194u8, 119u8, 169u8, 54u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <FheType as alloy_sol_types::SolType>::tokenize(&self.resultType),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.caller,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                checkHCUForFheGeReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `checkHCUForFheGt(uint8,bytes1,bytes32,bytes32,bytes32,address)` and selector `0x458fb277`.
```solidity
function checkHCUForFheGt(FheType resultType, bytes1 scalarByte, bytes32 lhs, bytes32 rhs, bytes32 result, address caller) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForFheGtCall {
        #[allow(missing_docs)]
        pub resultType: <FheType as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`checkHCUForFheGt(uint8,bytes1,bytes32,bytes32,bytes32,address)`](checkHCUForFheGtCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForFheGtReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <FheType as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::FixedBytes<1>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForFheGtCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForFheGtCall) -> Self {
                    (
                        value.resultType,
                        value.scalarByte,
                        value.lhs,
                        value.rhs,
                        value.result,
                        value.caller,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForFheGtCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        resultType: tuple.0,
                        scalarByte: tuple.1,
                        lhs: tuple.2,
                        rhs: tuple.3,
                        result: tuple.4,
                        caller: tuple.5,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForFheGtReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForFheGtReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForFheGtReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl checkHCUForFheGtReturn {
            fn _tokenize(
                &self,
            ) -> <checkHCUForFheGtCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for checkHCUForFheGtCall {
            type Parameters<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = checkHCUForFheGtReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "checkHCUForFheGt(uint8,bytes1,bytes32,bytes32,bytes32,address)";
            const SELECTOR: [u8; 4] = [69u8, 143u8, 178u8, 119u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <FheType as alloy_sol_types::SolType>::tokenize(&self.resultType),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.caller,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                checkHCUForFheGtReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `checkHCUForFheLe(uint8,bytes1,bytes32,bytes32,bytes32,address)` and selector `0x38bd17e5`.
```solidity
function checkHCUForFheLe(FheType resultType, bytes1 scalarByte, bytes32 lhs, bytes32 rhs, bytes32 result, address caller) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForFheLeCall {
        #[allow(missing_docs)]
        pub resultType: <FheType as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`checkHCUForFheLe(uint8,bytes1,bytes32,bytes32,bytes32,address)`](checkHCUForFheLeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForFheLeReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <FheType as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::FixedBytes<1>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForFheLeCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForFheLeCall) -> Self {
                    (
                        value.resultType,
                        value.scalarByte,
                        value.lhs,
                        value.rhs,
                        value.result,
                        value.caller,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForFheLeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        resultType: tuple.0,
                        scalarByte: tuple.1,
                        lhs: tuple.2,
                        rhs: tuple.3,
                        result: tuple.4,
                        caller: tuple.5,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForFheLeReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForFheLeReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForFheLeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl checkHCUForFheLeReturn {
            fn _tokenize(
                &self,
            ) -> <checkHCUForFheLeCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for checkHCUForFheLeCall {
            type Parameters<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = checkHCUForFheLeReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "checkHCUForFheLe(uint8,bytes1,bytes32,bytes32,bytes32,address)";
            const SELECTOR: [u8; 4] = [56u8, 189u8, 23u8, 229u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <FheType as alloy_sol_types::SolType>::tokenize(&self.resultType),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.caller,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                checkHCUForFheLeReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `checkHCUForFheLt(uint8,bytes1,bytes32,bytes32,bytes32,address)` and selector `0x3bb7d5a3`.
```solidity
function checkHCUForFheLt(FheType resultType, bytes1 scalarByte, bytes32 lhs, bytes32 rhs, bytes32 result, address caller) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForFheLtCall {
        #[allow(missing_docs)]
        pub resultType: <FheType as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`checkHCUForFheLt(uint8,bytes1,bytes32,bytes32,bytes32,address)`](checkHCUForFheLtCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForFheLtReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <FheType as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::FixedBytes<1>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForFheLtCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForFheLtCall) -> Self {
                    (
                        value.resultType,
                        value.scalarByte,
                        value.lhs,
                        value.rhs,
                        value.result,
                        value.caller,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForFheLtCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        resultType: tuple.0,
                        scalarByte: tuple.1,
                        lhs: tuple.2,
                        rhs: tuple.3,
                        result: tuple.4,
                        caller: tuple.5,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForFheLtReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForFheLtReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForFheLtReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl checkHCUForFheLtReturn {
            fn _tokenize(
                &self,
            ) -> <checkHCUForFheLtCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for checkHCUForFheLtCall {
            type Parameters<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = checkHCUForFheLtReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "checkHCUForFheLt(uint8,bytes1,bytes32,bytes32,bytes32,address)";
            const SELECTOR: [u8; 4] = [59u8, 183u8, 213u8, 163u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <FheType as alloy_sol_types::SolType>::tokenize(&self.resultType),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.caller,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                checkHCUForFheLtReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `checkHCUForFheMax(uint8,bytes1,bytes32,bytes32,bytes32,address)` and selector `0x968302d7`.
```solidity
function checkHCUForFheMax(FheType resultType, bytes1 scalarByte, bytes32 lhs, bytes32 rhs, bytes32 result, address caller) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForFheMaxCall {
        #[allow(missing_docs)]
        pub resultType: <FheType as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`checkHCUForFheMax(uint8,bytes1,bytes32,bytes32,bytes32,address)`](checkHCUForFheMaxCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForFheMaxReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <FheType as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::FixedBytes<1>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForFheMaxCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForFheMaxCall) -> Self {
                    (
                        value.resultType,
                        value.scalarByte,
                        value.lhs,
                        value.rhs,
                        value.result,
                        value.caller,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForFheMaxCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        resultType: tuple.0,
                        scalarByte: tuple.1,
                        lhs: tuple.2,
                        rhs: tuple.3,
                        result: tuple.4,
                        caller: tuple.5,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForFheMaxReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForFheMaxReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForFheMaxReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl checkHCUForFheMaxReturn {
            fn _tokenize(
                &self,
            ) -> <checkHCUForFheMaxCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for checkHCUForFheMaxCall {
            type Parameters<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = checkHCUForFheMaxReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "checkHCUForFheMax(uint8,bytes1,bytes32,bytes32,bytes32,address)";
            const SELECTOR: [u8; 4] = [150u8, 131u8, 2u8, 215u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <FheType as alloy_sol_types::SolType>::tokenize(&self.resultType),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.caller,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                checkHCUForFheMaxReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `checkHCUForFheMin(uint8,bytes1,bytes32,bytes32,bytes32,address)` and selector `0x04553fb6`.
```solidity
function checkHCUForFheMin(FheType resultType, bytes1 scalarByte, bytes32 lhs, bytes32 rhs, bytes32 result, address caller) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForFheMinCall {
        #[allow(missing_docs)]
        pub resultType: <FheType as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`checkHCUForFheMin(uint8,bytes1,bytes32,bytes32,bytes32,address)`](checkHCUForFheMinCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForFheMinReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <FheType as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::FixedBytes<1>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForFheMinCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForFheMinCall) -> Self {
                    (
                        value.resultType,
                        value.scalarByte,
                        value.lhs,
                        value.rhs,
                        value.result,
                        value.caller,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForFheMinCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        resultType: tuple.0,
                        scalarByte: tuple.1,
                        lhs: tuple.2,
                        rhs: tuple.3,
                        result: tuple.4,
                        caller: tuple.5,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForFheMinReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForFheMinReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForFheMinReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl checkHCUForFheMinReturn {
            fn _tokenize(
                &self,
            ) -> <checkHCUForFheMinCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for checkHCUForFheMinCall {
            type Parameters<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = checkHCUForFheMinReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "checkHCUForFheMin(uint8,bytes1,bytes32,bytes32,bytes32,address)";
            const SELECTOR: [u8; 4] = [4u8, 85u8, 63u8, 182u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <FheType as alloy_sol_types::SolType>::tokenize(&self.resultType),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.caller,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                checkHCUForFheMinReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `checkHCUForFheMul(uint8,bytes1,bytes32,bytes32,bytes32,address)` and selector `0x818f4d69`.
```solidity
function checkHCUForFheMul(FheType resultType, bytes1 scalarByte, bytes32 lhs, bytes32 rhs, bytes32 result, address caller) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForFheMulCall {
        #[allow(missing_docs)]
        pub resultType: <FheType as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`checkHCUForFheMul(uint8,bytes1,bytes32,bytes32,bytes32,address)`](checkHCUForFheMulCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForFheMulReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <FheType as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::FixedBytes<1>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForFheMulCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForFheMulCall) -> Self {
                    (
                        value.resultType,
                        value.scalarByte,
                        value.lhs,
                        value.rhs,
                        value.result,
                        value.caller,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForFheMulCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        resultType: tuple.0,
                        scalarByte: tuple.1,
                        lhs: tuple.2,
                        rhs: tuple.3,
                        result: tuple.4,
                        caller: tuple.5,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForFheMulReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForFheMulReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForFheMulReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl checkHCUForFheMulReturn {
            fn _tokenize(
                &self,
            ) -> <checkHCUForFheMulCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for checkHCUForFheMulCall {
            type Parameters<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = checkHCUForFheMulReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "checkHCUForFheMul(uint8,bytes1,bytes32,bytes32,bytes32,address)";
            const SELECTOR: [u8; 4] = [129u8, 143u8, 77u8, 105u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <FheType as alloy_sol_types::SolType>::tokenize(&self.resultType),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.caller,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                checkHCUForFheMulReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `checkHCUForFheNe(uint8,bytes1,bytes32,bytes32,bytes32,address)` and selector `0x6bad18b6`.
```solidity
function checkHCUForFheNe(FheType resultType, bytes1 scalarByte, bytes32 lhs, bytes32 rhs, bytes32 result, address caller) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForFheNeCall {
        #[allow(missing_docs)]
        pub resultType: <FheType as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`checkHCUForFheNe(uint8,bytes1,bytes32,bytes32,bytes32,address)`](checkHCUForFheNeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForFheNeReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <FheType as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::FixedBytes<1>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForFheNeCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForFheNeCall) -> Self {
                    (
                        value.resultType,
                        value.scalarByte,
                        value.lhs,
                        value.rhs,
                        value.result,
                        value.caller,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForFheNeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        resultType: tuple.0,
                        scalarByte: tuple.1,
                        lhs: tuple.2,
                        rhs: tuple.3,
                        result: tuple.4,
                        caller: tuple.5,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForFheNeReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForFheNeReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForFheNeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl checkHCUForFheNeReturn {
            fn _tokenize(
                &self,
            ) -> <checkHCUForFheNeCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for checkHCUForFheNeCall {
            type Parameters<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = checkHCUForFheNeReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "checkHCUForFheNe(uint8,bytes1,bytes32,bytes32,bytes32,address)";
            const SELECTOR: [u8; 4] = [107u8, 173u8, 24u8, 182u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <FheType as alloy_sol_types::SolType>::tokenize(&self.resultType),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.caller,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                checkHCUForFheNeReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `checkHCUForFheNeg(uint8,bytes32,bytes32,address)` and selector `0x497c22c5`.
```solidity
function checkHCUForFheNeg(FheType resultType, bytes32 ct, bytes32 result, address caller) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForFheNegCall {
        #[allow(missing_docs)]
        pub resultType: <FheType as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub ct: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`checkHCUForFheNeg(uint8,bytes32,bytes32,address)`](checkHCUForFheNegCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForFheNegReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <FheType as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForFheNegCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForFheNegCall) -> Self {
                    (value.resultType, value.ct, value.result, value.caller)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForFheNegCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        resultType: tuple.0,
                        ct: tuple.1,
                        result: tuple.2,
                        caller: tuple.3,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForFheNegReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForFheNegReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForFheNegReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl checkHCUForFheNegReturn {
            fn _tokenize(
                &self,
            ) -> <checkHCUForFheNegCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for checkHCUForFheNegCall {
            type Parameters<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = checkHCUForFheNegReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "checkHCUForFheNeg(uint8,bytes32,bytes32,address)";
            const SELECTOR: [u8; 4] = [73u8, 124u8, 34u8, 197u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <FheType as alloy_sol_types::SolType>::tokenize(&self.resultType),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.ct),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.caller,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                checkHCUForFheNegReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `checkHCUForFheNot(uint8,bytes32,bytes32,address)` and selector `0x2dcbc5d1`.
```solidity
function checkHCUForFheNot(FheType resultType, bytes32 ct, bytes32 result, address caller) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForFheNotCall {
        #[allow(missing_docs)]
        pub resultType: <FheType as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub ct: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`checkHCUForFheNot(uint8,bytes32,bytes32,address)`](checkHCUForFheNotCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForFheNotReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <FheType as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForFheNotCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForFheNotCall) -> Self {
                    (value.resultType, value.ct, value.result, value.caller)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForFheNotCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        resultType: tuple.0,
                        ct: tuple.1,
                        result: tuple.2,
                        caller: tuple.3,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForFheNotReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForFheNotReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForFheNotReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl checkHCUForFheNotReturn {
            fn _tokenize(
                &self,
            ) -> <checkHCUForFheNotCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for checkHCUForFheNotCall {
            type Parameters<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = checkHCUForFheNotReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "checkHCUForFheNot(uint8,bytes32,bytes32,address)";
            const SELECTOR: [u8; 4] = [45u8, 203u8, 197u8, 209u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <FheType as alloy_sol_types::SolType>::tokenize(&self.resultType),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.ct),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.caller,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                checkHCUForFheNotReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `checkHCUForFheRand(uint8,bytes32,address)` and selector `0xd5b8b8f3`.
```solidity
function checkHCUForFheRand(FheType resultType, bytes32 result, address caller) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForFheRandCall {
        #[allow(missing_docs)]
        pub resultType: <FheType as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`checkHCUForFheRand(uint8,bytes32,address)`](checkHCUForFheRandCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForFheRandReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <FheType as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForFheRandCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForFheRandCall) -> Self {
                    (value.resultType, value.result, value.caller)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForFheRandCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        resultType: tuple.0,
                        result: tuple.1,
                        caller: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForFheRandReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForFheRandReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForFheRandReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl checkHCUForFheRandReturn {
            fn _tokenize(
                &self,
            ) -> <checkHCUForFheRandCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for checkHCUForFheRandCall {
            type Parameters<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = checkHCUForFheRandReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "checkHCUForFheRand(uint8,bytes32,address)";
            const SELECTOR: [u8; 4] = [213u8, 184u8, 184u8, 243u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <FheType as alloy_sol_types::SolType>::tokenize(&self.resultType),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.caller,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                checkHCUForFheRandReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `checkHCUForFheRandBounded(uint8,bytes32,address)` and selector `0x6cf0bd25`.
```solidity
function checkHCUForFheRandBounded(FheType resultType, bytes32 result, address caller) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForFheRandBoundedCall {
        #[allow(missing_docs)]
        pub resultType: <FheType as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`checkHCUForFheRandBounded(uint8,bytes32,address)`](checkHCUForFheRandBoundedCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForFheRandBoundedReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <FheType as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForFheRandBoundedCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForFheRandBoundedCall) -> Self {
                    (value.resultType, value.result, value.caller)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForFheRandBoundedCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        resultType: tuple.0,
                        result: tuple.1,
                        caller: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForFheRandBoundedReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForFheRandBoundedReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForFheRandBoundedReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl checkHCUForFheRandBoundedReturn {
            fn _tokenize(
                &self,
            ) -> <checkHCUForFheRandBoundedCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for checkHCUForFheRandBoundedCall {
            type Parameters<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = checkHCUForFheRandBoundedReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "checkHCUForFheRandBounded(uint8,bytes32,address)";
            const SELECTOR: [u8; 4] = [108u8, 240u8, 189u8, 37u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <FheType as alloy_sol_types::SolType>::tokenize(&self.resultType),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.caller,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                checkHCUForFheRandBoundedReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `checkHCUForFheRem(uint8,bytes1,bytes32,bytes32,bytes32,address)` and selector `0x3311b1bc`.
```solidity
function checkHCUForFheRem(FheType resultType, bytes1 scalarByte, bytes32 lhs, bytes32, bytes32 result, address caller) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForFheRemCall {
        #[allow(missing_docs)]
        pub resultType: <FheType as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub _3: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`checkHCUForFheRem(uint8,bytes1,bytes32,bytes32,bytes32,address)`](checkHCUForFheRemCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForFheRemReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <FheType as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::FixedBytes<1>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForFheRemCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForFheRemCall) -> Self {
                    (
                        value.resultType,
                        value.scalarByte,
                        value.lhs,
                        value._3,
                        value.result,
                        value.caller,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForFheRemCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        resultType: tuple.0,
                        scalarByte: tuple.1,
                        lhs: tuple.2,
                        _3: tuple.3,
                        result: tuple.4,
                        caller: tuple.5,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForFheRemReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForFheRemReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForFheRemReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl checkHCUForFheRemReturn {
            fn _tokenize(
                &self,
            ) -> <checkHCUForFheRemCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for checkHCUForFheRemCall {
            type Parameters<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = checkHCUForFheRemReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "checkHCUForFheRem(uint8,bytes1,bytes32,bytes32,bytes32,address)";
            const SELECTOR: [u8; 4] = [51u8, 17u8, 177u8, 188u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <FheType as alloy_sol_types::SolType>::tokenize(&self.resultType),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self._3),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.caller,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                checkHCUForFheRemReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `checkHCUForFheRotl(uint8,bytes1,bytes32,bytes32,bytes32,address)` and selector `0x5f76eb30`.
```solidity
function checkHCUForFheRotl(FheType resultType, bytes1 scalarByte, bytes32 lhs, bytes32 rhs, bytes32 result, address caller) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForFheRotlCall {
        #[allow(missing_docs)]
        pub resultType: <FheType as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`checkHCUForFheRotl(uint8,bytes1,bytes32,bytes32,bytes32,address)`](checkHCUForFheRotlCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForFheRotlReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <FheType as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::FixedBytes<1>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForFheRotlCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForFheRotlCall) -> Self {
                    (
                        value.resultType,
                        value.scalarByte,
                        value.lhs,
                        value.rhs,
                        value.result,
                        value.caller,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForFheRotlCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        resultType: tuple.0,
                        scalarByte: tuple.1,
                        lhs: tuple.2,
                        rhs: tuple.3,
                        result: tuple.4,
                        caller: tuple.5,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForFheRotlReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForFheRotlReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForFheRotlReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl checkHCUForFheRotlReturn {
            fn _tokenize(
                &self,
            ) -> <checkHCUForFheRotlCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for checkHCUForFheRotlCall {
            type Parameters<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = checkHCUForFheRotlReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "checkHCUForFheRotl(uint8,bytes1,bytes32,bytes32,bytes32,address)";
            const SELECTOR: [u8; 4] = [95u8, 118u8, 235u8, 48u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <FheType as alloy_sol_types::SolType>::tokenize(&self.resultType),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.caller,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                checkHCUForFheRotlReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `checkHCUForFheRotr(uint8,bytes1,bytes32,bytes32,bytes32,address)` and selector `0x8629f545`.
```solidity
function checkHCUForFheRotr(FheType resultType, bytes1 scalarByte, bytes32 lhs, bytes32 rhs, bytes32 result, address caller) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForFheRotrCall {
        #[allow(missing_docs)]
        pub resultType: <FheType as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`checkHCUForFheRotr(uint8,bytes1,bytes32,bytes32,bytes32,address)`](checkHCUForFheRotrCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForFheRotrReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <FheType as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::FixedBytes<1>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForFheRotrCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForFheRotrCall) -> Self {
                    (
                        value.resultType,
                        value.scalarByte,
                        value.lhs,
                        value.rhs,
                        value.result,
                        value.caller,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForFheRotrCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        resultType: tuple.0,
                        scalarByte: tuple.1,
                        lhs: tuple.2,
                        rhs: tuple.3,
                        result: tuple.4,
                        caller: tuple.5,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForFheRotrReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForFheRotrReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForFheRotrReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl checkHCUForFheRotrReturn {
            fn _tokenize(
                &self,
            ) -> <checkHCUForFheRotrCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for checkHCUForFheRotrCall {
            type Parameters<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = checkHCUForFheRotrReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "checkHCUForFheRotr(uint8,bytes1,bytes32,bytes32,bytes32,address)";
            const SELECTOR: [u8; 4] = [134u8, 41u8, 245u8, 69u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <FheType as alloy_sol_types::SolType>::tokenize(&self.resultType),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.caller,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                checkHCUForFheRotrReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `checkHCUForFheShl(uint8,bytes1,bytes32,bytes32,bytes32,address)` and selector `0xf7d198f8`.
```solidity
function checkHCUForFheShl(FheType resultType, bytes1 scalarByte, bytes32 lhs, bytes32 rhs, bytes32 result, address caller) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForFheShlCall {
        #[allow(missing_docs)]
        pub resultType: <FheType as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`checkHCUForFheShl(uint8,bytes1,bytes32,bytes32,bytes32,address)`](checkHCUForFheShlCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForFheShlReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <FheType as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::FixedBytes<1>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForFheShlCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForFheShlCall) -> Self {
                    (
                        value.resultType,
                        value.scalarByte,
                        value.lhs,
                        value.rhs,
                        value.result,
                        value.caller,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForFheShlCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        resultType: tuple.0,
                        scalarByte: tuple.1,
                        lhs: tuple.2,
                        rhs: tuple.3,
                        result: tuple.4,
                        caller: tuple.5,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForFheShlReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForFheShlReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForFheShlReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl checkHCUForFheShlReturn {
            fn _tokenize(
                &self,
            ) -> <checkHCUForFheShlCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for checkHCUForFheShlCall {
            type Parameters<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = checkHCUForFheShlReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "checkHCUForFheShl(uint8,bytes1,bytes32,bytes32,bytes32,address)";
            const SELECTOR: [u8; 4] = [247u8, 209u8, 152u8, 248u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <FheType as alloy_sol_types::SolType>::tokenize(&self.resultType),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.caller,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                checkHCUForFheShlReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `checkHCUForFheShr(uint8,bytes1,bytes32,bytes32,bytes32,address)` and selector `0x07ccdf61`.
```solidity
function checkHCUForFheShr(FheType resultType, bytes1 scalarByte, bytes32 lhs, bytes32 rhs, bytes32 result, address caller) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForFheShrCall {
        #[allow(missing_docs)]
        pub resultType: <FheType as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`checkHCUForFheShr(uint8,bytes1,bytes32,bytes32,bytes32,address)`](checkHCUForFheShrCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForFheShrReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <FheType as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::FixedBytes<1>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForFheShrCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForFheShrCall) -> Self {
                    (
                        value.resultType,
                        value.scalarByte,
                        value.lhs,
                        value.rhs,
                        value.result,
                        value.caller,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForFheShrCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        resultType: tuple.0,
                        scalarByte: tuple.1,
                        lhs: tuple.2,
                        rhs: tuple.3,
                        result: tuple.4,
                        caller: tuple.5,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForFheShrReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForFheShrReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForFheShrReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl checkHCUForFheShrReturn {
            fn _tokenize(
                &self,
            ) -> <checkHCUForFheShrCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for checkHCUForFheShrCall {
            type Parameters<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = checkHCUForFheShrReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "checkHCUForFheShr(uint8,bytes1,bytes32,bytes32,bytes32,address)";
            const SELECTOR: [u8; 4] = [7u8, 204u8, 223u8, 97u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <FheType as alloy_sol_types::SolType>::tokenize(&self.resultType),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.caller,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                checkHCUForFheShrReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `checkHCUForFheSub(uint8,bytes1,bytes32,bytes32,bytes32,address)` and selector `0xd633c96b`.
```solidity
function checkHCUForFheSub(FheType resultType, bytes1 scalarByte, bytes32 lhs, bytes32 rhs, bytes32 result, address caller) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForFheSubCall {
        #[allow(missing_docs)]
        pub resultType: <FheType as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub scalarByte: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`checkHCUForFheSub(uint8,bytes1,bytes32,bytes32,bytes32,address)`](checkHCUForFheSubCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForFheSubReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <FheType as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::FixedBytes<1>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForFheSubCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForFheSubCall) -> Self {
                    (
                        value.resultType,
                        value.scalarByte,
                        value.lhs,
                        value.rhs,
                        value.result,
                        value.caller,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForFheSubCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        resultType: tuple.0,
                        scalarByte: tuple.1,
                        lhs: tuple.2,
                        rhs: tuple.3,
                        result: tuple.4,
                        caller: tuple.5,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForFheSubReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForFheSubReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForFheSubReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl checkHCUForFheSubReturn {
            fn _tokenize(
                &self,
            ) -> <checkHCUForFheSubCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for checkHCUForFheSubCall {
            type Parameters<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = checkHCUForFheSubReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "checkHCUForFheSub(uint8,bytes1,bytes32,bytes32,bytes32,address)";
            const SELECTOR: [u8; 4] = [214u8, 51u8, 201u8, 107u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <FheType as alloy_sol_types::SolType>::tokenize(&self.resultType),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalarByte),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.caller,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                checkHCUForFheSubReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `checkHCUForIfThenElse(uint8,bytes32,bytes32,bytes32,bytes32,address)` and selector `0x2e3c3906`.
```solidity
function checkHCUForIfThenElse(FheType resultType, bytes32 lhs, bytes32 middle, bytes32 rhs, bytes32 result, address caller) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForIfThenElseCall {
        #[allow(missing_docs)]
        pub resultType: <FheType as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub lhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub middle: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub rhs: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`checkHCUForIfThenElse(uint8,bytes32,bytes32,bytes32,bytes32,address)`](checkHCUForIfThenElseCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForIfThenElseReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <FheType as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForIfThenElseCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForIfThenElseCall) -> Self {
                    (
                        value.resultType,
                        value.lhs,
                        value.middle,
                        value.rhs,
                        value.result,
                        value.caller,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForIfThenElseCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        resultType: tuple.0,
                        lhs: tuple.1,
                        middle: tuple.2,
                        rhs: tuple.3,
                        result: tuple.4,
                        caller: tuple.5,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForIfThenElseReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForIfThenElseReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForIfThenElseReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl checkHCUForIfThenElseReturn {
            fn _tokenize(
                &self,
            ) -> <checkHCUForIfThenElseCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for checkHCUForIfThenElseCall {
            type Parameters<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = checkHCUForIfThenElseReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "checkHCUForIfThenElse(uint8,bytes32,bytes32,bytes32,bytes32,address)";
            const SELECTOR: [u8; 4] = [46u8, 60u8, 57u8, 6u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <FheType as alloy_sol_types::SolType>::tokenize(&self.resultType),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.middle),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rhs),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.caller,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                checkHCUForIfThenElseReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `checkHCUForTrivialEncrypt(uint8,bytes32,address)` and selector `0xb78bef59`.
```solidity
function checkHCUForTrivialEncrypt(FheType resultType, bytes32 result, address caller) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForTrivialEncryptCall {
        #[allow(missing_docs)]
        pub resultType: <FheType as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`checkHCUForTrivialEncrypt(uint8,bytes32,address)`](checkHCUForTrivialEncryptCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkHCUForTrivialEncryptReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <FheType as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForTrivialEncryptCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForTrivialEncryptCall) -> Self {
                    (value.resultType, value.result, value.caller)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForTrivialEncryptCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        resultType: tuple.0,
                        result: tuple.1,
                        caller: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkHCUForTrivialEncryptReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkHCUForTrivialEncryptReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkHCUForTrivialEncryptReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl checkHCUForTrivialEncryptReturn {
            fn _tokenize(
                &self,
            ) -> <checkHCUForTrivialEncryptCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for checkHCUForTrivialEncryptCall {
            type Parameters<'a> = (
                FheType,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = checkHCUForTrivialEncryptReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "checkHCUForTrivialEncrypt(uint8,bytes32,address)";
            const SELECTOR: [u8; 4] = [183u8, 139u8, 239u8, 89u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <FheType as alloy_sol_types::SolType>::tokenize(&self.resultType),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.result),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.caller,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                checkHCUForTrivialEncryptReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getBlockMeter()` and selector `0x9f4b9937`.
```solidity
function getBlockMeter() external view returns (uint48 blockNumber, uint48 usedHCU);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getBlockMeterCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getBlockMeter()`](getBlockMeterCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getBlockMeterReturn {
        #[allow(missing_docs)]
        pub blockNumber: alloy::sol_types::private::primitives::aliases::U48,
        #[allow(missing_docs)]
        pub usedHCU: alloy::sol_types::private::primitives::aliases::U48,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getBlockMeterCall> for UnderlyingRustTuple<'_> {
                fn from(value: getBlockMeterCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getBlockMeterCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<48>,
                alloy::sol_types::sol_data::Uint<48>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U48,
                alloy::sol_types::private::primitives::aliases::U48,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getBlockMeterReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getBlockMeterReturn) -> Self {
                    (value.blockNumber, value.usedHCU)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getBlockMeterReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        blockNumber: tuple.0,
                        usedHCU: tuple.1,
                    }
                }
            }
        }
        impl getBlockMeterReturn {
            fn _tokenize(
                &self,
            ) -> <getBlockMeterCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        48,
                    > as alloy_sol_types::SolType>::tokenize(&self.blockNumber),
                    <alloy::sol_types::sol_data::Uint<
                        48,
                    > as alloy_sol_types::SolType>::tokenize(&self.usedHCU),
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getBlockMeterCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getBlockMeterReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Uint<48>,
                alloy::sol_types::sol_data::Uint<48>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getBlockMeter()";
            const SELECTOR: [u8; 4] = [159u8, 75u8, 153u8, 55u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                getBlockMeterReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getFHEVMExecutorAddress()` and selector `0x268d6d31`.
```solidity
function getFHEVMExecutorAddress() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getFHEVMExecutorAddressCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getFHEVMExecutorAddress()`](getFHEVMExecutorAddressCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getFHEVMExecutorAddressReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getFHEVMExecutorAddressCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getFHEVMExecutorAddressCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getFHEVMExecutorAddressCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getFHEVMExecutorAddressReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getFHEVMExecutorAddressReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getFHEVMExecutorAddressReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getFHEVMExecutorAddressCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getFHEVMExecutorAddress()";
            const SELECTOR: [u8; 4] = [38u8, 141u8, 109u8, 49u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getFHEVMExecutorAddressReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getFHEVMExecutorAddressReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getGlobalHCUCapPerBlock()` and selector `0xb59547b8`.
```solidity
function getGlobalHCUCapPerBlock() external view returns (uint48);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getGlobalHCUCapPerBlockCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getGlobalHCUCapPerBlock()`](getGlobalHCUCapPerBlockCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getGlobalHCUCapPerBlockReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U48,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getGlobalHCUCapPerBlockCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getGlobalHCUCapPerBlockCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getGlobalHCUCapPerBlockCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<48>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U48,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getGlobalHCUCapPerBlockReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getGlobalHCUCapPerBlockReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getGlobalHCUCapPerBlockReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getGlobalHCUCapPerBlockCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U48;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<48>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getGlobalHCUCapPerBlock()";
            const SELECTOR: [u8; 4] = [181u8, 149u8, 71u8, 184u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        48,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getGlobalHCUCapPerBlockReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getGlobalHCUCapPerBlockReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getMaxHCUDepthPerTx()` and selector `0x1e24aa49`.
```solidity
function getMaxHCUDepthPerTx() external view returns (uint48);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getMaxHCUDepthPerTxCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getMaxHCUDepthPerTx()`](getMaxHCUDepthPerTxCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getMaxHCUDepthPerTxReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U48,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getMaxHCUDepthPerTxCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getMaxHCUDepthPerTxCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getMaxHCUDepthPerTxCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<48>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U48,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getMaxHCUDepthPerTxReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getMaxHCUDepthPerTxReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getMaxHCUDepthPerTxReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getMaxHCUDepthPerTxCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U48;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<48>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getMaxHCUDepthPerTx()";
            const SELECTOR: [u8; 4] = [30u8, 36u8, 170u8, 73u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        48,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getMaxHCUDepthPerTxReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getMaxHCUDepthPerTxReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getMaxHCUPerTx()` and selector `0xc13c1971`.
```solidity
function getMaxHCUPerTx() external view returns (uint48);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getMaxHCUPerTxCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getMaxHCUPerTx()`](getMaxHCUPerTxCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getMaxHCUPerTxReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U48,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getMaxHCUPerTxCall> for UnderlyingRustTuple<'_> {
                fn from(value: getMaxHCUPerTxCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getMaxHCUPerTxCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<48>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U48,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getMaxHCUPerTxReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getMaxHCUPerTxReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getMaxHCUPerTxReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getMaxHCUPerTxCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U48;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<48>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getMaxHCUPerTx()";
            const SELECTOR: [u8; 4] = [193u8, 60u8, 25u8, 113u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        48,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getMaxHCUPerTxReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getMaxHCUPerTxReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getVersion()` and selector `0x0d8e6e2c`.
```solidity
function getVersion() external pure returns (string memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getVersionCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getVersion()`](getVersionCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getVersionReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getVersionCall> for UnderlyingRustTuple<'_> {
                fn from(value: getVersionCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getVersionCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getVersionReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getVersionReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getVersionReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getVersionCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::String;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getVersion()";
            const SELECTOR: [u8; 4] = [13u8, 142u8, 110u8, 44u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getVersionReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getVersionReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `initializeFromEmptyProxy(uint48,uint48,uint48)` and selector `0x196a456d`.
```solidity
function initializeFromEmptyProxy(uint48 hcuCapPerBlock, uint48 maxHCUDepthPerTx, uint48 maxHCUPerTx) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct initializeFromEmptyProxyCall {
        #[allow(missing_docs)]
        pub hcuCapPerBlock: alloy::sol_types::private::primitives::aliases::U48,
        #[allow(missing_docs)]
        pub maxHCUDepthPerTx: alloy::sol_types::private::primitives::aliases::U48,
        #[allow(missing_docs)]
        pub maxHCUPerTx: alloy::sol_types::private::primitives::aliases::U48,
    }
    ///Container type for the return parameters of the [`initializeFromEmptyProxy(uint48,uint48,uint48)`](initializeFromEmptyProxyCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct initializeFromEmptyProxyReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<48>,
                alloy::sol_types::sol_data::Uint<48>,
                alloy::sol_types::sol_data::Uint<48>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U48,
                alloy::sol_types::private::primitives::aliases::U48,
                alloy::sol_types::private::primitives::aliases::U48,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<initializeFromEmptyProxyCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: initializeFromEmptyProxyCall) -> Self {
                    (value.hcuCapPerBlock, value.maxHCUDepthPerTx, value.maxHCUPerTx)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for initializeFromEmptyProxyCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        hcuCapPerBlock: tuple.0,
                        maxHCUDepthPerTx: tuple.1,
                        maxHCUPerTx: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<initializeFromEmptyProxyReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: initializeFromEmptyProxyReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for initializeFromEmptyProxyReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl initializeFromEmptyProxyReturn {
            fn _tokenize(
                &self,
            ) -> <initializeFromEmptyProxyCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for initializeFromEmptyProxyCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<48>,
                alloy::sol_types::sol_data::Uint<48>,
                alloy::sol_types::sol_data::Uint<48>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = initializeFromEmptyProxyReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "initializeFromEmptyProxy(uint48,uint48,uint48)";
            const SELECTOR: [u8; 4] = [25u8, 106u8, 69u8, 109u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        48,
                    > as alloy_sol_types::SolType>::tokenize(&self.hcuCapPerBlock),
                    <alloy::sol_types::sol_data::Uint<
                        48,
                    > as alloy_sol_types::SolType>::tokenize(&self.maxHCUDepthPerTx),
                    <alloy::sol_types::sol_data::Uint<
                        48,
                    > as alloy_sol_types::SolType>::tokenize(&self.maxHCUPerTx),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                initializeFromEmptyProxyReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `isBlockHCUWhitelisted(address)` and selector `0xede8776e`.
```solidity
function isBlockHCUWhitelisted(address account) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isBlockHCUWhitelistedCall {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`isBlockHCUWhitelisted(address)`](isBlockHCUWhitelistedCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isBlockHCUWhitelistedReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isBlockHCUWhitelistedCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: isBlockHCUWhitelistedCall) -> Self {
                    (value.account,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for isBlockHCUWhitelistedCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { account: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isBlockHCUWhitelistedReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: isBlockHCUWhitelistedReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for isBlockHCUWhitelistedReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for isBlockHCUWhitelistedCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bool;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "isBlockHCUWhitelisted(address)";
            const SELECTOR: [u8; 4] = [237u8, 232u8, 119u8, 110u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: isBlockHCUWhitelistedReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: isBlockHCUWhitelistedReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `proxiableUUID()` and selector `0x52d1902d`.
```solidity
function proxiableUUID() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct proxiableUUIDCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`proxiableUUID()`](proxiableUUIDCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct proxiableUUIDReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<proxiableUUIDCall> for UnderlyingRustTuple<'_> {
                fn from(value: proxiableUUIDCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for proxiableUUIDCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<proxiableUUIDReturn> for UnderlyingRustTuple<'_> {
                fn from(value: proxiableUUIDReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for proxiableUUIDReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for proxiableUUIDCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "proxiableUUID()";
            const SELECTOR: [u8; 4] = [82u8, 209u8, 144u8, 45u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: proxiableUUIDReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: proxiableUUIDReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `reinitializeV2(uint48,uint48,uint48)` and selector `0x7748671a`.
```solidity
function reinitializeV2(uint48 hcuCapPerBlock, uint48 maxHCUDepthPerTx, uint48 maxHCUPerTx) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct reinitializeV2Call {
        #[allow(missing_docs)]
        pub hcuCapPerBlock: alloy::sol_types::private::primitives::aliases::U48,
        #[allow(missing_docs)]
        pub maxHCUDepthPerTx: alloy::sol_types::private::primitives::aliases::U48,
        #[allow(missing_docs)]
        pub maxHCUPerTx: alloy::sol_types::private::primitives::aliases::U48,
    }
    ///Container type for the return parameters of the [`reinitializeV2(uint48,uint48,uint48)`](reinitializeV2Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct reinitializeV2Return {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<48>,
                alloy::sol_types::sol_data::Uint<48>,
                alloy::sol_types::sol_data::Uint<48>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U48,
                alloy::sol_types::private::primitives::aliases::U48,
                alloy::sol_types::private::primitives::aliases::U48,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<reinitializeV2Call> for UnderlyingRustTuple<'_> {
                fn from(value: reinitializeV2Call) -> Self {
                    (value.hcuCapPerBlock, value.maxHCUDepthPerTx, value.maxHCUPerTx)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for reinitializeV2Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        hcuCapPerBlock: tuple.0,
                        maxHCUDepthPerTx: tuple.1,
                        maxHCUPerTx: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<reinitializeV2Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: reinitializeV2Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for reinitializeV2Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl reinitializeV2Return {
            fn _tokenize(
                &self,
            ) -> <reinitializeV2Call as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for reinitializeV2Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<48>,
                alloy::sol_types::sol_data::Uint<48>,
                alloy::sol_types::sol_data::Uint<48>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = reinitializeV2Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "reinitializeV2(uint48,uint48,uint48)";
            const SELECTOR: [u8; 4] = [119u8, 72u8, 103u8, 26u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        48,
                    > as alloy_sol_types::SolType>::tokenize(&self.hcuCapPerBlock),
                    <alloy::sol_types::sol_data::Uint<
                        48,
                    > as alloy_sol_types::SolType>::tokenize(&self.maxHCUDepthPerTx),
                    <alloy::sol_types::sol_data::Uint<
                        48,
                    > as alloy_sol_types::SolType>::tokenize(&self.maxHCUPerTx),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                reinitializeV2Return::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `removeFromBlockHCUWhitelist(address)` and selector `0x28677ca7`.
```solidity
function removeFromBlockHCUWhitelist(address account) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct removeFromBlockHCUWhitelistCall {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`removeFromBlockHCUWhitelist(address)`](removeFromBlockHCUWhitelistCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct removeFromBlockHCUWhitelistReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<removeFromBlockHCUWhitelistCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: removeFromBlockHCUWhitelistCall) -> Self {
                    (value.account,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for removeFromBlockHCUWhitelistCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { account: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<removeFromBlockHCUWhitelistReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: removeFromBlockHCUWhitelistReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for removeFromBlockHCUWhitelistReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl removeFromBlockHCUWhitelistReturn {
            fn _tokenize(
                &self,
            ) -> <removeFromBlockHCUWhitelistCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for removeFromBlockHCUWhitelistCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = removeFromBlockHCUWhitelistReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "removeFromBlockHCUWhitelist(address)";
            const SELECTOR: [u8; 4] = [40u8, 103u8, 124u8, 167u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                removeFromBlockHCUWhitelistReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `setHCUPerBlock(uint48)` and selector `0xa036ea2e`.
```solidity
function setHCUPerBlock(uint48 hcuPerBlock) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setHCUPerBlockCall {
        #[allow(missing_docs)]
        pub hcuPerBlock: alloy::sol_types::private::primitives::aliases::U48,
    }
    ///Container type for the return parameters of the [`setHCUPerBlock(uint48)`](setHCUPerBlockCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setHCUPerBlockReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<48>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U48,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setHCUPerBlockCall> for UnderlyingRustTuple<'_> {
                fn from(value: setHCUPerBlockCall) -> Self {
                    (value.hcuPerBlock,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setHCUPerBlockCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { hcuPerBlock: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setHCUPerBlockReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setHCUPerBlockReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setHCUPerBlockReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl setHCUPerBlockReturn {
            fn _tokenize(
                &self,
            ) -> <setHCUPerBlockCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setHCUPerBlockCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<48>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setHCUPerBlockReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setHCUPerBlock(uint48)";
            const SELECTOR: [u8; 4] = [160u8, 54u8, 234u8, 46u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        48,
                    > as alloy_sol_types::SolType>::tokenize(&self.hcuPerBlock),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                setHCUPerBlockReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `setMaxHCUDepthPerTx(uint48)` and selector `0x5c414b57`.
```solidity
function setMaxHCUDepthPerTx(uint48 maxHCUDepthPerTx) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setMaxHCUDepthPerTxCall {
        #[allow(missing_docs)]
        pub maxHCUDepthPerTx: alloy::sol_types::private::primitives::aliases::U48,
    }
    ///Container type for the return parameters of the [`setMaxHCUDepthPerTx(uint48)`](setMaxHCUDepthPerTxCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setMaxHCUDepthPerTxReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<48>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U48,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setMaxHCUDepthPerTxCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: setMaxHCUDepthPerTxCall) -> Self {
                    (value.maxHCUDepthPerTx,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setMaxHCUDepthPerTxCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { maxHCUDepthPerTx: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setMaxHCUDepthPerTxReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setMaxHCUDepthPerTxReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setMaxHCUDepthPerTxReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl setMaxHCUDepthPerTxReturn {
            fn _tokenize(
                &self,
            ) -> <setMaxHCUDepthPerTxCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setMaxHCUDepthPerTxCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<48>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setMaxHCUDepthPerTxReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setMaxHCUDepthPerTx(uint48)";
            const SELECTOR: [u8; 4] = [92u8, 65u8, 75u8, 87u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        48,
                    > as alloy_sol_types::SolType>::tokenize(&self.maxHCUDepthPerTx),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                setMaxHCUDepthPerTxReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `setMaxHCUPerTx(uint48)` and selector `0xab394755`.
```solidity
function setMaxHCUPerTx(uint48 maxHCUPerTx) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setMaxHCUPerTxCall {
        #[allow(missing_docs)]
        pub maxHCUPerTx: alloy::sol_types::private::primitives::aliases::U48,
    }
    ///Container type for the return parameters of the [`setMaxHCUPerTx(uint48)`](setMaxHCUPerTxCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setMaxHCUPerTxReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<48>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U48,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setMaxHCUPerTxCall> for UnderlyingRustTuple<'_> {
                fn from(value: setMaxHCUPerTxCall) -> Self {
                    (value.maxHCUPerTx,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setMaxHCUPerTxCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { maxHCUPerTx: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setMaxHCUPerTxReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setMaxHCUPerTxReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setMaxHCUPerTxReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl setMaxHCUPerTxReturn {
            fn _tokenize(
                &self,
            ) -> <setMaxHCUPerTxCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setMaxHCUPerTxCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<48>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setMaxHCUPerTxReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setMaxHCUPerTx(uint48)";
            const SELECTOR: [u8; 4] = [171u8, 57u8, 71u8, 85u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        48,
                    > as alloy_sol_types::SolType>::tokenize(&self.maxHCUPerTx),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                setMaxHCUPerTxReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `upgradeToAndCall(address,bytes)` and selector `0x4f1ef286`.
```solidity
function upgradeToAndCall(address newImplementation, bytes memory data) external payable;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct upgradeToAndCallCall {
        #[allow(missing_docs)]
        pub newImplementation: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub data: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`upgradeToAndCall(address,bytes)`](upgradeToAndCallCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct upgradeToAndCallReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<upgradeToAndCallCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: upgradeToAndCallCall) -> Self {
                    (value.newImplementation, value.data)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for upgradeToAndCallCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        newImplementation: tuple.0,
                        data: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<upgradeToAndCallReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: upgradeToAndCallReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for upgradeToAndCallReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl upgradeToAndCallReturn {
            fn _tokenize(
                &self,
            ) -> <upgradeToAndCallCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for upgradeToAndCallCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = upgradeToAndCallReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "upgradeToAndCall(address,bytes)";
            const SELECTOR: [u8; 4] = [79u8, 30u8, 242u8, 134u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.newImplementation,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.data,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                upgradeToAndCallReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    ///Container for all the [`HCULimit`](self) function calls.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive()]
    pub enum HCULimitCalls {
        #[allow(missing_docs)]
        UPGRADE_INTERFACE_VERSION(UPGRADE_INTERFACE_VERSIONCall),
        #[allow(missing_docs)]
        addToBlockHCUWhitelist(addToBlockHCUWhitelistCall),
        #[allow(missing_docs)]
        checkHCUForCast(checkHCUForCastCall),
        #[allow(missing_docs)]
        checkHCUForFheAdd(checkHCUForFheAddCall),
        #[allow(missing_docs)]
        checkHCUForFheBitAnd(checkHCUForFheBitAndCall),
        #[allow(missing_docs)]
        checkHCUForFheBitOr(checkHCUForFheBitOrCall),
        #[allow(missing_docs)]
        checkHCUForFheBitXor(checkHCUForFheBitXorCall),
        #[allow(missing_docs)]
        checkHCUForFheDiv(checkHCUForFheDivCall),
        #[allow(missing_docs)]
        checkHCUForFheEq(checkHCUForFheEqCall),
        #[allow(missing_docs)]
        checkHCUForFheGe(checkHCUForFheGeCall),
        #[allow(missing_docs)]
        checkHCUForFheGt(checkHCUForFheGtCall),
        #[allow(missing_docs)]
        checkHCUForFheLe(checkHCUForFheLeCall),
        #[allow(missing_docs)]
        checkHCUForFheLt(checkHCUForFheLtCall),
        #[allow(missing_docs)]
        checkHCUForFheMax(checkHCUForFheMaxCall),
        #[allow(missing_docs)]
        checkHCUForFheMin(checkHCUForFheMinCall),
        #[allow(missing_docs)]
        checkHCUForFheMul(checkHCUForFheMulCall),
        #[allow(missing_docs)]
        checkHCUForFheNe(checkHCUForFheNeCall),
        #[allow(missing_docs)]
        checkHCUForFheNeg(checkHCUForFheNegCall),
        #[allow(missing_docs)]
        checkHCUForFheNot(checkHCUForFheNotCall),
        #[allow(missing_docs)]
        checkHCUForFheRand(checkHCUForFheRandCall),
        #[allow(missing_docs)]
        checkHCUForFheRandBounded(checkHCUForFheRandBoundedCall),
        #[allow(missing_docs)]
        checkHCUForFheRem(checkHCUForFheRemCall),
        #[allow(missing_docs)]
        checkHCUForFheRotl(checkHCUForFheRotlCall),
        #[allow(missing_docs)]
        checkHCUForFheRotr(checkHCUForFheRotrCall),
        #[allow(missing_docs)]
        checkHCUForFheShl(checkHCUForFheShlCall),
        #[allow(missing_docs)]
        checkHCUForFheShr(checkHCUForFheShrCall),
        #[allow(missing_docs)]
        checkHCUForFheSub(checkHCUForFheSubCall),
        #[allow(missing_docs)]
        checkHCUForIfThenElse(checkHCUForIfThenElseCall),
        #[allow(missing_docs)]
        checkHCUForTrivialEncrypt(checkHCUForTrivialEncryptCall),
        #[allow(missing_docs)]
        getBlockMeter(getBlockMeterCall),
        #[allow(missing_docs)]
        getFHEVMExecutorAddress(getFHEVMExecutorAddressCall),
        #[allow(missing_docs)]
        getGlobalHCUCapPerBlock(getGlobalHCUCapPerBlockCall),
        #[allow(missing_docs)]
        getMaxHCUDepthPerTx(getMaxHCUDepthPerTxCall),
        #[allow(missing_docs)]
        getMaxHCUPerTx(getMaxHCUPerTxCall),
        #[allow(missing_docs)]
        getVersion(getVersionCall),
        #[allow(missing_docs)]
        initializeFromEmptyProxy(initializeFromEmptyProxyCall),
        #[allow(missing_docs)]
        isBlockHCUWhitelisted(isBlockHCUWhitelistedCall),
        #[allow(missing_docs)]
        proxiableUUID(proxiableUUIDCall),
        #[allow(missing_docs)]
        reinitializeV2(reinitializeV2Call),
        #[allow(missing_docs)]
        removeFromBlockHCUWhitelist(removeFromBlockHCUWhitelistCall),
        #[allow(missing_docs)]
        setHCUPerBlock(setHCUPerBlockCall),
        #[allow(missing_docs)]
        setMaxHCUDepthPerTx(setMaxHCUDepthPerTxCall),
        #[allow(missing_docs)]
        setMaxHCUPerTx(setMaxHCUPerTxCall),
        #[allow(missing_docs)]
        upgradeToAndCall(upgradeToAndCallCall),
    }
    #[automatically_derived]
    impl HCULimitCalls {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [4u8, 85u8, 63u8, 182u8],
            [7u8, 204u8, 223u8, 97u8],
            [13u8, 142u8, 110u8, 44u8],
            [25u8, 106u8, 69u8, 109u8],
            [30u8, 36u8, 170u8, 73u8],
            [38u8, 141u8, 109u8, 49u8],
            [40u8, 103u8, 124u8, 167u8],
            [45u8, 203u8, 197u8, 209u8],
            [46u8, 60u8, 57u8, 6u8],
            [51u8, 17u8, 177u8, 188u8],
            [56u8, 189u8, 23u8, 229u8],
            [59u8, 183u8, 213u8, 163u8],
            [69u8, 143u8, 178u8, 119u8],
            [73u8, 124u8, 34u8, 197u8],
            [79u8, 30u8, 242u8, 134u8],
            [82u8, 209u8, 144u8, 45u8],
            [92u8, 65u8, 75u8, 87u8],
            [95u8, 118u8, 235u8, 48u8],
            [96u8, 225u8, 33u8, 137u8],
            [105u8, 147u8, 26u8, 251u8],
            [107u8, 173u8, 24u8, 182u8],
            [108u8, 240u8, 189u8, 37u8],
            [111u8, 214u8, 94u8, 77u8],
            [119u8, 72u8, 103u8, 26u8],
            [129u8, 143u8, 77u8, 105u8],
            [134u8, 41u8, 245u8, 69u8],
            [150u8, 131u8, 2u8, 215u8],
            [155u8, 63u8, 120u8, 26u8],
            [159u8, 75u8, 153u8, 55u8],
            [159u8, 146u8, 89u8, 187u8],
            [160u8, 54u8, 234u8, 46u8],
            [171u8, 57u8, 71u8, 85u8],
            [173u8, 60u8, 177u8, 204u8],
            [181u8, 149u8, 71u8, 184u8],
            [183u8, 139u8, 239u8, 89u8],
            [192u8, 197u8, 223u8, 124u8],
            [193u8, 57u8, 12u8, 52u8],
            [193u8, 60u8, 25u8, 113u8],
            [194u8, 119u8, 169u8, 54u8],
            [200u8, 222u8, 67u8, 82u8],
            [213u8, 184u8, 184u8, 243u8],
            [214u8, 51u8, 201u8, 107u8],
            [237u8, 232u8, 119u8, 110u8],
            [247u8, 209u8, 152u8, 248u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for HCULimitCalls {
        const NAME: &'static str = "HCULimitCalls";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 44usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::UPGRADE_INTERFACE_VERSION(_) => {
                    <UPGRADE_INTERFACE_VERSIONCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::addToBlockHCUWhitelist(_) => {
                    <addToBlockHCUWhitelistCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::checkHCUForCast(_) => {
                    <checkHCUForCastCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::checkHCUForFheAdd(_) => {
                    <checkHCUForFheAddCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::checkHCUForFheBitAnd(_) => {
                    <checkHCUForFheBitAndCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::checkHCUForFheBitOr(_) => {
                    <checkHCUForFheBitOrCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::checkHCUForFheBitXor(_) => {
                    <checkHCUForFheBitXorCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::checkHCUForFheDiv(_) => {
                    <checkHCUForFheDivCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::checkHCUForFheEq(_) => {
                    <checkHCUForFheEqCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::checkHCUForFheGe(_) => {
                    <checkHCUForFheGeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::checkHCUForFheGt(_) => {
                    <checkHCUForFheGtCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::checkHCUForFheLe(_) => {
                    <checkHCUForFheLeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::checkHCUForFheLt(_) => {
                    <checkHCUForFheLtCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::checkHCUForFheMax(_) => {
                    <checkHCUForFheMaxCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::checkHCUForFheMin(_) => {
                    <checkHCUForFheMinCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::checkHCUForFheMul(_) => {
                    <checkHCUForFheMulCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::checkHCUForFheNe(_) => {
                    <checkHCUForFheNeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::checkHCUForFheNeg(_) => {
                    <checkHCUForFheNegCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::checkHCUForFheNot(_) => {
                    <checkHCUForFheNotCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::checkHCUForFheRand(_) => {
                    <checkHCUForFheRandCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::checkHCUForFheRandBounded(_) => {
                    <checkHCUForFheRandBoundedCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::checkHCUForFheRem(_) => {
                    <checkHCUForFheRemCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::checkHCUForFheRotl(_) => {
                    <checkHCUForFheRotlCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::checkHCUForFheRotr(_) => {
                    <checkHCUForFheRotrCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::checkHCUForFheShl(_) => {
                    <checkHCUForFheShlCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::checkHCUForFheShr(_) => {
                    <checkHCUForFheShrCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::checkHCUForFheSub(_) => {
                    <checkHCUForFheSubCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::checkHCUForIfThenElse(_) => {
                    <checkHCUForIfThenElseCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::checkHCUForTrivialEncrypt(_) => {
                    <checkHCUForTrivialEncryptCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getBlockMeter(_) => {
                    <getBlockMeterCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getFHEVMExecutorAddress(_) => {
                    <getFHEVMExecutorAddressCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getGlobalHCUCapPerBlock(_) => {
                    <getGlobalHCUCapPerBlockCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getMaxHCUDepthPerTx(_) => {
                    <getMaxHCUDepthPerTxCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getMaxHCUPerTx(_) => {
                    <getMaxHCUPerTxCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getVersion(_) => {
                    <getVersionCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::initializeFromEmptyProxy(_) => {
                    <initializeFromEmptyProxyCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::isBlockHCUWhitelisted(_) => {
                    <isBlockHCUWhitelistedCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::proxiableUUID(_) => {
                    <proxiableUUIDCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::reinitializeV2(_) => {
                    <reinitializeV2Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::removeFromBlockHCUWhitelist(_) => {
                    <removeFromBlockHCUWhitelistCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setHCUPerBlock(_) => {
                    <setHCUPerBlockCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setMaxHCUDepthPerTx(_) => {
                    <setMaxHCUDepthPerTxCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setMaxHCUPerTx(_) => {
                    <setMaxHCUPerTxCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::upgradeToAndCall(_) => {
                    <upgradeToAndCallCall as alloy_sol_types::SolCall>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<HCULimitCalls>] = &[
                {
                    fn checkHCUForFheMin(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForFheMinCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForFheMin)
                    }
                    checkHCUForFheMin
                },
                {
                    fn checkHCUForFheShr(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForFheShrCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForFheShr)
                    }
                    checkHCUForFheShr
                },
                {
                    fn getVersion(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <getVersionCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitCalls::getVersion)
                    }
                    getVersion
                },
                {
                    fn initializeFromEmptyProxy(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <initializeFromEmptyProxyCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitCalls::initializeFromEmptyProxy)
                    }
                    initializeFromEmptyProxy
                },
                {
                    fn getMaxHCUDepthPerTx(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <getMaxHCUDepthPerTxCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitCalls::getMaxHCUDepthPerTx)
                    }
                    getMaxHCUDepthPerTx
                },
                {
                    fn getFHEVMExecutorAddress(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <getFHEVMExecutorAddressCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitCalls::getFHEVMExecutorAddress)
                    }
                    getFHEVMExecutorAddress
                },
                {
                    fn removeFromBlockHCUWhitelist(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <removeFromBlockHCUWhitelistCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitCalls::removeFromBlockHCUWhitelist)
                    }
                    removeFromBlockHCUWhitelist
                },
                {
                    fn checkHCUForFheNot(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForFheNotCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForFheNot)
                    }
                    checkHCUForFheNot
                },
                {
                    fn checkHCUForIfThenElse(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForIfThenElseCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForIfThenElse)
                    }
                    checkHCUForIfThenElse
                },
                {
                    fn checkHCUForFheRem(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForFheRemCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForFheRem)
                    }
                    checkHCUForFheRem
                },
                {
                    fn checkHCUForFheLe(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForFheLeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForFheLe)
                    }
                    checkHCUForFheLe
                },
                {
                    fn checkHCUForFheLt(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForFheLtCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForFheLt)
                    }
                    checkHCUForFheLt
                },
                {
                    fn checkHCUForFheGt(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForFheGtCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForFheGt)
                    }
                    checkHCUForFheGt
                },
                {
                    fn checkHCUForFheNeg(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForFheNegCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForFheNeg)
                    }
                    checkHCUForFheNeg
                },
                {
                    fn upgradeToAndCall(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <upgradeToAndCallCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitCalls::upgradeToAndCall)
                    }
                    upgradeToAndCall
                },
                {
                    fn proxiableUUID(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <proxiableUUIDCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitCalls::proxiableUUID)
                    }
                    proxiableUUID
                },
                {
                    fn setMaxHCUDepthPerTx(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <setMaxHCUDepthPerTxCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitCalls::setMaxHCUDepthPerTx)
                    }
                    setMaxHCUDepthPerTx
                },
                {
                    fn checkHCUForFheRotl(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForFheRotlCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForFheRotl)
                    }
                    checkHCUForFheRotl
                },
                {
                    fn checkHCUForFheEq(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForFheEqCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForFheEq)
                    }
                    checkHCUForFheEq
                },
                {
                    fn checkHCUForCast(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForCastCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForCast)
                    }
                    checkHCUForCast
                },
                {
                    fn checkHCUForFheNe(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForFheNeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForFheNe)
                    }
                    checkHCUForFheNe
                },
                {
                    fn checkHCUForFheRandBounded(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForFheRandBoundedCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForFheRandBounded)
                    }
                    checkHCUForFheRandBounded
                },
                {
                    fn addToBlockHCUWhitelist(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <addToBlockHCUWhitelistCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitCalls::addToBlockHCUWhitelist)
                    }
                    addToBlockHCUWhitelist
                },
                {
                    fn reinitializeV2(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <reinitializeV2Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitCalls::reinitializeV2)
                    }
                    reinitializeV2
                },
                {
                    fn checkHCUForFheMul(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForFheMulCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForFheMul)
                    }
                    checkHCUForFheMul
                },
                {
                    fn checkHCUForFheRotr(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForFheRotrCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForFheRotr)
                    }
                    checkHCUForFheRotr
                },
                {
                    fn checkHCUForFheMax(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForFheMaxCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForFheMax)
                    }
                    checkHCUForFheMax
                },
                {
                    fn checkHCUForFheDiv(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForFheDivCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForFheDiv)
                    }
                    checkHCUForFheDiv
                },
                {
                    fn getBlockMeter(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <getBlockMeterCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitCalls::getBlockMeter)
                    }
                    getBlockMeter
                },
                {
                    fn checkHCUForFheBitXor(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForFheBitXorCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForFheBitXor)
                    }
                    checkHCUForFheBitXor
                },
                {
                    fn setHCUPerBlock(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <setHCUPerBlockCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitCalls::setHCUPerBlock)
                    }
                    setHCUPerBlock
                },
                {
                    fn setMaxHCUPerTx(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <setMaxHCUPerTxCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitCalls::setMaxHCUPerTx)
                    }
                    setMaxHCUPerTx
                },
                {
                    fn UPGRADE_INTERFACE_VERSION(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <UPGRADE_INTERFACE_VERSIONCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitCalls::UPGRADE_INTERFACE_VERSION)
                    }
                    UPGRADE_INTERFACE_VERSION
                },
                {
                    fn getGlobalHCUCapPerBlock(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <getGlobalHCUCapPerBlockCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitCalls::getGlobalHCUCapPerBlock)
                    }
                    getGlobalHCUCapPerBlock
                },
                {
                    fn checkHCUForTrivialEncrypt(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForTrivialEncryptCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForTrivialEncrypt)
                    }
                    checkHCUForTrivialEncrypt
                },
                {
                    fn checkHCUForFheBitOr(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForFheBitOrCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForFheBitOr)
                    }
                    checkHCUForFheBitOr
                },
                {
                    fn checkHCUForFheAdd(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForFheAddCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForFheAdd)
                    }
                    checkHCUForFheAdd
                },
                {
                    fn getMaxHCUPerTx(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <getMaxHCUPerTxCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitCalls::getMaxHCUPerTx)
                    }
                    getMaxHCUPerTx
                },
                {
                    fn checkHCUForFheGe(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForFheGeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForFheGe)
                    }
                    checkHCUForFheGe
                },
                {
                    fn checkHCUForFheBitAnd(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForFheBitAndCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForFheBitAnd)
                    }
                    checkHCUForFheBitAnd
                },
                {
                    fn checkHCUForFheRand(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForFheRandCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForFheRand)
                    }
                    checkHCUForFheRand
                },
                {
                    fn checkHCUForFheSub(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForFheSubCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForFheSub)
                    }
                    checkHCUForFheSub
                },
                {
                    fn isBlockHCUWhitelisted(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <isBlockHCUWhitelistedCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitCalls::isBlockHCUWhitelisted)
                    }
                    isBlockHCUWhitelisted
                },
                {
                    fn checkHCUForFheShl(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForFheShlCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForFheShl)
                    }
                    checkHCUForFheShl
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data)
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw_validate(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_VALIDATE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<HCULimitCalls>] = &[
                {
                    fn checkHCUForFheMin(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForFheMinCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForFheMin)
                    }
                    checkHCUForFheMin
                },
                {
                    fn checkHCUForFheShr(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForFheShrCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForFheShr)
                    }
                    checkHCUForFheShr
                },
                {
                    fn getVersion(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <getVersionCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitCalls::getVersion)
                    }
                    getVersion
                },
                {
                    fn initializeFromEmptyProxy(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <initializeFromEmptyProxyCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitCalls::initializeFromEmptyProxy)
                    }
                    initializeFromEmptyProxy
                },
                {
                    fn getMaxHCUDepthPerTx(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <getMaxHCUDepthPerTxCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitCalls::getMaxHCUDepthPerTx)
                    }
                    getMaxHCUDepthPerTx
                },
                {
                    fn getFHEVMExecutorAddress(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <getFHEVMExecutorAddressCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitCalls::getFHEVMExecutorAddress)
                    }
                    getFHEVMExecutorAddress
                },
                {
                    fn removeFromBlockHCUWhitelist(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <removeFromBlockHCUWhitelistCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitCalls::removeFromBlockHCUWhitelist)
                    }
                    removeFromBlockHCUWhitelist
                },
                {
                    fn checkHCUForFheNot(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForFheNotCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForFheNot)
                    }
                    checkHCUForFheNot
                },
                {
                    fn checkHCUForIfThenElse(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForIfThenElseCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForIfThenElse)
                    }
                    checkHCUForIfThenElse
                },
                {
                    fn checkHCUForFheRem(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForFheRemCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForFheRem)
                    }
                    checkHCUForFheRem
                },
                {
                    fn checkHCUForFheLe(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForFheLeCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForFheLe)
                    }
                    checkHCUForFheLe
                },
                {
                    fn checkHCUForFheLt(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForFheLtCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForFheLt)
                    }
                    checkHCUForFheLt
                },
                {
                    fn checkHCUForFheGt(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForFheGtCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForFheGt)
                    }
                    checkHCUForFheGt
                },
                {
                    fn checkHCUForFheNeg(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForFheNegCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForFheNeg)
                    }
                    checkHCUForFheNeg
                },
                {
                    fn upgradeToAndCall(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <upgradeToAndCallCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitCalls::upgradeToAndCall)
                    }
                    upgradeToAndCall
                },
                {
                    fn proxiableUUID(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <proxiableUUIDCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitCalls::proxiableUUID)
                    }
                    proxiableUUID
                },
                {
                    fn setMaxHCUDepthPerTx(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <setMaxHCUDepthPerTxCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitCalls::setMaxHCUDepthPerTx)
                    }
                    setMaxHCUDepthPerTx
                },
                {
                    fn checkHCUForFheRotl(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForFheRotlCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForFheRotl)
                    }
                    checkHCUForFheRotl
                },
                {
                    fn checkHCUForFheEq(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForFheEqCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForFheEq)
                    }
                    checkHCUForFheEq
                },
                {
                    fn checkHCUForCast(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForCastCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForCast)
                    }
                    checkHCUForCast
                },
                {
                    fn checkHCUForFheNe(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForFheNeCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForFheNe)
                    }
                    checkHCUForFheNe
                },
                {
                    fn checkHCUForFheRandBounded(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForFheRandBoundedCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForFheRandBounded)
                    }
                    checkHCUForFheRandBounded
                },
                {
                    fn addToBlockHCUWhitelist(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <addToBlockHCUWhitelistCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitCalls::addToBlockHCUWhitelist)
                    }
                    addToBlockHCUWhitelist
                },
                {
                    fn reinitializeV2(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <reinitializeV2Call as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitCalls::reinitializeV2)
                    }
                    reinitializeV2
                },
                {
                    fn checkHCUForFheMul(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForFheMulCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForFheMul)
                    }
                    checkHCUForFheMul
                },
                {
                    fn checkHCUForFheRotr(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForFheRotrCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForFheRotr)
                    }
                    checkHCUForFheRotr
                },
                {
                    fn checkHCUForFheMax(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForFheMaxCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForFheMax)
                    }
                    checkHCUForFheMax
                },
                {
                    fn checkHCUForFheDiv(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForFheDivCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForFheDiv)
                    }
                    checkHCUForFheDiv
                },
                {
                    fn getBlockMeter(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <getBlockMeterCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitCalls::getBlockMeter)
                    }
                    getBlockMeter
                },
                {
                    fn checkHCUForFheBitXor(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForFheBitXorCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForFheBitXor)
                    }
                    checkHCUForFheBitXor
                },
                {
                    fn setHCUPerBlock(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <setHCUPerBlockCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitCalls::setHCUPerBlock)
                    }
                    setHCUPerBlock
                },
                {
                    fn setMaxHCUPerTx(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <setMaxHCUPerTxCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitCalls::setMaxHCUPerTx)
                    }
                    setMaxHCUPerTx
                },
                {
                    fn UPGRADE_INTERFACE_VERSION(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <UPGRADE_INTERFACE_VERSIONCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitCalls::UPGRADE_INTERFACE_VERSION)
                    }
                    UPGRADE_INTERFACE_VERSION
                },
                {
                    fn getGlobalHCUCapPerBlock(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <getGlobalHCUCapPerBlockCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitCalls::getGlobalHCUCapPerBlock)
                    }
                    getGlobalHCUCapPerBlock
                },
                {
                    fn checkHCUForTrivialEncrypt(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForTrivialEncryptCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForTrivialEncrypt)
                    }
                    checkHCUForTrivialEncrypt
                },
                {
                    fn checkHCUForFheBitOr(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForFheBitOrCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForFheBitOr)
                    }
                    checkHCUForFheBitOr
                },
                {
                    fn checkHCUForFheAdd(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForFheAddCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForFheAdd)
                    }
                    checkHCUForFheAdd
                },
                {
                    fn getMaxHCUPerTx(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <getMaxHCUPerTxCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitCalls::getMaxHCUPerTx)
                    }
                    getMaxHCUPerTx
                },
                {
                    fn checkHCUForFheGe(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForFheGeCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForFheGe)
                    }
                    checkHCUForFheGe
                },
                {
                    fn checkHCUForFheBitAnd(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForFheBitAndCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForFheBitAnd)
                    }
                    checkHCUForFheBitAnd
                },
                {
                    fn checkHCUForFheRand(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForFheRandCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForFheRand)
                    }
                    checkHCUForFheRand
                },
                {
                    fn checkHCUForFheSub(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForFheSubCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForFheSub)
                    }
                    checkHCUForFheSub
                },
                {
                    fn isBlockHCUWhitelisted(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <isBlockHCUWhitelistedCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitCalls::isBlockHCUWhitelisted)
                    }
                    isBlockHCUWhitelisted
                },
                {
                    fn checkHCUForFheShl(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitCalls> {
                        <checkHCUForFheShlCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitCalls::checkHCUForFheShl)
                    }
                    checkHCUForFheShl
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_VALIDATE_SHIMS[idx](data)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::UPGRADE_INTERFACE_VERSION(inner) => {
                    <UPGRADE_INTERFACE_VERSIONCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::addToBlockHCUWhitelist(inner) => {
                    <addToBlockHCUWhitelistCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::checkHCUForCast(inner) => {
                    <checkHCUForCastCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::checkHCUForFheAdd(inner) => {
                    <checkHCUForFheAddCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::checkHCUForFheBitAnd(inner) => {
                    <checkHCUForFheBitAndCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::checkHCUForFheBitOr(inner) => {
                    <checkHCUForFheBitOrCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::checkHCUForFheBitXor(inner) => {
                    <checkHCUForFheBitXorCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::checkHCUForFheDiv(inner) => {
                    <checkHCUForFheDivCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::checkHCUForFheEq(inner) => {
                    <checkHCUForFheEqCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::checkHCUForFheGe(inner) => {
                    <checkHCUForFheGeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::checkHCUForFheGt(inner) => {
                    <checkHCUForFheGtCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::checkHCUForFheLe(inner) => {
                    <checkHCUForFheLeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::checkHCUForFheLt(inner) => {
                    <checkHCUForFheLtCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::checkHCUForFheMax(inner) => {
                    <checkHCUForFheMaxCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::checkHCUForFheMin(inner) => {
                    <checkHCUForFheMinCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::checkHCUForFheMul(inner) => {
                    <checkHCUForFheMulCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::checkHCUForFheNe(inner) => {
                    <checkHCUForFheNeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::checkHCUForFheNeg(inner) => {
                    <checkHCUForFheNegCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::checkHCUForFheNot(inner) => {
                    <checkHCUForFheNotCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::checkHCUForFheRand(inner) => {
                    <checkHCUForFheRandCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::checkHCUForFheRandBounded(inner) => {
                    <checkHCUForFheRandBoundedCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::checkHCUForFheRem(inner) => {
                    <checkHCUForFheRemCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::checkHCUForFheRotl(inner) => {
                    <checkHCUForFheRotlCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::checkHCUForFheRotr(inner) => {
                    <checkHCUForFheRotrCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::checkHCUForFheShl(inner) => {
                    <checkHCUForFheShlCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::checkHCUForFheShr(inner) => {
                    <checkHCUForFheShrCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::checkHCUForFheSub(inner) => {
                    <checkHCUForFheSubCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::checkHCUForIfThenElse(inner) => {
                    <checkHCUForIfThenElseCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::checkHCUForTrivialEncrypt(inner) => {
                    <checkHCUForTrivialEncryptCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getBlockMeter(inner) => {
                    <getBlockMeterCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getFHEVMExecutorAddress(inner) => {
                    <getFHEVMExecutorAddressCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getGlobalHCUCapPerBlock(inner) => {
                    <getGlobalHCUCapPerBlockCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getMaxHCUDepthPerTx(inner) => {
                    <getMaxHCUDepthPerTxCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getMaxHCUPerTx(inner) => {
                    <getMaxHCUPerTxCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getVersion(inner) => {
                    <getVersionCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::initializeFromEmptyProxy(inner) => {
                    <initializeFromEmptyProxyCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::isBlockHCUWhitelisted(inner) => {
                    <isBlockHCUWhitelistedCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::proxiableUUID(inner) => {
                    <proxiableUUIDCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::reinitializeV2(inner) => {
                    <reinitializeV2Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::removeFromBlockHCUWhitelist(inner) => {
                    <removeFromBlockHCUWhitelistCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setHCUPerBlock(inner) => {
                    <setHCUPerBlockCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setMaxHCUDepthPerTx(inner) => {
                    <setMaxHCUDepthPerTxCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setMaxHCUPerTx(inner) => {
                    <setMaxHCUPerTxCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::upgradeToAndCall(inner) => {
                    <upgradeToAndCallCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::UPGRADE_INTERFACE_VERSION(inner) => {
                    <UPGRADE_INTERFACE_VERSIONCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::addToBlockHCUWhitelist(inner) => {
                    <addToBlockHCUWhitelistCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::checkHCUForCast(inner) => {
                    <checkHCUForCastCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::checkHCUForFheAdd(inner) => {
                    <checkHCUForFheAddCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::checkHCUForFheBitAnd(inner) => {
                    <checkHCUForFheBitAndCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::checkHCUForFheBitOr(inner) => {
                    <checkHCUForFheBitOrCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::checkHCUForFheBitXor(inner) => {
                    <checkHCUForFheBitXorCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::checkHCUForFheDiv(inner) => {
                    <checkHCUForFheDivCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::checkHCUForFheEq(inner) => {
                    <checkHCUForFheEqCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::checkHCUForFheGe(inner) => {
                    <checkHCUForFheGeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::checkHCUForFheGt(inner) => {
                    <checkHCUForFheGtCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::checkHCUForFheLe(inner) => {
                    <checkHCUForFheLeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::checkHCUForFheLt(inner) => {
                    <checkHCUForFheLtCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::checkHCUForFheMax(inner) => {
                    <checkHCUForFheMaxCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::checkHCUForFheMin(inner) => {
                    <checkHCUForFheMinCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::checkHCUForFheMul(inner) => {
                    <checkHCUForFheMulCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::checkHCUForFheNe(inner) => {
                    <checkHCUForFheNeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::checkHCUForFheNeg(inner) => {
                    <checkHCUForFheNegCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::checkHCUForFheNot(inner) => {
                    <checkHCUForFheNotCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::checkHCUForFheRand(inner) => {
                    <checkHCUForFheRandCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::checkHCUForFheRandBounded(inner) => {
                    <checkHCUForFheRandBoundedCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::checkHCUForFheRem(inner) => {
                    <checkHCUForFheRemCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::checkHCUForFheRotl(inner) => {
                    <checkHCUForFheRotlCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::checkHCUForFheRotr(inner) => {
                    <checkHCUForFheRotrCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::checkHCUForFheShl(inner) => {
                    <checkHCUForFheShlCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::checkHCUForFheShr(inner) => {
                    <checkHCUForFheShrCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::checkHCUForFheSub(inner) => {
                    <checkHCUForFheSubCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::checkHCUForIfThenElse(inner) => {
                    <checkHCUForIfThenElseCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::checkHCUForTrivialEncrypt(inner) => {
                    <checkHCUForTrivialEncryptCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getBlockMeter(inner) => {
                    <getBlockMeterCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getFHEVMExecutorAddress(inner) => {
                    <getFHEVMExecutorAddressCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getGlobalHCUCapPerBlock(inner) => {
                    <getGlobalHCUCapPerBlockCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getMaxHCUDepthPerTx(inner) => {
                    <getMaxHCUDepthPerTxCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getMaxHCUPerTx(inner) => {
                    <getMaxHCUPerTxCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getVersion(inner) => {
                    <getVersionCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::initializeFromEmptyProxy(inner) => {
                    <initializeFromEmptyProxyCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::isBlockHCUWhitelisted(inner) => {
                    <isBlockHCUWhitelistedCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::proxiableUUID(inner) => {
                    <proxiableUUIDCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::reinitializeV2(inner) => {
                    <reinitializeV2Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::removeFromBlockHCUWhitelist(inner) => {
                    <removeFromBlockHCUWhitelistCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setHCUPerBlock(inner) => {
                    <setHCUPerBlockCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setMaxHCUDepthPerTx(inner) => {
                    <setMaxHCUDepthPerTxCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setMaxHCUPerTx(inner) => {
                    <setMaxHCUPerTxCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::upgradeToAndCall(inner) => {
                    <upgradeToAndCallCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`HCULimit`](self) custom errors.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub enum HCULimitErrors {
        #[allow(missing_docs)]
        AddressEmptyCode(AddressEmptyCode),
        #[allow(missing_docs)]
        AlreadyBlockHCUWhitelisted(AlreadyBlockHCUWhitelisted),
        #[allow(missing_docs)]
        CallerMustBeFHEVMExecutorContract(CallerMustBeFHEVMExecutorContract),
        #[allow(missing_docs)]
        ERC1967InvalidImplementation(ERC1967InvalidImplementation),
        #[allow(missing_docs)]
        ERC1967NonPayable(ERC1967NonPayable),
        #[allow(missing_docs)]
        FailedCall(FailedCall),
        #[allow(missing_docs)]
        HCUBlockLimitExceeded(HCUBlockLimitExceeded),
        #[allow(missing_docs)]
        HCUTransactionDepthLimitExceeded(HCUTransactionDepthLimitExceeded),
        #[allow(missing_docs)]
        HCUTransactionLimitExceeded(HCUTransactionLimitExceeded),
        #[allow(missing_docs)]
        InvalidInitialization(InvalidInitialization),
        #[allow(missing_docs)]
        NotBlockHCUWhitelisted(NotBlockHCUWhitelisted),
        #[allow(missing_docs)]
        NotHostOwner(NotHostOwner),
        #[allow(missing_docs)]
        NotInitializing(NotInitializing),
        #[allow(missing_docs)]
        NotInitializingFromEmptyProxy(NotInitializingFromEmptyProxy),
        #[allow(missing_docs)]
        OnlyScalarOperationsAreSupported(OnlyScalarOperationsAreSupported),
        #[allow(missing_docs)]
        UUPSUnauthorizedCallContext(UUPSUnauthorizedCallContext),
        #[allow(missing_docs)]
        UUPSUnsupportedProxiableUUID(UUPSUnsupportedProxiableUUID),
        #[allow(missing_docs)]
        UnsupportedOperation(UnsupportedOperation),
    }
    #[automatically_derived]
    impl HCULimitErrors {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [33u8, 191u8, 218u8, 16u8],
            [49u8, 168u8, 26u8, 129u8],
            [76u8, 156u8, 140u8, 227u8],
            [106u8, 169u8, 235u8, 5u8],
            [111u8, 79u8, 115u8, 31u8],
            [119u8, 227u8, 194u8, 147u8],
            [153u8, 150u8, 179u8, 21u8],
            [155u8, 166u8, 6u8, 27u8],
            [170u8, 29u8, 73u8, 164u8],
            [173u8, 37u8, 17u8, 116u8],
            [179u8, 152u8, 151u8, 159u8],
            [214u8, 189u8, 162u8, 117u8],
            [215u8, 230u8, 188u8, 248u8],
            [224u8, 124u8, 141u8, 186u8],
            [227u8, 204u8, 52u8, 24u8],
            [249u8, 46u8, 232u8, 169u8],
            [249u8, 156u8, 79u8, 209u8],
            [252u8, 52u8, 72u8, 112u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for HCULimitErrors {
        const NAME: &'static str = "HCULimitErrors";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 18usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::AddressEmptyCode(_) => {
                    <AddressEmptyCode as alloy_sol_types::SolError>::SELECTOR
                }
                Self::AlreadyBlockHCUWhitelisted(_) => {
                    <AlreadyBlockHCUWhitelisted as alloy_sol_types::SolError>::SELECTOR
                }
                Self::CallerMustBeFHEVMExecutorContract(_) => {
                    <CallerMustBeFHEVMExecutorContract as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC1967InvalidImplementation(_) => {
                    <ERC1967InvalidImplementation as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC1967NonPayable(_) => {
                    <ERC1967NonPayable as alloy_sol_types::SolError>::SELECTOR
                }
                Self::FailedCall(_) => {
                    <FailedCall as alloy_sol_types::SolError>::SELECTOR
                }
                Self::HCUBlockLimitExceeded(_) => {
                    <HCUBlockLimitExceeded as alloy_sol_types::SolError>::SELECTOR
                }
                Self::HCUTransactionDepthLimitExceeded(_) => {
                    <HCUTransactionDepthLimitExceeded as alloy_sol_types::SolError>::SELECTOR
                }
                Self::HCUTransactionLimitExceeded(_) => {
                    <HCUTransactionLimitExceeded as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidInitialization(_) => {
                    <InvalidInitialization as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NotBlockHCUWhitelisted(_) => {
                    <NotBlockHCUWhitelisted as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NotHostOwner(_) => {
                    <NotHostOwner as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NotInitializing(_) => {
                    <NotInitializing as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NotInitializingFromEmptyProxy(_) => {
                    <NotInitializingFromEmptyProxy as alloy_sol_types::SolError>::SELECTOR
                }
                Self::OnlyScalarOperationsAreSupported(_) => {
                    <OnlyScalarOperationsAreSupported as alloy_sol_types::SolError>::SELECTOR
                }
                Self::UUPSUnauthorizedCallContext(_) => {
                    <UUPSUnauthorizedCallContext as alloy_sol_types::SolError>::SELECTOR
                }
                Self::UUPSUnsupportedProxiableUUID(_) => {
                    <UUPSUnsupportedProxiableUUID as alloy_sol_types::SolError>::SELECTOR
                }
                Self::UnsupportedOperation(_) => {
                    <UnsupportedOperation as alloy_sol_types::SolError>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<HCULimitErrors>] = &[
                {
                    fn NotHostOwner(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitErrors> {
                        <NotHostOwner as alloy_sol_types::SolError>::abi_decode_raw(data)
                            .map(HCULimitErrors::NotHostOwner)
                    }
                    NotHostOwner
                },
                {
                    fn CallerMustBeFHEVMExecutorContract(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitErrors> {
                        <CallerMustBeFHEVMExecutorContract as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitErrors::CallerMustBeFHEVMExecutorContract)
                    }
                    CallerMustBeFHEVMExecutorContract
                },
                {
                    fn ERC1967InvalidImplementation(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitErrors> {
                        <ERC1967InvalidImplementation as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitErrors::ERC1967InvalidImplementation)
                    }
                    ERC1967InvalidImplementation
                },
                {
                    fn OnlyScalarOperationsAreSupported(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitErrors> {
                        <OnlyScalarOperationsAreSupported as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitErrors::OnlyScalarOperationsAreSupported)
                    }
                    OnlyScalarOperationsAreSupported
                },
                {
                    fn NotInitializingFromEmptyProxy(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitErrors> {
                        <NotInitializingFromEmptyProxy as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitErrors::NotInitializingFromEmptyProxy)
                    }
                    NotInitializingFromEmptyProxy
                },
                {
                    fn HCUTransactionLimitExceeded(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitErrors> {
                        <HCUTransactionLimitExceeded as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitErrors::HCUTransactionLimitExceeded)
                    }
                    HCUTransactionLimitExceeded
                },
                {
                    fn AddressEmptyCode(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitErrors> {
                        <AddressEmptyCode as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitErrors::AddressEmptyCode)
                    }
                    AddressEmptyCode
                },
                {
                    fn UnsupportedOperation(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitErrors> {
                        <UnsupportedOperation as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitErrors::UnsupportedOperation)
                    }
                    UnsupportedOperation
                },
                {
                    fn UUPSUnsupportedProxiableUUID(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitErrors> {
                        <UUPSUnsupportedProxiableUUID as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitErrors::UUPSUnsupportedProxiableUUID)
                    }
                    UUPSUnsupportedProxiableUUID
                },
                {
                    fn HCUBlockLimitExceeded(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitErrors> {
                        <HCUBlockLimitExceeded as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitErrors::HCUBlockLimitExceeded)
                    }
                    HCUBlockLimitExceeded
                },
                {
                    fn ERC1967NonPayable(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitErrors> {
                        <ERC1967NonPayable as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitErrors::ERC1967NonPayable)
                    }
                    ERC1967NonPayable
                },
                {
                    fn FailedCall(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitErrors> {
                        <FailedCall as alloy_sol_types::SolError>::abi_decode_raw(data)
                            .map(HCULimitErrors::FailedCall)
                    }
                    FailedCall
                },
                {
                    fn NotInitializing(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitErrors> {
                        <NotInitializing as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitErrors::NotInitializing)
                    }
                    NotInitializing
                },
                {
                    fn UUPSUnauthorizedCallContext(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitErrors> {
                        <UUPSUnauthorizedCallContext as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitErrors::UUPSUnauthorizedCallContext)
                    }
                    UUPSUnauthorizedCallContext
                },
                {
                    fn NotBlockHCUWhitelisted(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitErrors> {
                        <NotBlockHCUWhitelisted as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitErrors::NotBlockHCUWhitelisted)
                    }
                    NotBlockHCUWhitelisted
                },
                {
                    fn InvalidInitialization(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitErrors> {
                        <InvalidInitialization as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitErrors::InvalidInitialization)
                    }
                    InvalidInitialization
                },
                {
                    fn AlreadyBlockHCUWhitelisted(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitErrors> {
                        <AlreadyBlockHCUWhitelisted as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitErrors::AlreadyBlockHCUWhitelisted)
                    }
                    AlreadyBlockHCUWhitelisted
                },
                {
                    fn HCUTransactionDepthLimitExceeded(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitErrors> {
                        <HCUTransactionDepthLimitExceeded as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(HCULimitErrors::HCUTransactionDepthLimitExceeded)
                    }
                    HCUTransactionDepthLimitExceeded
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data)
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw_validate(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_VALIDATE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<HCULimitErrors>] = &[
                {
                    fn NotHostOwner(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitErrors> {
                        <NotHostOwner as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitErrors::NotHostOwner)
                    }
                    NotHostOwner
                },
                {
                    fn CallerMustBeFHEVMExecutorContract(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitErrors> {
                        <CallerMustBeFHEVMExecutorContract as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitErrors::CallerMustBeFHEVMExecutorContract)
                    }
                    CallerMustBeFHEVMExecutorContract
                },
                {
                    fn ERC1967InvalidImplementation(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitErrors> {
                        <ERC1967InvalidImplementation as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitErrors::ERC1967InvalidImplementation)
                    }
                    ERC1967InvalidImplementation
                },
                {
                    fn OnlyScalarOperationsAreSupported(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitErrors> {
                        <OnlyScalarOperationsAreSupported as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitErrors::OnlyScalarOperationsAreSupported)
                    }
                    OnlyScalarOperationsAreSupported
                },
                {
                    fn NotInitializingFromEmptyProxy(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitErrors> {
                        <NotInitializingFromEmptyProxy as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitErrors::NotInitializingFromEmptyProxy)
                    }
                    NotInitializingFromEmptyProxy
                },
                {
                    fn HCUTransactionLimitExceeded(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitErrors> {
                        <HCUTransactionLimitExceeded as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitErrors::HCUTransactionLimitExceeded)
                    }
                    HCUTransactionLimitExceeded
                },
                {
                    fn AddressEmptyCode(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitErrors> {
                        <AddressEmptyCode as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitErrors::AddressEmptyCode)
                    }
                    AddressEmptyCode
                },
                {
                    fn UnsupportedOperation(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitErrors> {
                        <UnsupportedOperation as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitErrors::UnsupportedOperation)
                    }
                    UnsupportedOperation
                },
                {
                    fn UUPSUnsupportedProxiableUUID(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitErrors> {
                        <UUPSUnsupportedProxiableUUID as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitErrors::UUPSUnsupportedProxiableUUID)
                    }
                    UUPSUnsupportedProxiableUUID
                },
                {
                    fn HCUBlockLimitExceeded(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitErrors> {
                        <HCUBlockLimitExceeded as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitErrors::HCUBlockLimitExceeded)
                    }
                    HCUBlockLimitExceeded
                },
                {
                    fn ERC1967NonPayable(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitErrors> {
                        <ERC1967NonPayable as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitErrors::ERC1967NonPayable)
                    }
                    ERC1967NonPayable
                },
                {
                    fn FailedCall(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitErrors> {
                        <FailedCall as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitErrors::FailedCall)
                    }
                    FailedCall
                },
                {
                    fn NotInitializing(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitErrors> {
                        <NotInitializing as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitErrors::NotInitializing)
                    }
                    NotInitializing
                },
                {
                    fn UUPSUnauthorizedCallContext(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitErrors> {
                        <UUPSUnauthorizedCallContext as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitErrors::UUPSUnauthorizedCallContext)
                    }
                    UUPSUnauthorizedCallContext
                },
                {
                    fn NotBlockHCUWhitelisted(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitErrors> {
                        <NotBlockHCUWhitelisted as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitErrors::NotBlockHCUWhitelisted)
                    }
                    NotBlockHCUWhitelisted
                },
                {
                    fn InvalidInitialization(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitErrors> {
                        <InvalidInitialization as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitErrors::InvalidInitialization)
                    }
                    InvalidInitialization
                },
                {
                    fn AlreadyBlockHCUWhitelisted(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitErrors> {
                        <AlreadyBlockHCUWhitelisted as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitErrors::AlreadyBlockHCUWhitelisted)
                    }
                    AlreadyBlockHCUWhitelisted
                },
                {
                    fn HCUTransactionDepthLimitExceeded(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<HCULimitErrors> {
                        <HCUTransactionDepthLimitExceeded as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(HCULimitErrors::HCUTransactionDepthLimitExceeded)
                    }
                    HCUTransactionDepthLimitExceeded
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_VALIDATE_SHIMS[idx](data)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::AddressEmptyCode(inner) => {
                    <AddressEmptyCode as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::AlreadyBlockHCUWhitelisted(inner) => {
                    <AlreadyBlockHCUWhitelisted as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::CallerMustBeFHEVMExecutorContract(inner) => {
                    <CallerMustBeFHEVMExecutorContract as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC1967InvalidImplementation(inner) => {
                    <ERC1967InvalidImplementation as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC1967NonPayable(inner) => {
                    <ERC1967NonPayable as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::FailedCall(inner) => {
                    <FailedCall as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::HCUBlockLimitExceeded(inner) => {
                    <HCUBlockLimitExceeded as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::HCUTransactionDepthLimitExceeded(inner) => {
                    <HCUTransactionDepthLimitExceeded as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::HCUTransactionLimitExceeded(inner) => {
                    <HCUTransactionLimitExceeded as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidInitialization(inner) => {
                    <InvalidInitialization as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NotBlockHCUWhitelisted(inner) => {
                    <NotBlockHCUWhitelisted as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NotHostOwner(inner) => {
                    <NotHostOwner as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::NotInitializing(inner) => {
                    <NotInitializing as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NotInitializingFromEmptyProxy(inner) => {
                    <NotInitializingFromEmptyProxy as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::OnlyScalarOperationsAreSupported(inner) => {
                    <OnlyScalarOperationsAreSupported as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::UUPSUnauthorizedCallContext(inner) => {
                    <UUPSUnauthorizedCallContext as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::UUPSUnsupportedProxiableUUID(inner) => {
                    <UUPSUnsupportedProxiableUUID as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::UnsupportedOperation(inner) => {
                    <UnsupportedOperation as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::AddressEmptyCode(inner) => {
                    <AddressEmptyCode as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::AlreadyBlockHCUWhitelisted(inner) => {
                    <AlreadyBlockHCUWhitelisted as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::CallerMustBeFHEVMExecutorContract(inner) => {
                    <CallerMustBeFHEVMExecutorContract as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC1967InvalidImplementation(inner) => {
                    <ERC1967InvalidImplementation as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC1967NonPayable(inner) => {
                    <ERC1967NonPayable as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::FailedCall(inner) => {
                    <FailedCall as alloy_sol_types::SolError>::abi_encode_raw(inner, out)
                }
                Self::HCUBlockLimitExceeded(inner) => {
                    <HCUBlockLimitExceeded as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::HCUTransactionDepthLimitExceeded(inner) => {
                    <HCUTransactionDepthLimitExceeded as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::HCUTransactionLimitExceeded(inner) => {
                    <HCUTransactionLimitExceeded as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidInitialization(inner) => {
                    <InvalidInitialization as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NotBlockHCUWhitelisted(inner) => {
                    <NotBlockHCUWhitelisted as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NotHostOwner(inner) => {
                    <NotHostOwner as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NotInitializing(inner) => {
                    <NotInitializing as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NotInitializingFromEmptyProxy(inner) => {
                    <NotInitializingFromEmptyProxy as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::OnlyScalarOperationsAreSupported(inner) => {
                    <OnlyScalarOperationsAreSupported as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::UUPSUnauthorizedCallContext(inner) => {
                    <UUPSUnauthorizedCallContext as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::UUPSUnsupportedProxiableUUID(inner) => {
                    <UUPSUnsupportedProxiableUUID as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::UnsupportedOperation(inner) => {
                    <UnsupportedOperation as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`HCULimit`](self) events.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub enum HCULimitEvents {
        #[allow(missing_docs)]
        BlockHCUWhitelistAdded(BlockHCUWhitelistAdded),
        #[allow(missing_docs)]
        BlockHCUWhitelistRemoved(BlockHCUWhitelistRemoved),
        #[allow(missing_docs)]
        HCUPerBlockSet(HCUPerBlockSet),
        #[allow(missing_docs)]
        Initialized(Initialized),
        #[allow(missing_docs)]
        MaxHCUDepthPerTxSet(MaxHCUDepthPerTxSet),
        #[allow(missing_docs)]
        MaxHCUPerTxSet(MaxHCUPerTxSet),
        #[allow(missing_docs)]
        Upgraded(Upgraded),
    }
    #[automatically_derived]
    impl HCULimitEvents {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 32usize]] = &[
            [
                85u8, 17u8, 177u8, 133u8, 31u8, 196u8, 10u8, 38u8, 41u8, 200u8, 85u8,
                186u8, 183u8, 173u8, 206u8, 50u8, 118u8, 196u8, 112u8, 216u8, 25u8, 14u8,
                176u8, 20u8, 49u8, 228u8, 24u8, 220u8, 42u8, 241u8, 62u8, 142u8,
            ],
            [
                100u8, 203u8, 158u8, 122u8, 230u8, 73u8, 124u8, 89u8, 8u8, 12u8, 219u8,
                192u8, 72u8, 85u8, 46u8, 18u8, 61u8, 82u8, 170u8, 66u8, 64u8, 225u8,
                55u8, 117u8, 138u8, 23u8, 53u8, 130u8, 120u8, 105u8, 97u8, 202u8,
            ],
            [
                146u8, 252u8, 151u8, 175u8, 21u8, 0u8, 38u8, 70u8, 206u8, 166u8, 60u8,
                118u8, 51u8, 187u8, 55u8, 91u8, 130u8, 219u8, 124u8, 222u8, 123u8, 72u8,
                12u8, 117u8, 254u8, 99u8, 65u8, 218u8, 204u8, 41u8, 44u8, 129u8,
            ],
            [
                188u8, 124u8, 215u8, 90u8, 32u8, 238u8, 39u8, 253u8, 154u8, 222u8, 186u8,
                179u8, 32u8, 65u8, 247u8, 85u8, 33u8, 77u8, 188u8, 107u8, 255u8, 169u8,
                12u8, 192u8, 34u8, 91u8, 57u8, 218u8, 46u8, 92u8, 45u8, 59u8,
            ],
            [
                193u8, 241u8, 252u8, 170u8, 137u8, 138u8, 174u8, 34u8, 99u8, 221u8,
                237u8, 113u8, 46u8, 23u8, 152u8, 8u8, 63u8, 202u8, 146u8, 114u8, 255u8,
                128u8, 62u8, 228u8, 21u8, 12u8, 228u8, 143u8, 134u8, 25u8, 137u8, 26u8,
            ],
            [
                199u8, 245u8, 5u8, 178u8, 243u8, 113u8, 174u8, 33u8, 117u8, 238u8, 73u8,
                19u8, 244u8, 73u8, 158u8, 31u8, 38u8, 51u8, 167u8, 181u8, 147u8, 99u8,
                33u8, 238u8, 209u8, 205u8, 174u8, 182u8, 17u8, 81u8, 129u8, 210u8,
            ],
            [
                204u8, 161u8, 212u8, 99u8, 132u8, 205u8, 187u8, 238u8, 242u8, 249u8,
                218u8, 221u8, 183u8, 109u8, 177u8, 56u8, 16u8, 28u8, 153u8, 5u8, 248u8,
                24u8, 216u8, 103u8, 182u8, 48u8, 25u8, 92u8, 18u8, 141u8, 60u8, 102u8,
            ],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolEventInterface for HCULimitEvents {
        const NAME: &'static str = "HCULimitEvents";
        const COUNT: usize = 7usize;
        fn decode_raw_log(
            topics: &[alloy_sol_types::Word],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            match topics.first().copied() {
                Some(
                    <BlockHCUWhitelistAdded as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <BlockHCUWhitelistAdded as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::BlockHCUWhitelistAdded)
                }
                Some(
                    <BlockHCUWhitelistRemoved as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <BlockHCUWhitelistRemoved as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::BlockHCUWhitelistRemoved)
                }
                Some(<HCUPerBlockSet as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <HCUPerBlockSet as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::HCUPerBlockSet)
                }
                Some(<Initialized as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Initialized as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::Initialized)
                }
                Some(
                    <MaxHCUDepthPerTxSet as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <MaxHCUDepthPerTxSet as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::MaxHCUDepthPerTxSet)
                }
                Some(<MaxHCUPerTxSet as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <MaxHCUPerTxSet as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::MaxHCUPerTxSet)
                }
                Some(<Upgraded as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Upgraded as alloy_sol_types::SolEvent>::decode_raw_log(topics, data)
                        .map(Self::Upgraded)
                }
                _ => {
                    alloy_sol_types::private::Err(alloy_sol_types::Error::InvalidLog {
                        name: <Self as alloy_sol_types::SolEventInterface>::NAME,
                        log: alloy_sol_types::private::Box::new(
                            alloy_sol_types::private::LogData::new_unchecked(
                                topics.to_vec(),
                                data.to_vec().into(),
                            ),
                        ),
                    })
                }
            }
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::private::IntoLogData for HCULimitEvents {
        fn to_log_data(&self) -> alloy_sol_types::private::LogData {
            match self {
                Self::BlockHCUWhitelistAdded(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::BlockHCUWhitelistRemoved(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::HCUPerBlockSet(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Initialized(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::MaxHCUDepthPerTxSet(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::MaxHCUPerTxSet(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Upgraded(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
            }
        }
        fn into_log_data(self) -> alloy_sol_types::private::LogData {
            match self {
                Self::BlockHCUWhitelistAdded(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::BlockHCUWhitelistRemoved(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::HCUPerBlockSet(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Initialized(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::MaxHCUDepthPerTxSet(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::MaxHCUPerTxSet(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Upgraded(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`HCULimit`](self) contract instance.

See the [wrapper's documentation](`HCULimitInstance`) for more details.*/
    #[inline]
    pub const fn new<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> HCULimitInstance<P, N> {
        HCULimitInstance::<P, N>::new(address, provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
    ) -> impl ::core::future::Future<
        Output = alloy_contract::Result<HCULimitInstance<P, N>>,
    > {
        HCULimitInstance::<P, N>::deploy(provider)
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(provider: P) -> alloy_contract::RawCallBuilder<P, N> {
        HCULimitInstance::<P, N>::deploy_builder(provider)
    }
    /**A [`HCULimit`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`HCULimit`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct HCULimitInstance<P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network: ::core::marker::PhantomData<N>,
    }
    #[automatically_derived]
    impl<P, N> ::core::fmt::Debug for HCULimitInstance<P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("HCULimitInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > HCULimitInstance<P, N> {
        /**Creates a new wrapper around an on-chain [`HCULimit`](self) contract instance.

See the [wrapper's documentation](`HCULimitInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            provider: P,
        ) -> Self {
            Self {
                address,
                provider,
                _network: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            provider: P,
        ) -> alloy_contract::Result<HCULimitInstance<P, N>> {
            let call_builder = Self::deploy_builder(provider);
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(provider: P) -> alloy_contract::RawCallBuilder<P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                provider,
                ::core::clone::Clone::clone(&BYTECODE),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<P: ::core::clone::Clone, N> HCULimitInstance<&P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> HCULimitInstance<P, N> {
            HCULimitInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > HCULimitInstance<P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<&P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        ///Creates a new call builder for the [`UPGRADE_INTERFACE_VERSION`] function.
        pub fn UPGRADE_INTERFACE_VERSION(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, UPGRADE_INTERFACE_VERSIONCall, N> {
            self.call_builder(&UPGRADE_INTERFACE_VERSIONCall)
        }
        ///Creates a new call builder for the [`addToBlockHCUWhitelist`] function.
        pub fn addToBlockHCUWhitelist(
            &self,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, addToBlockHCUWhitelistCall, N> {
            self.call_builder(
                &addToBlockHCUWhitelistCall {
                    account,
                },
            )
        }
        ///Creates a new call builder for the [`checkHCUForCast`] function.
        pub fn checkHCUForCast(
            &self,
            resultType: <FheType as alloy::sol_types::SolType>::RustType,
            ct: alloy::sol_types::private::FixedBytes<32>,
            result: alloy::sol_types::private::FixedBytes<32>,
            caller: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, checkHCUForCastCall, N> {
            self.call_builder(
                &checkHCUForCastCall {
                    resultType,
                    ct,
                    result,
                    caller,
                },
            )
        }
        ///Creates a new call builder for the [`checkHCUForFheAdd`] function.
        pub fn checkHCUForFheAdd(
            &self,
            resultType: <FheType as alloy::sol_types::SolType>::RustType,
            scalarByte: alloy::sol_types::private::FixedBytes<1>,
            lhs: alloy::sol_types::private::FixedBytes<32>,
            rhs: alloy::sol_types::private::FixedBytes<32>,
            result: alloy::sol_types::private::FixedBytes<32>,
            caller: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, checkHCUForFheAddCall, N> {
            self.call_builder(
                &checkHCUForFheAddCall {
                    resultType,
                    scalarByte,
                    lhs,
                    rhs,
                    result,
                    caller,
                },
            )
        }
        ///Creates a new call builder for the [`checkHCUForFheBitAnd`] function.
        pub fn checkHCUForFheBitAnd(
            &self,
            resultType: <FheType as alloy::sol_types::SolType>::RustType,
            scalarByte: alloy::sol_types::private::FixedBytes<1>,
            lhs: alloy::sol_types::private::FixedBytes<32>,
            rhs: alloy::sol_types::private::FixedBytes<32>,
            result: alloy::sol_types::private::FixedBytes<32>,
            caller: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, checkHCUForFheBitAndCall, N> {
            self.call_builder(
                &checkHCUForFheBitAndCall {
                    resultType,
                    scalarByte,
                    lhs,
                    rhs,
                    result,
                    caller,
                },
            )
        }
        ///Creates a new call builder for the [`checkHCUForFheBitOr`] function.
        pub fn checkHCUForFheBitOr(
            &self,
            resultType: <FheType as alloy::sol_types::SolType>::RustType,
            scalarByte: alloy::sol_types::private::FixedBytes<1>,
            lhs: alloy::sol_types::private::FixedBytes<32>,
            rhs: alloy::sol_types::private::FixedBytes<32>,
            result: alloy::sol_types::private::FixedBytes<32>,
            caller: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, checkHCUForFheBitOrCall, N> {
            self.call_builder(
                &checkHCUForFheBitOrCall {
                    resultType,
                    scalarByte,
                    lhs,
                    rhs,
                    result,
                    caller,
                },
            )
        }
        ///Creates a new call builder for the [`checkHCUForFheBitXor`] function.
        pub fn checkHCUForFheBitXor(
            &self,
            resultType: <FheType as alloy::sol_types::SolType>::RustType,
            scalarByte: alloy::sol_types::private::FixedBytes<1>,
            lhs: alloy::sol_types::private::FixedBytes<32>,
            rhs: alloy::sol_types::private::FixedBytes<32>,
            result: alloy::sol_types::private::FixedBytes<32>,
            caller: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, checkHCUForFheBitXorCall, N> {
            self.call_builder(
                &checkHCUForFheBitXorCall {
                    resultType,
                    scalarByte,
                    lhs,
                    rhs,
                    result,
                    caller,
                },
            )
        }
        ///Creates a new call builder for the [`checkHCUForFheDiv`] function.
        pub fn checkHCUForFheDiv(
            &self,
            resultType: <FheType as alloy::sol_types::SolType>::RustType,
            scalarByte: alloy::sol_types::private::FixedBytes<1>,
            lhs: alloy::sol_types::private::FixedBytes<32>,
            _3: alloy::sol_types::private::FixedBytes<32>,
            result: alloy::sol_types::private::FixedBytes<32>,
            caller: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, checkHCUForFheDivCall, N> {
            self.call_builder(
                &checkHCUForFheDivCall {
                    resultType,
                    scalarByte,
                    lhs,
                    _3,
                    result,
                    caller,
                },
            )
        }
        ///Creates a new call builder for the [`checkHCUForFheEq`] function.
        pub fn checkHCUForFheEq(
            &self,
            resultType: <FheType as alloy::sol_types::SolType>::RustType,
            scalarByte: alloy::sol_types::private::FixedBytes<1>,
            lhs: alloy::sol_types::private::FixedBytes<32>,
            rhs: alloy::sol_types::private::FixedBytes<32>,
            result: alloy::sol_types::private::FixedBytes<32>,
            caller: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, checkHCUForFheEqCall, N> {
            self.call_builder(
                &checkHCUForFheEqCall {
                    resultType,
                    scalarByte,
                    lhs,
                    rhs,
                    result,
                    caller,
                },
            )
        }
        ///Creates a new call builder for the [`checkHCUForFheGe`] function.
        pub fn checkHCUForFheGe(
            &self,
            resultType: <FheType as alloy::sol_types::SolType>::RustType,
            scalarByte: alloy::sol_types::private::FixedBytes<1>,
            lhs: alloy::sol_types::private::FixedBytes<32>,
            rhs: alloy::sol_types::private::FixedBytes<32>,
            result: alloy::sol_types::private::FixedBytes<32>,
            caller: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, checkHCUForFheGeCall, N> {
            self.call_builder(
                &checkHCUForFheGeCall {
                    resultType,
                    scalarByte,
                    lhs,
                    rhs,
                    result,
                    caller,
                },
            )
        }
        ///Creates a new call builder for the [`checkHCUForFheGt`] function.
        pub fn checkHCUForFheGt(
            &self,
            resultType: <FheType as alloy::sol_types::SolType>::RustType,
            scalarByte: alloy::sol_types::private::FixedBytes<1>,
            lhs: alloy::sol_types::private::FixedBytes<32>,
            rhs: alloy::sol_types::private::FixedBytes<32>,
            result: alloy::sol_types::private::FixedBytes<32>,
            caller: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, checkHCUForFheGtCall, N> {
            self.call_builder(
                &checkHCUForFheGtCall {
                    resultType,
                    scalarByte,
                    lhs,
                    rhs,
                    result,
                    caller,
                },
            )
        }
        ///Creates a new call builder for the [`checkHCUForFheLe`] function.
        pub fn checkHCUForFheLe(
            &self,
            resultType: <FheType as alloy::sol_types::SolType>::RustType,
            scalarByte: alloy::sol_types::private::FixedBytes<1>,
            lhs: alloy::sol_types::private::FixedBytes<32>,
            rhs: alloy::sol_types::private::FixedBytes<32>,
            result: alloy::sol_types::private::FixedBytes<32>,
            caller: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, checkHCUForFheLeCall, N> {
            self.call_builder(
                &checkHCUForFheLeCall {
                    resultType,
                    scalarByte,
                    lhs,
                    rhs,
                    result,
                    caller,
                },
            )
        }
        ///Creates a new call builder for the [`checkHCUForFheLt`] function.
        pub fn checkHCUForFheLt(
            &self,
            resultType: <FheType as alloy::sol_types::SolType>::RustType,
            scalarByte: alloy::sol_types::private::FixedBytes<1>,
            lhs: alloy::sol_types::private::FixedBytes<32>,
            rhs: alloy::sol_types::private::FixedBytes<32>,
            result: alloy::sol_types::private::FixedBytes<32>,
            caller: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, checkHCUForFheLtCall, N> {
            self.call_builder(
                &checkHCUForFheLtCall {
                    resultType,
                    scalarByte,
                    lhs,
                    rhs,
                    result,
                    caller,
                },
            )
        }
        ///Creates a new call builder for the [`checkHCUForFheMax`] function.
        pub fn checkHCUForFheMax(
            &self,
            resultType: <FheType as alloy::sol_types::SolType>::RustType,
            scalarByte: alloy::sol_types::private::FixedBytes<1>,
            lhs: alloy::sol_types::private::FixedBytes<32>,
            rhs: alloy::sol_types::private::FixedBytes<32>,
            result: alloy::sol_types::private::FixedBytes<32>,
            caller: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, checkHCUForFheMaxCall, N> {
            self.call_builder(
                &checkHCUForFheMaxCall {
                    resultType,
                    scalarByte,
                    lhs,
                    rhs,
                    result,
                    caller,
                },
            )
        }
        ///Creates a new call builder for the [`checkHCUForFheMin`] function.
        pub fn checkHCUForFheMin(
            &self,
            resultType: <FheType as alloy::sol_types::SolType>::RustType,
            scalarByte: alloy::sol_types::private::FixedBytes<1>,
            lhs: alloy::sol_types::private::FixedBytes<32>,
            rhs: alloy::sol_types::private::FixedBytes<32>,
            result: alloy::sol_types::private::FixedBytes<32>,
            caller: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, checkHCUForFheMinCall, N> {
            self.call_builder(
                &checkHCUForFheMinCall {
                    resultType,
                    scalarByte,
                    lhs,
                    rhs,
                    result,
                    caller,
                },
            )
        }
        ///Creates a new call builder for the [`checkHCUForFheMul`] function.
        pub fn checkHCUForFheMul(
            &self,
            resultType: <FheType as alloy::sol_types::SolType>::RustType,
            scalarByte: alloy::sol_types::private::FixedBytes<1>,
            lhs: alloy::sol_types::private::FixedBytes<32>,
            rhs: alloy::sol_types::private::FixedBytes<32>,
            result: alloy::sol_types::private::FixedBytes<32>,
            caller: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, checkHCUForFheMulCall, N> {
            self.call_builder(
                &checkHCUForFheMulCall {
                    resultType,
                    scalarByte,
                    lhs,
                    rhs,
                    result,
                    caller,
                },
            )
        }
        ///Creates a new call builder for the [`checkHCUForFheNe`] function.
        pub fn checkHCUForFheNe(
            &self,
            resultType: <FheType as alloy::sol_types::SolType>::RustType,
            scalarByte: alloy::sol_types::private::FixedBytes<1>,
            lhs: alloy::sol_types::private::FixedBytes<32>,
            rhs: alloy::sol_types::private::FixedBytes<32>,
            result: alloy::sol_types::private::FixedBytes<32>,
            caller: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, checkHCUForFheNeCall, N> {
            self.call_builder(
                &checkHCUForFheNeCall {
                    resultType,
                    scalarByte,
                    lhs,
                    rhs,
                    result,
                    caller,
                },
            )
        }
        ///Creates a new call builder for the [`checkHCUForFheNeg`] function.
        pub fn checkHCUForFheNeg(
            &self,
            resultType: <FheType as alloy::sol_types::SolType>::RustType,
            ct: alloy::sol_types::private::FixedBytes<32>,
            result: alloy::sol_types::private::FixedBytes<32>,
            caller: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, checkHCUForFheNegCall, N> {
            self.call_builder(
                &checkHCUForFheNegCall {
                    resultType,
                    ct,
                    result,
                    caller,
                },
            )
        }
        ///Creates a new call builder for the [`checkHCUForFheNot`] function.
        pub fn checkHCUForFheNot(
            &self,
            resultType: <FheType as alloy::sol_types::SolType>::RustType,
            ct: alloy::sol_types::private::FixedBytes<32>,
            result: alloy::sol_types::private::FixedBytes<32>,
            caller: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, checkHCUForFheNotCall, N> {
            self.call_builder(
                &checkHCUForFheNotCall {
                    resultType,
                    ct,
                    result,
                    caller,
                },
            )
        }
        ///Creates a new call builder for the [`checkHCUForFheRand`] function.
        pub fn checkHCUForFheRand(
            &self,
            resultType: <FheType as alloy::sol_types::SolType>::RustType,
            result: alloy::sol_types::private::FixedBytes<32>,
            caller: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, checkHCUForFheRandCall, N> {
            self.call_builder(
                &checkHCUForFheRandCall {
                    resultType,
                    result,
                    caller,
                },
            )
        }
        ///Creates a new call builder for the [`checkHCUForFheRandBounded`] function.
        pub fn checkHCUForFheRandBounded(
            &self,
            resultType: <FheType as alloy::sol_types::SolType>::RustType,
            result: alloy::sol_types::private::FixedBytes<32>,
            caller: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, checkHCUForFheRandBoundedCall, N> {
            self.call_builder(
                &checkHCUForFheRandBoundedCall {
                    resultType,
                    result,
                    caller,
                },
            )
        }
        ///Creates a new call builder for the [`checkHCUForFheRem`] function.
        pub fn checkHCUForFheRem(
            &self,
            resultType: <FheType as alloy::sol_types::SolType>::RustType,
            scalarByte: alloy::sol_types::private::FixedBytes<1>,
            lhs: alloy::sol_types::private::FixedBytes<32>,
            _3: alloy::sol_types::private::FixedBytes<32>,
            result: alloy::sol_types::private::FixedBytes<32>,
            caller: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, checkHCUForFheRemCall, N> {
            self.call_builder(
                &checkHCUForFheRemCall {
                    resultType,
                    scalarByte,
                    lhs,
                    _3,
                    result,
                    caller,
                },
            )
        }
        ///Creates a new call builder for the [`checkHCUForFheRotl`] function.
        pub fn checkHCUForFheRotl(
            &self,
            resultType: <FheType as alloy::sol_types::SolType>::RustType,
            scalarByte: alloy::sol_types::private::FixedBytes<1>,
            lhs: alloy::sol_types::private::FixedBytes<32>,
            rhs: alloy::sol_types::private::FixedBytes<32>,
            result: alloy::sol_types::private::FixedBytes<32>,
            caller: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, checkHCUForFheRotlCall, N> {
            self.call_builder(
                &checkHCUForFheRotlCall {
                    resultType,
                    scalarByte,
                    lhs,
                    rhs,
                    result,
                    caller,
                },
            )
        }
        ///Creates a new call builder for the [`checkHCUForFheRotr`] function.
        pub fn checkHCUForFheRotr(
            &self,
            resultType: <FheType as alloy::sol_types::SolType>::RustType,
            scalarByte: alloy::sol_types::private::FixedBytes<1>,
            lhs: alloy::sol_types::private::FixedBytes<32>,
            rhs: alloy::sol_types::private::FixedBytes<32>,
            result: alloy::sol_types::private::FixedBytes<32>,
            caller: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, checkHCUForFheRotrCall, N> {
            self.call_builder(
                &checkHCUForFheRotrCall {
                    resultType,
                    scalarByte,
                    lhs,
                    rhs,
                    result,
                    caller,
                },
            )
        }
        ///Creates a new call builder for the [`checkHCUForFheShl`] function.
        pub fn checkHCUForFheShl(
            &self,
            resultType: <FheType as alloy::sol_types::SolType>::RustType,
            scalarByte: alloy::sol_types::private::FixedBytes<1>,
            lhs: alloy::sol_types::private::FixedBytes<32>,
            rhs: alloy::sol_types::private::FixedBytes<32>,
            result: alloy::sol_types::private::FixedBytes<32>,
            caller: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, checkHCUForFheShlCall, N> {
            self.call_builder(
                &checkHCUForFheShlCall {
                    resultType,
                    scalarByte,
                    lhs,
                    rhs,
                    result,
                    caller,
                },
            )
        }
        ///Creates a new call builder for the [`checkHCUForFheShr`] function.
        pub fn checkHCUForFheShr(
            &self,
            resultType: <FheType as alloy::sol_types::SolType>::RustType,
            scalarByte: alloy::sol_types::private::FixedBytes<1>,
            lhs: alloy::sol_types::private::FixedBytes<32>,
            rhs: alloy::sol_types::private::FixedBytes<32>,
            result: alloy::sol_types::private::FixedBytes<32>,
            caller: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, checkHCUForFheShrCall, N> {
            self.call_builder(
                &checkHCUForFheShrCall {
                    resultType,
                    scalarByte,
                    lhs,
                    rhs,
                    result,
                    caller,
                },
            )
        }
        ///Creates a new call builder for the [`checkHCUForFheSub`] function.
        pub fn checkHCUForFheSub(
            &self,
            resultType: <FheType as alloy::sol_types::SolType>::RustType,
            scalarByte: alloy::sol_types::private::FixedBytes<1>,
            lhs: alloy::sol_types::private::FixedBytes<32>,
            rhs: alloy::sol_types::private::FixedBytes<32>,
            result: alloy::sol_types::private::FixedBytes<32>,
            caller: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, checkHCUForFheSubCall, N> {
            self.call_builder(
                &checkHCUForFheSubCall {
                    resultType,
                    scalarByte,
                    lhs,
                    rhs,
                    result,
                    caller,
                },
            )
        }
        ///Creates a new call builder for the [`checkHCUForIfThenElse`] function.
        pub fn checkHCUForIfThenElse(
            &self,
            resultType: <FheType as alloy::sol_types::SolType>::RustType,
            lhs: alloy::sol_types::private::FixedBytes<32>,
            middle: alloy::sol_types::private::FixedBytes<32>,
            rhs: alloy::sol_types::private::FixedBytes<32>,
            result: alloy::sol_types::private::FixedBytes<32>,
            caller: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, checkHCUForIfThenElseCall, N> {
            self.call_builder(
                &checkHCUForIfThenElseCall {
                    resultType,
                    lhs,
                    middle,
                    rhs,
                    result,
                    caller,
                },
            )
        }
        ///Creates a new call builder for the [`checkHCUForTrivialEncrypt`] function.
        pub fn checkHCUForTrivialEncrypt(
            &self,
            resultType: <FheType as alloy::sol_types::SolType>::RustType,
            result: alloy::sol_types::private::FixedBytes<32>,
            caller: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, checkHCUForTrivialEncryptCall, N> {
            self.call_builder(
                &checkHCUForTrivialEncryptCall {
                    resultType,
                    result,
                    caller,
                },
            )
        }
        ///Creates a new call builder for the [`getBlockMeter`] function.
        pub fn getBlockMeter(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, getBlockMeterCall, N> {
            self.call_builder(&getBlockMeterCall)
        }
        ///Creates a new call builder for the [`getFHEVMExecutorAddress`] function.
        pub fn getFHEVMExecutorAddress(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, getFHEVMExecutorAddressCall, N> {
            self.call_builder(&getFHEVMExecutorAddressCall)
        }
        ///Creates a new call builder for the [`getGlobalHCUCapPerBlock`] function.
        pub fn getGlobalHCUCapPerBlock(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, getGlobalHCUCapPerBlockCall, N> {
            self.call_builder(&getGlobalHCUCapPerBlockCall)
        }
        ///Creates a new call builder for the [`getMaxHCUDepthPerTx`] function.
        pub fn getMaxHCUDepthPerTx(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, getMaxHCUDepthPerTxCall, N> {
            self.call_builder(&getMaxHCUDepthPerTxCall)
        }
        ///Creates a new call builder for the [`getMaxHCUPerTx`] function.
        pub fn getMaxHCUPerTx(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, getMaxHCUPerTxCall, N> {
            self.call_builder(&getMaxHCUPerTxCall)
        }
        ///Creates a new call builder for the [`getVersion`] function.
        pub fn getVersion(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, getVersionCall, N> {
            self.call_builder(&getVersionCall)
        }
        ///Creates a new call builder for the [`initializeFromEmptyProxy`] function.
        pub fn initializeFromEmptyProxy(
            &self,
            hcuCapPerBlock: alloy::sol_types::private::primitives::aliases::U48,
            maxHCUDepthPerTx: alloy::sol_types::private::primitives::aliases::U48,
            maxHCUPerTx: alloy::sol_types::private::primitives::aliases::U48,
        ) -> alloy_contract::SolCallBuilder<&P, initializeFromEmptyProxyCall, N> {
            self.call_builder(
                &initializeFromEmptyProxyCall {
                    hcuCapPerBlock,
                    maxHCUDepthPerTx,
                    maxHCUPerTx,
                },
            )
        }
        ///Creates a new call builder for the [`isBlockHCUWhitelisted`] function.
        pub fn isBlockHCUWhitelisted(
            &self,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, isBlockHCUWhitelistedCall, N> {
            self.call_builder(
                &isBlockHCUWhitelistedCall {
                    account,
                },
            )
        }
        ///Creates a new call builder for the [`proxiableUUID`] function.
        pub fn proxiableUUID(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, proxiableUUIDCall, N> {
            self.call_builder(&proxiableUUIDCall)
        }
        ///Creates a new call builder for the [`reinitializeV2`] function.
        pub fn reinitializeV2(
            &self,
            hcuCapPerBlock: alloy::sol_types::private::primitives::aliases::U48,
            maxHCUDepthPerTx: alloy::sol_types::private::primitives::aliases::U48,
            maxHCUPerTx: alloy::sol_types::private::primitives::aliases::U48,
        ) -> alloy_contract::SolCallBuilder<&P, reinitializeV2Call, N> {
            self.call_builder(
                &reinitializeV2Call {
                    hcuCapPerBlock,
                    maxHCUDepthPerTx,
                    maxHCUPerTx,
                },
            )
        }
        ///Creates a new call builder for the [`removeFromBlockHCUWhitelist`] function.
        pub fn removeFromBlockHCUWhitelist(
            &self,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, removeFromBlockHCUWhitelistCall, N> {
            self.call_builder(
                &removeFromBlockHCUWhitelistCall {
                    account,
                },
            )
        }
        ///Creates a new call builder for the [`setHCUPerBlock`] function.
        pub fn setHCUPerBlock(
            &self,
            hcuPerBlock: alloy::sol_types::private::primitives::aliases::U48,
        ) -> alloy_contract::SolCallBuilder<&P, setHCUPerBlockCall, N> {
            self.call_builder(&setHCUPerBlockCall { hcuPerBlock })
        }
        ///Creates a new call builder for the [`setMaxHCUDepthPerTx`] function.
        pub fn setMaxHCUDepthPerTx(
            &self,
            maxHCUDepthPerTx: alloy::sol_types::private::primitives::aliases::U48,
        ) -> alloy_contract::SolCallBuilder<&P, setMaxHCUDepthPerTxCall, N> {
            self.call_builder(
                &setMaxHCUDepthPerTxCall {
                    maxHCUDepthPerTx,
                },
            )
        }
        ///Creates a new call builder for the [`setMaxHCUPerTx`] function.
        pub fn setMaxHCUPerTx(
            &self,
            maxHCUPerTx: alloy::sol_types::private::primitives::aliases::U48,
        ) -> alloy_contract::SolCallBuilder<&P, setMaxHCUPerTxCall, N> {
            self.call_builder(&setMaxHCUPerTxCall { maxHCUPerTx })
        }
        ///Creates a new call builder for the [`upgradeToAndCall`] function.
        pub fn upgradeToAndCall(
            &self,
            newImplementation: alloy::sol_types::private::Address,
            data: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<&P, upgradeToAndCallCall, N> {
            self.call_builder(
                &upgradeToAndCallCall {
                    newImplementation,
                    data,
                },
            )
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > HCULimitInstance<P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<&P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
        ///Creates a new event filter for the [`BlockHCUWhitelistAdded`] event.
        pub fn BlockHCUWhitelistAdded_filter(
            &self,
        ) -> alloy_contract::Event<&P, BlockHCUWhitelistAdded, N> {
            self.event_filter::<BlockHCUWhitelistAdded>()
        }
        ///Creates a new event filter for the [`BlockHCUWhitelistRemoved`] event.
        pub fn BlockHCUWhitelistRemoved_filter(
            &self,
        ) -> alloy_contract::Event<&P, BlockHCUWhitelistRemoved, N> {
            self.event_filter::<BlockHCUWhitelistRemoved>()
        }
        ///Creates a new event filter for the [`HCUPerBlockSet`] event.
        pub fn HCUPerBlockSet_filter(
            &self,
        ) -> alloy_contract::Event<&P, HCUPerBlockSet, N> {
            self.event_filter::<HCUPerBlockSet>()
        }
        ///Creates a new event filter for the [`Initialized`] event.
        pub fn Initialized_filter(&self) -> alloy_contract::Event<&P, Initialized, N> {
            self.event_filter::<Initialized>()
        }
        ///Creates a new event filter for the [`MaxHCUDepthPerTxSet`] event.
        pub fn MaxHCUDepthPerTxSet_filter(
            &self,
        ) -> alloy_contract::Event<&P, MaxHCUDepthPerTxSet, N> {
            self.event_filter::<MaxHCUDepthPerTxSet>()
        }
        ///Creates a new event filter for the [`MaxHCUPerTxSet`] event.
        pub fn MaxHCUPerTxSet_filter(
            &self,
        ) -> alloy_contract::Event<&P, MaxHCUPerTxSet, N> {
            self.event_filter::<MaxHCUPerTxSet>()
        }
        ///Creates a new event filter for the [`Upgraded`] event.
        pub fn Upgraded_filter(&self) -> alloy_contract::Event<&P, Upgraded, N> {
            self.event_filter::<Upgraded>()
        }
    }
}
