/**

Generated by the following Solidity interface...
```solidity
interface KmsContexts {
    type ContextStatus is uint8;
    struct DecryptionThresholds {
        uint256 publicDecryptionThreshold;
        uint256 userDecryptionThreshold;
    }
    struct KmsBlockPeriods {
        uint256 preActivationBlockPeriod;
        uint256 generationBlockPeriod;
        uint256 suspendedBlockPeriod;
    }
    struct KmsContext {
        uint256 contextId;
        uint256 previousContextId;
        bytes8 softwareVersion;
        uint256 mpcThreshold;
        KmsNode[] kmsNodes;
    }
    struct KmsNode {
        string name;
        address signerAddress;
        address txSenderAddress;
        uint256 partyId;
        bytes backupEncryptionKey;
        string externalUrl;
        string publicStorageUrl;
        bytes tlsCertificate;
    }

    error AddressEmptyCode(address target);
    error CompromiseActiveKmsContextNotAllowed(uint256 contextId);
    error ContextAlreadyExists(uint256 contextId);
    error ContextNotActive(uint256 contextId);
    error ContextNotActiveOrSuspended(uint256 contextId);
    error ContextNotGenerated(uint256 contextId);
    error ContextNotInitializedOrIsGenerating(uint256 contextId);
    error ContextNotPreActivatedOrSuspended(uint256 contextId);
    error DestroyActiveKmsContextNotAllowed(uint256 contextId);
    error ECDSAInvalidSignature();
    error ECDSAInvalidSignatureLength(uint256 length);
    error ECDSAInvalidSignatureS(bytes32 s);
    error ERC1967InvalidImplementation(address implementation);
    error ERC1967NonPayable();
    error EmptyKmsNodes();
    error EnforcedPause();
    error ExpectedPause();
    error FailedCall();
    error InvalidHighMpcThreshold(uint256 contextId, uint256 mpcThreshold, uint256 nKmsNodes);
    error InvalidHighPublicDecryptionThreshold(uint256 publicDecryptionThreshold, uint256 nKmsNodes);
    error InvalidHighUserDecryptionThreshold(uint256 userDecryptionThreshold, uint256 nKmsNodes);
    error InvalidInitialization();
    error InvalidNullContextId();
    error InvalidNullPublicDecryptionThreshold();
    error InvalidNullUserDecryptionThreshold();
    error KmsContextNotGenerating(uint256 contextId);
    error KmsContextNotInitialized(uint256 contextId);
    error KmsNodeAlreadyValidatedKeyResharing(uint256 contextId, address kmsSigner);
    error NoSuspendedKmsContext();
    error NotInitializing();
    error NotInitializingFromEmptyProxy();
    error NotKmsNodeFromContext(uint256 contextId, address kmsTxSenderAddress);
    error NotKmsSignerFromContext(uint256 contextId, address signerAddress);
    error NotKmsTxSenderFromContext(uint256 contextId, address txSenderAddress);
    error NotOwnerOrPauser(address notOwnerOrPauser);
    error NumberOfKmsNodesChanged(uint256 activeKmsNodesLength, uint256 newKmsNodesLength);
    error OwnableInvalidOwner(address owner);
    error OwnableUnauthorizedAccount(address account);
    error SuspendedKmsContextOngoing(uint256 suspendedContextId);
    error UUPSUnauthorizedCallContext();
    error UUPSUnsupportedProxiableUUID(bytes32 slot);

    event ActivateKmsContext(uint256 contextId);
    event CompromiseKmsContext(uint256 contextId);
    event DeactivateKmsContext(uint256 contextId);
    event DestroyKmsContext(uint256 contextId);
    event EIP712DomainChanged();
    event InitializeKmsContexts(DecryptionThresholds decryptionThresholds, bytes8 softwareVersion, uint256 mpcThreshold, KmsNode[] kmsNodes);
    event Initialized(uint64 version);
    event InvalidateKeyResharing(uint256 contextId);
    event NewKmsContext(KmsContext activeKmsContext, KmsContext newKmsContext, KmsBlockPeriods blockPeriods);
    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
    event Paused(address account);
    event PreActivateKmsContext(KmsContext newKmsContext, uint256 preActivationBlockNumber);
    event StartKeyResharing(KmsContext activeKmsContext, KmsContext newKmsContext, uint256 generationBlockNumber);
    event SuspendKmsContext(uint256 contextId);
    event Unpaused(address account);
    event UpdatePublicDecryptionThreshold(uint256 newPublicDecryptionThreshold);
    event UpdateUserDecryptionThreshold(uint256 newUserDecryptionThreshold);
    event Upgraded(address indexed implementation);
    event ValidateKeyResharing(KmsContext newKmsContext);

    constructor();

    function UPGRADE_INTERFACE_VERSION() external view returns (string memory);
    function acceptOwnership() external;
    function addKmsContext(bytes8 softwareVersion, bool reshareKeys, uint256 mpcThreshold, KmsNode[] memory kmsNodes, KmsBlockPeriods memory blockPeriods, DecryptionThresholds memory decryptionThresholds) external;
    function checkIsKmsSignerFromContext(uint256 contextId, address signerAddress) external view;
    function checkIsKmsTxSenderFromContext(uint256 contextId, address txSenderAddress) external view;
    function compromiseKmsContext(uint256 contextId) external;
    function destroyKmsContext(uint256 contextId) external;
    function eip712Domain() external view returns (bytes1 fields, string memory name, string memory version, uint256 chainId, address verifyingContract, bytes32 salt, uint256[] memory extensions);
    function getActiveKmsContext() external view returns (KmsContext memory);
    function getActiveKmsContextId() external view returns (uint256);
    function getKmsContextGenerationBlockPeriod() external view returns (uint256);
    function getKmsContextStatus(uint256 contextId) external view returns (ContextStatus);
    function getKmsContextSuspensionBlockPeriod() external view returns (uint256);
    function getKmsNode(address kmsTxSenderAddress) external view returns (KmsNode memory);
    function getKmsSigners() external view returns (address[] memory);
    function getKmsTxSenders() external view returns (address[] memory);
    function getPublicDecryptionThresholdFromContext(uint256 contextId) external view returns (uint256);
    function getSuspendedKmsContextId() external view returns (uint256);
    function getUserDecryptionThresholdFromContext(uint256 contextId) external view returns (uint256);
    function getVersion() external pure returns (string memory);
    function initializeFromEmptyProxy(bytes8 initialSoftwareVersion, uint256 initialMpcThreshold, KmsNode[] memory initialKmsNodes, DecryptionThresholds memory initialDecryptionThresholds) external;
    function moveSuspendedKmsContextToActive() external;
    function owner() external view returns (address);
    function pause() external;
    function paused() external view returns (bool);
    function pendingOwner() external view returns (address);
    function proxiableUUID() external view returns (bytes32);
    function refreshKmsContextStatuses() external;
    function renounceOwnership() external;
    function transferOwnership(address newOwner) external;
    function unpause() external;
    function updatePublicDecryptionThreshold(uint256 newPublicDecryptionThreshold) external;
    function updateUserDecryptionThreshold(uint256 newUserDecryptionThreshold) external;
    function upgradeToAndCall(address newImplementation, bytes memory data) external payable;
    function validateKeyResharing(uint256 contextId, bytes memory signature) external;
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "constructor",
    "inputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "UPGRADE_INTERFACE_VERSION",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "acceptOwnership",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "addKmsContext",
    "inputs": [
      {
        "name": "softwareVersion",
        "type": "bytes8",
        "internalType": "bytes8"
      },
      {
        "name": "reshareKeys",
        "type": "bool",
        "internalType": "bool"
      },
      {
        "name": "mpcThreshold",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "kmsNodes",
        "type": "tuple[]",
        "internalType": "struct KmsNode[]",
        "components": [
          {
            "name": "name",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "signerAddress",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "txSenderAddress",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "partyId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "backupEncryptionKey",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "externalUrl",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "publicStorageUrl",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "tlsCertificate",
            "type": "bytes",
            "internalType": "bytes"
          }
        ]
      },
      {
        "name": "blockPeriods",
        "type": "tuple",
        "internalType": "struct KmsBlockPeriods",
        "components": [
          {
            "name": "preActivationBlockPeriod",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "generationBlockPeriod",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "suspendedBlockPeriod",
            "type": "uint256",
            "internalType": "uint256"
          }
        ]
      },
      {
        "name": "decryptionThresholds",
        "type": "tuple",
        "internalType": "struct DecryptionThresholds",
        "components": [
          {
            "name": "publicDecryptionThreshold",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "userDecryptionThreshold",
            "type": "uint256",
            "internalType": "uint256"
          }
        ]
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "checkIsKmsSignerFromContext",
    "inputs": [
      {
        "name": "contextId",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "signerAddress",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "checkIsKmsTxSenderFromContext",
    "inputs": [
      {
        "name": "contextId",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "txSenderAddress",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "compromiseKmsContext",
    "inputs": [
      {
        "name": "contextId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "destroyKmsContext",
    "inputs": [
      {
        "name": "contextId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "eip712Domain",
    "inputs": [],
    "outputs": [
      {
        "name": "fields",
        "type": "bytes1",
        "internalType": "bytes1"
      },
      {
        "name": "name",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "version",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "chainId",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "verifyingContract",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "salt",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "extensions",
        "type": "uint256[]",
        "internalType": "uint256[]"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getActiveKmsContext",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "tuple",
        "internalType": "struct KmsContext",
        "components": [
          {
            "name": "contextId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "previousContextId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "softwareVersion",
            "type": "bytes8",
            "internalType": "bytes8"
          },
          {
            "name": "mpcThreshold",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "kmsNodes",
            "type": "tuple[]",
            "internalType": "struct KmsNode[]",
            "components": [
              {
                "name": "name",
                "type": "string",
                "internalType": "string"
              },
              {
                "name": "signerAddress",
                "type": "address",
                "internalType": "address"
              },
              {
                "name": "txSenderAddress",
                "type": "address",
                "internalType": "address"
              },
              {
                "name": "partyId",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "backupEncryptionKey",
                "type": "bytes",
                "internalType": "bytes"
              },
              {
                "name": "externalUrl",
                "type": "string",
                "internalType": "string"
              },
              {
                "name": "publicStorageUrl",
                "type": "string",
                "internalType": "string"
              },
              {
                "name": "tlsCertificate",
                "type": "bytes",
                "internalType": "bytes"
              }
            ]
          }
        ]
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getActiveKmsContextId",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getKmsContextGenerationBlockPeriod",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getKmsContextStatus",
    "inputs": [
      {
        "name": "contextId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint8",
        "internalType": "enum ContextStatus"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getKmsContextSuspensionBlockPeriod",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getKmsNode",
    "inputs": [
      {
        "name": "kmsTxSenderAddress",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "tuple",
        "internalType": "struct KmsNode",
        "components": [
          {
            "name": "name",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "signerAddress",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "txSenderAddress",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "partyId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "backupEncryptionKey",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "externalUrl",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "publicStorageUrl",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "tlsCertificate",
            "type": "bytes",
            "internalType": "bytes"
          }
        ]
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getKmsSigners",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address[]",
        "internalType": "address[]"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getKmsTxSenders",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address[]",
        "internalType": "address[]"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getPublicDecryptionThresholdFromContext",
    "inputs": [
      {
        "name": "contextId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getSuspendedKmsContextId",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getUserDecryptionThresholdFromContext",
    "inputs": [
      {
        "name": "contextId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getVersion",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "initializeFromEmptyProxy",
    "inputs": [
      {
        "name": "initialSoftwareVersion",
        "type": "bytes8",
        "internalType": "bytes8"
      },
      {
        "name": "initialMpcThreshold",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "initialKmsNodes",
        "type": "tuple[]",
        "internalType": "struct KmsNode[]",
        "components": [
          {
            "name": "name",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "signerAddress",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "txSenderAddress",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "partyId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "backupEncryptionKey",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "externalUrl",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "publicStorageUrl",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "tlsCertificate",
            "type": "bytes",
            "internalType": "bytes"
          }
        ]
      },
      {
        "name": "initialDecryptionThresholds",
        "type": "tuple",
        "internalType": "struct DecryptionThresholds",
        "components": [
          {
            "name": "publicDecryptionThreshold",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "userDecryptionThreshold",
            "type": "uint256",
            "internalType": "uint256"
          }
        ]
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "moveSuspendedKmsContextToActive",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "owner",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "pause",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "paused",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "pendingOwner",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "proxiableUUID",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "refreshKmsContextStatuses",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "renounceOwnership",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "transferOwnership",
    "inputs": [
      {
        "name": "newOwner",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "unpause",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "updatePublicDecryptionThreshold",
    "inputs": [
      {
        "name": "newPublicDecryptionThreshold",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "updateUserDecryptionThreshold",
    "inputs": [
      {
        "name": "newUserDecryptionThreshold",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "upgradeToAndCall",
    "inputs": [
      {
        "name": "newImplementation",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "data",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [],
    "stateMutability": "payable"
  },
  {
    "type": "function",
    "name": "validateKeyResharing",
    "inputs": [
      {
        "name": "contextId",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "signature",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "event",
    "name": "ActivateKmsContext",
    "inputs": [
      {
        "name": "contextId",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "CompromiseKmsContext",
    "inputs": [
      {
        "name": "contextId",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "DeactivateKmsContext",
    "inputs": [
      {
        "name": "contextId",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "DestroyKmsContext",
    "inputs": [
      {
        "name": "contextId",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "EIP712DomainChanged",
    "inputs": [],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "InitializeKmsContexts",
    "inputs": [
      {
        "name": "decryptionThresholds",
        "type": "tuple",
        "indexed": false,
        "internalType": "struct DecryptionThresholds",
        "components": [
          {
            "name": "publicDecryptionThreshold",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "userDecryptionThreshold",
            "type": "uint256",
            "internalType": "uint256"
          }
        ]
      },
      {
        "name": "softwareVersion",
        "type": "bytes8",
        "indexed": false,
        "internalType": "bytes8"
      },
      {
        "name": "mpcThreshold",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "kmsNodes",
        "type": "tuple[]",
        "indexed": false,
        "internalType": "struct KmsNode[]",
        "components": [
          {
            "name": "name",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "signerAddress",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "txSenderAddress",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "partyId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "backupEncryptionKey",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "externalUrl",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "publicStorageUrl",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "tlsCertificate",
            "type": "bytes",
            "internalType": "bytes"
          }
        ]
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Initialized",
    "inputs": [
      {
        "name": "version",
        "type": "uint64",
        "indexed": false,
        "internalType": "uint64"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "InvalidateKeyResharing",
    "inputs": [
      {
        "name": "contextId",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "NewKmsContext",
    "inputs": [
      {
        "name": "activeKmsContext",
        "type": "tuple",
        "indexed": false,
        "internalType": "struct KmsContext",
        "components": [
          {
            "name": "contextId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "previousContextId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "softwareVersion",
            "type": "bytes8",
            "internalType": "bytes8"
          },
          {
            "name": "mpcThreshold",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "kmsNodes",
            "type": "tuple[]",
            "internalType": "struct KmsNode[]",
            "components": [
              {
                "name": "name",
                "type": "string",
                "internalType": "string"
              },
              {
                "name": "signerAddress",
                "type": "address",
                "internalType": "address"
              },
              {
                "name": "txSenderAddress",
                "type": "address",
                "internalType": "address"
              },
              {
                "name": "partyId",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "backupEncryptionKey",
                "type": "bytes",
                "internalType": "bytes"
              },
              {
                "name": "externalUrl",
                "type": "string",
                "internalType": "string"
              },
              {
                "name": "publicStorageUrl",
                "type": "string",
                "internalType": "string"
              },
              {
                "name": "tlsCertificate",
                "type": "bytes",
                "internalType": "bytes"
              }
            ]
          }
        ]
      },
      {
        "name": "newKmsContext",
        "type": "tuple",
        "indexed": false,
        "internalType": "struct KmsContext",
        "components": [
          {
            "name": "contextId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "previousContextId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "softwareVersion",
            "type": "bytes8",
            "internalType": "bytes8"
          },
          {
            "name": "mpcThreshold",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "kmsNodes",
            "type": "tuple[]",
            "internalType": "struct KmsNode[]",
            "components": [
              {
                "name": "name",
                "type": "string",
                "internalType": "string"
              },
              {
                "name": "signerAddress",
                "type": "address",
                "internalType": "address"
              },
              {
                "name": "txSenderAddress",
                "type": "address",
                "internalType": "address"
              },
              {
                "name": "partyId",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "backupEncryptionKey",
                "type": "bytes",
                "internalType": "bytes"
              },
              {
                "name": "externalUrl",
                "type": "string",
                "internalType": "string"
              },
              {
                "name": "publicStorageUrl",
                "type": "string",
                "internalType": "string"
              },
              {
                "name": "tlsCertificate",
                "type": "bytes",
                "internalType": "bytes"
              }
            ]
          }
        ]
      },
      {
        "name": "blockPeriods",
        "type": "tuple",
        "indexed": false,
        "internalType": "struct KmsBlockPeriods",
        "components": [
          {
            "name": "preActivationBlockPeriod",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "generationBlockPeriod",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "suspendedBlockPeriod",
            "type": "uint256",
            "internalType": "uint256"
          }
        ]
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "OwnershipTransferStarted",
    "inputs": [
      {
        "name": "previousOwner",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "newOwner",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "OwnershipTransferred",
    "inputs": [
      {
        "name": "previousOwner",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "newOwner",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Paused",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "PreActivateKmsContext",
    "inputs": [
      {
        "name": "newKmsContext",
        "type": "tuple",
        "indexed": false,
        "internalType": "struct KmsContext",
        "components": [
          {
            "name": "contextId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "previousContextId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "softwareVersion",
            "type": "bytes8",
            "internalType": "bytes8"
          },
          {
            "name": "mpcThreshold",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "kmsNodes",
            "type": "tuple[]",
            "internalType": "struct KmsNode[]",
            "components": [
              {
                "name": "name",
                "type": "string",
                "internalType": "string"
              },
              {
                "name": "signerAddress",
                "type": "address",
                "internalType": "address"
              },
              {
                "name": "txSenderAddress",
                "type": "address",
                "internalType": "address"
              },
              {
                "name": "partyId",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "backupEncryptionKey",
                "type": "bytes",
                "internalType": "bytes"
              },
              {
                "name": "externalUrl",
                "type": "string",
                "internalType": "string"
              },
              {
                "name": "publicStorageUrl",
                "type": "string",
                "internalType": "string"
              },
              {
                "name": "tlsCertificate",
                "type": "bytes",
                "internalType": "bytes"
              }
            ]
          }
        ]
      },
      {
        "name": "preActivationBlockNumber",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "StartKeyResharing",
    "inputs": [
      {
        "name": "activeKmsContext",
        "type": "tuple",
        "indexed": false,
        "internalType": "struct KmsContext",
        "components": [
          {
            "name": "contextId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "previousContextId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "softwareVersion",
            "type": "bytes8",
            "internalType": "bytes8"
          },
          {
            "name": "mpcThreshold",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "kmsNodes",
            "type": "tuple[]",
            "internalType": "struct KmsNode[]",
            "components": [
              {
                "name": "name",
                "type": "string",
                "internalType": "string"
              },
              {
                "name": "signerAddress",
                "type": "address",
                "internalType": "address"
              },
              {
                "name": "txSenderAddress",
                "type": "address",
                "internalType": "address"
              },
              {
                "name": "partyId",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "backupEncryptionKey",
                "type": "bytes",
                "internalType": "bytes"
              },
              {
                "name": "externalUrl",
                "type": "string",
                "internalType": "string"
              },
              {
                "name": "publicStorageUrl",
                "type": "string",
                "internalType": "string"
              },
              {
                "name": "tlsCertificate",
                "type": "bytes",
                "internalType": "bytes"
              }
            ]
          }
        ]
      },
      {
        "name": "newKmsContext",
        "type": "tuple",
        "indexed": false,
        "internalType": "struct KmsContext",
        "components": [
          {
            "name": "contextId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "previousContextId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "softwareVersion",
            "type": "bytes8",
            "internalType": "bytes8"
          },
          {
            "name": "mpcThreshold",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "kmsNodes",
            "type": "tuple[]",
            "internalType": "struct KmsNode[]",
            "components": [
              {
                "name": "name",
                "type": "string",
                "internalType": "string"
              },
              {
                "name": "signerAddress",
                "type": "address",
                "internalType": "address"
              },
              {
                "name": "txSenderAddress",
                "type": "address",
                "internalType": "address"
              },
              {
                "name": "partyId",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "backupEncryptionKey",
                "type": "bytes",
                "internalType": "bytes"
              },
              {
                "name": "externalUrl",
                "type": "string",
                "internalType": "string"
              },
              {
                "name": "publicStorageUrl",
                "type": "string",
                "internalType": "string"
              },
              {
                "name": "tlsCertificate",
                "type": "bytes",
                "internalType": "bytes"
              }
            ]
          }
        ]
      },
      {
        "name": "generationBlockNumber",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "SuspendKmsContext",
    "inputs": [
      {
        "name": "contextId",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Unpaused",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "UpdatePublicDecryptionThreshold",
    "inputs": [
      {
        "name": "newPublicDecryptionThreshold",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "UpdateUserDecryptionThreshold",
    "inputs": [
      {
        "name": "newUserDecryptionThreshold",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Upgraded",
    "inputs": [
      {
        "name": "implementation",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "ValidateKeyResharing",
    "inputs": [
      {
        "name": "newKmsContext",
        "type": "tuple",
        "indexed": false,
        "internalType": "struct KmsContext",
        "components": [
          {
            "name": "contextId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "previousContextId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "softwareVersion",
            "type": "bytes8",
            "internalType": "bytes8"
          },
          {
            "name": "mpcThreshold",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "kmsNodes",
            "type": "tuple[]",
            "internalType": "struct KmsNode[]",
            "components": [
              {
                "name": "name",
                "type": "string",
                "internalType": "string"
              },
              {
                "name": "signerAddress",
                "type": "address",
                "internalType": "address"
              },
              {
                "name": "txSenderAddress",
                "type": "address",
                "internalType": "address"
              },
              {
                "name": "partyId",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "backupEncryptionKey",
                "type": "bytes",
                "internalType": "bytes"
              },
              {
                "name": "externalUrl",
                "type": "string",
                "internalType": "string"
              },
              {
                "name": "publicStorageUrl",
                "type": "string",
                "internalType": "string"
              },
              {
                "name": "tlsCertificate",
                "type": "bytes",
                "internalType": "bytes"
              }
            ]
          }
        ]
      }
    ],
    "anonymous": false
  },
  {
    "type": "error",
    "name": "AddressEmptyCode",
    "inputs": [
      {
        "name": "target",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "CompromiseActiveKmsContextNotAllowed",
    "inputs": [
      {
        "name": "contextId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "ContextAlreadyExists",
    "inputs": [
      {
        "name": "contextId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "ContextNotActive",
    "inputs": [
      {
        "name": "contextId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "ContextNotActiveOrSuspended",
    "inputs": [
      {
        "name": "contextId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "ContextNotGenerated",
    "inputs": [
      {
        "name": "contextId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "ContextNotInitializedOrIsGenerating",
    "inputs": [
      {
        "name": "contextId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "ContextNotPreActivatedOrSuspended",
    "inputs": [
      {
        "name": "contextId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "DestroyActiveKmsContextNotAllowed",
    "inputs": [
      {
        "name": "contextId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "ECDSAInvalidSignature",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ECDSAInvalidSignatureLength",
    "inputs": [
      {
        "name": "length",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "ECDSAInvalidSignatureS",
    "inputs": [
      {
        "name": "s",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ]
  },
  {
    "type": "error",
    "name": "ERC1967InvalidImplementation",
    "inputs": [
      {
        "name": "implementation",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "ERC1967NonPayable",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EmptyKmsNodes",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EnforcedPause",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ExpectedPause",
    "inputs": []
  },
  {
    "type": "error",
    "name": "FailedCall",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidHighMpcThreshold",
    "inputs": [
      {
        "name": "contextId",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "mpcThreshold",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "nKmsNodes",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "InvalidHighPublicDecryptionThreshold",
    "inputs": [
      {
        "name": "publicDecryptionThreshold",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "nKmsNodes",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "InvalidHighUserDecryptionThreshold",
    "inputs": [
      {
        "name": "userDecryptionThreshold",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "nKmsNodes",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "InvalidInitialization",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidNullContextId",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidNullPublicDecryptionThreshold",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidNullUserDecryptionThreshold",
    "inputs": []
  },
  {
    "type": "error",
    "name": "KmsContextNotGenerating",
    "inputs": [
      {
        "name": "contextId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "KmsContextNotInitialized",
    "inputs": [
      {
        "name": "contextId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "KmsNodeAlreadyValidatedKeyResharing",
    "inputs": [
      {
        "name": "contextId",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "kmsSigner",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "NoSuspendedKmsContext",
    "inputs": []
  },
  {
    "type": "error",
    "name": "NotInitializing",
    "inputs": []
  },
  {
    "type": "error",
    "name": "NotInitializingFromEmptyProxy",
    "inputs": []
  },
  {
    "type": "error",
    "name": "NotKmsNodeFromContext",
    "inputs": [
      {
        "name": "contextId",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "kmsTxSenderAddress",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "NotKmsSignerFromContext",
    "inputs": [
      {
        "name": "contextId",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "signerAddress",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "NotKmsTxSenderFromContext",
    "inputs": [
      {
        "name": "contextId",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "txSenderAddress",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "NotOwnerOrPauser",
    "inputs": [
      {
        "name": "notOwnerOrPauser",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "NumberOfKmsNodesChanged",
    "inputs": [
      {
        "name": "activeKmsNodesLength",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "newKmsNodesLength",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "OwnableInvalidOwner",
    "inputs": [
      {
        "name": "owner",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "OwnableUnauthorizedAccount",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "SuspendedKmsContextOngoing",
    "inputs": [
      {
        "name": "suspendedContextId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "UUPSUnauthorizedCallContext",
    "inputs": []
  },
  {
    "type": "error",
    "name": "UUPSUnsupportedProxiableUUID",
    "inputs": [
      {
        "name": "slot",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ]
  }
]
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod KmsContexts {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x60a06040523073ffffffffffffffffffffffffffffffffffffffff1660809073ffffffffffffffffffffffffffffffffffffffff1681525034801562000043575f80fd5b50620000546200005a60201b60201c565b620001c4565b5f6200006b6200015e60201b60201c565b9050805f0160089054906101000a900460ff1615620000b6576040517ff92ee8a900000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b67ffffffffffffffff8016815f015f9054906101000a900467ffffffffffffffff1667ffffffffffffffff16146200015b5767ffffffffffffffff815f015f6101000a81548167ffffffffffffffff021916908367ffffffffffffffff1602179055507fc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d267ffffffffffffffff604051620001529190620001a9565b60405180910390a15b50565b5f7ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00905090565b5f67ffffffffffffffff82169050919050565b620001a38162000185565b82525050565b5f602082019050620001be5f83018462000198565b92915050565b608051617498620001eb5f395f81816130d20152818161312701526132e101526174985ff3fe608060405260043610610203575f3560e01c806383b420c411610117578063d8e3ae011161009f578063e3b2a8741161006e578063e3b2a874146106af578063e7b1ec39146106eb578063eb843cf614610713578063f27cb9571461073b578063f2fde38b1461075157610203565b8063d8e3ae011461060b578063defba06a14610635578063dfe36aee1461065d578063e30c39781461068557610203565b80638da5cb5b116100e65780638da5cb5b1461052b5780639ee77af314610555578063ad3cb1cc1461057d578063b8715d4d146105a7578063c0ae64f7146105e357610203565b806383b420c4146104a75780638456cb59146104cf57806384b0196e146104e55780638cb967511461051557610203565b80634d6942601161019a57806364b00cc51161016957806364b00cc5146103eb578063715018a6146104275780637420f3d41461043d57806379ba5097146104675780637eaac8f21461047d57610203565b80634d6942601461033f5780634f1ef2861461037b57806352d1902d146103975780635c975abb146103c157610203565b80632e2d3a82116101d65780632e2d3a82146102ad5780633f4ba83a146102d557806343e37e8a146102eb5780634965e4551461031557610203565b80630a50e318146102075780630d8e6e2c146102315780630dd486c01461025b5780631079ebeb14610285575b5f80fd5b348015610212575f80fd5b5061021b610779565b60405161022891906154cc565b60405180910390f35b34801561023c575f80fd5b50610245610792565b604051610252919061556f565b60405180910390f35b348015610266575f80fd5b5061026f61080d565b60405161027c91906158a8565b60405180910390f35b348015610290575f80fd5b506102ab60048036038101906102a69190615964565b610c99565b005b3480156102b8575f80fd5b506102d360048036038101906102ce91906159c1565b611256565b005b3480156102e0575f80fd5b506102e96112bf565b005b3480156102f6575f80fd5b506102ff6112d1565b60405161030c91906154cc565b60405180910390f35b348015610320575f80fd5b506103296112ea565b60405161033691906154cc565b60405180910390f35b34801561034a575f80fd5b50610365600480360381019061036091906159c1565b611301565b6040516103729190615a5f565b60405180910390f35b61039560048036038101906103909190615bca565b611321565b005b3480156103a2575f80fd5b506103ab611340565b6040516103b89190615c3c565b60405180910390f35b3480156103cc575f80fd5b506103d5611371565b6040516103e29190615c6f565b60405180910390f35b3480156103f6575f80fd5b50610411600480360381019061040c91906159c1565b611393565b60405161041e91906154cc565b60405180910390f35b348015610432575f80fd5b5061043b611422565b005b348015610448575f80fd5b50610451611435565b60405161045e9190615d30565b60405180910390f35b348015610472575f80fd5b5061047b6114e9565b005b348015610488575f80fd5b50610491611577565b60405161049e9190615d30565b60405180910390f35b3480156104b2575f80fd5b506104cd60048036038101906104c89190615df1565b61162b565b005b3480156104da575f80fd5b506104e3611898565b005b3480156104f0575f80fd5b506104f96119d3565b60405161050c9796959493929190615f66565b60405180910390f35b348015610520575f80fd5b50610529611adc565b005b348015610536575f80fd5b5061053f611d13565b60405161054c9190615fe8565b60405180910390f35b348015610560575f80fd5b5061057b600480360381019061057691906159c1565b611d48565b005b348015610588575f80fd5b50610591611e57565b60405161059e919061556f565b60405180910390f35b3480156105b2575f80fd5b506105cd60048036038101906105c891906159c1565b611e90565b6040516105da91906154cc565b60405180910390f35b3480156105ee575f80fd5b50610609600480360381019061060491906159c1565b611f1f565b005b348015610616575f80fd5b5061061f61202e565b60405161062c91906154cc565b60405180910390f35b348015610640575f80fd5b5061065b60048036038101906106569190616001565b612045565b005b348015610668575f80fd5b50610683600480360381019061067e9190616001565b61215a565b005b348015610690575f80fd5b5061069961226f565b6040516106a69190615fe8565b60405180910390f35b3480156106ba575f80fd5b506106d560048036038101906106d0919061603f565b6122a4565b6040516106e29190616133565b60405180910390f35b3480156106f6575f80fd5b50610711600480360381019061070c919061619b565b612723565b005b34801561071e575f80fd5b50610739600480360381019061073491906159c1565b612913565b005b348015610746575f80fd5b5061074f61297c565b005b34801561075c575f80fd5b506107776004803603810190610772919061603f565b612a69565b005b5f80610783612b22565b9050805f016004015491505090565b60606040518060400160405280600b81526020017f4b6d73436f6e74657874730000000000000000000000000000000000000000008152506107d35f612b49565b6107dd6001612b49565b6107e65f612b49565b6040516020016107f99493929190616314565b604051602081830303815290604052905090565b610815615400565b5f61081e612b22565b90505f6108296112d1565b9050816007015f8281526020019081526020015f206040518060a00160405290815f820154815260200160018201548152602001600282015f9054906101000a900460c01b77ffffffffffffffffffffffffffffffffffffffffffffffff191677ffffffffffffffffffffffffffffffffffffffffffffffff191681526020016003820154815260200160048201805480602002602001604051908101604052809291908181526020015f905b82821015610c8a578382905f5260205f209060080201604051806101000160405290815f820180546109079061639f565b80601f01602080910402602001604051908101604052809291908181526020018280546109339061639f565b801561097e5780601f106109555761010080835404028352916020019161097e565b820191905f5260205f20905b81548152906001019060200180831161096157829003601f168201915b50505050508152602001600182015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001600282015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200160038201548152602001600482018054610a4b9061639f565b80601f0160208091040260200160405190810160405280929190818152602001828054610a779061639f565b8015610ac25780601f10610a9957610100808354040283529160200191610ac2565b820191905f5260205f20905b815481529060010190602001808311610aa557829003601f168201915b50505050508152602001600582018054610adb9061639f565b80601f0160208091040260200160405190810160405280929190818152602001828054610b079061639f565b8015610b525780601f10610b2957610100808354040283529160200191610b52565b820191905f5260205f20905b815481529060010190602001808311610b3557829003601f168201915b50505050508152602001600682018054610b6b9061639f565b80601f0160208091040260200160405190810160405280929190818152602001828054610b979061639f565b8015610be25780601f10610bb957610100808354040283529160200191610be2565b820191905f5260205f20905b815481529060010190602001808311610bc557829003601f168201915b50505050508152602001600782018054610bfb9061639f565b80601f0160208091040260200160405190810160405280929190818152602001828054610c279061639f565b8015610c725780601f10610c4957610100808354040283529160200191610c72565b820191905f5260205f20905b815481529060010190602001808311610c5557829003601f168201915b505050505081525050815260200190600101906108d6565b50505050815250509250505090565b610ca38333612045565b5f610cac612b22565b9050610cba815f0185612c13565b610cfb57836040517f5e51a2e1000000000000000000000000000000000000000000000000000000008152600401610cf291906154cc565b60405180910390fd5b5f60405180602001604052808681525090505f610d1782612c62565b9050610d2586828787612cbd565b5f83600a015f8881526020019081526020015f20905080868690918060018154018082558091505060019003905f5260205f20015f909192909192909192909192509182610d74929190616576565b505f846007015f8981526020019081526020015f206040518060a00160405290815f820154815260200160018201548152602001600282015f9054906101000a900460c01b77ffffffffffffffffffffffffffffffffffffffffffffffff191677ffffffffffffffffffffffffffffffffffffffffffffffff191681526020016003820154815260200160048201805480602002602001604051908101604052809291908181526020015f905b828210156111d5578382905f5260205f209060080201604051806101000160405290815f82018054610e529061639f565b80601f0160208091040260200160405190810160405280929190818152602001828054610e7e9061639f565b8015610ec95780601f10610ea057610100808354040283529160200191610ec9565b820191905f5260205f20905b815481529060010190602001808311610eac57829003601f168201915b50505050508152602001600182015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001600282015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200160038201548152602001600482018054610f969061639f565b80601f0160208091040260200160405190810160405280929190818152602001828054610fc29061639f565b801561100d5780601f10610fe45761010080835404028352916020019161100d565b820191905f5260205f20905b815481529060010190602001808311610ff057829003601f168201915b505050505081526020016005820180546110269061639f565b80601f01602080910402602001604051908101604052809291908181526020018280546110529061639f565b801561109d5780601f106110745761010080835404028352916020019161109d565b820191905f5260205f20905b81548152906001019060200180831161108057829003601f168201915b505050505081526020016006820180546110b69061639f565b80601f01602080910402602001604051908101604052809291908181526020018280546110e29061639f565b801561112d5780601f106111045761010080835404028352916020019161112d565b820191905f5260205f20905b81548152906001019060200180831161111057829003601f168201915b505050505081526020016007820180546111469061639f565b80601f01602080910402602001604051908101604052809291908181526020018280546111729061639f565b80156111bd5780601f10611194576101008083540402835291602001916111bd565b820191905f5260205f20905b8154815290600101906020018083116111a057829003601f168201915b50505050508152505081526020019060010190610e21565b505050508152505090506111ed818380549050612e2f565b1561124c575f856013015f8a81526020019081526020015f205490506112138282612e46565b7f68898a98936bf23a56e8ed4b23dcc98cef926bd9ac2ce522f1f9423e3864f2f58260405161124291906158a8565b60405180910390a1505b5050505050505050565b61125e612ec9565b611266612f50565b5f61126f61080d565b9050611284815f015183836080015151612f91565b7fe41802af725729adcb8c151e2937380a25c69155757e3af5d3979adab5035800826040516112b391906154cc565b60405180910390a15050565b6112c7612ec9565b6112cf61303a565b565b5f806112db612b22565b9050805f016003015491505090565b5f806112f4612b22565b9050806005015491505090565b5f8061130b612b22565b9050611319815f01846130a8565b915050919050565b6113296130d0565b611332826131b6565b61133c82826131c1565b5050565b5f6113496132df565b7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5f1b905090565b5f8061137b613366565b9050805f015f9054906101000a900460ff1691505090565b5f815f61139e612b22565b90505f816007015f8481526020019081526020015f205f0154036113f957816040517f82b1fbda0000000000000000000000000000000000000000000000000000000081526004016113f091906154cc565b60405180910390fd5b5f611402612b22565b9050806016015f8681526020019081526020015f20549350505050919050565b61142a612ec9565b6114335f61338d565b565b60605f6114406112d1565b90505f61144b612b22565b905080600e015f8381526020019081526020015f208054806020026020016040519081016040528092919081815260200182805480156114dd57602002820191905f5260205f20905b815f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019060010190808311611494575b50505050509250505090565b5f6114f26133ca565b90508073ffffffffffffffffffffffffffffffffffffffff1661151361226f565b73ffffffffffffffffffffffffffffffffffffffff161461156b57806040517f118cdaa70000000000000000000000000000000000000000000000000000000081526004016115629190615fe8565b60405180910390fd5b6115748161338d565b50565b60605f6115826112d1565b90505f61158d612b22565b905080600f015f8381526020019081526020015f2080548060200260200160405190810160405280929190818152602001828054801561161f57602002820191905f5260205f20905b815f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190600101908083116115d6575b50505050509250505090565b60016116356133d1565b67ffffffffffffffff1614611676576040517f6f4f731f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60025f6116816133f5565b9050805f0160089054906101000a900460ff16806116c957508167ffffffffffffffff16815f015f9054906101000a900467ffffffffffffffff1667ffffffffffffffff1610155b15611700576040517ff92ee8a900000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b81815f015f6101000a81548167ffffffffffffffff021916908367ffffffffffffffff1602179055506001815f0160086101000a81548160ff0219169083151502179055506117b96040518060400160405280600b81526020017f4b6d73436f6e74657874730000000000000000000000000000000000000000008152506040518060400160405280600181526020017f310000000000000000000000000000000000000000000000000000000000000081525061341c565b6117c96117c4611d13565b613432565b6117d1613446565b5f6117e05f8989898989613458565b90505f6117eb612b22565b90506117fc815f01835f0151613da6565b7f5448756ee13f8e5e9a81f574ac68c8814a16612bee06fea0fd80c61610436dcd858a8a8a8a6040516118339594939291906169c8565b60405180910390a150505f815f0160086101000a81548160ff0219169083151502179055507fc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d2826040516118879190616a36565b60405180910390a150505050505050565b6118a0611d13565b73ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614158015611987575073c7d45661a345ec5ca0e8521cfef7e32fda0daa6873ffffffffffffffffffffffffffffffffffffffff16637008b5486040518163ffffffff1660e01b8152600401602060405180830381865afa158015611933573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906119579190616a63565b73ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614155b156119c957336040517f46c0d9af0000000000000000000000000000000000000000000000000000000081526004016119c09190615fe8565b60405180910390fd5b6119d1613ea1565b565b5f6060805f805f60605f6119e5613f10565b90505f801b815f0154148015611a0057505f801b8160010154145b611a3f576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611a3690616ad8565b60405180910390fd5b611a47613f37565b611a4f613fd5565b46305f801b5f67ffffffffffffffff811115611a6e57611a6d615aa6565b5b604051908082528060200260200182016040528015611a9c5781602001602082028036833780820191505090505b507f0f0000000000000000000000000000000000000000000000000000000000000095949392919097509750975097509750975097505090919293949596565b611ae4612f50565b5f611aed612b22565b90505f815f016001015490505f8114158015611b1c5750816010015f8281526020019081526020015f20544310155b15611b9b577e9fe8f0db45996decf7b06fc7b6ec5f887d5f04db2e0c4ad7f4e4ee5eefc5a381604051611b4f91906154cc565b60405180910390a1611b63825f0182614073565b7f3e8f02dc7af6e3a67f3af0bc99bcf11b4deb46105e9ba7f1ac6da82322e9025e81604051611b9291906154cc565b60405180910390a15b5f825f016002015490505f8114158015611bc85750826011015f8281526020019081526020015f20544310155b15611c9b575f611bd66112d1565b90505f846014015f8381526020019081526020015f205443611bf89190616b23565b905080856012015f8481526020019081526020015f2081905550611c1e855f0183614140565b7f851a08c16b15959c338ac4b56466d06c9f9d5ff8d715168aa125d5ccaf53832082604051611c4d91906154cc565b60405180910390a1611c61855f0184613da6565b7f4f54a6ac981cc8dc83142b3eb4d120be7c70fc5de6477a14eae3e9ca647644bc83604051611c9091906154cc565b60405180910390a150505b5f611ca4610779565b90505f8114611d0d57836012015f8281526020019081526020015f2054431115611d0c57611cd4845f0182614216565b7f8fb75858a565aee117342d93196a7f0b54c1c8519885eddda6a01f477359b36381604051611d0391906154cc565b60405180910390a15b5b50505050565b5f80611d1d614318565b9050805f015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1691505090565b611d50612ec9565b805f611d5a612b22565b90505f816007015f8481526020019081526020015f205f015403611db557816040517f82b1fbda000000000000000000000000000000000000000000000000000000008152600401611dac91906154cc565b60405180910390fd5b5f611dbe612b22565b9050611dcc815f018561433f565b15611e0e57836040517f77d05ea7000000000000000000000000000000000000000000000000000000008152600401611e0591906154cc565b60405180910390fd5b611e1a815f018561438e565b7fbc1114fa9a77648cd097ee6cf149c344fa278b9b983f30dd65b6fd6a9d464a0784604051611e4991906154cc565b60405180910390a150505050565b6040518060400160405280600581526020017f352e302e3000000000000000000000000000000000000000000000000000000081525081565b5f815f611e9b612b22565b90505f816007015f8481526020019081526020015f205f015403611ef657816040517f82b1fbda000000000000000000000000000000000000000000000000000000008152600401611eed91906154cc565b60405180910390fd5b5f611eff612b22565b9050806015015f8681526020019081526020015f20549350505050919050565b611f27612ec9565b805f611f31612b22565b90505f816007015f8481526020019081526020015f205f015403611f8c57816040517f82b1fbda000000000000000000000000000000000000000000000000000000008152600401611f8391906154cc565b60405180910390fd5b5f611f95612b22565b9050611fa3815f018561433f565b15611fe557836040517fb25e4eb3000000000000000000000000000000000000000000000000000000008152600401611fdc91906154cc565b60405180910390fd5b611ff1815f0185614073565b7f3e8f02dc7af6e3a67f3af0bc99bcf11b4deb46105e9ba7f1ac6da82322e9025e8460405161202091906154cc565b60405180910390a150505050565b5f80612038612b22565b9050806006015491505090565b815f61204f612b22565b90505f816007015f8481526020019081526020015f205f0154036120aa57816040517f82b1fbda0000000000000000000000000000000000000000000000000000000081526004016120a191906154cc565b60405180910390fd5b5f6120b3612b22565b905080600c015f8681526020019081526020015f205f8573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f9054906101000a900460ff166121535784846040517ffdf8a05d00000000000000000000000000000000000000000000000000000000815260040161214a929190616b56565b60405180910390fd5b5050505050565b815f612164612b22565b90505f816007015f8481526020019081526020015f205f0154036121bf57816040517f82b1fbda0000000000000000000000000000000000000000000000000000000081526004016121b691906154cc565b60405180910390fd5b5f6121c8612b22565b905080600d015f8681526020019081526020015f205f8573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f9054906101000a900460ff166122685784846040517f89b45e5d00000000000000000000000000000000000000000000000000000000815260040161225f929190616b56565b60405180910390fd5b5050505050565b5f806122796144a3565b9050805f015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1691505090565b6122ac615446565b5f6122b56112d1565b90505f6122c0612b22565b90505f81600b015f8481526020019081526020015f205f8673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f20604051806101000160405290815f8201805461232c9061639f565b80601f01602080910402602001604051908101604052809291908181526020018280546123589061639f565b80156123a35780601f1061237a576101008083540402835291602001916123a3565b820191905f5260205f20905b81548152906001019060200180831161238657829003601f168201915b50505050508152602001600182015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001600282015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001600382015481526020016004820180546124709061639f565b80601f016020809104026020016040519081016040528092919081815260200182805461249c9061639f565b80156124e75780601f106124be576101008083540402835291602001916124e7565b820191905f5260205f20905b8154815290600101906020018083116124ca57829003601f168201915b505050505081526020016005820180546125009061639f565b80601f016020809104026020016040519081016040528092919081815260200182805461252c9061639f565b80156125775780601f1061254e57610100808354040283529160200191612577565b820191905f5260205f20905b81548152906001019060200180831161255a57829003601f168201915b505050505081526020016006820180546125909061639f565b80601f01602080910402602001604051908101604052809291908181526020018280546125bc9061639f565b80156126075780601f106125de57610100808354040283529160200191612607565b820191905f5260205f20905b8154815290600101906020018083116125ea57829003601f168201915b505050505081526020016007820180546126209061639f565b80601f016020809104026020016040519081016040528092919081815260200182805461264c9061639f565b80156126975780601f1061266e57610100808354040283529160200191612697565b820191905f5260205f20905b81548152906001019060200180831161267a57829003601f168201915b50505050508152505090505f73ffffffffffffffffffffffffffffffffffffffff16816040015173ffffffffffffffffffffffffffffffffffffffff16036127185782856040517f0494d3c000000000000000000000000000000000000000000000000000000000815260040161270f929190616b56565b60405180910390fd5b809350505050919050565b61272b612ec9565b5f612734612b22565b90505f61273f61080d565b90505f81608001515190505f8787905090508181146127975781816040517fd595a96200000000000000000000000000000000000000000000000000000000815260040161278e929190616b7d565b60405180910390fd5b5f6127a0610779565b90505f81146127e657806040517f7623d3570000000000000000000000000000000000000000000000000000000081526004016127dd91906154cc565b60405180910390fd5b5f6127f8855f01518e8d8d8d8c613458565b90508760400135866014015f875f015181526020019081526020015f20819055507fa69a4c9341cd7d458fde12c31a1f582f7d4caedb27c4a7c34cc992208a3ce4c585828a60405161284c93929190616bfc565b60405180910390a1612863865f01825f01516144ca565b8b156128f657875f0135866013015f835f015181526020019081526020015f20819055505f8860200135436128989190616b23565b905080876010015f845f015181526020019081526020015f20819055507f5dc601065a035d78305cd9ef27c91a009cd8d37297e43bb76319490895a0d0588683836040516128e893929190616c3f565b60405180910390a150612904565b61290381895f0135612e46565b5b50505050505050505050505050565b61291b612ec9565b612923612f50565b5f61292c61080d565b9050612941815f015183836080015151614597565b7f837e0a6528dadfa2dc792692c5182e52a9f5bbdeed7b2372927a26c6958396138260405161297091906154cc565b60405180910390a15050565b612984612ec9565b5f61298d612b22565b90505f612998610779565b90505f81036129d3576040517f207ea3f300000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f6129dc6112d1565b90506129ea835f0182614216565b7f8fb75858a565aee117342d93196a7f0b54c1c8519885eddda6a01f477359b36381604051612a1991906154cc565b60405180910390a1612a2d835f0183613da6565b7f4f54a6ac981cc8dc83142b3eb4d120be7c70fc5de6477a14eae3e9ca647644bc82604051612a5c91906154cc565b60405180910390a1505050565b612a71612ec9565b5f612a7a6144a3565b905081815f015f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508173ffffffffffffffffffffffffffffffffffffffff16612adc611d13565b73ffffffffffffffffffffffffffffffffffffffff167f38d16b8cac22d99fc7c124b9cd0de2d3fa1faef420bfe791d8c362d765e2270060405160405180910390a35050565b5f7f7d8159810a7ebf944e8fa93cc4fbd1cade6c71f8b0b86b37187ac7991777b100905090565b60605f6001612b5784614640565b0190505f8167ffffffffffffffff811115612b7557612b74615aa6565b5b6040519080825280601f01601f191660200182016040528015612ba75781602001600182028036833780820191505090505b5090505f82602001820190505b600115612c08578080600190039150507f3031323334353637383961626364656600000000000000000000000000000000600a86061a8153600a8581612bfd57612bfc616c82565b5b0494505f8503612bb4575b819350505050919050565b5f60016007811115612c2857612c276159ec565b5b835f015f8481526020019081526020015f205f9054906101000a900460ff166007811115612c5957612c586159ec565b5b14905092915050565b5f612cb66040518060600160405280602b815260200161746d602b913980519060200120835f0151604051602001612c9b929190616caf565b60405160208183030381529060405280519060200120614791565b9050919050565b5f612cc6612b22565b90505f612d168585858080601f0160208091040260200160405190810160405280939291908181526020018383808284375f81840152601f19601f820116905080830192505050505050506147aa565b9050612d22868261215a565b816009015f8781526020019081526020015f205f8273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f9054906101000a900460ff1615612dc15785816040517f99b158c1000000000000000000000000000000000000000000000000000000008152600401612db8929190616b56565b60405180910390fd5b6001826009015f8881526020019081526020015f205f8373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f6101000a81548160ff021916908315150217905550505050505050565b5f8083608001515190508083101591505092915050565b5f612e4f612b22565b9050612e60815f01845f01516147d4565b5f8243612e6d9190616b23565b905080826011015f865f015181526020019081526020015f20819055507f4540f7808fcaec86c376a89d2c0c93a5056c21680db54332c7f2959d87fefc8b8482604051612ebb929190616cd6565b60405180910390a150505050565b612ed16133ca565b73ffffffffffffffffffffffffffffffffffffffff16612eef611d13565b73ffffffffffffffffffffffffffffffffffffffff1614612f4e57612f126133ca565b6040517f118cdaa7000000000000000000000000000000000000000000000000000000008152600401612f459190615fe8565b60405180910390fd5b565b612f58611371565b15612f8f576040517fd93c066500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b565b5f612f9a612b22565b90505f8303612fd5576040517fb1ae92ea00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b8183111561301c5782826040517f84208f23000000000000000000000000000000000000000000000000000000008152600401613013929190616b7d565b60405180910390fd5b82816015015f8681526020019081526020015f208190555050505050565b6130426148aa565b5f61304b613366565b90505f815f015f6101000a81548160ff0219169083151502179055507f5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa6130906133ca565b60405161309d9190615fe8565b60405180910390a150565b5f825f015f8381526020019081526020015f205f9054906101000a900460ff16905092915050565b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff163073ffffffffffffffffffffffffffffffffffffffff16148061317d57507f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff166131646148ea565b73ffffffffffffffffffffffffffffffffffffffff1614155b156131b4576040517fe07c8dba00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b565b6131be612ec9565b50565b8173ffffffffffffffffffffffffffffffffffffffff166352d1902d6040518163ffffffff1660e01b8152600401602060405180830381865afa92505050801561322957506040513d601f19601f820116820180604052508101906132269190616d2e565b60015b61326a57816040517f4c9c8ce30000000000000000000000000000000000000000000000000000000081526004016132619190615fe8565b60405180910390fd5b7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5f1b81146132d057806040517faa1d49a40000000000000000000000000000000000000000000000000000000081526004016132c79190615c3c565b60405180910390fd5b6132da838361493d565b505050565b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff163073ffffffffffffffffffffffffffffffffffffffff1614613364576040517fe07c8dba00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b565b5f7fcd5ed15c6e187e77e9aee88184c21f4f2182ab5827cb3b7e07fbedcd63f03300905090565b5f6133966144a3565b9050805f015f6101000a81549073ffffffffffffffffffffffffffffffffffffffff02191690556133c6826149af565b5050565b5f33905090565b5f6133da6133f5565b5f015f9054906101000a900467ffffffffffffffff16905090565b5f7ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00905090565b613424614a80565b61342e8282614ac0565b5050565b61343a614a80565b61344381614b11565b50565b61344e614a80565b613456614b95565b565b613460615400565b5f613469612b22565b90505f85859050036134a7576040517f068c8d4000000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b806008015f8154809291906134bb90616d59565b91905055505f8160080154905080826007015f8381526020019081526020015f205f018190555088826007015f8381526020019081526020015f206001018190555087826007015f8381526020019081526020015f206002015f6101000a81548167ffffffffffffffff021916908360c01c0217905550613540818888889050614bc5565b5f5b868690508110156135c957826007015f8381526020019081526020015f2060040187878381811061357657613575616da0565b5b90506020028101906135889190616dd9565b908060018154018082558091505060019003905f5260205f2090600802015f9091909190915081816135ba919061725b565b50508080600101915050613542565b505f5b86869050811015613922578686828181106135ea576135e9616da0565b5b90506020028101906135fc9190616dd9565b83600b015f8481526020019081526020015f205f89898581811061362357613622616da0565b5b90506020028101906136359190616dd9565b6040016020810190613647919061603f565b73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f20818161368c919061725b565b905050600183600c015f8481526020019081526020015f205f8989858181106136b8576136b7616da0565b5b90506020028101906136ca9190616dd9565b60400160208101906136dc919061603f565b73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f6101000a81548160ff02191690831515021790555082600e015f8381526020019081526020015f2087878381811061375157613750616da0565b5b90506020028101906137639190616dd9565b6040016020810190613775919061603f565b908060018154018082558091505060019003905f5260205f20015f9091909190916101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550600183600d015f8481526020019081526020015f205f8989858181106137fb576137fa616da0565b5b905060200281019061380d9190616dd9565b602001602081019061381f919061603f565b73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f6101000a81548160ff02191690831515021790555082600f015f8381526020019081526020015f2087878381811061389457613893616da0565b5b90506020028101906138a69190616dd9565b60200160208101906138b8919061603f565b908060018154018082558091505060019003905f5260205f20015f9091909190916101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555080806001019150506135cc565b50613931818588889050614c39565b816007015f8281526020019081526020015f206040518060a00160405290815f820154815260200160018201548152602001600282015f9054906101000a900460c01b77ffffffffffffffffffffffffffffffffffffffffffffffff191677ffffffffffffffffffffffffffffffffffffffffffffffff191681526020016003820154815260200160048201805480602002602001604051908101604052809291908181526020015f905b82821015613d90578382905f5260205f209060080201604051806101000160405290815f82018054613a0d9061639f565b80601f0160208091040260200160405190810160405280929190818152602001828054613a399061639f565b8015613a845780601f10613a5b57610100808354040283529160200191613a84565b820191905f5260205f20905b815481529060010190602001808311613a6757829003601f168201915b50505050508152602001600182015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001600282015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200160038201548152602001600482018054613b519061639f565b80601f0160208091040260200160405190810160405280929190818152602001828054613b7d9061639f565b8015613bc85780601f10613b9f57610100808354040283529160200191613bc8565b820191905f5260205f20905b815481529060010190602001808311613bab57829003601f168201915b50505050508152602001600582018054613be19061639f565b80601f0160208091040260200160405190810160405280929190818152602001828054613c0d9061639f565b8015613c585780601f10613c2f57610100808354040283529160200191613c58565b820191905f5260205f20905b815481529060010190602001808311613c3b57829003601f168201915b50505050508152602001600682018054613c719061639f565b80601f0160208091040260200160405190810160405280929190818152602001828054613c9d9061639f565b8015613ce85780601f10613cbf57610100808354040283529160200191613ce8565b820191905f5260205f20905b815481529060010190602001808311613ccb57829003601f168201915b50505050508152602001600782018054613d019061639f565b80601f0160208091040260200160405190810160405280929190818152602001828054613d2d9061639f565b8015613d785780601f10613d4f57610100808354040283529160200191613d78565b820191905f5260205f20905b815481529060010190602001808311613d5b57829003601f168201915b505050505081525050815260200190600101906139dc565b5050505081525050925050509695505050505050565b805f8103613de0576040517fcb17b7a500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b613dea8383614c5b565b158015613dfe5750613dfc8383614caa565b155b8015613e0e57505f836003015414155b15613e5057816040517f12b49e3d000000000000000000000000000000000000000000000000000000008152600401613e4791906154cc565b60405180910390fd5b6003835f015f8481526020019081526020015f205f6101000a81548160ff02191690836007811115613e8557613e846159ec565b5b02179055508183600301819055505f8360020181905550505050565b613ea9612f50565b5f613eb2613366565b90506001815f015f6101000a81548160ff0219169083151502179055507f62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258613ef86133ca565b604051613f059190615fe8565b60405180910390a150565b5f7fa16a46d94261c7517cc8ff89f61c0ce93598e3c849801011dee649a6a557d100905090565b60605f613f42613f10565b9050806002018054613f539061639f565b80601f0160208091040260200160405190810160405280929190818152602001828054613f7f9061639f565b8015613fca5780601f10613fa157610100808354040283529160200191613fca565b820191905f5260205f20905b815481529060010190602001808311613fad57829003601f168201915b505050505091505090565b60605f613fe0613f10565b9050806003018054613ff19061639f565b80601f016020809104026020016040519081016040528092919081815260200182805461401d9061639f565b80156140685780601f1061403f57610100808354040283529160200191614068565b820191905f5260205f20905b81548152906001019060200180831161404b57829003601f168201915b505050505091505090565b805f81036140ad576040517fcb17b7a500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6007835f015f8481526020019081526020015f205f6101000a81548160ff021916908360078111156140e2576140e16159ec565b5b0217905550818360010154036140fc575f83600101819055505b81836002015403614111575f83600201819055505b81836003015403614126575f83600301819055505b8183600401540361413b575f83600401819055505b505050565b805f810361417a576040517fcb17b7a500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b614184838361433f565b6141c557816040517f331486b30000000000000000000000000000000000000000000000000000000081526004016141bc91906154cc565b60405180910390fd5b6004835f015f8481526020019081526020015f205f6101000a81548160ff021916908360078111156141fa576141f96159ec565b5b02179055508183600401819055505f8360030181905550505050565b805f8103614250576040517fcb17b7a500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b61425a838361433f565b158061426d575061426b8383614caa565b155b156142af57816040517f2b3652d10000000000000000000000000000000000000000000000000000000081526004016142a691906154cc565b60405180910390fd5b6005835f015f8481526020019081526020015f205f6101000a81548160ff021916908360078111156142e4576142e36159ec565b5b0217905550818360030154036142fe575f83600301819055505b81836004015403614313575f83600401819055505b505050565b5f7f9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300905090565b5f60036007811115614354576143536159ec565b5b835f015f8481526020019081526020015f205f9054906101000a900460ff166007811115614385576143846159ec565b5b14905092915050565b805f81036143c8576040517fcb17b7a500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6143d28383614cf9565b806143e357506143e28383612c13565b5b1561442557816040517fb0c5151d00000000000000000000000000000000000000000000000000000000815260040161441c91906154cc565b60405180910390fd5b6006835f015f8481526020019081526020015f205f6101000a81548160ff0219169083600781111561445a576144596159ec565b5b021790555081836002015403614474575f83600201819055505b81836003015403614489575f83600301819055505b8183600401540361449e575f83600401819055505b505050565b5f7f237e158222e3e6968b72b9db0d8043aacf074ad9f650f0d1606b4d82ee432c00905090565b805f8103614504576040517fcb17b7a500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b61450e8383614cf9565b61454f57816040517f6653f6d700000000000000000000000000000000000000000000000000000000815260040161454691906154cc565b60405180910390fd5b6001835f015f8481526020019081526020015f205f6101000a81548160ff02191690836007811115614584576145836159ec565b5b0217905550818360010181905550505050565b5f6145a0612b22565b90505f83036145db576040517fe60a727100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b818311156146225782826040517fd2535e11000000000000000000000000000000000000000000000000000000008152600401614619929190616b7d565b60405180910390fd5b82816016015f8681526020019081526020015f208190555050505050565b5f805f90507a184f03e93ff9f4daa797ed6e38ed64bf6a1f010000000000000000831061469c577a184f03e93ff9f4daa797ed6e38ed64bf6a1f010000000000000000838161469257614691616c82565b5b0492506040810190505b6d04ee2d6d415b85acef810000000083106146d9576d04ee2d6d415b85acef810000000083816146cf576146ce616c82565b5b0492506020810190505b662386f26fc10000831061470857662386f26fc1000083816146fe576146fd616c82565b5b0492506010810190505b6305f5e1008310614731576305f5e100838161472757614726616c82565b5b0492506008810190505b612710831061475657612710838161474c5761474b616c82565b5b0492506004810190505b60648310614779576064838161476f5761476e616c82565b5b0492506002810190505b600a8310614788576001810190505b80915050919050565b5f6147a361479d614d47565b83614d55565b9050919050565b5f805f806147b88686614d95565b9250925092506147c88282614dea565b82935050505092915050565b805f810361480e576040517fcb17b7a500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6148188383612c13565b61485957816040517fc0b5ee6600000000000000000000000000000000000000000000000000000000815260040161485091906154cc565b60405180910390fd5b6002835f015f8481526020019081526020015f205f6101000a81548160ff0219169083600781111561488e5761488d6159ec565b5b02179055508183600201819055505f8360010181905550505050565b6148b2611371565b6148e8576040517f8dfc202b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b565b5f6149167f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5f1b614f4c565b5f015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905090565b61494682614f55565b8173ffffffffffffffffffffffffffffffffffffffff167fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b60405160405180910390a25f815111156149a25761499c828261501e565b506149ab565b6149aa61509e565b5b5050565b5f6149b8614318565b90505f815f015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905082825f015f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508273ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e060405160405180910390a3505050565b614a886150da565b614abe576040517fd7e6bcf800000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b565b614ac8614a80565b5f614ad1613f10565b905082816002019081614ae49190617269565b5081816003019081614af69190617269565b505f801b815f01819055505f801b8160010181905550505050565b614b19614a80565b5f73ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1603614b89575f6040517f1e4fbdf7000000000000000000000000000000000000000000000000000000008152600401614b809190615fe8565b60405180910390fd5b614b928161338d565b50565b614b9d614a80565b5f614ba6613366565b90505f815f015f6101000a81548160ff02191690831515021790555050565b5f614bce612b22565b9050818310614c18578383836040517f8789a6ca000000000000000000000000000000000000000000000000000000008152600401614c0f93929190617338565b60405180910390fd5b82816007015f8681526020019081526020015f206003018190555050505050565b614c4783835f013583612f91565b614c5683836020013583614597565b505050565b5f60026007811115614c7057614c6f6159ec565b5b835f015f8481526020019081526020015f205f9054906101000a900460ff166007811115614ca157614ca06159ec565b5b14905092915050565b5f60046007811115614cbf57614cbe6159ec565b5b835f015f8481526020019081526020015f205f9054906101000a900460ff166007811115614cf057614cef6159ec565b5b14905092915050565b5f806007811115614d0d57614d0c6159ec565b5b835f015f8481526020019081526020015f205f9054906101000a900460ff166007811115614d3e57614d3d6159ec565b5b14905092915050565b5f614d506150f8565b905090565b5f6040517f190100000000000000000000000000000000000000000000000000000000000081528360028201528260228201526042812091505092915050565b5f805f6041845103614dd5575f805f602087015192506040870151915060608701515f1a9050614dc78882858561515b565b955095509550505050614de3565b5f600285515f1b9250925092505b9250925092565b5f6003811115614dfd57614dfc6159ec565b5b826003811115614e1057614e0f6159ec565b5b0315614f485760016003811115614e2a57614e296159ec565b5b826003811115614e3d57614e3c6159ec565b5b03614e74576040517ff645eedf00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60026003811115614e8857614e876159ec565b5b826003811115614e9b57614e9a6159ec565b5b03614edf57805f1c6040517ffce698f7000000000000000000000000000000000000000000000000000000008152600401614ed691906154cc565b60405180910390fd5b600380811115614ef257614ef16159ec565b5b826003811115614f0557614f046159ec565b5b03614f4757806040517fd78bce0c000000000000000000000000000000000000000000000000000000008152600401614f3e9190615c3c565b60405180910390fd5b5b5050565b5f819050919050565b5f8173ffffffffffffffffffffffffffffffffffffffff163b03614fb057806040517f4c9c8ce3000000000000000000000000000000000000000000000000000000008152600401614fa79190615fe8565b60405180910390fd5b80614fdc7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5f1b614f4c565b5f015f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555050565b60605f808473ffffffffffffffffffffffffffffffffffffffff168460405161504791906173a7565b5f60405180830381855af49150503d805f811461507f576040519150601f19603f3d011682016040523d82523d5f602084013e615084565b606091505b5091509150615094858383615242565b9250505092915050565b5f3411156150d8576040517fb398979f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b565b5f6150e36133f5565b5f0160089054906101000a900460ff16905090565b5f7f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f6151226152cf565b61512a615345565b46306040516020016151409594939291906173bd565b60405160208183030381529060405280519060200120905090565b5f805f7f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0845f1c1115615197575f600385925092509250615238565b5f6001888888886040515f81526020016040526040516151ba9493929190617429565b6020604051602081039080840390855afa1580156151da573d5f803e3d5ffd5b5050506020604051035190505f73ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff160361522b575f60015f801b93509350935050615238565b805f805f1b935093509350505b9450945094915050565b60608261525757615252826153bc565b6152c7565b5f825114801561527d57505f8473ffffffffffffffffffffffffffffffffffffffff163b145b156152bf57836040517f9996b3150000000000000000000000000000000000000000000000000000000081526004016152b69190615fe8565b60405180910390fd5b8190506152c8565b5b9392505050565b5f806152d9613f10565b90505f6152e4613f37565b90505f8151111561530057808051906020012092505050615342565b5f825f015490505f801b811461531b57809350505050615342565b7fc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a47093505050505b90565b5f8061534f613f10565b90505f61535a613fd5565b90505f81511115615376578080519060200120925050506153b9565b5f826001015490505f801b8114615392578093505050506153b9565b7fc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a47093505050505b90565b5f815111156153ce5780518082602001fd5b6040517fd6bda27500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6040518060a001604052805f81526020015f81526020015f77ffffffffffffffffffffffffffffffffffffffffffffffff191681526020015f8152602001606081525090565b604051806101000160405280606081526020015f73ffffffffffffffffffffffffffffffffffffffff1681526020015f73ffffffffffffffffffffffffffffffffffffffff1681526020015f8152602001606081526020016060815260200160608152602001606081525090565b5f819050919050565b6154c6816154b4565b82525050565b5f6020820190506154df5f8301846154bd565b92915050565b5f81519050919050565b5f82825260208201905092915050565b5f5b8381101561551c578082015181840152602081019050615501565b5f8484015250505050565b5f601f19601f8301169050919050565b5f615541826154e5565b61554b81856154ef565b935061555b8185602086016154ff565b61556481615527565b840191505092915050565b5f6020820190508181035f8301526155878184615537565b905092915050565b615598816154b4565b82525050565b5f7fffffffffffffffff00000000000000000000000000000000000000000000000082169050919050565b6155d28161559e565b82525050565b5f81519050919050565b5f82825260208201905092915050565b5f819050602082019050919050565b5f82825260208201905092915050565b5f61561b826154e5565b6156258185615601565b93506156358185602086016154ff565b61563e81615527565b840191505092915050565b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f61567282615649565b9050919050565b61568281615668565b82525050565b5f81519050919050565b5f82825260208201905092915050565b5f6156ac82615688565b6156b68185615692565b93506156c68185602086016154ff565b6156cf81615527565b840191505092915050565b5f61010083015f8301518482035f8601526156f58282615611565b915050602083015161570a6020860182615679565b50604083015161571d6040860182615679565b506060830151615730606086018261558f565b506080830151848203608086015261574882826156a2565b91505060a083015184820360a08601526157628282615611565b91505060c083015184820360c086015261577c8282615611565b91505060e083015184820360e086015261579682826156a2565b9150508091505092915050565b5f6157ae83836156da565b905092915050565b5f602082019050919050565b5f6157cc826155d8565b6157d681856155e2565b9350836020820285016157e8856155f2565b805f5b85811015615823578484038952815161580485826157a3565b945061580f836157b6565b925060208a019950506001810190506157eb565b50829750879550505050505092915050565b5f60a083015f83015161584a5f86018261558f565b50602083015161585d602086018261558f565b50604083015161587060408601826155c9565b506060830151615883606086018261558f565b506080830151848203608086015261589b82826157c2565b9150508091505092915050565b5f6020820190508181035f8301526158c08184615835565b905092915050565b5f604051905090565b5f80fd5b5f80fd5b6158e2816154b4565b81146158ec575f80fd5b50565b5f813590506158fd816158d9565b92915050565b5f80fd5b5f80fd5b5f80fd5b5f8083601f84011261592457615923615903565b5b8235905067ffffffffffffffff81111561594157615940615907565b5b60208301915083600182028301111561595d5761595c61590b565b5b9250929050565b5f805f6040848603121561597b5761597a6158d1565b5b5f615988868287016158ef565b935050602084013567ffffffffffffffff8111156159a9576159a86158d5565b5b6159b58682870161590f565b92509250509250925092565b5f602082840312156159d6576159d56158d1565b5b5f6159e3848285016158ef565b91505092915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52602160045260245ffd5b60088110615a2a57615a296159ec565b5b50565b5f819050615a3a82615a19565b919050565b5f615a4982615a2d565b9050919050565b615a5981615a3f565b82525050565b5f602082019050615a725f830184615a50565b92915050565b615a8181615668565b8114615a8b575f80fd5b50565b5f81359050615a9c81615a78565b92915050565b5f80fd5b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b615adc82615527565b810181811067ffffffffffffffff82111715615afb57615afa615aa6565b5b80604052505050565b5f615b0d6158c8565b9050615b198282615ad3565b919050565b5f67ffffffffffffffff821115615b3857615b37615aa6565b5b615b4182615527565b9050602081019050919050565b828183375f83830152505050565b5f615b6e615b6984615b1e565b615b04565b905082815260208101848484011115615b8a57615b89615aa2565b5b615b95848285615b4e565b509392505050565b5f82601f830112615bb157615bb0615903565b5b8135615bc1848260208601615b5c565b91505092915050565b5f8060408385031215615be057615bdf6158d1565b5b5f615bed85828601615a8e565b925050602083013567ffffffffffffffff811115615c0e57615c0d6158d5565b5b615c1a85828601615b9d565b9150509250929050565b5f819050919050565b615c3681615c24565b82525050565b5f602082019050615c4f5f830184615c2d565b92915050565b5f8115159050919050565b615c6981615c55565b82525050565b5f602082019050615c825f830184615c60565b92915050565b5f81519050919050565b5f82825260208201905092915050565b5f819050602082019050919050565b5f615cbc8383615679565b60208301905092915050565b5f602082019050919050565b5f615cde82615c88565b615ce88185615c92565b9350615cf383615ca2565b805f5b83811015615d23578151615d0a8882615cb1565b9750615d1583615cc8565b925050600181019050615cf6565b5085935050505092915050565b5f6020820190508181035f830152615d488184615cd4565b905092915050565b615d598161559e565b8114615d63575f80fd5b50565b5f81359050615d7481615d50565b92915050565b5f8083601f840112615d8f57615d8e615903565b5b8235905067ffffffffffffffff811115615dac57615dab615907565b5b602083019150836020820283011115615dc857615dc761590b565b5b9250929050565b5f80fd5b5f60408284031215615de857615de7615dcf565b5b81905092915050565b5f805f805f60a08688031215615e0a57615e096158d1565b5b5f615e1788828901615d66565b9550506020615e28888289016158ef565b945050604086013567ffffffffffffffff811115615e4957615e486158d5565b5b615e5588828901615d7a565b93509350506060615e6888828901615dd3565b9150509295509295909350565b5f7fff0000000000000000000000000000000000000000000000000000000000000082169050919050565b615ea981615e75565b82525050565b615eb881615668565b82525050565b5f81519050919050565b5f82825260208201905092915050565b5f819050602082019050919050565b5f615ef2838361558f565b60208301905092915050565b5f602082019050919050565b5f615f1482615ebe565b615f1e8185615ec8565b9350615f2983615ed8565b805f5b83811015615f59578151615f408882615ee7565b9750615f4b83615efe565b925050600181019050615f2c565b5085935050505092915050565b5f60e082019050615f795f83018a615ea0565b8181036020830152615f8b8189615537565b90508181036040830152615f9f8188615537565b9050615fae60608301876154bd565b615fbb6080830186615eaf565b615fc860a0830185615c2d565b81810360c0830152615fda8184615f0a565b905098975050505050505050565b5f602082019050615ffb5f830184615eaf565b92915050565b5f8060408385031215616017576160166158d1565b5b5f616024858286016158ef565b925050602061603585828601615a8e565b9150509250929050565b5f60208284031215616054576160536158d1565b5b5f61606184828501615a8e565b91505092915050565b5f61010083015f8301518482035f8601526160858282615611565b915050602083015161609a6020860182615679565b5060408301516160ad6040860182615679565b5060608301516160c0606086018261558f565b50608083015184820360808601526160d882826156a2565b91505060a083015184820360a08601526160f28282615611565b91505060c083015184820360c086015261610c8282615611565b91505060e083015184820360e086015261612682826156a2565b9150508091505092915050565b5f6020820190508181035f83015261614b818461606a565b905092915050565b61615c81615c55565b8114616166575f80fd5b50565b5f8135905061617781616153565b92915050565b5f6060828403121561619257616191615dcf565b5b81905092915050565b5f805f805f805f610120888a0312156161b7576161b66158d1565b5b5f6161c48a828b01615d66565b97505060206161d58a828b01616169565b96505060406161e68a828b016158ef565b955050606088013567ffffffffffffffff811115616207576162066158d5565b5b6162138a828b01615d7a565b945094505060806162268a828b0161617d565b92505060e06162378a828b01615dd3565b91505092959891949750929550565b5f81905092915050565b5f61625a826154e5565b6162648185616246565b93506162748185602086016154ff565b80840191505092915050565b7f20760000000000000000000000000000000000000000000000000000000000005f82015250565b5f6162b4600283616246565b91506162bf82616280565b600282019050919050565b7f2e000000000000000000000000000000000000000000000000000000000000005f82015250565b5f6162fe600183616246565b9150616309826162ca565b600182019050919050565b5f61631f8287616250565b915061632a826162a8565b91506163368286616250565b9150616341826162f2565b915061634d8285616250565b9150616358826162f2565b91506163648284616250565b915081905095945050505050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52602260045260245ffd5b5f60028204905060018216806163b657607f821691505b6020821081036163c9576163c8616372565b5b50919050565b5f82905092915050565b5f819050815f5260205f209050919050565b5f6020601f8301049050919050565b5f82821b905092915050565b5f600883026164357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff826163fa565b61643f86836163fa565b95508019841693508086168417925050509392505050565b5f819050919050565b5f61647a616475616470846154b4565b616457565b6154b4565b9050919050565b5f819050919050565b61649383616460565b6164a761649f82616481565b848454616406565b825550505050565b5f90565b6164bb6164af565b6164c681848461648a565b505050565b5b818110156164e9576164de5f826164b3565b6001810190506164cc565b5050565b601f82111561652e576164ff816163d9565b616508846163eb565b81016020851015616517578190505b61652b616523856163eb565b8301826164cb565b50505b505050565b5f82821c905092915050565b5f61654e5f1984600802616533565b1980831691505092915050565b5f616566838361653f565b9150826002028217905092915050565b61658083836163cf565b67ffffffffffffffff81111561659957616598615aa6565b5b6165a3825461639f565b6165ae8282856164ed565b5f601f8311600181146165db575f84156165c9578287013590505b6165d3858261655b565b86555061663a565b601f1984166165e9866163d9565b5f5b82811015616610578489013582556001820191506020850194506020810190506165eb565b8683101561662d5784890135616629601f89168261653f565b8355505b6001600288020188555050505b50505050505050565b5f61665160208401846158ef565b905092915050565b604082016166695f830183616643565b6166755f85018261558f565b506166836020830183616643565b616690602085018261558f565b50505050565b61669f8161559e565b82525050565b5f82825260208201905092915050565b5f819050919050565b5f80fd5b5f80fd5b5f80fd5b5f80833560016020038436030381126166e6576166e56166c6565b5b83810192508235915060208301925067ffffffffffffffff82111561670e5761670d6166be565b5b600182023603831315616724576167236166c2565b5b509250929050565b5f6167378385615601565b9350616744838584615b4e565b61674d83615527565b840190509392505050565b5f6167666020840184615a8e565b905092915050565b5f808335600160200384360303811261678a576167896166c6565b5b83810192508235915060208301925067ffffffffffffffff8211156167b2576167b16166be565b5b6001820236038313156167c8576167c76166c2565b5b509250929050565b5f6167db8385615692565b93506167e8838584615b4e565b6167f183615527565b840190509392505050565b5f610100830161680e5f8401846166ca565b8583035f87015261682083828461672c565b925050506168316020840184616758565b61683e6020860182615679565b5061684c6040840184616758565b6168596040860182615679565b506168676060840184616643565b616874606086018261558f565b50616882608084018461676e565b85830360808701526168958382846167d0565b925050506168a660a08401846166ca565b85830360a08701526168b983828461672c565b925050506168ca60c08401846166ca565b85830360c08701526168dd83828461672c565b925050506168ee60e084018461676e565b85830360e08701526169018382846167d0565b925050508091505092915050565b5f61691a83836167fc565b905092915050565b5f823560016101000383360303811261693e5761693d6166c6565b5b82810191505092915050565b5f602082019050919050565b5f61696183856166a5565b935083602084028501616973846166b5565b805f5b878110156169b657848403895261698d8284616922565b616997858261690f565b94506169a28361694a565b925060208a01995050600181019050616976565b50829750879450505050509392505050565b5f60a0820190506169db5f830188616659565b6169e86040830187616696565b6169f560608301866154bd565b8181036080830152616a08818486616956565b90509695505050505050565b5f67ffffffffffffffff82169050919050565b616a3081616a14565b82525050565b5f602082019050616a495f830184616a27565b92915050565b5f81519050616a5d81615a78565b92915050565b5f60208284031215616a7857616a776158d1565b5b5f616a8584828501616a4f565b91505092915050565b7f4549503731323a20556e696e697469616c697a656400000000000000000000005f82015250565b5f616ac26015836154ef565b9150616acd82616a8e565b602082019050919050565b5f6020820190508181035f830152616aef81616ab6565b9050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5f616b2d826154b4565b9150616b38836154b4565b9250828201905080821115616b5057616b4f616af6565b5b92915050565b5f604082019050616b695f8301856154bd565b616b766020830184615eaf565b9392505050565b5f604082019050616b905f8301856154bd565b616b9d60208301846154bd565b9392505050565b60608201616bb45f830183616643565b616bc05f85018261558f565b50616bce6020830183616643565b616bdb602085018261558f565b50616be96040830183616643565b616bf6604085018261558f565b50505050565b5f60a0820190508181035f830152616c148186615835565b90508181036020830152616c288185615835565b9050616c376040830184616ba4565b949350505050565b5f6060820190508181035f830152616c578186615835565b90508181036020830152616c6b8185615835565b9050616c7a60408301846154bd565b949350505050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601260045260245ffd5b5f604082019050616cc25f830185615c2d565b616ccf60208301846154bd565b9392505050565b5f6040820190508181035f830152616cee8185615835565b9050616cfd60208301846154bd565b9392505050565b616d0d81615c24565b8114616d17575f80fd5b50565b5f81519050616d2881616d04565b92915050565b5f60208284031215616d4357616d426158d1565b5b5f616d5084828501616d1a565b91505092915050565b5f616d63826154b4565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8203616d9557616d94616af6565b5b600182019050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603260045260245ffd5b5f80fd5b5f80fd5b5f80fd5b5f8235600161010003833603038112616df557616df4616dcd565b5b80830191505092915050565b5f8083356001602003843603038112616e1d57616e1c616dcd565b5b80840192508235915067ffffffffffffffff821115616e3f57616e3e616dd1565b5b602083019250600182023603831315616e5b57616e5a616dd5565b5b509250929050565b5f82905092915050565b5f819050815f5260205f209050919050565b601f821115616ec057616e9181616e6d565b616e9a846163eb565b81016020851015616ea9578190505b616ebd616eb5856163eb565b8301826164cb565b50505b505050565b616ecf8383616e63565b67ffffffffffffffff811115616ee857616ee7615aa6565b5b616ef2825461639f565b616efd828285616e7f565b5f601f831160018114616f2a575f8415616f18578287013590505b616f22858261655b565b865550616f89565b601f198416616f3886616e6d565b5f5b82811015616f5f57848901358255600182019150602085019450602081019050616f3a565b86831015616f7c5784890135616f78601f89168261653f565b8355505b6001600288020188555050505b50505050505050565b616f9d838383616ec5565b505050565b5f8135616fae81615a78565b80915050919050565b5f815f1b9050919050565b5f73ffffffffffffffffffffffffffffffffffffffff616fe184616fb7565b9350801983169250808416831791505092915050565b5f61701161700c61700784615649565b616457565b615649565b9050919050565b5f61702282616ff7565b9050919050565b5f61703382617018565b9050919050565b5f819050919050565b61704c82617029565b61705f6170588261703a565b8354616fc2565b8255505050565b5f8135617072816158d9565b80915050919050565b5f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff6170a684616fb7565b9350801983169250808416831791505092915050565b6170c582616460565b6170d86170d182616481565b835461707b565b8255505050565b5f80833560016020038436030381126170fb576170fa616dcd565b5b80840192508235915067ffffffffffffffff82111561711d5761711c616dd1565b5b60208301925060018202360383131561713957617138616dd5565b5b509250929050565b61714c838383616576565b505050565b5f81015f83016171618185616e01565b61716c818386616f92565b5050505060018101602083018061718281616fa2565b905061718e8184617043565b5050506002810160408301806171a381616fa2565b90506171af8184617043565b5050506003810160608301806171c481617066565b90506171d081846170bc565b50505060048101608083016171e581856170df565b6171f0818386617141565b505050506005810160a083016172068185616e01565b617211818386616f92565b505050506006810160c083016172278185616e01565b617232818386616f92565b505050506007810160e0830161724881856170df565b617253818386617141565b505050505050565b6172658282617151565b5050565b617272826154e5565b67ffffffffffffffff81111561728b5761728a615aa6565b5b617295825461639f565b6172a0828285616e7f565b5f60209050601f8311600181146172d1575f84156172bf578287015190505b6172c9858261655b565b865550617330565b601f1984166172df86616e6d565b5f5b82811015617306578489015182556001820191506020850194506020810190506172e1565b86831015617323578489015161731f601f89168261653f565b8355505b6001600288020188555050505b505050505050565b5f60608201905061734b5f8301866154bd565b61735860208301856154bd565b61736560408301846154bd565b949350505050565b5f81905092915050565b5f61738182615688565b61738b818561736d565b935061739b8185602086016154ff565b80840191505092915050565b5f6173b28284617377565b915081905092915050565b5f60a0820190506173d05f830188615c2d565b6173dd6020830187615c2d565b6173ea6040830186615c2d565b6173f760608301856154bd565b6174046080830184615eaf565b9695505050505050565b5f60ff82169050919050565b6174238161740e565b82525050565b5f60808201905061743c5f830187615c2d565b617449602083018661741a565b6174566040830185615c2d565b6174636060830184615c2d565b9594505050505056fe4b6579526573686172696e67566572696669636174696f6e2875696e7432353620636f6e74657874496429
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\xA0`@R0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`\x80\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81RP4\x80\x15b\0\0CW_\x80\xFD[Pb\0\0Tb\0\0Z` \x1B` \x1CV[b\0\x01\xC4V[_b\0\0kb\0\x01^` \x1B` \x1CV[\x90P\x80_\x01`\x08\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x15b\0\0\xB6W`@Q\x7F\xF9.\xE8\xA9\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\x16\x81_\x01_\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14b\0\x01[Wg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81_\x01_a\x01\0\n\x81T\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP\x7F\xC7\xF5\x05\xB2\xF3q\xAE!u\xEEI\x13\xF4I\x9E\x1F&3\xA7\xB5\x93c!\xEE\xD1\xCD\xAE\xB6\x11Q\x81\xD2g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@Qb\0\x01R\x91\x90b\0\x01\xA9V[`@Q\x80\x91\x03\x90\xA1[PV[_\x7F\xF0\xC5~\x16\x84\r\xF0@\xF1P\x88\xDC/\x81\xFE9\x1C9#\xBE\xC7>#\xA9f.\xFC\x9C\"\x9Cj\0\x90P\x90V[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[b\0\x01\xA3\x81b\0\x01\x85V[\x82RPPV[_` \x82\x01\x90Pb\0\x01\xBE_\x83\x01\x84b\0\x01\x98V[\x92\x91PPV[`\x80Qat\x98b\0\x01\xEB_9_\x81\x81a0\xD2\x01R\x81\x81a1'\x01Ra2\xE1\x01Rat\x98_\xF3\xFE`\x80`@R`\x046\x10a\x02\x03W_5`\xE0\x1C\x80c\x83\xB4 \xC4\x11a\x01\x17W\x80c\xD8\xE3\xAE\x01\x11a\0\x9FW\x80c\xE3\xB2\xA8t\x11a\0nW\x80c\xE3\xB2\xA8t\x14a\x06\xAFW\x80c\xE7\xB1\xEC9\x14a\x06\xEBW\x80c\xEB\x84<\xF6\x14a\x07\x13W\x80c\xF2|\xB9W\x14a\x07;W\x80c\xF2\xFD\xE3\x8B\x14a\x07QWa\x02\x03V[\x80c\xD8\xE3\xAE\x01\x14a\x06\x0BW\x80c\xDE\xFB\xA0j\x14a\x065W\x80c\xDF\xE3j\xEE\x14a\x06]W\x80c\xE3\x0C9x\x14a\x06\x85Wa\x02\x03V[\x80c\x8D\xA5\xCB[\x11a\0\xE6W\x80c\x8D\xA5\xCB[\x14a\x05+W\x80c\x9E\xE7z\xF3\x14a\x05UW\x80c\xAD<\xB1\xCC\x14a\x05}W\x80c\xB8q]M\x14a\x05\xA7W\x80c\xC0\xAEd\xF7\x14a\x05\xE3Wa\x02\x03V[\x80c\x83\xB4 \xC4\x14a\x04\xA7W\x80c\x84V\xCBY\x14a\x04\xCFW\x80c\x84\xB0\x19n\x14a\x04\xE5W\x80c\x8C\xB9gQ\x14a\x05\x15Wa\x02\x03V[\x80cMiB`\x11a\x01\x9AW\x80cd\xB0\x0C\xC5\x11a\x01iW\x80cd\xB0\x0C\xC5\x14a\x03\xEBW\x80cqP\x18\xA6\x14a\x04'W\x80ct \xF3\xD4\x14a\x04=W\x80cy\xBAP\x97\x14a\x04gW\x80c~\xAA\xC8\xF2\x14a\x04}Wa\x02\x03V[\x80cMiB`\x14a\x03?W\x80cO\x1E\xF2\x86\x14a\x03{W\x80cR\xD1\x90-\x14a\x03\x97W\x80c\\\x97Z\xBB\x14a\x03\xC1Wa\x02\x03V[\x80c.-:\x82\x11a\x01\xD6W\x80c.-:\x82\x14a\x02\xADW\x80c?K\xA8:\x14a\x02\xD5W\x80cC\xE3~\x8A\x14a\x02\xEBW\x80cIe\xE4U\x14a\x03\x15Wa\x02\x03V[\x80c\nP\xE3\x18\x14a\x02\x07W\x80c\r\x8En,\x14a\x021W\x80c\r\xD4\x86\xC0\x14a\x02[W\x80c\x10y\xEB\xEB\x14a\x02\x85W[_\x80\xFD[4\x80\x15a\x02\x12W_\x80\xFD[Pa\x02\x1Ba\x07yV[`@Qa\x02(\x91\x90aT\xCCV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x02<W_\x80\xFD[Pa\x02Ea\x07\x92V[`@Qa\x02R\x91\x90aUoV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x02fW_\x80\xFD[Pa\x02oa\x08\rV[`@Qa\x02|\x91\x90aX\xA8V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x02\x90W_\x80\xFD[Pa\x02\xAB`\x04\x806\x03\x81\x01\x90a\x02\xA6\x91\x90aYdV[a\x0C\x99V[\0[4\x80\x15a\x02\xB8W_\x80\xFD[Pa\x02\xD3`\x04\x806\x03\x81\x01\x90a\x02\xCE\x91\x90aY\xC1V[a\x12VV[\0[4\x80\x15a\x02\xE0W_\x80\xFD[Pa\x02\xE9a\x12\xBFV[\0[4\x80\x15a\x02\xF6W_\x80\xFD[Pa\x02\xFFa\x12\xD1V[`@Qa\x03\x0C\x91\x90aT\xCCV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x03 W_\x80\xFD[Pa\x03)a\x12\xEAV[`@Qa\x036\x91\x90aT\xCCV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x03JW_\x80\xFD[Pa\x03e`\x04\x806\x03\x81\x01\x90a\x03`\x91\x90aY\xC1V[a\x13\x01V[`@Qa\x03r\x91\x90aZ_V[`@Q\x80\x91\x03\x90\xF3[a\x03\x95`\x04\x806\x03\x81\x01\x90a\x03\x90\x91\x90a[\xCAV[a\x13!V[\0[4\x80\x15a\x03\xA2W_\x80\xFD[Pa\x03\xABa\x13@V[`@Qa\x03\xB8\x91\x90a\\<V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x03\xCCW_\x80\xFD[Pa\x03\xD5a\x13qV[`@Qa\x03\xE2\x91\x90a\\oV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x03\xF6W_\x80\xFD[Pa\x04\x11`\x04\x806\x03\x81\x01\x90a\x04\x0C\x91\x90aY\xC1V[a\x13\x93V[`@Qa\x04\x1E\x91\x90aT\xCCV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x042W_\x80\xFD[Pa\x04;a\x14\"V[\0[4\x80\x15a\x04HW_\x80\xFD[Pa\x04Qa\x145V[`@Qa\x04^\x91\x90a]0V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x04rW_\x80\xFD[Pa\x04{a\x14\xE9V[\0[4\x80\x15a\x04\x88W_\x80\xFD[Pa\x04\x91a\x15wV[`@Qa\x04\x9E\x91\x90a]0V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x04\xB2W_\x80\xFD[Pa\x04\xCD`\x04\x806\x03\x81\x01\x90a\x04\xC8\x91\x90a]\xF1V[a\x16+V[\0[4\x80\x15a\x04\xDAW_\x80\xFD[Pa\x04\xE3a\x18\x98V[\0[4\x80\x15a\x04\xF0W_\x80\xFD[Pa\x04\xF9a\x19\xD3V[`@Qa\x05\x0C\x97\x96\x95\x94\x93\x92\x91\x90a_fV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x05 W_\x80\xFD[Pa\x05)a\x1A\xDCV[\0[4\x80\x15a\x056W_\x80\xFD[Pa\x05?a\x1D\x13V[`@Qa\x05L\x91\x90a_\xE8V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x05`W_\x80\xFD[Pa\x05{`\x04\x806\x03\x81\x01\x90a\x05v\x91\x90aY\xC1V[a\x1DHV[\0[4\x80\x15a\x05\x88W_\x80\xFD[Pa\x05\x91a\x1EWV[`@Qa\x05\x9E\x91\x90aUoV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x05\xB2W_\x80\xFD[Pa\x05\xCD`\x04\x806\x03\x81\x01\x90a\x05\xC8\x91\x90aY\xC1V[a\x1E\x90V[`@Qa\x05\xDA\x91\x90aT\xCCV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x05\xEEW_\x80\xFD[Pa\x06\t`\x04\x806\x03\x81\x01\x90a\x06\x04\x91\x90aY\xC1V[a\x1F\x1FV[\0[4\x80\x15a\x06\x16W_\x80\xFD[Pa\x06\x1Fa .V[`@Qa\x06,\x91\x90aT\xCCV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x06@W_\x80\xFD[Pa\x06[`\x04\x806\x03\x81\x01\x90a\x06V\x91\x90a`\x01V[a EV[\0[4\x80\x15a\x06hW_\x80\xFD[Pa\x06\x83`\x04\x806\x03\x81\x01\x90a\x06~\x91\x90a`\x01V[a!ZV[\0[4\x80\x15a\x06\x90W_\x80\xFD[Pa\x06\x99a\"oV[`@Qa\x06\xA6\x91\x90a_\xE8V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x06\xBAW_\x80\xFD[Pa\x06\xD5`\x04\x806\x03\x81\x01\x90a\x06\xD0\x91\x90a`?V[a\"\xA4V[`@Qa\x06\xE2\x91\x90aa3V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x06\xF6W_\x80\xFD[Pa\x07\x11`\x04\x806\x03\x81\x01\x90a\x07\x0C\x91\x90aa\x9BV[a'#V[\0[4\x80\x15a\x07\x1EW_\x80\xFD[Pa\x079`\x04\x806\x03\x81\x01\x90a\x074\x91\x90aY\xC1V[a)\x13V[\0[4\x80\x15a\x07FW_\x80\xFD[Pa\x07Oa)|V[\0[4\x80\x15a\x07\\W_\x80\xFD[Pa\x07w`\x04\x806\x03\x81\x01\x90a\x07r\x91\x90a`?V[a*iV[\0[_\x80a\x07\x83a+\"V[\x90P\x80_\x01`\x04\x01T\x91PP\x90V[```@Q\x80`@\x01`@R\x80`\x0B\x81R` \x01\x7FKmsContexts\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81RPa\x07\xD3_a+IV[a\x07\xDD`\x01a+IV[a\x07\xE6_a+IV[`@Q` \x01a\x07\xF9\x94\x93\x92\x91\x90ac\x14V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x90P\x90V[a\x08\x15aT\0V[_a\x08\x1Ea+\"V[\x90P_a\x08)a\x12\xD1V[\x90P\x81`\x07\x01_\x82\x81R` \x01\x90\x81R` \x01_ `@Q\x80`\xA0\x01`@R\x90\x81_\x82\x01T\x81R` \x01`\x01\x82\x01T\x81R` \x01`\x02\x82\x01_\x90T\x90a\x01\0\n\x90\x04`\xC0\x1Bw\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16w\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x81R` \x01`\x03\x82\x01T\x81R` \x01`\x04\x82\x01\x80T\x80` \x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01_\x90[\x82\x82\x10\x15a\x0C\x8AW\x83\x82\x90_R` _ \x90`\x08\x02\x01`@Q\x80a\x01\0\x01`@R\x90\x81_\x82\x01\x80Ta\t\x07\x90ac\x9FV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\t3\x90ac\x9FV[\x80\x15a\t~W\x80`\x1F\x10a\tUWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\t~V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\taW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x01\x82\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01`\x02\x82\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01`\x03\x82\x01T\x81R` \x01`\x04\x82\x01\x80Ta\nK\x90ac\x9FV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\nw\x90ac\x9FV[\x80\x15a\n\xC2W\x80`\x1F\x10a\n\x99Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\n\xC2V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\n\xA5W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x05\x82\x01\x80Ta\n\xDB\x90ac\x9FV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x0B\x07\x90ac\x9FV[\x80\x15a\x0BRW\x80`\x1F\x10a\x0B)Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x0BRV[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x0B5W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x06\x82\x01\x80Ta\x0Bk\x90ac\x9FV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x0B\x97\x90ac\x9FV[\x80\x15a\x0B\xE2W\x80`\x1F\x10a\x0B\xB9Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x0B\xE2V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x0B\xC5W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x07\x82\x01\x80Ta\x0B\xFB\x90ac\x9FV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x0C'\x90ac\x9FV[\x80\x15a\x0CrW\x80`\x1F\x10a\x0CIWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x0CrV[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x0CUW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81RPP\x81R` \x01\x90`\x01\x01\x90a\x08\xD6V[PPPP\x81RPP\x92PPP\x90V[a\x0C\xA3\x833a EV[_a\x0C\xACa+\"V[\x90Pa\x0C\xBA\x81_\x01\x85a,\x13V[a\x0C\xFBW\x83`@Q\x7F^Q\xA2\xE1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x0C\xF2\x91\x90aT\xCCV[`@Q\x80\x91\x03\x90\xFD[_`@Q\x80` \x01`@R\x80\x86\x81RP\x90P_a\r\x17\x82a,bV[\x90Pa\r%\x86\x82\x87\x87a,\xBDV[_\x83`\n\x01_\x88\x81R` \x01\x90\x81R` \x01_ \x90P\x80\x86\x86\x90\x91\x80`\x01\x81T\x01\x80\x82U\x80\x91PP`\x01\x90\x03\x90_R` _ \x01_\x90\x91\x92\x90\x91\x92\x90\x91\x92\x90\x91\x92P\x91\x82a\rt\x92\x91\x90aevV[P_\x84`\x07\x01_\x89\x81R` \x01\x90\x81R` \x01_ `@Q\x80`\xA0\x01`@R\x90\x81_\x82\x01T\x81R` \x01`\x01\x82\x01T\x81R` \x01`\x02\x82\x01_\x90T\x90a\x01\0\n\x90\x04`\xC0\x1Bw\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16w\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x81R` \x01`\x03\x82\x01T\x81R` \x01`\x04\x82\x01\x80T\x80` \x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01_\x90[\x82\x82\x10\x15a\x11\xD5W\x83\x82\x90_R` _ \x90`\x08\x02\x01`@Q\x80a\x01\0\x01`@R\x90\x81_\x82\x01\x80Ta\x0ER\x90ac\x9FV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x0E~\x90ac\x9FV[\x80\x15a\x0E\xC9W\x80`\x1F\x10a\x0E\xA0Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x0E\xC9V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x0E\xACW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x01\x82\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01`\x02\x82\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01`\x03\x82\x01T\x81R` \x01`\x04\x82\x01\x80Ta\x0F\x96\x90ac\x9FV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x0F\xC2\x90ac\x9FV[\x80\x15a\x10\rW\x80`\x1F\x10a\x0F\xE4Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x10\rV[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x0F\xF0W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x05\x82\x01\x80Ta\x10&\x90ac\x9FV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x10R\x90ac\x9FV[\x80\x15a\x10\x9DW\x80`\x1F\x10a\x10tWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x10\x9DV[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x10\x80W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x06\x82\x01\x80Ta\x10\xB6\x90ac\x9FV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x10\xE2\x90ac\x9FV[\x80\x15a\x11-W\x80`\x1F\x10a\x11\x04Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x11-V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x11\x10W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x07\x82\x01\x80Ta\x11F\x90ac\x9FV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x11r\x90ac\x9FV[\x80\x15a\x11\xBDW\x80`\x1F\x10a\x11\x94Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x11\xBDV[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x11\xA0W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81RPP\x81R` \x01\x90`\x01\x01\x90a\x0E!V[PPPP\x81RPP\x90Pa\x11\xED\x81\x83\x80T\x90Pa./V[\x15a\x12LW_\x85`\x13\x01_\x8A\x81R` \x01\x90\x81R` \x01_ T\x90Pa\x12\x13\x82\x82a.FV[\x7Fh\x89\x8A\x98\x93k\xF2:V\xE8\xEDK#\xDC\xC9\x8C\xEF\x92k\xD9\xAC,\xE5\"\xF1\xF9B>8d\xF2\xF5\x82`@Qa\x12B\x91\x90aX\xA8V[`@Q\x80\x91\x03\x90\xA1P[PPPPPPPPV[a\x12^a.\xC9V[a\x12fa/PV[_a\x12oa\x08\rV[\x90Pa\x12\x84\x81_\x01Q\x83\x83`\x80\x01QQa/\x91V[\x7F\xE4\x18\x02\xAFrW)\xAD\xCB\x8C\x15\x1E)78\n%\xC6\x91Uu~:\xF5\xD3\x97\x9A\xDA\xB5\x03X\0\x82`@Qa\x12\xB3\x91\x90aT\xCCV[`@Q\x80\x91\x03\x90\xA1PPV[a\x12\xC7a.\xC9V[a\x12\xCFa0:V[V[_\x80a\x12\xDBa+\"V[\x90P\x80_\x01`\x03\x01T\x91PP\x90V[_\x80a\x12\xF4a+\"V[\x90P\x80`\x05\x01T\x91PP\x90V[_\x80a\x13\x0Ba+\"V[\x90Pa\x13\x19\x81_\x01\x84a0\xA8V[\x91PP\x91\x90PV[a\x13)a0\xD0V[a\x132\x82a1\xB6V[a\x13<\x82\x82a1\xC1V[PPV[_a\x13Ia2\xDFV[\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC_\x1B\x90P\x90V[_\x80a\x13{a3fV[\x90P\x80_\x01_\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x91PP\x90V[_\x81_a\x13\x9Ea+\"V[\x90P_\x81`\x07\x01_\x84\x81R` \x01\x90\x81R` \x01_ _\x01T\x03a\x13\xF9W\x81`@Q\x7F\x82\xB1\xFB\xDA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x13\xF0\x91\x90aT\xCCV[`@Q\x80\x91\x03\x90\xFD[_a\x14\x02a+\"V[\x90P\x80`\x16\x01_\x86\x81R` \x01\x90\x81R` \x01_ T\x93PPPP\x91\x90PV[a\x14*a.\xC9V[a\x143_a3\x8DV[V[``_a\x14@a\x12\xD1V[\x90P_a\x14Ka+\"V[\x90P\x80`\x0E\x01_\x83\x81R` \x01\x90\x81R` \x01_ \x80T\x80` \x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80T\x80\x15a\x14\xDDW` \x02\x82\x01\x91\x90_R` _ \x90[\x81_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90`\x01\x01\x90\x80\x83\x11a\x14\x94W[PPPPP\x92PPP\x90V[_a\x14\xF2a3\xCAV[\x90P\x80s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x15\x13a\"oV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x15kW\x80`@Q\x7F\x11\x8C\xDA\xA7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x15b\x91\x90a_\xE8V[`@Q\x80\x91\x03\x90\xFD[a\x15t\x81a3\x8DV[PV[``_a\x15\x82a\x12\xD1V[\x90P_a\x15\x8Da+\"V[\x90P\x80`\x0F\x01_\x83\x81R` \x01\x90\x81R` \x01_ \x80T\x80` \x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80T\x80\x15a\x16\x1FW` \x02\x82\x01\x91\x90_R` _ \x90[\x81_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90`\x01\x01\x90\x80\x83\x11a\x15\xD6W[PPPPP\x92PPP\x90V[`\x01a\x165a3\xD1V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x16vW`@Q\x7FoOs\x1F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x02_a\x16\x81a3\xF5V[\x90P\x80_\x01`\x08\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x80a\x16\xC9WP\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81_\x01_\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x10\x15[\x15a\x17\0W`@Q\x7F\xF9.\xE8\xA9\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x81\x81_\x01_a\x01\0\n\x81T\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP`\x01\x81_\x01`\x08a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UPa\x17\xB9`@Q\x80`@\x01`@R\x80`\x0B\x81R` \x01\x7FKmsContexts\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81RP`@Q\x80`@\x01`@R\x80`\x01\x81R` \x01\x7F1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81RPa4\x1CV[a\x17\xC9a\x17\xC4a\x1D\x13V[a42V[a\x17\xD1a4FV[_a\x17\xE0_\x89\x89\x89\x89\x89a4XV[\x90P_a\x17\xEBa+\"V[\x90Pa\x17\xFC\x81_\x01\x83_\x01Qa=\xA6V[\x7FTHun\xE1?\x8E^\x9A\x81\xF5t\xACh\xC8\x81J\x16a+\xEE\x06\xFE\xA0\xFD\x80\xC6\x16\x10Cm\xCD\x85\x8A\x8A\x8A\x8A`@Qa\x183\x95\x94\x93\x92\x91\x90ai\xC8V[`@Q\x80\x91\x03\x90\xA1PP_\x81_\x01`\x08a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP\x7F\xC7\xF5\x05\xB2\xF3q\xAE!u\xEEI\x13\xF4I\x9E\x1F&3\xA7\xB5\x93c!\xEE\xD1\xCD\xAE\xB6\x11Q\x81\xD2\x82`@Qa\x18\x87\x91\x90aj6V[`@Q\x80\x91\x03\x90\xA1PPPPPPPV[a\x18\xA0a\x1D\x13V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14\x15\x80\x15a\x19\x87WPs\xC7\xD4Va\xA3E\xEC\\\xA0\xE8R\x1C\xFE\xF7\xE3/\xDA\r\xAAhs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16cp\x08\xB5H`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x193W=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x19W\x91\x90ajcV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14\x15[\x15a\x19\xC9W3`@Q\x7FF\xC0\xD9\xAF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x19\xC0\x91\x90a_\xE8V[`@Q\x80\x91\x03\x90\xFD[a\x19\xD1a>\xA1V[V[_``\x80_\x80_``_a\x19\xE5a?\x10V[\x90P_\x80\x1B\x81_\x01T\x14\x80\x15a\x1A\0WP_\x80\x1B\x81`\x01\x01T\x14[a\x1A?W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x1A6\x90aj\xD8V[`@Q\x80\x91\x03\x90\xFD[a\x1AGa?7V[a\x1AOa?\xD5V[F0_\x80\x1B_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x1AnWa\x1AmaZ\xA6V[[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a\x1A\x9CW\x81` \x01` \x82\x02\x806\x837\x80\x82\x01\x91PP\x90P[P\x7F\x0F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x95\x94\x93\x92\x91\x90\x97P\x97P\x97P\x97P\x97P\x97P\x97PP\x90\x91\x92\x93\x94\x95\x96V[a\x1A\xE4a/PV[_a\x1A\xEDa+\"V[\x90P_\x81_\x01`\x01\x01T\x90P_\x81\x14\x15\x80\x15a\x1B\x1CWP\x81`\x10\x01_\x82\x81R` \x01\x90\x81R` \x01_ TC\x10\x15[\x15a\x1B\x9BW~\x9F\xE8\xF0\xDBE\x99m\xEC\xF7\xB0o\xC7\xB6\xEC_\x88}_\x04\xDB.\x0CJ\xD7\xF4\xE4\xEE^\xEF\xC5\xA3\x81`@Qa\x1BO\x91\x90aT\xCCV[`@Q\x80\x91\x03\x90\xA1a\x1Bc\x82_\x01\x82a@sV[\x7F>\x8F\x02\xDCz\xF6\xE3\xA6\x7F:\xF0\xBC\x99\xBC\xF1\x1BM\xEBF\x10^\x9B\xA7\xF1\xACm\xA8#\"\xE9\x02^\x81`@Qa\x1B\x92\x91\x90aT\xCCV[`@Q\x80\x91\x03\x90\xA1[_\x82_\x01`\x02\x01T\x90P_\x81\x14\x15\x80\x15a\x1B\xC8WP\x82`\x11\x01_\x82\x81R` \x01\x90\x81R` \x01_ TC\x10\x15[\x15a\x1C\x9BW_a\x1B\xD6a\x12\xD1V[\x90P_\x84`\x14\x01_\x83\x81R` \x01\x90\x81R` \x01_ TCa\x1B\xF8\x91\x90ak#V[\x90P\x80\x85`\x12\x01_\x84\x81R` \x01\x90\x81R` \x01_ \x81\x90UPa\x1C\x1E\x85_\x01\x83aA@V[\x7F\x85\x1A\x08\xC1k\x15\x95\x9C3\x8A\xC4\xB5df\xD0l\x9F\x9D_\xF8\xD7\x15\x16\x8A\xA1%\xD5\xCC\xAFS\x83 \x82`@Qa\x1CM\x91\x90aT\xCCV[`@Q\x80\x91\x03\x90\xA1a\x1Ca\x85_\x01\x84a=\xA6V[\x7FOT\xA6\xAC\x98\x1C\xC8\xDC\x83\x14+>\xB4\xD1 \xBE|p\xFC]\xE6Gz\x14\xEA\xE3\xE9\xCAdvD\xBC\x83`@Qa\x1C\x90\x91\x90aT\xCCV[`@Q\x80\x91\x03\x90\xA1PP[_a\x1C\xA4a\x07yV[\x90P_\x81\x14a\x1D\rW\x83`\x12\x01_\x82\x81R` \x01\x90\x81R` \x01_ TC\x11\x15a\x1D\x0CWa\x1C\xD4\x84_\x01\x82aB\x16V[\x7F\x8F\xB7XX\xA5e\xAE\xE1\x174-\x93\x19j\x7F\x0BT\xC1\xC8Q\x98\x85\xED\xDD\xA6\xA0\x1FGsY\xB3c\x81`@Qa\x1D\x03\x91\x90aT\xCCV[`@Q\x80\x91\x03\x90\xA1[[PPPPV[_\x80a\x1D\x1DaC\x18V[\x90P\x80_\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x91PP\x90V[a\x1DPa.\xC9V[\x80_a\x1DZa+\"V[\x90P_\x81`\x07\x01_\x84\x81R` \x01\x90\x81R` \x01_ _\x01T\x03a\x1D\xB5W\x81`@Q\x7F\x82\xB1\xFB\xDA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x1D\xAC\x91\x90aT\xCCV[`@Q\x80\x91\x03\x90\xFD[_a\x1D\xBEa+\"V[\x90Pa\x1D\xCC\x81_\x01\x85aC?V[\x15a\x1E\x0EW\x83`@Q\x7Fw\xD0^\xA7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x1E\x05\x91\x90aT\xCCV[`@Q\x80\x91\x03\x90\xFD[a\x1E\x1A\x81_\x01\x85aC\x8EV[\x7F\xBC\x11\x14\xFA\x9Awd\x8C\xD0\x97\xEEl\xF1I\xC3D\xFA'\x8B\x9B\x98?0\xDDe\xB6\xFDj\x9DFJ\x07\x84`@Qa\x1EI\x91\x90aT\xCCV[`@Q\x80\x91\x03\x90\xA1PPPPV[`@Q\x80`@\x01`@R\x80`\x05\x81R` \x01\x7F5.0.0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81RP\x81V[_\x81_a\x1E\x9Ba+\"V[\x90P_\x81`\x07\x01_\x84\x81R` \x01\x90\x81R` \x01_ _\x01T\x03a\x1E\xF6W\x81`@Q\x7F\x82\xB1\xFB\xDA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x1E\xED\x91\x90aT\xCCV[`@Q\x80\x91\x03\x90\xFD[_a\x1E\xFFa+\"V[\x90P\x80`\x15\x01_\x86\x81R` \x01\x90\x81R` \x01_ T\x93PPPP\x91\x90PV[a\x1F'a.\xC9V[\x80_a\x1F1a+\"V[\x90P_\x81`\x07\x01_\x84\x81R` \x01\x90\x81R` \x01_ _\x01T\x03a\x1F\x8CW\x81`@Q\x7F\x82\xB1\xFB\xDA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x1F\x83\x91\x90aT\xCCV[`@Q\x80\x91\x03\x90\xFD[_a\x1F\x95a+\"V[\x90Pa\x1F\xA3\x81_\x01\x85aC?V[\x15a\x1F\xE5W\x83`@Q\x7F\xB2^N\xB3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x1F\xDC\x91\x90aT\xCCV[`@Q\x80\x91\x03\x90\xFD[a\x1F\xF1\x81_\x01\x85a@sV[\x7F>\x8F\x02\xDCz\xF6\xE3\xA6\x7F:\xF0\xBC\x99\xBC\xF1\x1BM\xEBF\x10^\x9B\xA7\xF1\xACm\xA8#\"\xE9\x02^\x84`@Qa  \x91\x90aT\xCCV[`@Q\x80\x91\x03\x90\xA1PPPPV[_\x80a 8a+\"V[\x90P\x80`\x06\x01T\x91PP\x90V[\x81_a Oa+\"V[\x90P_\x81`\x07\x01_\x84\x81R` \x01\x90\x81R` \x01_ _\x01T\x03a \xAAW\x81`@Q\x7F\x82\xB1\xFB\xDA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a \xA1\x91\x90aT\xCCV[`@Q\x80\x91\x03\x90\xFD[_a \xB3a+\"V[\x90P\x80`\x0C\x01_\x86\x81R` \x01\x90\x81R` \x01_ _\x85s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16a!SW\x84\x84`@Q\x7F\xFD\xF8\xA0]\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a!J\x92\x91\x90akVV[`@Q\x80\x91\x03\x90\xFD[PPPPPV[\x81_a!da+\"V[\x90P_\x81`\x07\x01_\x84\x81R` \x01\x90\x81R` \x01_ _\x01T\x03a!\xBFW\x81`@Q\x7F\x82\xB1\xFB\xDA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a!\xB6\x91\x90aT\xCCV[`@Q\x80\x91\x03\x90\xFD[_a!\xC8a+\"V[\x90P\x80`\r\x01_\x86\x81R` \x01\x90\x81R` \x01_ _\x85s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16a\"hW\x84\x84`@Q\x7F\x89\xB4^]\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\"_\x92\x91\x90akVV[`@Q\x80\x91\x03\x90\xFD[PPPPPV[_\x80a\"yaD\xA3V[\x90P\x80_\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x91PP\x90V[a\"\xACaTFV[_a\"\xB5a\x12\xD1V[\x90P_a\"\xC0a+\"V[\x90P_\x81`\x0B\x01_\x84\x81R` \x01\x90\x81R` \x01_ _\x86s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ `@Q\x80a\x01\0\x01`@R\x90\x81_\x82\x01\x80Ta#,\x90ac\x9FV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta#X\x90ac\x9FV[\x80\x15a#\xA3W\x80`\x1F\x10a#zWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a#\xA3V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a#\x86W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x01\x82\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01`\x02\x82\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01`\x03\x82\x01T\x81R` \x01`\x04\x82\x01\x80Ta$p\x90ac\x9FV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta$\x9C\x90ac\x9FV[\x80\x15a$\xE7W\x80`\x1F\x10a$\xBEWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a$\xE7V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a$\xCAW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x05\x82\x01\x80Ta%\0\x90ac\x9FV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta%,\x90ac\x9FV[\x80\x15a%wW\x80`\x1F\x10a%NWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a%wV[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a%ZW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x06\x82\x01\x80Ta%\x90\x90ac\x9FV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta%\xBC\x90ac\x9FV[\x80\x15a&\x07W\x80`\x1F\x10a%\xDEWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a&\x07V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a%\xEAW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x07\x82\x01\x80Ta& \x90ac\x9FV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta&L\x90ac\x9FV[\x80\x15a&\x97W\x80`\x1F\x10a&nWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a&\x97V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a&zW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81RPP\x90P_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81`@\x01Qs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x03a'\x18W\x82\x85`@Q\x7F\x04\x94\xD3\xC0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a'\x0F\x92\x91\x90akVV[`@Q\x80\x91\x03\x90\xFD[\x80\x93PPPP\x91\x90PV[a'+a.\xC9V[_a'4a+\"V[\x90P_a'?a\x08\rV[\x90P_\x81`\x80\x01QQ\x90P_\x87\x87\x90P\x90P\x81\x81\x14a'\x97W\x81\x81`@Q\x7F\xD5\x95\xA9b\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a'\x8E\x92\x91\x90ak}V[`@Q\x80\x91\x03\x90\xFD[_a'\xA0a\x07yV[\x90P_\x81\x14a'\xE6W\x80`@Q\x7Fv#\xD3W\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a'\xDD\x91\x90aT\xCCV[`@Q\x80\x91\x03\x90\xFD[_a'\xF8\x85_\x01Q\x8E\x8D\x8D\x8D\x8Ca4XV[\x90P\x87`@\x015\x86`\x14\x01_\x87_\x01Q\x81R` \x01\x90\x81R` \x01_ \x81\x90UP\x7F\xA6\x9AL\x93A\xCD}E\x8F\xDE\x12\xC3\x1A\x1FX/}L\xAE\xDB'\xC4\xA7\xC3L\xC9\x92 \x8A<\xE4\xC5\x85\x82\x8A`@Qa(L\x93\x92\x91\x90ak\xFCV[`@Q\x80\x91\x03\x90\xA1a(c\x86_\x01\x82_\x01QaD\xCAV[\x8B\x15a(\xF6W\x87_\x015\x86`\x13\x01_\x83_\x01Q\x81R` \x01\x90\x81R` \x01_ \x81\x90UP_\x88` \x015Ca(\x98\x91\x90ak#V[\x90P\x80\x87`\x10\x01_\x84_\x01Q\x81R` \x01\x90\x81R` \x01_ \x81\x90UP\x7F]\xC6\x01\x06Z\x03]x0\\\xD9\xEF'\xC9\x1A\0\x9C\xD8\xD3r\x97\xE4;\xB7c\x19I\x08\x95\xA0\xD0X\x86\x83\x83`@Qa(\xE8\x93\x92\x91\x90al?V[`@Q\x80\x91\x03\x90\xA1Pa)\x04V[a)\x03\x81\x89_\x015a.FV[[PPPPPPPPPPPPPV[a)\x1Ba.\xC9V[a)#a/PV[_a),a\x08\rV[\x90Pa)A\x81_\x01Q\x83\x83`\x80\x01QQaE\x97V[\x7F\x83~\ne(\xDA\xDF\xA2\xDCy&\x92\xC5\x18.R\xA9\xF5\xBB\xDE\xED{#r\x92z&\xC6\x95\x83\x96\x13\x82`@Qa)p\x91\x90aT\xCCV[`@Q\x80\x91\x03\x90\xA1PPV[a)\x84a.\xC9V[_a)\x8Da+\"V[\x90P_a)\x98a\x07yV[\x90P_\x81\x03a)\xD3W`@Q\x7F ~\xA3\xF3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_a)\xDCa\x12\xD1V[\x90Pa)\xEA\x83_\x01\x82aB\x16V[\x7F\x8F\xB7XX\xA5e\xAE\xE1\x174-\x93\x19j\x7F\x0BT\xC1\xC8Q\x98\x85\xED\xDD\xA6\xA0\x1FGsY\xB3c\x81`@Qa*\x19\x91\x90aT\xCCV[`@Q\x80\x91\x03\x90\xA1a*-\x83_\x01\x83a=\xA6V[\x7FOT\xA6\xAC\x98\x1C\xC8\xDC\x83\x14+>\xB4\xD1 \xBE|p\xFC]\xE6Gz\x14\xEA\xE3\xE9\xCAdvD\xBC\x82`@Qa*\\\x91\x90aT\xCCV[`@Q\x80\x91\x03\x90\xA1PPPV[a*qa.\xC9V[_a*zaD\xA3V[\x90P\x81\x81_\x01_a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a*\xDCa\x1D\x13V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F8\xD1k\x8C\xAC\"\xD9\x9F\xC7\xC1$\xB9\xCD\r\xE2\xD3\xFA\x1F\xAE\xF4 \xBF\xE7\x91\xD8\xC3b\xD7e\xE2'\0`@Q`@Q\x80\x91\x03\x90\xA3PPV[_\x7F}\x81Y\x81\n~\xBF\x94N\x8F\xA9<\xC4\xFB\xD1\xCA\xDElq\xF8\xB0\xB8k7\x18z\xC7\x99\x17w\xB1\0\x90P\x90V[``_`\x01a+W\x84aF@V[\x01\x90P_\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a+uWa+taZ\xA6V[[`@Q\x90\x80\x82R\x80`\x1F\x01`\x1F\x19\x16` \x01\x82\x01`@R\x80\x15a+\xA7W\x81` \x01`\x01\x82\x02\x806\x837\x80\x82\x01\x91PP\x90P[P\x90P_\x82` \x01\x82\x01\x90P[`\x01\x15a,\x08W\x80\x80`\x01\x90\x03\x91PP\x7F0123456789abcdef\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\n\x86\x06\x1A\x81S`\n\x85\x81a+\xFDWa+\xFCal\x82V[[\x04\x94P_\x85\x03a+\xB4W[\x81\x93PPPP\x91\x90PV[_`\x01`\x07\x81\x11\x15a,(Wa,'aY\xECV[[\x83_\x01_\x84\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16`\x07\x81\x11\x15a,YWa,XaY\xECV[[\x14\x90P\x92\x91PPV[_a,\xB6`@Q\x80``\x01`@R\x80`+\x81R` \x01atm`+\x919\x80Q\x90` \x01 \x83_\x01Q`@Q` \x01a,\x9B\x92\x91\x90al\xAFV[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 aG\x91V[\x90P\x91\x90PV[_a,\xC6a+\"V[\x90P_a-\x16\x85\x85\x85\x80\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x93\x92\x91\x90\x81\x81R` \x01\x83\x83\x80\x82\x847_\x81\x84\x01R`\x1F\x19`\x1F\x82\x01\x16\x90P\x80\x83\x01\x92PPPPPPPaG\xAAV[\x90Pa-\"\x86\x82a!ZV[\x81`\t\x01_\x87\x81R` \x01\x90\x81R` \x01_ _\x82s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x15a-\xC1W\x85\x81`@Q\x7F\x99\xB1X\xC1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a-\xB8\x92\x91\x90akVV[`@Q\x80\x91\x03\x90\xFD[`\x01\x82`\t\x01_\x88\x81R` \x01\x90\x81R` \x01_ _\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UPPPPPPPV[_\x80\x83`\x80\x01QQ\x90P\x80\x83\x10\x15\x91PP\x92\x91PPV[_a.Oa+\"V[\x90Pa.`\x81_\x01\x84_\x01QaG\xD4V[_\x82Ca.m\x91\x90ak#V[\x90P\x80\x82`\x11\x01_\x86_\x01Q\x81R` \x01\x90\x81R` \x01_ \x81\x90UP\x7FE@\xF7\x80\x8F\xCA\xEC\x86\xC3v\xA8\x9D,\x0C\x93\xA5\x05l!h\r\xB5C2\xC7\xF2\x95\x9D\x87\xFE\xFC\x8B\x84\x82`@Qa.\xBB\x92\x91\x90al\xD6V[`@Q\x80\x91\x03\x90\xA1PPPPV[a.\xD1a3\xCAV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a.\xEFa\x1D\x13V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a/NWa/\x12a3\xCAV[`@Q\x7F\x11\x8C\xDA\xA7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a/E\x91\x90a_\xE8V[`@Q\x80\x91\x03\x90\xFD[V[a/Xa\x13qV[\x15a/\x8FW`@Q\x7F\xD9<\x06e\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[V[_a/\x9Aa+\"V[\x90P_\x83\x03a/\xD5W`@Q\x7F\xB1\xAE\x92\xEA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x81\x83\x11\x15a0\x1CW\x82\x82`@Q\x7F\x84 \x8F#\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a0\x13\x92\x91\x90ak}V[`@Q\x80\x91\x03\x90\xFD[\x82\x81`\x15\x01_\x86\x81R` \x01\x90\x81R` \x01_ \x81\x90UPPPPPV[a0BaH\xAAV[_a0Ka3fV[\x90P_\x81_\x01_a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP\x7F]\xB9\xEE\nI[\xF2\xE6\xFF\x9C\x91\xA7\x83L\x1B\xA4\xFD\xD2D\xA5\xE8\xAANS{\xD3\x8A\xEA\xE4\xB0s\xAAa0\x90a3\xCAV[`@Qa0\x9D\x91\x90a_\xE8V[`@Q\x80\x91\x03\x90\xA1PV[_\x82_\x01_\x83\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x90P\x92\x91PPV[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x160s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14\x80a1}WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a1daH\xEAV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14\x15[\x15a1\xB4W`@Q\x7F\xE0|\x8D\xBA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[V[a1\xBEa.\xC9V[PV[\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16cR\xD1\x90-`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x92PPP\x80\x15a2)WP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a2&\x91\x90am.V[`\x01[a2jW\x81`@Q\x7FL\x9C\x8C\xE3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a2a\x91\x90a_\xE8V[`@Q\x80\x91\x03\x90\xFD[\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC_\x1B\x81\x14a2\xD0W\x80`@Q\x7F\xAA\x1DI\xA4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a2\xC7\x91\x90a\\<V[`@Q\x80\x91\x03\x90\xFD[a2\xDA\x83\x83aI=V[PPPV[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x160s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a3dW`@Q\x7F\xE0|\x8D\xBA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[V[_\x7F\xCD^\xD1\\n\x18~w\xE9\xAE\xE8\x81\x84\xC2\x1FO!\x82\xABX'\xCB;~\x07\xFB\xED\xCDc\xF03\0\x90P\x90V[_a3\x96aD\xA3V[\x90P\x80_\x01_a\x01\0\n\x81T\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90Ua3\xC6\x82aI\xAFV[PPV[_3\x90P\x90V[_a3\xDAa3\xF5V[_\x01_\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P\x90V[_\x7F\xF0\xC5~\x16\x84\r\xF0@\xF1P\x88\xDC/\x81\xFE9\x1C9#\xBE\xC7>#\xA9f.\xFC\x9C\"\x9Cj\0\x90P\x90V[a4$aJ\x80V[a4.\x82\x82aJ\xC0V[PPV[a4:aJ\x80V[a4C\x81aK\x11V[PV[a4NaJ\x80V[a4VaK\x95V[V[a4`aT\0V[_a4ia+\"V[\x90P_\x85\x85\x90P\x03a4\xA7W`@Q\x7F\x06\x8C\x8D@\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x80`\x08\x01_\x81T\x80\x92\x91\x90a4\xBB\x90amYV[\x91\x90PUP_\x81`\x08\x01T\x90P\x80\x82`\x07\x01_\x83\x81R` \x01\x90\x81R` \x01_ _\x01\x81\x90UP\x88\x82`\x07\x01_\x83\x81R` \x01\x90\x81R` \x01_ `\x01\x01\x81\x90UP\x87\x82`\x07\x01_\x83\x81R` \x01\x90\x81R` \x01_ `\x02\x01_a\x01\0\n\x81T\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83`\xC0\x1C\x02\x17\x90UPa5@\x81\x88\x88\x88\x90PaK\xC5V[_[\x86\x86\x90P\x81\x10\x15a5\xC9W\x82`\x07\x01_\x83\x81R` \x01\x90\x81R` \x01_ `\x04\x01\x87\x87\x83\x81\x81\x10a5vWa5uam\xA0V[[\x90P` \x02\x81\x01\x90a5\x88\x91\x90am\xD9V[\x90\x80`\x01\x81T\x01\x80\x82U\x80\x91PP`\x01\x90\x03\x90_R` _ \x90`\x08\x02\x01_\x90\x91\x90\x91\x90\x91P\x81\x81a5\xBA\x91\x90ar[V[PP\x80\x80`\x01\x01\x91PPa5BV[P_[\x86\x86\x90P\x81\x10\x15a9\"W\x86\x86\x82\x81\x81\x10a5\xEAWa5\xE9am\xA0V[[\x90P` \x02\x81\x01\x90a5\xFC\x91\x90am\xD9V[\x83`\x0B\x01_\x84\x81R` \x01\x90\x81R` \x01_ _\x89\x89\x85\x81\x81\x10a6#Wa6\"am\xA0V[[\x90P` \x02\x81\x01\x90a65\x91\x90am\xD9V[`@\x01` \x81\x01\x90a6G\x91\x90a`?V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ \x81\x81a6\x8C\x91\x90ar[V[\x90PP`\x01\x83`\x0C\x01_\x84\x81R` \x01\x90\x81R` \x01_ _\x89\x89\x85\x81\x81\x10a6\xB8Wa6\xB7am\xA0V[[\x90P` \x02\x81\x01\x90a6\xCA\x91\x90am\xD9V[`@\x01` \x81\x01\x90a6\xDC\x91\x90a`?V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP\x82`\x0E\x01_\x83\x81R` \x01\x90\x81R` \x01_ \x87\x87\x83\x81\x81\x10a7QWa7Pam\xA0V[[\x90P` \x02\x81\x01\x90a7c\x91\x90am\xD9V[`@\x01` \x81\x01\x90a7u\x91\x90a`?V[\x90\x80`\x01\x81T\x01\x80\x82U\x80\x91PP`\x01\x90\x03\x90_R` _ \x01_\x90\x91\x90\x91\x90\x91a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP`\x01\x83`\r\x01_\x84\x81R` \x01\x90\x81R` \x01_ _\x89\x89\x85\x81\x81\x10a7\xFBWa7\xFAam\xA0V[[\x90P` \x02\x81\x01\x90a8\r\x91\x90am\xD9V[` \x01` \x81\x01\x90a8\x1F\x91\x90a`?V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP\x82`\x0F\x01_\x83\x81R` \x01\x90\x81R` \x01_ \x87\x87\x83\x81\x81\x10a8\x94Wa8\x93am\xA0V[[\x90P` \x02\x81\x01\x90a8\xA6\x91\x90am\xD9V[` \x01` \x81\x01\x90a8\xB8\x91\x90a`?V[\x90\x80`\x01\x81T\x01\x80\x82U\x80\x91PP`\x01\x90\x03\x90_R` _ \x01_\x90\x91\x90\x91\x90\x91a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP\x80\x80`\x01\x01\x91PPa5\xCCV[Pa91\x81\x85\x88\x88\x90PaL9V[\x81`\x07\x01_\x82\x81R` \x01\x90\x81R` \x01_ `@Q\x80`\xA0\x01`@R\x90\x81_\x82\x01T\x81R` \x01`\x01\x82\x01T\x81R` \x01`\x02\x82\x01_\x90T\x90a\x01\0\n\x90\x04`\xC0\x1Bw\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16w\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x81R` \x01`\x03\x82\x01T\x81R` \x01`\x04\x82\x01\x80T\x80` \x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01_\x90[\x82\x82\x10\x15a=\x90W\x83\x82\x90_R` _ \x90`\x08\x02\x01`@Q\x80a\x01\0\x01`@R\x90\x81_\x82\x01\x80Ta:\r\x90ac\x9FV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta:9\x90ac\x9FV[\x80\x15a:\x84W\x80`\x1F\x10a:[Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a:\x84V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a:gW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x01\x82\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01`\x02\x82\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01`\x03\x82\x01T\x81R` \x01`\x04\x82\x01\x80Ta;Q\x90ac\x9FV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta;}\x90ac\x9FV[\x80\x15a;\xC8W\x80`\x1F\x10a;\x9FWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a;\xC8V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a;\xABW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x05\x82\x01\x80Ta;\xE1\x90ac\x9FV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta<\r\x90ac\x9FV[\x80\x15a<XW\x80`\x1F\x10a</Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a<XV[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a<;W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x06\x82\x01\x80Ta<q\x90ac\x9FV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta<\x9D\x90ac\x9FV[\x80\x15a<\xE8W\x80`\x1F\x10a<\xBFWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a<\xE8V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a<\xCBW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x07\x82\x01\x80Ta=\x01\x90ac\x9FV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta=-\x90ac\x9FV[\x80\x15a=xW\x80`\x1F\x10a=OWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a=xV[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a=[W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81RPP\x81R` \x01\x90`\x01\x01\x90a9\xDCV[PPPP\x81RPP\x92PPP\x96\x95PPPPPPV[\x80_\x81\x03a=\xE0W`@Q\x7F\xCB\x17\xB7\xA5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a=\xEA\x83\x83aL[V[\x15\x80\x15a=\xFEWPa=\xFC\x83\x83aL\xAAV[\x15[\x80\x15a>\x0EWP_\x83`\x03\x01T\x14\x15[\x15a>PW\x81`@Q\x7F\x12\xB4\x9E=\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a>G\x91\x90aT\xCCV[`@Q\x80\x91\x03\x90\xFD[`\x03\x83_\x01_\x84\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83`\x07\x81\x11\x15a>\x85Wa>\x84aY\xECV[[\x02\x17\x90UP\x81\x83`\x03\x01\x81\x90UP_\x83`\x02\x01\x81\x90UPPPPV[a>\xA9a/PV[_a>\xB2a3fV[\x90P`\x01\x81_\x01_a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP\x7Fb\xE7\x8C\xEA\x01\xBE\xE3 \xCDNB\x02p\xB5\xEAt\0\r\x11\xB0\xC9\xF7GT\xEB\xDB\xFCTK\x05\xA2Xa>\xF8a3\xCAV[`@Qa?\x05\x91\x90a_\xE8V[`@Q\x80\x91\x03\x90\xA1PV[_\x7F\xA1jF\xD9Ba\xC7Q|\xC8\xFF\x89\xF6\x1C\x0C\xE95\x98\xE3\xC8I\x80\x10\x11\xDE\xE6I\xA6\xA5W\xD1\0\x90P\x90V[``_a?Ba?\x10V[\x90P\x80`\x02\x01\x80Ta?S\x90ac\x9FV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta?\x7F\x90ac\x9FV[\x80\x15a?\xCAW\x80`\x1F\x10a?\xA1Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a?\xCAV[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a?\xADW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x91PP\x90V[``_a?\xE0a?\x10V[\x90P\x80`\x03\x01\x80Ta?\xF1\x90ac\x9FV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta@\x1D\x90ac\x9FV[\x80\x15a@hW\x80`\x1F\x10a@?Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a@hV[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a@KW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x91PP\x90V[\x80_\x81\x03a@\xADW`@Q\x7F\xCB\x17\xB7\xA5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x07\x83_\x01_\x84\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83`\x07\x81\x11\x15a@\xE2Wa@\xE1aY\xECV[[\x02\x17\x90UP\x81\x83`\x01\x01T\x03a@\xFCW_\x83`\x01\x01\x81\x90UP[\x81\x83`\x02\x01T\x03aA\x11W_\x83`\x02\x01\x81\x90UP[\x81\x83`\x03\x01T\x03aA&W_\x83`\x03\x01\x81\x90UP[\x81\x83`\x04\x01T\x03aA;W_\x83`\x04\x01\x81\x90UP[PPPV[\x80_\x81\x03aAzW`@Q\x7F\xCB\x17\xB7\xA5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[aA\x84\x83\x83aC?V[aA\xC5W\x81`@Q\x7F3\x14\x86\xB3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aA\xBC\x91\x90aT\xCCV[`@Q\x80\x91\x03\x90\xFD[`\x04\x83_\x01_\x84\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83`\x07\x81\x11\x15aA\xFAWaA\xF9aY\xECV[[\x02\x17\x90UP\x81\x83`\x04\x01\x81\x90UP_\x83`\x03\x01\x81\x90UPPPPV[\x80_\x81\x03aBPW`@Q\x7F\xCB\x17\xB7\xA5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[aBZ\x83\x83aC?V[\x15\x80aBmWPaBk\x83\x83aL\xAAV[\x15[\x15aB\xAFW\x81`@Q\x7F+6R\xD1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aB\xA6\x91\x90aT\xCCV[`@Q\x80\x91\x03\x90\xFD[`\x05\x83_\x01_\x84\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83`\x07\x81\x11\x15aB\xE4WaB\xE3aY\xECV[[\x02\x17\x90UP\x81\x83`\x03\x01T\x03aB\xFEW_\x83`\x03\x01\x81\x90UP[\x81\x83`\x04\x01T\x03aC\x13W_\x83`\x04\x01\x81\x90UP[PPPV[_\x7F\x90\x16\xD0\x9Dr\xD4\x0F\xDA\xE2\xFD\x8C\xEA\xC6\xB6#Lw\x06!O\xD3\x9C\x1C\xD1\xE6\t\xA0R\x8C\x19\x93\0\x90P\x90V[_`\x03`\x07\x81\x11\x15aCTWaCSaY\xECV[[\x83_\x01_\x84\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16`\x07\x81\x11\x15aC\x85WaC\x84aY\xECV[[\x14\x90P\x92\x91PPV[\x80_\x81\x03aC\xC8W`@Q\x7F\xCB\x17\xB7\xA5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[aC\xD2\x83\x83aL\xF9V[\x80aC\xE3WPaC\xE2\x83\x83a,\x13V[[\x15aD%W\x81`@Q\x7F\xB0\xC5\x15\x1D\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aD\x1C\x91\x90aT\xCCV[`@Q\x80\x91\x03\x90\xFD[`\x06\x83_\x01_\x84\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83`\x07\x81\x11\x15aDZWaDYaY\xECV[[\x02\x17\x90UP\x81\x83`\x02\x01T\x03aDtW_\x83`\x02\x01\x81\x90UP[\x81\x83`\x03\x01T\x03aD\x89W_\x83`\x03\x01\x81\x90UP[\x81\x83`\x04\x01T\x03aD\x9EW_\x83`\x04\x01\x81\x90UP[PPPV[_\x7F#~\x15\x82\"\xE3\xE6\x96\x8Br\xB9\xDB\r\x80C\xAA\xCF\x07J\xD9\xF6P\xF0\xD1`kM\x82\xEEC,\0\x90P\x90V[\x80_\x81\x03aE\x04W`@Q\x7F\xCB\x17\xB7\xA5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[aE\x0E\x83\x83aL\xF9V[aEOW\x81`@Q\x7FfS\xF6\xD7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aEF\x91\x90aT\xCCV[`@Q\x80\x91\x03\x90\xFD[`\x01\x83_\x01_\x84\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83`\x07\x81\x11\x15aE\x84WaE\x83aY\xECV[[\x02\x17\x90UP\x81\x83`\x01\x01\x81\x90UPPPPV[_aE\xA0a+\"V[\x90P_\x83\x03aE\xDBW`@Q\x7F\xE6\nrq\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x81\x83\x11\x15aF\"W\x82\x82`@Q\x7F\xD2S^\x11\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aF\x19\x92\x91\x90ak}V[`@Q\x80\x91\x03\x90\xFD[\x82\x81`\x16\x01_\x86\x81R` \x01\x90\x81R` \x01_ \x81\x90UPPPPPV[_\x80_\x90Pz\x18O\x03\xE9?\xF9\xF4\xDA\xA7\x97\xEDn8\xEDd\xBFj\x1F\x01\0\0\0\0\0\0\0\0\x83\x10aF\x9CWz\x18O\x03\xE9?\xF9\xF4\xDA\xA7\x97\xEDn8\xEDd\xBFj\x1F\x01\0\0\0\0\0\0\0\0\x83\x81aF\x92WaF\x91al\x82V[[\x04\x92P`@\x81\x01\x90P[m\x04\xEE-mA[\x85\xAC\xEF\x81\0\0\0\0\x83\x10aF\xD9Wm\x04\xEE-mA[\x85\xAC\xEF\x81\0\0\0\0\x83\x81aF\xCFWaF\xCEal\x82V[[\x04\x92P` \x81\x01\x90P[f#\x86\xF2o\xC1\0\0\x83\x10aG\x08Wf#\x86\xF2o\xC1\0\0\x83\x81aF\xFEWaF\xFDal\x82V[[\x04\x92P`\x10\x81\x01\x90P[c\x05\xF5\xE1\0\x83\x10aG1Wc\x05\xF5\xE1\0\x83\x81aG'WaG&al\x82V[[\x04\x92P`\x08\x81\x01\x90P[a'\x10\x83\x10aGVWa'\x10\x83\x81aGLWaGKal\x82V[[\x04\x92P`\x04\x81\x01\x90P[`d\x83\x10aGyW`d\x83\x81aGoWaGnal\x82V[[\x04\x92P`\x02\x81\x01\x90P[`\n\x83\x10aG\x88W`\x01\x81\x01\x90P[\x80\x91PP\x91\x90PV[_aG\xA3aG\x9DaMGV[\x83aMUV[\x90P\x91\x90PV[_\x80_\x80aG\xB8\x86\x86aM\x95V[\x92P\x92P\x92PaG\xC8\x82\x82aM\xEAV[\x82\x93PPPP\x92\x91PPV[\x80_\x81\x03aH\x0EW`@Q\x7F\xCB\x17\xB7\xA5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[aH\x18\x83\x83a,\x13V[aHYW\x81`@Q\x7F\xC0\xB5\xEEf\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aHP\x91\x90aT\xCCV[`@Q\x80\x91\x03\x90\xFD[`\x02\x83_\x01_\x84\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83`\x07\x81\x11\x15aH\x8EWaH\x8DaY\xECV[[\x02\x17\x90UP\x81\x83`\x02\x01\x81\x90UP_\x83`\x01\x01\x81\x90UPPPPV[aH\xB2a\x13qV[aH\xE8W`@Q\x7F\x8D\xFC +\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[V[_aI\x16\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC_\x1BaOLV[_\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P\x90V[aIF\x82aOUV[\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xBC|\xD7Z \xEE'\xFD\x9A\xDE\xBA\xB3 A\xF7U!M\xBCk\xFF\xA9\x0C\xC0\"[9\xDA.\\-;`@Q`@Q\x80\x91\x03\x90\xA2_\x81Q\x11\x15aI\xA2WaI\x9C\x82\x82aP\x1EV[PaI\xABV[aI\xAAaP\x9EV[[PPV[_aI\xB8aC\x18V[\x90P_\x81_\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P\x82\x82_\x01_a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP\x82s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\x8B\xE0\x07\x9CS\x16Y\x14\x13D\xCD\x1F\xD0\xA4\xF2\x84\x19I\x7F\x97\"\xA3\xDA\xAF\xE3\xB4\x18okdW\xE0`@Q`@Q\x80\x91\x03\x90\xA3PPPV[aJ\x88aP\xDAV[aJ\xBEW`@Q\x7F\xD7\xE6\xBC\xF8\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[V[aJ\xC8aJ\x80V[_aJ\xD1a?\x10V[\x90P\x82\x81`\x02\x01\x90\x81aJ\xE4\x91\x90ariV[P\x81\x81`\x03\x01\x90\x81aJ\xF6\x91\x90ariV[P_\x80\x1B\x81_\x01\x81\x90UP_\x80\x1B\x81`\x01\x01\x81\x90UPPPPV[aK\x19aJ\x80V[_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x03aK\x89W_`@Q\x7F\x1EO\xBD\xF7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aK\x80\x91\x90a_\xE8V[`@Q\x80\x91\x03\x90\xFD[aK\x92\x81a3\x8DV[PV[aK\x9DaJ\x80V[_aK\xA6a3fV[\x90P_\x81_\x01_a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UPPV[_aK\xCEa+\"V[\x90P\x81\x83\x10aL\x18W\x83\x83\x83`@Q\x7F\x87\x89\xA6\xCA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aL\x0F\x93\x92\x91\x90as8V[`@Q\x80\x91\x03\x90\xFD[\x82\x81`\x07\x01_\x86\x81R` \x01\x90\x81R` \x01_ `\x03\x01\x81\x90UPPPPPV[aLG\x83\x83_\x015\x83a/\x91V[aLV\x83\x83` \x015\x83aE\x97V[PPPV[_`\x02`\x07\x81\x11\x15aLpWaLoaY\xECV[[\x83_\x01_\x84\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16`\x07\x81\x11\x15aL\xA1WaL\xA0aY\xECV[[\x14\x90P\x92\x91PPV[_`\x04`\x07\x81\x11\x15aL\xBFWaL\xBEaY\xECV[[\x83_\x01_\x84\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16`\x07\x81\x11\x15aL\xF0WaL\xEFaY\xECV[[\x14\x90P\x92\x91PPV[_\x80`\x07\x81\x11\x15aM\rWaM\x0CaY\xECV[[\x83_\x01_\x84\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16`\x07\x81\x11\x15aM>WaM=aY\xECV[[\x14\x90P\x92\x91PPV[_aMPaP\xF8V[\x90P\x90V[_`@Q\x7F\x19\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R\x83`\x02\x82\x01R\x82`\"\x82\x01R`B\x81 \x91PP\x92\x91PPV[_\x80_`A\x84Q\x03aM\xD5W_\x80_` \x87\x01Q\x92P`@\x87\x01Q\x91P``\x87\x01Q_\x1A\x90PaM\xC7\x88\x82\x85\x85aQ[V[\x95P\x95P\x95PPPPaM\xE3V[_`\x02\x85Q_\x1B\x92P\x92P\x92P[\x92P\x92P\x92V[_`\x03\x81\x11\x15aM\xFDWaM\xFCaY\xECV[[\x82`\x03\x81\x11\x15aN\x10WaN\x0FaY\xECV[[\x03\x15aOHW`\x01`\x03\x81\x11\x15aN*WaN)aY\xECV[[\x82`\x03\x81\x11\x15aN=WaN<aY\xECV[[\x03aNtW`@Q\x7F\xF6E\xEE\xDF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x02`\x03\x81\x11\x15aN\x88WaN\x87aY\xECV[[\x82`\x03\x81\x11\x15aN\x9BWaN\x9AaY\xECV[[\x03aN\xDFW\x80_\x1C`@Q\x7F\xFC\xE6\x98\xF7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aN\xD6\x91\x90aT\xCCV[`@Q\x80\x91\x03\x90\xFD[`\x03\x80\x81\x11\x15aN\xF2WaN\xF1aY\xECV[[\x82`\x03\x81\x11\x15aO\x05WaO\x04aY\xECV[[\x03aOGW\x80`@Q\x7F\xD7\x8B\xCE\x0C\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aO>\x91\x90a\\<V[`@Q\x80\x91\x03\x90\xFD[[PPV[_\x81\x90P\x91\x90PV[_\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16;\x03aO\xB0W\x80`@Q\x7FL\x9C\x8C\xE3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aO\xA7\x91\x90a_\xE8V[`@Q\x80\x91\x03\x90\xFD[\x80aO\xDC\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC_\x1BaOLV[_\x01_a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UPPV[``_\x80\x84s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x84`@QaPG\x91\x90as\xA7V[_`@Q\x80\x83\x03\x81\x85Z\xF4\x91PP=\x80_\x81\x14aP\x7FW`@Q\x91P`\x1F\x19`?=\x01\x16\x82\x01`@R=\x82R=_` \x84\x01>aP\x84V[``\x91P[P\x91P\x91PaP\x94\x85\x83\x83aRBV[\x92PPP\x92\x91PPV[_4\x11\x15aP\xD8W`@Q\x7F\xB3\x98\x97\x9F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[V[_aP\xE3a3\xF5V[_\x01`\x08\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x90P\x90V[_\x7F\x8Bs\xC3\xC6\x9B\xB8\xFE=Q.\xCCL\xF7Y\xCCy#\x9F{\x17\x9B\x0F\xFA\xCA\xA9\xA7]R+9@\x0FaQ\"aR\xCFV[aQ*aSEV[F0`@Q` \x01aQ@\x95\x94\x93\x92\x91\x90as\xBDV[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x90P\x90V[_\x80_\x7F\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF]WnsW\xA4P\x1D\xDF\xE9/Fh\x1B \xA0\x84_\x1C\x11\x15aQ\x97W_`\x03\x85\x92P\x92P\x92PaR8V[_`\x01\x88\x88\x88\x88`@Q_\x81R` \x01`@R`@QaQ\xBA\x94\x93\x92\x91\x90at)V[` `@Q` \x81\x03\x90\x80\x84\x03\x90\x85Z\xFA\x15\x80\x15aQ\xDAW=_\x80>=_\xFD[PPP` `@Q\x03Q\x90P_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x03aR+W_`\x01_\x80\x1B\x93P\x93P\x93PPaR8V[\x80_\x80_\x1B\x93P\x93P\x93PP[\x94P\x94P\x94\x91PPV[``\x82aRWWaRR\x82aS\xBCV[aR\xC7V[_\x82Q\x14\x80\x15aR}WP_\x84s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16;\x14[\x15aR\xBFW\x83`@Q\x7F\x99\x96\xB3\x15\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aR\xB6\x91\x90a_\xE8V[`@Q\x80\x91\x03\x90\xFD[\x81\x90PaR\xC8V[[\x93\x92PPPV[_\x80aR\xD9a?\x10V[\x90P_aR\xE4a?7V[\x90P_\x81Q\x11\x15aS\0W\x80\x80Q\x90` \x01 \x92PPPaSBV[_\x82_\x01T\x90P_\x80\x1B\x81\x14aS\x1BW\x80\x93PPPPaSBV[\x7F\xC5\xD2F\x01\x86\xF7#<\x92~}\xB2\xDC\xC7\x03\xC0\xE5\0\xB6S\xCA\x82';{\xFA\xD8\x04]\x85\xA4p\x93PPPP[\x90V[_\x80aSOa?\x10V[\x90P_aSZa?\xD5V[\x90P_\x81Q\x11\x15aSvW\x80\x80Q\x90` \x01 \x92PPPaS\xB9V[_\x82`\x01\x01T\x90P_\x80\x1B\x81\x14aS\x92W\x80\x93PPPPaS\xB9V[\x7F\xC5\xD2F\x01\x86\xF7#<\x92~}\xB2\xDC\xC7\x03\xC0\xE5\0\xB6S\xCA\x82';{\xFA\xD8\x04]\x85\xA4p\x93PPPP[\x90V[_\x81Q\x11\x15aS\xCEW\x80Q\x80\x82` \x01\xFD[`@Q\x7F\xD6\xBD\xA2u\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`@Q\x80`\xA0\x01`@R\x80_\x81R` \x01_\x81R` \x01_w\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x81R` \x01_\x81R` \x01``\x81RP\x90V[`@Q\x80a\x01\0\x01`@R\x80``\x81R` \x01_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01_\x81R` \x01``\x81R` \x01``\x81R` \x01``\x81R` \x01``\x81RP\x90V[_\x81\x90P\x91\x90PV[aT\xC6\x81aT\xB4V[\x82RPPV[_` \x82\x01\x90PaT\xDF_\x83\x01\x84aT\xBDV[\x92\x91PPV[_\x81Q\x90P\x91\x90PV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[_[\x83\x81\x10\x15aU\x1CW\x80\x82\x01Q\x81\x84\x01R` \x81\x01\x90PaU\x01V[_\x84\x84\x01RPPPPV[_`\x1F\x19`\x1F\x83\x01\x16\x90P\x91\x90PV[_aUA\x82aT\xE5V[aUK\x81\x85aT\xEFV[\x93PaU[\x81\x85` \x86\x01aT\xFFV[aUd\x81aU'V[\x84\x01\x91PP\x92\x91PPV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01RaU\x87\x81\x84aU7V[\x90P\x92\x91PPV[aU\x98\x81aT\xB4V[\x82RPPV[_\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\x16\x90P\x91\x90PV[aU\xD2\x81aU\x9EV[\x82RPPV[_\x81Q\x90P\x91\x90PV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[_\x81\x90P` \x82\x01\x90P\x91\x90PV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[_aV\x1B\x82aT\xE5V[aV%\x81\x85aV\x01V[\x93PaV5\x81\x85` \x86\x01aT\xFFV[aV>\x81aU'V[\x84\x01\x91PP\x92\x91PPV[_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[_aVr\x82aVIV[\x90P\x91\x90PV[aV\x82\x81aVhV[\x82RPPV[_\x81Q\x90P\x91\x90PV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[_aV\xAC\x82aV\x88V[aV\xB6\x81\x85aV\x92V[\x93PaV\xC6\x81\x85` \x86\x01aT\xFFV[aV\xCF\x81aU'V[\x84\x01\x91PP\x92\x91PPV[_a\x01\0\x83\x01_\x83\x01Q\x84\x82\x03_\x86\x01RaV\xF5\x82\x82aV\x11V[\x91PP` \x83\x01QaW\n` \x86\x01\x82aVyV[P`@\x83\x01QaW\x1D`@\x86\x01\x82aVyV[P``\x83\x01QaW0``\x86\x01\x82aU\x8FV[P`\x80\x83\x01Q\x84\x82\x03`\x80\x86\x01RaWH\x82\x82aV\xA2V[\x91PP`\xA0\x83\x01Q\x84\x82\x03`\xA0\x86\x01RaWb\x82\x82aV\x11V[\x91PP`\xC0\x83\x01Q\x84\x82\x03`\xC0\x86\x01RaW|\x82\x82aV\x11V[\x91PP`\xE0\x83\x01Q\x84\x82\x03`\xE0\x86\x01RaW\x96\x82\x82aV\xA2V[\x91PP\x80\x91PP\x92\x91PPV[_aW\xAE\x83\x83aV\xDAV[\x90P\x92\x91PPV[_` \x82\x01\x90P\x91\x90PV[_aW\xCC\x82aU\xD8V[aW\xD6\x81\x85aU\xE2V[\x93P\x83` \x82\x02\x85\x01aW\xE8\x85aU\xF2V[\x80_[\x85\x81\x10\x15aX#W\x84\x84\x03\x89R\x81QaX\x04\x85\x82aW\xA3V[\x94PaX\x0F\x83aW\xB6V[\x92P` \x8A\x01\x99PP`\x01\x81\x01\x90PaW\xEBV[P\x82\x97P\x87\x95PPPPPP\x92\x91PPV[_`\xA0\x83\x01_\x83\x01QaXJ_\x86\x01\x82aU\x8FV[P` \x83\x01QaX]` \x86\x01\x82aU\x8FV[P`@\x83\x01QaXp`@\x86\x01\x82aU\xC9V[P``\x83\x01QaX\x83``\x86\x01\x82aU\x8FV[P`\x80\x83\x01Q\x84\x82\x03`\x80\x86\x01RaX\x9B\x82\x82aW\xC2V[\x91PP\x80\x91PP\x92\x91PPV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01RaX\xC0\x81\x84aX5V[\x90P\x92\x91PPV[_`@Q\x90P\x90V[_\x80\xFD[_\x80\xFD[aX\xE2\x81aT\xB4V[\x81\x14aX\xECW_\x80\xFD[PV[_\x815\x90PaX\xFD\x81aX\xD9V[\x92\x91PPV[_\x80\xFD[_\x80\xFD[_\x80\xFD[_\x80\x83`\x1F\x84\x01\x12aY$WaY#aY\x03V[[\x825\x90Pg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15aYAWaY@aY\x07V[[` \x83\x01\x91P\x83`\x01\x82\x02\x83\x01\x11\x15aY]WaY\\aY\x0BV[[\x92P\x92\x90PV[_\x80_`@\x84\x86\x03\x12\x15aY{WaYzaX\xD1V[[_aY\x88\x86\x82\x87\x01aX\xEFV[\x93PP` \x84\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15aY\xA9WaY\xA8aX\xD5V[[aY\xB5\x86\x82\x87\x01aY\x0FV[\x92P\x92PP\x92P\x92P\x92V[_` \x82\x84\x03\x12\x15aY\xD6WaY\xD5aX\xD1V[[_aY\xE3\x84\x82\x85\x01aX\xEFV[\x91PP\x92\x91PPV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`!`\x04R`$_\xFD[`\x08\x81\x10aZ*WaZ)aY\xECV[[PV[_\x81\x90PaZ:\x82aZ\x19V[\x91\x90PV[_aZI\x82aZ-V[\x90P\x91\x90PV[aZY\x81aZ?V[\x82RPPV[_` \x82\x01\x90PaZr_\x83\x01\x84aZPV[\x92\x91PPV[aZ\x81\x81aVhV[\x81\x14aZ\x8BW_\x80\xFD[PV[_\x815\x90PaZ\x9C\x81aZxV[\x92\x91PPV[_\x80\xFD[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`A`\x04R`$_\xFD[aZ\xDC\x82aU'V[\x81\x01\x81\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17\x15aZ\xFBWaZ\xFAaZ\xA6V[[\x80`@RPPPV[_a[\raX\xC8V[\x90Pa[\x19\x82\x82aZ\xD3V[\x91\x90PV[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15a[8Wa[7aZ\xA6V[[a[A\x82aU'V[\x90P` \x81\x01\x90P\x91\x90PV[\x82\x81\x837_\x83\x83\x01RPPPV[_a[na[i\x84a[\x1EV[a[\x04V[\x90P\x82\x81R` \x81\x01\x84\x84\x84\x01\x11\x15a[\x8AWa[\x89aZ\xA2V[[a[\x95\x84\x82\x85a[NV[P\x93\x92PPPV[_\x82`\x1F\x83\x01\x12a[\xB1Wa[\xB0aY\x03V[[\x815a[\xC1\x84\x82` \x86\x01a[\\V[\x91PP\x92\x91PPV[_\x80`@\x83\x85\x03\x12\x15a[\xE0Wa[\xDFaX\xD1V[[_a[\xED\x85\x82\x86\x01aZ\x8EV[\x92PP` \x83\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\\\x0EWa\\\raX\xD5V[[a\\\x1A\x85\x82\x86\x01a[\x9DV[\x91PP\x92P\x92\x90PV[_\x81\x90P\x91\x90PV[a\\6\x81a\\$V[\x82RPPV[_` \x82\x01\x90Pa\\O_\x83\x01\x84a\\-V[\x92\x91PPV[_\x81\x15\x15\x90P\x91\x90PV[a\\i\x81a\\UV[\x82RPPV[_` \x82\x01\x90Pa\\\x82_\x83\x01\x84a\\`V[\x92\x91PPV[_\x81Q\x90P\x91\x90PV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[_\x81\x90P` \x82\x01\x90P\x91\x90PV[_a\\\xBC\x83\x83aVyV[` \x83\x01\x90P\x92\x91PPV[_` \x82\x01\x90P\x91\x90PV[_a\\\xDE\x82a\\\x88V[a\\\xE8\x81\x85a\\\x92V[\x93Pa\\\xF3\x83a\\\xA2V[\x80_[\x83\x81\x10\x15a]#W\x81Qa]\n\x88\x82a\\\xB1V[\x97Pa]\x15\x83a\\\xC8V[\x92PP`\x01\x81\x01\x90Pa\\\xF6V[P\x85\x93PPPP\x92\x91PPV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra]H\x81\x84a\\\xD4V[\x90P\x92\x91PPV[a]Y\x81aU\x9EV[\x81\x14a]cW_\x80\xFD[PV[_\x815\x90Pa]t\x81a]PV[\x92\x91PPV[_\x80\x83`\x1F\x84\x01\x12a]\x8FWa]\x8EaY\x03V[[\x825\x90Pg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a]\xACWa]\xABaY\x07V[[` \x83\x01\x91P\x83` \x82\x02\x83\x01\x11\x15a]\xC8Wa]\xC7aY\x0BV[[\x92P\x92\x90PV[_\x80\xFD[_`@\x82\x84\x03\x12\x15a]\xE8Wa]\xE7a]\xCFV[[\x81\x90P\x92\x91PPV[_\x80_\x80_`\xA0\x86\x88\x03\x12\x15a^\nWa^\taX\xD1V[[_a^\x17\x88\x82\x89\x01a]fV[\x95PP` a^(\x88\x82\x89\x01aX\xEFV[\x94PP`@\x86\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a^IWa^HaX\xD5V[[a^U\x88\x82\x89\x01a]zV[\x93P\x93PP``a^h\x88\x82\x89\x01a]\xD3V[\x91PP\x92\x95P\x92\x95\x90\x93PV[_\x7F\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\x16\x90P\x91\x90PV[a^\xA9\x81a^uV[\x82RPPV[a^\xB8\x81aVhV[\x82RPPV[_\x81Q\x90P\x91\x90PV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[_\x81\x90P` \x82\x01\x90P\x91\x90PV[_a^\xF2\x83\x83aU\x8FV[` \x83\x01\x90P\x92\x91PPV[_` \x82\x01\x90P\x91\x90PV[_a_\x14\x82a^\xBEV[a_\x1E\x81\x85a^\xC8V[\x93Pa_)\x83a^\xD8V[\x80_[\x83\x81\x10\x15a_YW\x81Qa_@\x88\x82a^\xE7V[\x97Pa_K\x83a^\xFEV[\x92PP`\x01\x81\x01\x90Pa_,V[P\x85\x93PPPP\x92\x91PPV[_`\xE0\x82\x01\x90Pa_y_\x83\x01\x8Aa^\xA0V[\x81\x81\x03` \x83\x01Ra_\x8B\x81\x89aU7V[\x90P\x81\x81\x03`@\x83\x01Ra_\x9F\x81\x88aU7V[\x90Pa_\xAE``\x83\x01\x87aT\xBDV[a_\xBB`\x80\x83\x01\x86a^\xAFV[a_\xC8`\xA0\x83\x01\x85a\\-V[\x81\x81\x03`\xC0\x83\x01Ra_\xDA\x81\x84a_\nV[\x90P\x98\x97PPPPPPPPV[_` \x82\x01\x90Pa_\xFB_\x83\x01\x84a^\xAFV[\x92\x91PPV[_\x80`@\x83\x85\x03\x12\x15a`\x17Wa`\x16aX\xD1V[[_a`$\x85\x82\x86\x01aX\xEFV[\x92PP` a`5\x85\x82\x86\x01aZ\x8EV[\x91PP\x92P\x92\x90PV[_` \x82\x84\x03\x12\x15a`TWa`SaX\xD1V[[_a`a\x84\x82\x85\x01aZ\x8EV[\x91PP\x92\x91PPV[_a\x01\0\x83\x01_\x83\x01Q\x84\x82\x03_\x86\x01Ra`\x85\x82\x82aV\x11V[\x91PP` \x83\x01Qa`\x9A` \x86\x01\x82aVyV[P`@\x83\x01Qa`\xAD`@\x86\x01\x82aVyV[P``\x83\x01Qa`\xC0``\x86\x01\x82aU\x8FV[P`\x80\x83\x01Q\x84\x82\x03`\x80\x86\x01Ra`\xD8\x82\x82aV\xA2V[\x91PP`\xA0\x83\x01Q\x84\x82\x03`\xA0\x86\x01Ra`\xF2\x82\x82aV\x11V[\x91PP`\xC0\x83\x01Q\x84\x82\x03`\xC0\x86\x01Raa\x0C\x82\x82aV\x11V[\x91PP`\xE0\x83\x01Q\x84\x82\x03`\xE0\x86\x01Raa&\x82\x82aV\xA2V[\x91PP\x80\x91PP\x92\x91PPV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01RaaK\x81\x84a`jV[\x90P\x92\x91PPV[aa\\\x81a\\UV[\x81\x14aafW_\x80\xFD[PV[_\x815\x90Paaw\x81aaSV[\x92\x91PPV[_``\x82\x84\x03\x12\x15aa\x92Waa\x91a]\xCFV[[\x81\x90P\x92\x91PPV[_\x80_\x80_\x80_a\x01 \x88\x8A\x03\x12\x15aa\xB7Waa\xB6aX\xD1V[[_aa\xC4\x8A\x82\x8B\x01a]fV[\x97PP` aa\xD5\x8A\x82\x8B\x01aaiV[\x96PP`@aa\xE6\x8A\x82\x8B\x01aX\xEFV[\x95PP``\x88\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15ab\x07Wab\x06aX\xD5V[[ab\x13\x8A\x82\x8B\x01a]zV[\x94P\x94PP`\x80ab&\x8A\x82\x8B\x01aa}V[\x92PP`\xE0ab7\x8A\x82\x8B\x01a]\xD3V[\x91PP\x92\x95\x98\x91\x94\x97P\x92\x95PV[_\x81\x90P\x92\x91PPV[_abZ\x82aT\xE5V[abd\x81\x85abFV[\x93Pabt\x81\x85` \x86\x01aT\xFFV[\x80\x84\x01\x91PP\x92\x91PPV[\x7F v\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_ab\xB4`\x02\x83abFV[\x91Pab\xBF\x82ab\x80V[`\x02\x82\x01\x90P\x91\x90PV[\x7F.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_ab\xFE`\x01\x83abFV[\x91Pac\t\x82ab\xCAV[`\x01\x82\x01\x90P\x91\x90PV[_ac\x1F\x82\x87abPV[\x91Pac*\x82ab\xA8V[\x91Pac6\x82\x86abPV[\x91PacA\x82ab\xF2V[\x91PacM\x82\x85abPV[\x91PacX\x82ab\xF2V[\x91Pacd\x82\x84abPV[\x91P\x81\x90P\x95\x94PPPPPV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\"`\x04R`$_\xFD[_`\x02\x82\x04\x90P`\x01\x82\x16\x80ac\xB6W`\x7F\x82\x16\x91P[` \x82\x10\x81\x03ac\xC9Wac\xC8acrV[[P\x91\x90PV[_\x82\x90P\x92\x91PPV[_\x81\x90P\x81_R` _ \x90P\x91\x90PV[_` `\x1F\x83\x01\x04\x90P\x91\x90PV[_\x82\x82\x1B\x90P\x92\x91PPV[_`\x08\x83\x02ad5\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82ac\xFAV[ad?\x86\x83ac\xFAV[\x95P\x80\x19\x84\x16\x93P\x80\x86\x16\x84\x17\x92PPP\x93\x92PPPV[_\x81\x90P\x91\x90PV[_adzaduadp\x84aT\xB4V[adWV[aT\xB4V[\x90P\x91\x90PV[_\x81\x90P\x91\x90PV[ad\x93\x83ad`V[ad\xA7ad\x9F\x82ad\x81V[\x84\x84Tad\x06V[\x82UPPPPV[_\x90V[ad\xBBad\xAFV[ad\xC6\x81\x84\x84ad\x8AV[PPPV[[\x81\x81\x10\x15ad\xE9Wad\xDE_\x82ad\xB3V[`\x01\x81\x01\x90Pad\xCCV[PPV[`\x1F\x82\x11\x15ae.Wad\xFF\x81ac\xD9V[ae\x08\x84ac\xEBV[\x81\x01` \x85\x10\x15ae\x17W\x81\x90P[ae+ae#\x85ac\xEBV[\x83\x01\x82ad\xCBV[PP[PPPV[_\x82\x82\x1C\x90P\x92\x91PPV[_aeN_\x19\x84`\x08\x02ae3V[\x19\x80\x83\x16\x91PP\x92\x91PPV[_aef\x83\x83ae?V[\x91P\x82`\x02\x02\x82\x17\x90P\x92\x91PPV[ae\x80\x83\x83ac\xCFV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15ae\x99Wae\x98aZ\xA6V[[ae\xA3\x82Tac\x9FV[ae\xAE\x82\x82\x85ad\xEDV[_`\x1F\x83\x11`\x01\x81\x14ae\xDBW_\x84\x15ae\xC9W\x82\x87\x015\x90P[ae\xD3\x85\x82ae[V[\x86UPaf:V[`\x1F\x19\x84\x16ae\xE9\x86ac\xD9V[_[\x82\x81\x10\x15af\x10W\x84\x89\x015\x82U`\x01\x82\x01\x91P` \x85\x01\x94P` \x81\x01\x90Pae\xEBV[\x86\x83\x10\x15af-W\x84\x89\x015af)`\x1F\x89\x16\x82ae?V[\x83UP[`\x01`\x02\x88\x02\x01\x88UPPP[PPPPPPPV[_afQ` \x84\x01\x84aX\xEFV[\x90P\x92\x91PPV[`@\x82\x01afi_\x83\x01\x83afCV[afu_\x85\x01\x82aU\x8FV[Paf\x83` \x83\x01\x83afCV[af\x90` \x85\x01\x82aU\x8FV[PPPPV[af\x9F\x81aU\x9EV[\x82RPPV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[_\x81\x90P\x91\x90PV[_\x80\xFD[_\x80\xFD[_\x80\xFD[_\x80\x835`\x01` \x03\x846\x03\x03\x81\x12af\xE6Waf\xE5af\xC6V[[\x83\x81\x01\x92P\x825\x91P` \x83\x01\x92Pg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15ag\x0EWag\raf\xBEV[[`\x01\x82\x026\x03\x83\x13\x15ag$Wag#af\xC2V[[P\x92P\x92\x90PV[_ag7\x83\x85aV\x01V[\x93PagD\x83\x85\x84a[NV[agM\x83aU'V[\x84\x01\x90P\x93\x92PPPV[_agf` \x84\x01\x84aZ\x8EV[\x90P\x92\x91PPV[_\x80\x835`\x01` \x03\x846\x03\x03\x81\x12ag\x8AWag\x89af\xC6V[[\x83\x81\x01\x92P\x825\x91P` \x83\x01\x92Pg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15ag\xB2Wag\xB1af\xBEV[[`\x01\x82\x026\x03\x83\x13\x15ag\xC8Wag\xC7af\xC2V[[P\x92P\x92\x90PV[_ag\xDB\x83\x85aV\x92V[\x93Pag\xE8\x83\x85\x84a[NV[ag\xF1\x83aU'V[\x84\x01\x90P\x93\x92PPPV[_a\x01\0\x83\x01ah\x0E_\x84\x01\x84af\xCAV[\x85\x83\x03_\x87\x01Rah \x83\x82\x84ag,V[\x92PPPah1` \x84\x01\x84agXV[ah>` \x86\x01\x82aVyV[PahL`@\x84\x01\x84agXV[ahY`@\x86\x01\x82aVyV[Pahg``\x84\x01\x84afCV[aht``\x86\x01\x82aU\x8FV[Pah\x82`\x80\x84\x01\x84agnV[\x85\x83\x03`\x80\x87\x01Rah\x95\x83\x82\x84ag\xD0V[\x92PPPah\xA6`\xA0\x84\x01\x84af\xCAV[\x85\x83\x03`\xA0\x87\x01Rah\xB9\x83\x82\x84ag,V[\x92PPPah\xCA`\xC0\x84\x01\x84af\xCAV[\x85\x83\x03`\xC0\x87\x01Rah\xDD\x83\x82\x84ag,V[\x92PPPah\xEE`\xE0\x84\x01\x84agnV[\x85\x83\x03`\xE0\x87\x01Rai\x01\x83\x82\x84ag\xD0V[\x92PPP\x80\x91PP\x92\x91PPV[_ai\x1A\x83\x83ag\xFCV[\x90P\x92\x91PPV[_\x825`\x01a\x01\0\x03\x836\x03\x03\x81\x12ai>Wai=af\xC6V[[\x82\x81\x01\x91PP\x92\x91PPV[_` \x82\x01\x90P\x91\x90PV[_aia\x83\x85af\xA5V[\x93P\x83` \x84\x02\x85\x01ais\x84af\xB5V[\x80_[\x87\x81\x10\x15ai\xB6W\x84\x84\x03\x89Rai\x8D\x82\x84ai\"V[ai\x97\x85\x82ai\x0FV[\x94Pai\xA2\x83aiJV[\x92P` \x8A\x01\x99PP`\x01\x81\x01\x90PaivV[P\x82\x97P\x87\x94PPPPP\x93\x92PPPV[_`\xA0\x82\x01\x90Pai\xDB_\x83\x01\x88afYV[ai\xE8`@\x83\x01\x87af\x96V[ai\xF5``\x83\x01\x86aT\xBDV[\x81\x81\x03`\x80\x83\x01Raj\x08\x81\x84\x86aiVV[\x90P\x96\x95PPPPPPV[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[aj0\x81aj\x14V[\x82RPPV[_` \x82\x01\x90PajI_\x83\x01\x84aj'V[\x92\x91PPV[_\x81Q\x90Paj]\x81aZxV[\x92\x91PPV[_` \x82\x84\x03\x12\x15ajxWajwaX\xD1V[[_aj\x85\x84\x82\x85\x01ajOV[\x91PP\x92\x91PPV[\x7FEIP712: Uninitialized\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_aj\xC2`\x15\x83aT\xEFV[\x91Paj\xCD\x82aj\x8EV[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Raj\xEF\x81aj\xB6V[\x90P\x91\x90PV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x11`\x04R`$_\xFD[_ak-\x82aT\xB4V[\x91Pak8\x83aT\xB4V[\x92P\x82\x82\x01\x90P\x80\x82\x11\x15akPWakOaj\xF6V[[\x92\x91PPV[_`@\x82\x01\x90Paki_\x83\x01\x85aT\xBDV[akv` \x83\x01\x84a^\xAFV[\x93\x92PPPV[_`@\x82\x01\x90Pak\x90_\x83\x01\x85aT\xBDV[ak\x9D` \x83\x01\x84aT\xBDV[\x93\x92PPPV[``\x82\x01ak\xB4_\x83\x01\x83afCV[ak\xC0_\x85\x01\x82aU\x8FV[Pak\xCE` \x83\x01\x83afCV[ak\xDB` \x85\x01\x82aU\x8FV[Pak\xE9`@\x83\x01\x83afCV[ak\xF6`@\x85\x01\x82aU\x8FV[PPPPV[_`\xA0\x82\x01\x90P\x81\x81\x03_\x83\x01Ral\x14\x81\x86aX5V[\x90P\x81\x81\x03` \x83\x01Ral(\x81\x85aX5V[\x90Pal7`@\x83\x01\x84ak\xA4V[\x94\x93PPPPV[_``\x82\x01\x90P\x81\x81\x03_\x83\x01RalW\x81\x86aX5V[\x90P\x81\x81\x03` \x83\x01Ralk\x81\x85aX5V[\x90Palz`@\x83\x01\x84aT\xBDV[\x94\x93PPPPV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x12`\x04R`$_\xFD[_`@\x82\x01\x90Pal\xC2_\x83\x01\x85a\\-V[al\xCF` \x83\x01\x84aT\xBDV[\x93\x92PPPV[_`@\x82\x01\x90P\x81\x81\x03_\x83\x01Ral\xEE\x81\x85aX5V[\x90Pal\xFD` \x83\x01\x84aT\xBDV[\x93\x92PPPV[am\r\x81a\\$V[\x81\x14am\x17W_\x80\xFD[PV[_\x81Q\x90Pam(\x81am\x04V[\x92\x91PPV[_` \x82\x84\x03\x12\x15amCWamBaX\xD1V[[_amP\x84\x82\x85\x01am\x1AV[\x91PP\x92\x91PPV[_amc\x82aT\xB4V[\x91P\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x03am\x95Wam\x94aj\xF6V[[`\x01\x82\x01\x90P\x91\x90PV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`2`\x04R`$_\xFD[_\x80\xFD[_\x80\xFD[_\x80\xFD[_\x825`\x01a\x01\0\x03\x836\x03\x03\x81\x12am\xF5Wam\xF4am\xCDV[[\x80\x83\x01\x91PP\x92\x91PPV[_\x80\x835`\x01` \x03\x846\x03\x03\x81\x12an\x1DWan\x1Cam\xCDV[[\x80\x84\x01\x92P\x825\x91Pg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15an?Wan>am\xD1V[[` \x83\x01\x92P`\x01\x82\x026\x03\x83\x13\x15an[WanZam\xD5V[[P\x92P\x92\x90PV[_\x82\x90P\x92\x91PPV[_\x81\x90P\x81_R` _ \x90P\x91\x90PV[`\x1F\x82\x11\x15an\xC0Wan\x91\x81anmV[an\x9A\x84ac\xEBV[\x81\x01` \x85\x10\x15an\xA9W\x81\x90P[an\xBDan\xB5\x85ac\xEBV[\x83\x01\x82ad\xCBV[PP[PPPV[an\xCF\x83\x83ancV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15an\xE8Wan\xE7aZ\xA6V[[an\xF2\x82Tac\x9FV[an\xFD\x82\x82\x85an\x7FV[_`\x1F\x83\x11`\x01\x81\x14ao*W_\x84\x15ao\x18W\x82\x87\x015\x90P[ao\"\x85\x82ae[V[\x86UPao\x89V[`\x1F\x19\x84\x16ao8\x86anmV[_[\x82\x81\x10\x15ao_W\x84\x89\x015\x82U`\x01\x82\x01\x91P` \x85\x01\x94P` \x81\x01\x90Pao:V[\x86\x83\x10\x15ao|W\x84\x89\x015aox`\x1F\x89\x16\x82ae?V[\x83UP[`\x01`\x02\x88\x02\x01\x88UPPP[PPPPPPPV[ao\x9D\x83\x83\x83an\xC5V[PPPV[_\x815ao\xAE\x81aZxV[\x80\x91PP\x91\x90PV[_\x81_\x1B\x90P\x91\x90PV[_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFao\xE1\x84ao\xB7V[\x93P\x80\x19\x83\x16\x92P\x80\x84\x16\x83\x17\x91PP\x92\x91PPV[_ap\x11ap\x0Cap\x07\x84aVIV[adWV[aVIV[\x90P\x91\x90PV[_ap\"\x82ao\xF7V[\x90P\x91\x90PV[_ap3\x82ap\x18V[\x90P\x91\x90PV[_\x81\x90P\x91\x90PV[apL\x82ap)V[ap_apX\x82ap:V[\x83Tao\xC2V[\x82UPPPV[_\x815apr\x81aX\xD9V[\x80\x91PP\x91\x90PV[_\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFap\xA6\x84ao\xB7V[\x93P\x80\x19\x83\x16\x92P\x80\x84\x16\x83\x17\x91PP\x92\x91PPV[ap\xC5\x82ad`V[ap\xD8ap\xD1\x82ad\x81V[\x83Tap{V[\x82UPPPV[_\x80\x835`\x01` \x03\x846\x03\x03\x81\x12ap\xFBWap\xFAam\xCDV[[\x80\x84\x01\x92P\x825\x91Pg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15aq\x1DWaq\x1Cam\xD1V[[` \x83\x01\x92P`\x01\x82\x026\x03\x83\x13\x15aq9Waq8am\xD5V[[P\x92P\x92\x90PV[aqL\x83\x83\x83aevV[PPPV[_\x81\x01_\x83\x01aqa\x81\x85an\x01V[aql\x81\x83\x86ao\x92V[PPPP`\x01\x81\x01` \x83\x01\x80aq\x82\x81ao\xA2V[\x90Paq\x8E\x81\x84apCV[PPP`\x02\x81\x01`@\x83\x01\x80aq\xA3\x81ao\xA2V[\x90Paq\xAF\x81\x84apCV[PPP`\x03\x81\x01``\x83\x01\x80aq\xC4\x81apfV[\x90Paq\xD0\x81\x84ap\xBCV[PPP`\x04\x81\x01`\x80\x83\x01aq\xE5\x81\x85ap\xDFV[aq\xF0\x81\x83\x86aqAV[PPPP`\x05\x81\x01`\xA0\x83\x01ar\x06\x81\x85an\x01V[ar\x11\x81\x83\x86ao\x92V[PPPP`\x06\x81\x01`\xC0\x83\x01ar'\x81\x85an\x01V[ar2\x81\x83\x86ao\x92V[PPPP`\x07\x81\x01`\xE0\x83\x01arH\x81\x85ap\xDFV[arS\x81\x83\x86aqAV[PPPPPPV[are\x82\x82aqQV[PPV[arr\x82aT\xE5V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15ar\x8BWar\x8AaZ\xA6V[[ar\x95\x82Tac\x9FV[ar\xA0\x82\x82\x85an\x7FV[_` \x90P`\x1F\x83\x11`\x01\x81\x14ar\xD1W_\x84\x15ar\xBFW\x82\x87\x01Q\x90P[ar\xC9\x85\x82ae[V[\x86UPas0V[`\x1F\x19\x84\x16ar\xDF\x86anmV[_[\x82\x81\x10\x15as\x06W\x84\x89\x01Q\x82U`\x01\x82\x01\x91P` \x85\x01\x94P` \x81\x01\x90Par\xE1V[\x86\x83\x10\x15as#W\x84\x89\x01Qas\x1F`\x1F\x89\x16\x82ae?V[\x83UP[`\x01`\x02\x88\x02\x01\x88UPPP[PPPPPPV[_``\x82\x01\x90PasK_\x83\x01\x86aT\xBDV[asX` \x83\x01\x85aT\xBDV[ase`@\x83\x01\x84aT\xBDV[\x94\x93PPPPV[_\x81\x90P\x92\x91PPV[_as\x81\x82aV\x88V[as\x8B\x81\x85asmV[\x93Pas\x9B\x81\x85` \x86\x01aT\xFFV[\x80\x84\x01\x91PP\x92\x91PPV[_as\xB2\x82\x84aswV[\x91P\x81\x90P\x92\x91PPV[_`\xA0\x82\x01\x90Pas\xD0_\x83\x01\x88a\\-V[as\xDD` \x83\x01\x87a\\-V[as\xEA`@\x83\x01\x86a\\-V[as\xF7``\x83\x01\x85aT\xBDV[at\x04`\x80\x83\x01\x84a^\xAFV[\x96\x95PPPPPPV[_`\xFF\x82\x16\x90P\x91\x90PV[at#\x81at\x0EV[\x82RPPV[_`\x80\x82\x01\x90Pat<_\x83\x01\x87a\\-V[atI` \x83\x01\x86at\x1AV[atV`@\x83\x01\x85a\\-V[atc``\x83\x01\x84a\\-V[\x95\x94PPPPPV\xFEKeyResharingVerification(uint256 contextId)",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x608060405260043610610203575f3560e01c806383b420c411610117578063d8e3ae011161009f578063e3b2a8741161006e578063e3b2a874146106af578063e7b1ec39146106eb578063eb843cf614610713578063f27cb9571461073b578063f2fde38b1461075157610203565b8063d8e3ae011461060b578063defba06a14610635578063dfe36aee1461065d578063e30c39781461068557610203565b80638da5cb5b116100e65780638da5cb5b1461052b5780639ee77af314610555578063ad3cb1cc1461057d578063b8715d4d146105a7578063c0ae64f7146105e357610203565b806383b420c4146104a75780638456cb59146104cf57806384b0196e146104e55780638cb967511461051557610203565b80634d6942601161019a57806364b00cc51161016957806364b00cc5146103eb578063715018a6146104275780637420f3d41461043d57806379ba5097146104675780637eaac8f21461047d57610203565b80634d6942601461033f5780634f1ef2861461037b57806352d1902d146103975780635c975abb146103c157610203565b80632e2d3a82116101d65780632e2d3a82146102ad5780633f4ba83a146102d557806343e37e8a146102eb5780634965e4551461031557610203565b80630a50e318146102075780630d8e6e2c146102315780630dd486c01461025b5780631079ebeb14610285575b5f80fd5b348015610212575f80fd5b5061021b610779565b60405161022891906154cc565b60405180910390f35b34801561023c575f80fd5b50610245610792565b604051610252919061556f565b60405180910390f35b348015610266575f80fd5b5061026f61080d565b60405161027c91906158a8565b60405180910390f35b348015610290575f80fd5b506102ab60048036038101906102a69190615964565b610c99565b005b3480156102b8575f80fd5b506102d360048036038101906102ce91906159c1565b611256565b005b3480156102e0575f80fd5b506102e96112bf565b005b3480156102f6575f80fd5b506102ff6112d1565b60405161030c91906154cc565b60405180910390f35b348015610320575f80fd5b506103296112ea565b60405161033691906154cc565b60405180910390f35b34801561034a575f80fd5b50610365600480360381019061036091906159c1565b611301565b6040516103729190615a5f565b60405180910390f35b61039560048036038101906103909190615bca565b611321565b005b3480156103a2575f80fd5b506103ab611340565b6040516103b89190615c3c565b60405180910390f35b3480156103cc575f80fd5b506103d5611371565b6040516103e29190615c6f565b60405180910390f35b3480156103f6575f80fd5b50610411600480360381019061040c91906159c1565b611393565b60405161041e91906154cc565b60405180910390f35b348015610432575f80fd5b5061043b611422565b005b348015610448575f80fd5b50610451611435565b60405161045e9190615d30565b60405180910390f35b348015610472575f80fd5b5061047b6114e9565b005b348015610488575f80fd5b50610491611577565b60405161049e9190615d30565b60405180910390f35b3480156104b2575f80fd5b506104cd60048036038101906104c89190615df1565b61162b565b005b3480156104da575f80fd5b506104e3611898565b005b3480156104f0575f80fd5b506104f96119d3565b60405161050c9796959493929190615f66565b60405180910390f35b348015610520575f80fd5b50610529611adc565b005b348015610536575f80fd5b5061053f611d13565b60405161054c9190615fe8565b60405180910390f35b348015610560575f80fd5b5061057b600480360381019061057691906159c1565b611d48565b005b348015610588575f80fd5b50610591611e57565b60405161059e919061556f565b60405180910390f35b3480156105b2575f80fd5b506105cd60048036038101906105c891906159c1565b611e90565b6040516105da91906154cc565b60405180910390f35b3480156105ee575f80fd5b50610609600480360381019061060491906159c1565b611f1f565b005b348015610616575f80fd5b5061061f61202e565b60405161062c91906154cc565b60405180910390f35b348015610640575f80fd5b5061065b60048036038101906106569190616001565b612045565b005b348015610668575f80fd5b50610683600480360381019061067e9190616001565b61215a565b005b348015610690575f80fd5b5061069961226f565b6040516106a69190615fe8565b60405180910390f35b3480156106ba575f80fd5b506106d560048036038101906106d0919061603f565b6122a4565b6040516106e29190616133565b60405180910390f35b3480156106f6575f80fd5b50610711600480360381019061070c919061619b565b612723565b005b34801561071e575f80fd5b50610739600480360381019061073491906159c1565b612913565b005b348015610746575f80fd5b5061074f61297c565b005b34801561075c575f80fd5b506107776004803603810190610772919061603f565b612a69565b005b5f80610783612b22565b9050805f016004015491505090565b60606040518060400160405280600b81526020017f4b6d73436f6e74657874730000000000000000000000000000000000000000008152506107d35f612b49565b6107dd6001612b49565b6107e65f612b49565b6040516020016107f99493929190616314565b604051602081830303815290604052905090565b610815615400565b5f61081e612b22565b90505f6108296112d1565b9050816007015f8281526020019081526020015f206040518060a00160405290815f820154815260200160018201548152602001600282015f9054906101000a900460c01b77ffffffffffffffffffffffffffffffffffffffffffffffff191677ffffffffffffffffffffffffffffffffffffffffffffffff191681526020016003820154815260200160048201805480602002602001604051908101604052809291908181526020015f905b82821015610c8a578382905f5260205f209060080201604051806101000160405290815f820180546109079061639f565b80601f01602080910402602001604051908101604052809291908181526020018280546109339061639f565b801561097e5780601f106109555761010080835404028352916020019161097e565b820191905f5260205f20905b81548152906001019060200180831161096157829003601f168201915b50505050508152602001600182015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001600282015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200160038201548152602001600482018054610a4b9061639f565b80601f0160208091040260200160405190810160405280929190818152602001828054610a779061639f565b8015610ac25780601f10610a9957610100808354040283529160200191610ac2565b820191905f5260205f20905b815481529060010190602001808311610aa557829003601f168201915b50505050508152602001600582018054610adb9061639f565b80601f0160208091040260200160405190810160405280929190818152602001828054610b079061639f565b8015610b525780601f10610b2957610100808354040283529160200191610b52565b820191905f5260205f20905b815481529060010190602001808311610b3557829003601f168201915b50505050508152602001600682018054610b6b9061639f565b80601f0160208091040260200160405190810160405280929190818152602001828054610b979061639f565b8015610be25780601f10610bb957610100808354040283529160200191610be2565b820191905f5260205f20905b815481529060010190602001808311610bc557829003601f168201915b50505050508152602001600782018054610bfb9061639f565b80601f0160208091040260200160405190810160405280929190818152602001828054610c279061639f565b8015610c725780601f10610c4957610100808354040283529160200191610c72565b820191905f5260205f20905b815481529060010190602001808311610c5557829003601f168201915b505050505081525050815260200190600101906108d6565b50505050815250509250505090565b610ca38333612045565b5f610cac612b22565b9050610cba815f0185612c13565b610cfb57836040517f5e51a2e1000000000000000000000000000000000000000000000000000000008152600401610cf291906154cc565b60405180910390fd5b5f60405180602001604052808681525090505f610d1782612c62565b9050610d2586828787612cbd565b5f83600a015f8881526020019081526020015f20905080868690918060018154018082558091505060019003905f5260205f20015f909192909192909192909192509182610d74929190616576565b505f846007015f8981526020019081526020015f206040518060a00160405290815f820154815260200160018201548152602001600282015f9054906101000a900460c01b77ffffffffffffffffffffffffffffffffffffffffffffffff191677ffffffffffffffffffffffffffffffffffffffffffffffff191681526020016003820154815260200160048201805480602002602001604051908101604052809291908181526020015f905b828210156111d5578382905f5260205f209060080201604051806101000160405290815f82018054610e529061639f565b80601f0160208091040260200160405190810160405280929190818152602001828054610e7e9061639f565b8015610ec95780601f10610ea057610100808354040283529160200191610ec9565b820191905f5260205f20905b815481529060010190602001808311610eac57829003601f168201915b50505050508152602001600182015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001600282015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200160038201548152602001600482018054610f969061639f565b80601f0160208091040260200160405190810160405280929190818152602001828054610fc29061639f565b801561100d5780601f10610fe45761010080835404028352916020019161100d565b820191905f5260205f20905b815481529060010190602001808311610ff057829003601f168201915b505050505081526020016005820180546110269061639f565b80601f01602080910402602001604051908101604052809291908181526020018280546110529061639f565b801561109d5780601f106110745761010080835404028352916020019161109d565b820191905f5260205f20905b81548152906001019060200180831161108057829003601f168201915b505050505081526020016006820180546110b69061639f565b80601f01602080910402602001604051908101604052809291908181526020018280546110e29061639f565b801561112d5780601f106111045761010080835404028352916020019161112d565b820191905f5260205f20905b81548152906001019060200180831161111057829003601f168201915b505050505081526020016007820180546111469061639f565b80601f01602080910402602001604051908101604052809291908181526020018280546111729061639f565b80156111bd5780601f10611194576101008083540402835291602001916111bd565b820191905f5260205f20905b8154815290600101906020018083116111a057829003601f168201915b50505050508152505081526020019060010190610e21565b505050508152505090506111ed818380549050612e2f565b1561124c575f856013015f8a81526020019081526020015f205490506112138282612e46565b7f68898a98936bf23a56e8ed4b23dcc98cef926bd9ac2ce522f1f9423e3864f2f58260405161124291906158a8565b60405180910390a1505b5050505050505050565b61125e612ec9565b611266612f50565b5f61126f61080d565b9050611284815f015183836080015151612f91565b7fe41802af725729adcb8c151e2937380a25c69155757e3af5d3979adab5035800826040516112b391906154cc565b60405180910390a15050565b6112c7612ec9565b6112cf61303a565b565b5f806112db612b22565b9050805f016003015491505090565b5f806112f4612b22565b9050806005015491505090565b5f8061130b612b22565b9050611319815f01846130a8565b915050919050565b6113296130d0565b611332826131b6565b61133c82826131c1565b5050565b5f6113496132df565b7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5f1b905090565b5f8061137b613366565b9050805f015f9054906101000a900460ff1691505090565b5f815f61139e612b22565b90505f816007015f8481526020019081526020015f205f0154036113f957816040517f82b1fbda0000000000000000000000000000000000000000000000000000000081526004016113f091906154cc565b60405180910390fd5b5f611402612b22565b9050806016015f8681526020019081526020015f20549350505050919050565b61142a612ec9565b6114335f61338d565b565b60605f6114406112d1565b90505f61144b612b22565b905080600e015f8381526020019081526020015f208054806020026020016040519081016040528092919081815260200182805480156114dd57602002820191905f5260205f20905b815f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019060010190808311611494575b50505050509250505090565b5f6114f26133ca565b90508073ffffffffffffffffffffffffffffffffffffffff1661151361226f565b73ffffffffffffffffffffffffffffffffffffffff161461156b57806040517f118cdaa70000000000000000000000000000000000000000000000000000000081526004016115629190615fe8565b60405180910390fd5b6115748161338d565b50565b60605f6115826112d1565b90505f61158d612b22565b905080600f015f8381526020019081526020015f2080548060200260200160405190810160405280929190818152602001828054801561161f57602002820191905f5260205f20905b815f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190600101908083116115d6575b50505050509250505090565b60016116356133d1565b67ffffffffffffffff1614611676576040517f6f4f731f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60025f6116816133f5565b9050805f0160089054906101000a900460ff16806116c957508167ffffffffffffffff16815f015f9054906101000a900467ffffffffffffffff1667ffffffffffffffff1610155b15611700576040517ff92ee8a900000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b81815f015f6101000a81548167ffffffffffffffff021916908367ffffffffffffffff1602179055506001815f0160086101000a81548160ff0219169083151502179055506117b96040518060400160405280600b81526020017f4b6d73436f6e74657874730000000000000000000000000000000000000000008152506040518060400160405280600181526020017f310000000000000000000000000000000000000000000000000000000000000081525061341c565b6117c96117c4611d13565b613432565b6117d1613446565b5f6117e05f8989898989613458565b90505f6117eb612b22565b90506117fc815f01835f0151613da6565b7f5448756ee13f8e5e9a81f574ac68c8814a16612bee06fea0fd80c61610436dcd858a8a8a8a6040516118339594939291906169c8565b60405180910390a150505f815f0160086101000a81548160ff0219169083151502179055507fc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d2826040516118879190616a36565b60405180910390a150505050505050565b6118a0611d13565b73ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614158015611987575073c7d45661a345ec5ca0e8521cfef7e32fda0daa6873ffffffffffffffffffffffffffffffffffffffff16637008b5486040518163ffffffff1660e01b8152600401602060405180830381865afa158015611933573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906119579190616a63565b73ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614155b156119c957336040517f46c0d9af0000000000000000000000000000000000000000000000000000000081526004016119c09190615fe8565b60405180910390fd5b6119d1613ea1565b565b5f6060805f805f60605f6119e5613f10565b90505f801b815f0154148015611a0057505f801b8160010154145b611a3f576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611a3690616ad8565b60405180910390fd5b611a47613f37565b611a4f613fd5565b46305f801b5f67ffffffffffffffff811115611a6e57611a6d615aa6565b5b604051908082528060200260200182016040528015611a9c5781602001602082028036833780820191505090505b507f0f0000000000000000000000000000000000000000000000000000000000000095949392919097509750975097509750975097505090919293949596565b611ae4612f50565b5f611aed612b22565b90505f815f016001015490505f8114158015611b1c5750816010015f8281526020019081526020015f20544310155b15611b9b577e9fe8f0db45996decf7b06fc7b6ec5f887d5f04db2e0c4ad7f4e4ee5eefc5a381604051611b4f91906154cc565b60405180910390a1611b63825f0182614073565b7f3e8f02dc7af6e3a67f3af0bc99bcf11b4deb46105e9ba7f1ac6da82322e9025e81604051611b9291906154cc565b60405180910390a15b5f825f016002015490505f8114158015611bc85750826011015f8281526020019081526020015f20544310155b15611c9b575f611bd66112d1565b90505f846014015f8381526020019081526020015f205443611bf89190616b23565b905080856012015f8481526020019081526020015f2081905550611c1e855f0183614140565b7f851a08c16b15959c338ac4b56466d06c9f9d5ff8d715168aa125d5ccaf53832082604051611c4d91906154cc565b60405180910390a1611c61855f0184613da6565b7f4f54a6ac981cc8dc83142b3eb4d120be7c70fc5de6477a14eae3e9ca647644bc83604051611c9091906154cc565b60405180910390a150505b5f611ca4610779565b90505f8114611d0d57836012015f8281526020019081526020015f2054431115611d0c57611cd4845f0182614216565b7f8fb75858a565aee117342d93196a7f0b54c1c8519885eddda6a01f477359b36381604051611d0391906154cc565b60405180910390a15b5b50505050565b5f80611d1d614318565b9050805f015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1691505090565b611d50612ec9565b805f611d5a612b22565b90505f816007015f8481526020019081526020015f205f015403611db557816040517f82b1fbda000000000000000000000000000000000000000000000000000000008152600401611dac91906154cc565b60405180910390fd5b5f611dbe612b22565b9050611dcc815f018561433f565b15611e0e57836040517f77d05ea7000000000000000000000000000000000000000000000000000000008152600401611e0591906154cc565b60405180910390fd5b611e1a815f018561438e565b7fbc1114fa9a77648cd097ee6cf149c344fa278b9b983f30dd65b6fd6a9d464a0784604051611e4991906154cc565b60405180910390a150505050565b6040518060400160405280600581526020017f352e302e3000000000000000000000000000000000000000000000000000000081525081565b5f815f611e9b612b22565b90505f816007015f8481526020019081526020015f205f015403611ef657816040517f82b1fbda000000000000000000000000000000000000000000000000000000008152600401611eed91906154cc565b60405180910390fd5b5f611eff612b22565b9050806015015f8681526020019081526020015f20549350505050919050565b611f27612ec9565b805f611f31612b22565b90505f816007015f8481526020019081526020015f205f015403611f8c57816040517f82b1fbda000000000000000000000000000000000000000000000000000000008152600401611f8391906154cc565b60405180910390fd5b5f611f95612b22565b9050611fa3815f018561433f565b15611fe557836040517fb25e4eb3000000000000000000000000000000000000000000000000000000008152600401611fdc91906154cc565b60405180910390fd5b611ff1815f0185614073565b7f3e8f02dc7af6e3a67f3af0bc99bcf11b4deb46105e9ba7f1ac6da82322e9025e8460405161202091906154cc565b60405180910390a150505050565b5f80612038612b22565b9050806006015491505090565b815f61204f612b22565b90505f816007015f8481526020019081526020015f205f0154036120aa57816040517f82b1fbda0000000000000000000000000000000000000000000000000000000081526004016120a191906154cc565b60405180910390fd5b5f6120b3612b22565b905080600c015f8681526020019081526020015f205f8573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f9054906101000a900460ff166121535784846040517ffdf8a05d00000000000000000000000000000000000000000000000000000000815260040161214a929190616b56565b60405180910390fd5b5050505050565b815f612164612b22565b90505f816007015f8481526020019081526020015f205f0154036121bf57816040517f82b1fbda0000000000000000000000000000000000000000000000000000000081526004016121b691906154cc565b60405180910390fd5b5f6121c8612b22565b905080600d015f8681526020019081526020015f205f8573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f9054906101000a900460ff166122685784846040517f89b45e5d00000000000000000000000000000000000000000000000000000000815260040161225f929190616b56565b60405180910390fd5b5050505050565b5f806122796144a3565b9050805f015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1691505090565b6122ac615446565b5f6122b56112d1565b90505f6122c0612b22565b90505f81600b015f8481526020019081526020015f205f8673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f20604051806101000160405290815f8201805461232c9061639f565b80601f01602080910402602001604051908101604052809291908181526020018280546123589061639f565b80156123a35780601f1061237a576101008083540402835291602001916123a3565b820191905f5260205f20905b81548152906001019060200180831161238657829003601f168201915b50505050508152602001600182015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001600282015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001600382015481526020016004820180546124709061639f565b80601f016020809104026020016040519081016040528092919081815260200182805461249c9061639f565b80156124e75780601f106124be576101008083540402835291602001916124e7565b820191905f5260205f20905b8154815290600101906020018083116124ca57829003601f168201915b505050505081526020016005820180546125009061639f565b80601f016020809104026020016040519081016040528092919081815260200182805461252c9061639f565b80156125775780601f1061254e57610100808354040283529160200191612577565b820191905f5260205f20905b81548152906001019060200180831161255a57829003601f168201915b505050505081526020016006820180546125909061639f565b80601f01602080910402602001604051908101604052809291908181526020018280546125bc9061639f565b80156126075780601f106125de57610100808354040283529160200191612607565b820191905f5260205f20905b8154815290600101906020018083116125ea57829003601f168201915b505050505081526020016007820180546126209061639f565b80601f016020809104026020016040519081016040528092919081815260200182805461264c9061639f565b80156126975780601f1061266e57610100808354040283529160200191612697565b820191905f5260205f20905b81548152906001019060200180831161267a57829003601f168201915b50505050508152505090505f73ffffffffffffffffffffffffffffffffffffffff16816040015173ffffffffffffffffffffffffffffffffffffffff16036127185782856040517f0494d3c000000000000000000000000000000000000000000000000000000000815260040161270f929190616b56565b60405180910390fd5b809350505050919050565b61272b612ec9565b5f612734612b22565b90505f61273f61080d565b90505f81608001515190505f8787905090508181146127975781816040517fd595a96200000000000000000000000000000000000000000000000000000000815260040161278e929190616b7d565b60405180910390fd5b5f6127a0610779565b90505f81146127e657806040517f7623d3570000000000000000000000000000000000000000000000000000000081526004016127dd91906154cc565b60405180910390fd5b5f6127f8855f01518e8d8d8d8c613458565b90508760400135866014015f875f015181526020019081526020015f20819055507fa69a4c9341cd7d458fde12c31a1f582f7d4caedb27c4a7c34cc992208a3ce4c585828a60405161284c93929190616bfc565b60405180910390a1612863865f01825f01516144ca565b8b156128f657875f0135866013015f835f015181526020019081526020015f20819055505f8860200135436128989190616b23565b905080876010015f845f015181526020019081526020015f20819055507f5dc601065a035d78305cd9ef27c91a009cd8d37297e43bb76319490895a0d0588683836040516128e893929190616c3f565b60405180910390a150612904565b61290381895f0135612e46565b5b50505050505050505050505050565b61291b612ec9565b612923612f50565b5f61292c61080d565b9050612941815f015183836080015151614597565b7f837e0a6528dadfa2dc792692c5182e52a9f5bbdeed7b2372927a26c6958396138260405161297091906154cc565b60405180910390a15050565b612984612ec9565b5f61298d612b22565b90505f612998610779565b90505f81036129d3576040517f207ea3f300000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f6129dc6112d1565b90506129ea835f0182614216565b7f8fb75858a565aee117342d93196a7f0b54c1c8519885eddda6a01f477359b36381604051612a1991906154cc565b60405180910390a1612a2d835f0183613da6565b7f4f54a6ac981cc8dc83142b3eb4d120be7c70fc5de6477a14eae3e9ca647644bc82604051612a5c91906154cc565b60405180910390a1505050565b612a71612ec9565b5f612a7a6144a3565b905081815f015f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508173ffffffffffffffffffffffffffffffffffffffff16612adc611d13565b73ffffffffffffffffffffffffffffffffffffffff167f38d16b8cac22d99fc7c124b9cd0de2d3fa1faef420bfe791d8c362d765e2270060405160405180910390a35050565b5f7f7d8159810a7ebf944e8fa93cc4fbd1cade6c71f8b0b86b37187ac7991777b100905090565b60605f6001612b5784614640565b0190505f8167ffffffffffffffff811115612b7557612b74615aa6565b5b6040519080825280601f01601f191660200182016040528015612ba75781602001600182028036833780820191505090505b5090505f82602001820190505b600115612c08578080600190039150507f3031323334353637383961626364656600000000000000000000000000000000600a86061a8153600a8581612bfd57612bfc616c82565b5b0494505f8503612bb4575b819350505050919050565b5f60016007811115612c2857612c276159ec565b5b835f015f8481526020019081526020015f205f9054906101000a900460ff166007811115612c5957612c586159ec565b5b14905092915050565b5f612cb66040518060600160405280602b815260200161746d602b913980519060200120835f0151604051602001612c9b929190616caf565b60405160208183030381529060405280519060200120614791565b9050919050565b5f612cc6612b22565b90505f612d168585858080601f0160208091040260200160405190810160405280939291908181526020018383808284375f81840152601f19601f820116905080830192505050505050506147aa565b9050612d22868261215a565b816009015f8781526020019081526020015f205f8273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f9054906101000a900460ff1615612dc15785816040517f99b158c1000000000000000000000000000000000000000000000000000000008152600401612db8929190616b56565b60405180910390fd5b6001826009015f8881526020019081526020015f205f8373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f6101000a81548160ff021916908315150217905550505050505050565b5f8083608001515190508083101591505092915050565b5f612e4f612b22565b9050612e60815f01845f01516147d4565b5f8243612e6d9190616b23565b905080826011015f865f015181526020019081526020015f20819055507f4540f7808fcaec86c376a89d2c0c93a5056c21680db54332c7f2959d87fefc8b8482604051612ebb929190616cd6565b60405180910390a150505050565b612ed16133ca565b73ffffffffffffffffffffffffffffffffffffffff16612eef611d13565b73ffffffffffffffffffffffffffffffffffffffff1614612f4e57612f126133ca565b6040517f118cdaa7000000000000000000000000000000000000000000000000000000008152600401612f459190615fe8565b60405180910390fd5b565b612f58611371565b15612f8f576040517fd93c066500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b565b5f612f9a612b22565b90505f8303612fd5576040517fb1ae92ea00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b8183111561301c5782826040517f84208f23000000000000000000000000000000000000000000000000000000008152600401613013929190616b7d565b60405180910390fd5b82816015015f8681526020019081526020015f208190555050505050565b6130426148aa565b5f61304b613366565b90505f815f015f6101000a81548160ff0219169083151502179055507f5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa6130906133ca565b60405161309d9190615fe8565b60405180910390a150565b5f825f015f8381526020019081526020015f205f9054906101000a900460ff16905092915050565b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff163073ffffffffffffffffffffffffffffffffffffffff16148061317d57507f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff166131646148ea565b73ffffffffffffffffffffffffffffffffffffffff1614155b156131b4576040517fe07c8dba00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b565b6131be612ec9565b50565b8173ffffffffffffffffffffffffffffffffffffffff166352d1902d6040518163ffffffff1660e01b8152600401602060405180830381865afa92505050801561322957506040513d601f19601f820116820180604052508101906132269190616d2e565b60015b61326a57816040517f4c9c8ce30000000000000000000000000000000000000000000000000000000081526004016132619190615fe8565b60405180910390fd5b7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5f1b81146132d057806040517faa1d49a40000000000000000000000000000000000000000000000000000000081526004016132c79190615c3c565b60405180910390fd5b6132da838361493d565b505050565b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff163073ffffffffffffffffffffffffffffffffffffffff1614613364576040517fe07c8dba00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b565b5f7fcd5ed15c6e187e77e9aee88184c21f4f2182ab5827cb3b7e07fbedcd63f03300905090565b5f6133966144a3565b9050805f015f6101000a81549073ffffffffffffffffffffffffffffffffffffffff02191690556133c6826149af565b5050565b5f33905090565b5f6133da6133f5565b5f015f9054906101000a900467ffffffffffffffff16905090565b5f7ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00905090565b613424614a80565b61342e8282614ac0565b5050565b61343a614a80565b61344381614b11565b50565b61344e614a80565b613456614b95565b565b613460615400565b5f613469612b22565b90505f85859050036134a7576040517f068c8d4000000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b806008015f8154809291906134bb90616d59565b91905055505f8160080154905080826007015f8381526020019081526020015f205f018190555088826007015f8381526020019081526020015f206001018190555087826007015f8381526020019081526020015f206002015f6101000a81548167ffffffffffffffff021916908360c01c0217905550613540818888889050614bc5565b5f5b868690508110156135c957826007015f8381526020019081526020015f2060040187878381811061357657613575616da0565b5b90506020028101906135889190616dd9565b908060018154018082558091505060019003905f5260205f2090600802015f9091909190915081816135ba919061725b565b50508080600101915050613542565b505f5b86869050811015613922578686828181106135ea576135e9616da0565b5b90506020028101906135fc9190616dd9565b83600b015f8481526020019081526020015f205f89898581811061362357613622616da0565b5b90506020028101906136359190616dd9565b6040016020810190613647919061603f565b73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f20818161368c919061725b565b905050600183600c015f8481526020019081526020015f205f8989858181106136b8576136b7616da0565b5b90506020028101906136ca9190616dd9565b60400160208101906136dc919061603f565b73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f6101000a81548160ff02191690831515021790555082600e015f8381526020019081526020015f2087878381811061375157613750616da0565b5b90506020028101906137639190616dd9565b6040016020810190613775919061603f565b908060018154018082558091505060019003905f5260205f20015f9091909190916101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550600183600d015f8481526020019081526020015f205f8989858181106137fb576137fa616da0565b5b905060200281019061380d9190616dd9565b602001602081019061381f919061603f565b73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f6101000a81548160ff02191690831515021790555082600f015f8381526020019081526020015f2087878381811061389457613893616da0565b5b90506020028101906138a69190616dd9565b60200160208101906138b8919061603f565b908060018154018082558091505060019003905f5260205f20015f9091909190916101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555080806001019150506135cc565b50613931818588889050614c39565b816007015f8281526020019081526020015f206040518060a00160405290815f820154815260200160018201548152602001600282015f9054906101000a900460c01b77ffffffffffffffffffffffffffffffffffffffffffffffff191677ffffffffffffffffffffffffffffffffffffffffffffffff191681526020016003820154815260200160048201805480602002602001604051908101604052809291908181526020015f905b82821015613d90578382905f5260205f209060080201604051806101000160405290815f82018054613a0d9061639f565b80601f0160208091040260200160405190810160405280929190818152602001828054613a399061639f565b8015613a845780601f10613a5b57610100808354040283529160200191613a84565b820191905f5260205f20905b815481529060010190602001808311613a6757829003601f168201915b50505050508152602001600182015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001600282015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200160038201548152602001600482018054613b519061639f565b80601f0160208091040260200160405190810160405280929190818152602001828054613b7d9061639f565b8015613bc85780601f10613b9f57610100808354040283529160200191613bc8565b820191905f5260205f20905b815481529060010190602001808311613bab57829003601f168201915b50505050508152602001600582018054613be19061639f565b80601f0160208091040260200160405190810160405280929190818152602001828054613c0d9061639f565b8015613c585780601f10613c2f57610100808354040283529160200191613c58565b820191905f5260205f20905b815481529060010190602001808311613c3b57829003601f168201915b50505050508152602001600682018054613c719061639f565b80601f0160208091040260200160405190810160405280929190818152602001828054613c9d9061639f565b8015613ce85780601f10613cbf57610100808354040283529160200191613ce8565b820191905f5260205f20905b815481529060010190602001808311613ccb57829003601f168201915b50505050508152602001600782018054613d019061639f565b80601f0160208091040260200160405190810160405280929190818152602001828054613d2d9061639f565b8015613d785780601f10613d4f57610100808354040283529160200191613d78565b820191905f5260205f20905b815481529060010190602001808311613d5b57829003601f168201915b505050505081525050815260200190600101906139dc565b5050505081525050925050509695505050505050565b805f8103613de0576040517fcb17b7a500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b613dea8383614c5b565b158015613dfe5750613dfc8383614caa565b155b8015613e0e57505f836003015414155b15613e5057816040517f12b49e3d000000000000000000000000000000000000000000000000000000008152600401613e4791906154cc565b60405180910390fd5b6003835f015f8481526020019081526020015f205f6101000a81548160ff02191690836007811115613e8557613e846159ec565b5b02179055508183600301819055505f8360020181905550505050565b613ea9612f50565b5f613eb2613366565b90506001815f015f6101000a81548160ff0219169083151502179055507f62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258613ef86133ca565b604051613f059190615fe8565b60405180910390a150565b5f7fa16a46d94261c7517cc8ff89f61c0ce93598e3c849801011dee649a6a557d100905090565b60605f613f42613f10565b9050806002018054613f539061639f565b80601f0160208091040260200160405190810160405280929190818152602001828054613f7f9061639f565b8015613fca5780601f10613fa157610100808354040283529160200191613fca565b820191905f5260205f20905b815481529060010190602001808311613fad57829003601f168201915b505050505091505090565b60605f613fe0613f10565b9050806003018054613ff19061639f565b80601f016020809104026020016040519081016040528092919081815260200182805461401d9061639f565b80156140685780601f1061403f57610100808354040283529160200191614068565b820191905f5260205f20905b81548152906001019060200180831161404b57829003601f168201915b505050505091505090565b805f81036140ad576040517fcb17b7a500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6007835f015f8481526020019081526020015f205f6101000a81548160ff021916908360078111156140e2576140e16159ec565b5b0217905550818360010154036140fc575f83600101819055505b81836002015403614111575f83600201819055505b81836003015403614126575f83600301819055505b8183600401540361413b575f83600401819055505b505050565b805f810361417a576040517fcb17b7a500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b614184838361433f565b6141c557816040517f331486b30000000000000000000000000000000000000000000000000000000081526004016141bc91906154cc565b60405180910390fd5b6004835f015f8481526020019081526020015f205f6101000a81548160ff021916908360078111156141fa576141f96159ec565b5b02179055508183600401819055505f8360030181905550505050565b805f8103614250576040517fcb17b7a500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b61425a838361433f565b158061426d575061426b8383614caa565b155b156142af57816040517f2b3652d10000000000000000000000000000000000000000000000000000000081526004016142a691906154cc565b60405180910390fd5b6005835f015f8481526020019081526020015f205f6101000a81548160ff021916908360078111156142e4576142e36159ec565b5b0217905550818360030154036142fe575f83600301819055505b81836004015403614313575f83600401819055505b505050565b5f7f9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300905090565b5f60036007811115614354576143536159ec565b5b835f015f8481526020019081526020015f205f9054906101000a900460ff166007811115614385576143846159ec565b5b14905092915050565b805f81036143c8576040517fcb17b7a500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6143d28383614cf9565b806143e357506143e28383612c13565b5b1561442557816040517fb0c5151d00000000000000000000000000000000000000000000000000000000815260040161441c91906154cc565b60405180910390fd5b6006835f015f8481526020019081526020015f205f6101000a81548160ff0219169083600781111561445a576144596159ec565b5b021790555081836002015403614474575f83600201819055505b81836003015403614489575f83600301819055505b8183600401540361449e575f83600401819055505b505050565b5f7f237e158222e3e6968b72b9db0d8043aacf074ad9f650f0d1606b4d82ee432c00905090565b805f8103614504576040517fcb17b7a500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b61450e8383614cf9565b61454f57816040517f6653f6d700000000000000000000000000000000000000000000000000000000815260040161454691906154cc565b60405180910390fd5b6001835f015f8481526020019081526020015f205f6101000a81548160ff02191690836007811115614584576145836159ec565b5b0217905550818360010181905550505050565b5f6145a0612b22565b90505f83036145db576040517fe60a727100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b818311156146225782826040517fd2535e11000000000000000000000000000000000000000000000000000000008152600401614619929190616b7d565b60405180910390fd5b82816016015f8681526020019081526020015f208190555050505050565b5f805f90507a184f03e93ff9f4daa797ed6e38ed64bf6a1f010000000000000000831061469c577a184f03e93ff9f4daa797ed6e38ed64bf6a1f010000000000000000838161469257614691616c82565b5b0492506040810190505b6d04ee2d6d415b85acef810000000083106146d9576d04ee2d6d415b85acef810000000083816146cf576146ce616c82565b5b0492506020810190505b662386f26fc10000831061470857662386f26fc1000083816146fe576146fd616c82565b5b0492506010810190505b6305f5e1008310614731576305f5e100838161472757614726616c82565b5b0492506008810190505b612710831061475657612710838161474c5761474b616c82565b5b0492506004810190505b60648310614779576064838161476f5761476e616c82565b5b0492506002810190505b600a8310614788576001810190505b80915050919050565b5f6147a361479d614d47565b83614d55565b9050919050565b5f805f806147b88686614d95565b9250925092506147c88282614dea565b82935050505092915050565b805f810361480e576040517fcb17b7a500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6148188383612c13565b61485957816040517fc0b5ee6600000000000000000000000000000000000000000000000000000000815260040161485091906154cc565b60405180910390fd5b6002835f015f8481526020019081526020015f205f6101000a81548160ff0219169083600781111561488e5761488d6159ec565b5b02179055508183600201819055505f8360010181905550505050565b6148b2611371565b6148e8576040517f8dfc202b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b565b5f6149167f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5f1b614f4c565b5f015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905090565b61494682614f55565b8173ffffffffffffffffffffffffffffffffffffffff167fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b60405160405180910390a25f815111156149a25761499c828261501e565b506149ab565b6149aa61509e565b5b5050565b5f6149b8614318565b90505f815f015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905082825f015f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508273ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e060405160405180910390a3505050565b614a886150da565b614abe576040517fd7e6bcf800000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b565b614ac8614a80565b5f614ad1613f10565b905082816002019081614ae49190617269565b5081816003019081614af69190617269565b505f801b815f01819055505f801b8160010181905550505050565b614b19614a80565b5f73ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1603614b89575f6040517f1e4fbdf7000000000000000000000000000000000000000000000000000000008152600401614b809190615fe8565b60405180910390fd5b614b928161338d565b50565b614b9d614a80565b5f614ba6613366565b90505f815f015f6101000a81548160ff02191690831515021790555050565b5f614bce612b22565b9050818310614c18578383836040517f8789a6ca000000000000000000000000000000000000000000000000000000008152600401614c0f93929190617338565b60405180910390fd5b82816007015f8681526020019081526020015f206003018190555050505050565b614c4783835f013583612f91565b614c5683836020013583614597565b505050565b5f60026007811115614c7057614c6f6159ec565b5b835f015f8481526020019081526020015f205f9054906101000a900460ff166007811115614ca157614ca06159ec565b5b14905092915050565b5f60046007811115614cbf57614cbe6159ec565b5b835f015f8481526020019081526020015f205f9054906101000a900460ff166007811115614cf057614cef6159ec565b5b14905092915050565b5f806007811115614d0d57614d0c6159ec565b5b835f015f8481526020019081526020015f205f9054906101000a900460ff166007811115614d3e57614d3d6159ec565b5b14905092915050565b5f614d506150f8565b905090565b5f6040517f190100000000000000000000000000000000000000000000000000000000000081528360028201528260228201526042812091505092915050565b5f805f6041845103614dd5575f805f602087015192506040870151915060608701515f1a9050614dc78882858561515b565b955095509550505050614de3565b5f600285515f1b9250925092505b9250925092565b5f6003811115614dfd57614dfc6159ec565b5b826003811115614e1057614e0f6159ec565b5b0315614f485760016003811115614e2a57614e296159ec565b5b826003811115614e3d57614e3c6159ec565b5b03614e74576040517ff645eedf00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60026003811115614e8857614e876159ec565b5b826003811115614e9b57614e9a6159ec565b5b03614edf57805f1c6040517ffce698f7000000000000000000000000000000000000000000000000000000008152600401614ed691906154cc565b60405180910390fd5b600380811115614ef257614ef16159ec565b5b826003811115614f0557614f046159ec565b5b03614f4757806040517fd78bce0c000000000000000000000000000000000000000000000000000000008152600401614f3e9190615c3c565b60405180910390fd5b5b5050565b5f819050919050565b5f8173ffffffffffffffffffffffffffffffffffffffff163b03614fb057806040517f4c9c8ce3000000000000000000000000000000000000000000000000000000008152600401614fa79190615fe8565b60405180910390fd5b80614fdc7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5f1b614f4c565b5f015f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555050565b60605f808473ffffffffffffffffffffffffffffffffffffffff168460405161504791906173a7565b5f60405180830381855af49150503d805f811461507f576040519150601f19603f3d011682016040523d82523d5f602084013e615084565b606091505b5091509150615094858383615242565b9250505092915050565b5f3411156150d8576040517fb398979f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b565b5f6150e36133f5565b5f0160089054906101000a900460ff16905090565b5f7f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f6151226152cf565b61512a615345565b46306040516020016151409594939291906173bd565b60405160208183030381529060405280519060200120905090565b5f805f7f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0845f1c1115615197575f600385925092509250615238565b5f6001888888886040515f81526020016040526040516151ba9493929190617429565b6020604051602081039080840390855afa1580156151da573d5f803e3d5ffd5b5050506020604051035190505f73ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff160361522b575f60015f801b93509350935050615238565b805f805f1b935093509350505b9450945094915050565b60608261525757615252826153bc565b6152c7565b5f825114801561527d57505f8473ffffffffffffffffffffffffffffffffffffffff163b145b156152bf57836040517f9996b3150000000000000000000000000000000000000000000000000000000081526004016152b69190615fe8565b60405180910390fd5b8190506152c8565b5b9392505050565b5f806152d9613f10565b90505f6152e4613f37565b90505f8151111561530057808051906020012092505050615342565b5f825f015490505f801b811461531b57809350505050615342565b7fc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a47093505050505b90565b5f8061534f613f10565b90505f61535a613fd5565b90505f81511115615376578080519060200120925050506153b9565b5f826001015490505f801b8114615392578093505050506153b9565b7fc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a47093505050505b90565b5f815111156153ce5780518082602001fd5b6040517fd6bda27500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6040518060a001604052805f81526020015f81526020015f77ffffffffffffffffffffffffffffffffffffffffffffffff191681526020015f8152602001606081525090565b604051806101000160405280606081526020015f73ffffffffffffffffffffffffffffffffffffffff1681526020015f73ffffffffffffffffffffffffffffffffffffffff1681526020015f8152602001606081526020016060815260200160608152602001606081525090565b5f819050919050565b6154c6816154b4565b82525050565b5f6020820190506154df5f8301846154bd565b92915050565b5f81519050919050565b5f82825260208201905092915050565b5f5b8381101561551c578082015181840152602081019050615501565b5f8484015250505050565b5f601f19601f8301169050919050565b5f615541826154e5565b61554b81856154ef565b935061555b8185602086016154ff565b61556481615527565b840191505092915050565b5f6020820190508181035f8301526155878184615537565b905092915050565b615598816154b4565b82525050565b5f7fffffffffffffffff00000000000000000000000000000000000000000000000082169050919050565b6155d28161559e565b82525050565b5f81519050919050565b5f82825260208201905092915050565b5f819050602082019050919050565b5f82825260208201905092915050565b5f61561b826154e5565b6156258185615601565b93506156358185602086016154ff565b61563e81615527565b840191505092915050565b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f61567282615649565b9050919050565b61568281615668565b82525050565b5f81519050919050565b5f82825260208201905092915050565b5f6156ac82615688565b6156b68185615692565b93506156c68185602086016154ff565b6156cf81615527565b840191505092915050565b5f61010083015f8301518482035f8601526156f58282615611565b915050602083015161570a6020860182615679565b50604083015161571d6040860182615679565b506060830151615730606086018261558f565b506080830151848203608086015261574882826156a2565b91505060a083015184820360a08601526157628282615611565b91505060c083015184820360c086015261577c8282615611565b91505060e083015184820360e086015261579682826156a2565b9150508091505092915050565b5f6157ae83836156da565b905092915050565b5f602082019050919050565b5f6157cc826155d8565b6157d681856155e2565b9350836020820285016157e8856155f2565b805f5b85811015615823578484038952815161580485826157a3565b945061580f836157b6565b925060208a019950506001810190506157eb565b50829750879550505050505092915050565b5f60a083015f83015161584a5f86018261558f565b50602083015161585d602086018261558f565b50604083015161587060408601826155c9565b506060830151615883606086018261558f565b506080830151848203608086015261589b82826157c2565b9150508091505092915050565b5f6020820190508181035f8301526158c08184615835565b905092915050565b5f604051905090565b5f80fd5b5f80fd5b6158e2816154b4565b81146158ec575f80fd5b50565b5f813590506158fd816158d9565b92915050565b5f80fd5b5f80fd5b5f80fd5b5f8083601f84011261592457615923615903565b5b8235905067ffffffffffffffff81111561594157615940615907565b5b60208301915083600182028301111561595d5761595c61590b565b5b9250929050565b5f805f6040848603121561597b5761597a6158d1565b5b5f615988868287016158ef565b935050602084013567ffffffffffffffff8111156159a9576159a86158d5565b5b6159b58682870161590f565b92509250509250925092565b5f602082840312156159d6576159d56158d1565b5b5f6159e3848285016158ef565b91505092915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52602160045260245ffd5b60088110615a2a57615a296159ec565b5b50565b5f819050615a3a82615a19565b919050565b5f615a4982615a2d565b9050919050565b615a5981615a3f565b82525050565b5f602082019050615a725f830184615a50565b92915050565b615a8181615668565b8114615a8b575f80fd5b50565b5f81359050615a9c81615a78565b92915050565b5f80fd5b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b615adc82615527565b810181811067ffffffffffffffff82111715615afb57615afa615aa6565b5b80604052505050565b5f615b0d6158c8565b9050615b198282615ad3565b919050565b5f67ffffffffffffffff821115615b3857615b37615aa6565b5b615b4182615527565b9050602081019050919050565b828183375f83830152505050565b5f615b6e615b6984615b1e565b615b04565b905082815260208101848484011115615b8a57615b89615aa2565b5b615b95848285615b4e565b509392505050565b5f82601f830112615bb157615bb0615903565b5b8135615bc1848260208601615b5c565b91505092915050565b5f8060408385031215615be057615bdf6158d1565b5b5f615bed85828601615a8e565b925050602083013567ffffffffffffffff811115615c0e57615c0d6158d5565b5b615c1a85828601615b9d565b9150509250929050565b5f819050919050565b615c3681615c24565b82525050565b5f602082019050615c4f5f830184615c2d565b92915050565b5f8115159050919050565b615c6981615c55565b82525050565b5f602082019050615c825f830184615c60565b92915050565b5f81519050919050565b5f82825260208201905092915050565b5f819050602082019050919050565b5f615cbc8383615679565b60208301905092915050565b5f602082019050919050565b5f615cde82615c88565b615ce88185615c92565b9350615cf383615ca2565b805f5b83811015615d23578151615d0a8882615cb1565b9750615d1583615cc8565b925050600181019050615cf6565b5085935050505092915050565b5f6020820190508181035f830152615d488184615cd4565b905092915050565b615d598161559e565b8114615d63575f80fd5b50565b5f81359050615d7481615d50565b92915050565b5f8083601f840112615d8f57615d8e615903565b5b8235905067ffffffffffffffff811115615dac57615dab615907565b5b602083019150836020820283011115615dc857615dc761590b565b5b9250929050565b5f80fd5b5f60408284031215615de857615de7615dcf565b5b81905092915050565b5f805f805f60a08688031215615e0a57615e096158d1565b5b5f615e1788828901615d66565b9550506020615e28888289016158ef565b945050604086013567ffffffffffffffff811115615e4957615e486158d5565b5b615e5588828901615d7a565b93509350506060615e6888828901615dd3565b9150509295509295909350565b5f7fff0000000000000000000000000000000000000000000000000000000000000082169050919050565b615ea981615e75565b82525050565b615eb881615668565b82525050565b5f81519050919050565b5f82825260208201905092915050565b5f819050602082019050919050565b5f615ef2838361558f565b60208301905092915050565b5f602082019050919050565b5f615f1482615ebe565b615f1e8185615ec8565b9350615f2983615ed8565b805f5b83811015615f59578151615f408882615ee7565b9750615f4b83615efe565b925050600181019050615f2c565b5085935050505092915050565b5f60e082019050615f795f83018a615ea0565b8181036020830152615f8b8189615537565b90508181036040830152615f9f8188615537565b9050615fae60608301876154bd565b615fbb6080830186615eaf565b615fc860a0830185615c2d565b81810360c0830152615fda8184615f0a565b905098975050505050505050565b5f602082019050615ffb5f830184615eaf565b92915050565b5f8060408385031215616017576160166158d1565b5b5f616024858286016158ef565b925050602061603585828601615a8e565b9150509250929050565b5f60208284031215616054576160536158d1565b5b5f61606184828501615a8e565b91505092915050565b5f61010083015f8301518482035f8601526160858282615611565b915050602083015161609a6020860182615679565b5060408301516160ad6040860182615679565b5060608301516160c0606086018261558f565b50608083015184820360808601526160d882826156a2565b91505060a083015184820360a08601526160f28282615611565b91505060c083015184820360c086015261610c8282615611565b91505060e083015184820360e086015261612682826156a2565b9150508091505092915050565b5f6020820190508181035f83015261614b818461606a565b905092915050565b61615c81615c55565b8114616166575f80fd5b50565b5f8135905061617781616153565b92915050565b5f6060828403121561619257616191615dcf565b5b81905092915050565b5f805f805f805f610120888a0312156161b7576161b66158d1565b5b5f6161c48a828b01615d66565b97505060206161d58a828b01616169565b96505060406161e68a828b016158ef565b955050606088013567ffffffffffffffff811115616207576162066158d5565b5b6162138a828b01615d7a565b945094505060806162268a828b0161617d565b92505060e06162378a828b01615dd3565b91505092959891949750929550565b5f81905092915050565b5f61625a826154e5565b6162648185616246565b93506162748185602086016154ff565b80840191505092915050565b7f20760000000000000000000000000000000000000000000000000000000000005f82015250565b5f6162b4600283616246565b91506162bf82616280565b600282019050919050565b7f2e000000000000000000000000000000000000000000000000000000000000005f82015250565b5f6162fe600183616246565b9150616309826162ca565b600182019050919050565b5f61631f8287616250565b915061632a826162a8565b91506163368286616250565b9150616341826162f2565b915061634d8285616250565b9150616358826162f2565b91506163648284616250565b915081905095945050505050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52602260045260245ffd5b5f60028204905060018216806163b657607f821691505b6020821081036163c9576163c8616372565b5b50919050565b5f82905092915050565b5f819050815f5260205f209050919050565b5f6020601f8301049050919050565b5f82821b905092915050565b5f600883026164357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff826163fa565b61643f86836163fa565b95508019841693508086168417925050509392505050565b5f819050919050565b5f61647a616475616470846154b4565b616457565b6154b4565b9050919050565b5f819050919050565b61649383616460565b6164a761649f82616481565b848454616406565b825550505050565b5f90565b6164bb6164af565b6164c681848461648a565b505050565b5b818110156164e9576164de5f826164b3565b6001810190506164cc565b5050565b601f82111561652e576164ff816163d9565b616508846163eb565b81016020851015616517578190505b61652b616523856163eb565b8301826164cb565b50505b505050565b5f82821c905092915050565b5f61654e5f1984600802616533565b1980831691505092915050565b5f616566838361653f565b9150826002028217905092915050565b61658083836163cf565b67ffffffffffffffff81111561659957616598615aa6565b5b6165a3825461639f565b6165ae8282856164ed565b5f601f8311600181146165db575f84156165c9578287013590505b6165d3858261655b565b86555061663a565b601f1984166165e9866163d9565b5f5b82811015616610578489013582556001820191506020850194506020810190506165eb565b8683101561662d5784890135616629601f89168261653f565b8355505b6001600288020188555050505b50505050505050565b5f61665160208401846158ef565b905092915050565b604082016166695f830183616643565b6166755f85018261558f565b506166836020830183616643565b616690602085018261558f565b50505050565b61669f8161559e565b82525050565b5f82825260208201905092915050565b5f819050919050565b5f80fd5b5f80fd5b5f80fd5b5f80833560016020038436030381126166e6576166e56166c6565b5b83810192508235915060208301925067ffffffffffffffff82111561670e5761670d6166be565b5b600182023603831315616724576167236166c2565b5b509250929050565b5f6167378385615601565b9350616744838584615b4e565b61674d83615527565b840190509392505050565b5f6167666020840184615a8e565b905092915050565b5f808335600160200384360303811261678a576167896166c6565b5b83810192508235915060208301925067ffffffffffffffff8211156167b2576167b16166be565b5b6001820236038313156167c8576167c76166c2565b5b509250929050565b5f6167db8385615692565b93506167e8838584615b4e565b6167f183615527565b840190509392505050565b5f610100830161680e5f8401846166ca565b8583035f87015261682083828461672c565b925050506168316020840184616758565b61683e6020860182615679565b5061684c6040840184616758565b6168596040860182615679565b506168676060840184616643565b616874606086018261558f565b50616882608084018461676e565b85830360808701526168958382846167d0565b925050506168a660a08401846166ca565b85830360a08701526168b983828461672c565b925050506168ca60c08401846166ca565b85830360c08701526168dd83828461672c565b925050506168ee60e084018461676e565b85830360e08701526169018382846167d0565b925050508091505092915050565b5f61691a83836167fc565b905092915050565b5f823560016101000383360303811261693e5761693d6166c6565b5b82810191505092915050565b5f602082019050919050565b5f61696183856166a5565b935083602084028501616973846166b5565b805f5b878110156169b657848403895261698d8284616922565b616997858261690f565b94506169a28361694a565b925060208a01995050600181019050616976565b50829750879450505050509392505050565b5f60a0820190506169db5f830188616659565b6169e86040830187616696565b6169f560608301866154bd565b8181036080830152616a08818486616956565b90509695505050505050565b5f67ffffffffffffffff82169050919050565b616a3081616a14565b82525050565b5f602082019050616a495f830184616a27565b92915050565b5f81519050616a5d81615a78565b92915050565b5f60208284031215616a7857616a776158d1565b5b5f616a8584828501616a4f565b91505092915050565b7f4549503731323a20556e696e697469616c697a656400000000000000000000005f82015250565b5f616ac26015836154ef565b9150616acd82616a8e565b602082019050919050565b5f6020820190508181035f830152616aef81616ab6565b9050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5f616b2d826154b4565b9150616b38836154b4565b9250828201905080821115616b5057616b4f616af6565b5b92915050565b5f604082019050616b695f8301856154bd565b616b766020830184615eaf565b9392505050565b5f604082019050616b905f8301856154bd565b616b9d60208301846154bd565b9392505050565b60608201616bb45f830183616643565b616bc05f85018261558f565b50616bce6020830183616643565b616bdb602085018261558f565b50616be96040830183616643565b616bf6604085018261558f565b50505050565b5f60a0820190508181035f830152616c148186615835565b90508181036020830152616c288185615835565b9050616c376040830184616ba4565b949350505050565b5f6060820190508181035f830152616c578186615835565b90508181036020830152616c6b8185615835565b9050616c7a60408301846154bd565b949350505050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601260045260245ffd5b5f604082019050616cc25f830185615c2d565b616ccf60208301846154bd565b9392505050565b5f6040820190508181035f830152616cee8185615835565b9050616cfd60208301846154bd565b9392505050565b616d0d81615c24565b8114616d17575f80fd5b50565b5f81519050616d2881616d04565b92915050565b5f60208284031215616d4357616d426158d1565b5b5f616d5084828501616d1a565b91505092915050565b5f616d63826154b4565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8203616d9557616d94616af6565b5b600182019050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603260045260245ffd5b5f80fd5b5f80fd5b5f80fd5b5f8235600161010003833603038112616df557616df4616dcd565b5b80830191505092915050565b5f8083356001602003843603038112616e1d57616e1c616dcd565b5b80840192508235915067ffffffffffffffff821115616e3f57616e3e616dd1565b5b602083019250600182023603831315616e5b57616e5a616dd5565b5b509250929050565b5f82905092915050565b5f819050815f5260205f209050919050565b601f821115616ec057616e9181616e6d565b616e9a846163eb565b81016020851015616ea9578190505b616ebd616eb5856163eb565b8301826164cb565b50505b505050565b616ecf8383616e63565b67ffffffffffffffff811115616ee857616ee7615aa6565b5b616ef2825461639f565b616efd828285616e7f565b5f601f831160018114616f2a575f8415616f18578287013590505b616f22858261655b565b865550616f89565b601f198416616f3886616e6d565b5f5b82811015616f5f57848901358255600182019150602085019450602081019050616f3a565b86831015616f7c5784890135616f78601f89168261653f565b8355505b6001600288020188555050505b50505050505050565b616f9d838383616ec5565b505050565b5f8135616fae81615a78565b80915050919050565b5f815f1b9050919050565b5f73ffffffffffffffffffffffffffffffffffffffff616fe184616fb7565b9350801983169250808416831791505092915050565b5f61701161700c61700784615649565b616457565b615649565b9050919050565b5f61702282616ff7565b9050919050565b5f61703382617018565b9050919050565b5f819050919050565b61704c82617029565b61705f6170588261703a565b8354616fc2565b8255505050565b5f8135617072816158d9565b80915050919050565b5f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff6170a684616fb7565b9350801983169250808416831791505092915050565b6170c582616460565b6170d86170d182616481565b835461707b565b8255505050565b5f80833560016020038436030381126170fb576170fa616dcd565b5b80840192508235915067ffffffffffffffff82111561711d5761711c616dd1565b5b60208301925060018202360383131561713957617138616dd5565b5b509250929050565b61714c838383616576565b505050565b5f81015f83016171618185616e01565b61716c818386616f92565b5050505060018101602083018061718281616fa2565b905061718e8184617043565b5050506002810160408301806171a381616fa2565b90506171af8184617043565b5050506003810160608301806171c481617066565b90506171d081846170bc565b50505060048101608083016171e581856170df565b6171f0818386617141565b505050506005810160a083016172068185616e01565b617211818386616f92565b505050506006810160c083016172278185616e01565b617232818386616f92565b505050506007810160e0830161724881856170df565b617253818386617141565b505050505050565b6172658282617151565b5050565b617272826154e5565b67ffffffffffffffff81111561728b5761728a615aa6565b5b617295825461639f565b6172a0828285616e7f565b5f60209050601f8311600181146172d1575f84156172bf578287015190505b6172c9858261655b565b865550617330565b601f1984166172df86616e6d565b5f5b82811015617306578489015182556001820191506020850194506020810190506172e1565b86831015617323578489015161731f601f89168261653f565b8355505b6001600288020188555050505b505050505050565b5f60608201905061734b5f8301866154bd565b61735860208301856154bd565b61736560408301846154bd565b949350505050565b5f81905092915050565b5f61738182615688565b61738b818561736d565b935061739b8185602086016154ff565b80840191505092915050565b5f6173b28284617377565b915081905092915050565b5f60a0820190506173d05f830188615c2d565b6173dd6020830187615c2d565b6173ea6040830186615c2d565b6173f760608301856154bd565b6174046080830184615eaf565b9695505050505050565b5f60ff82169050919050565b6174238161740e565b82525050565b5f60808201905061743c5f830187615c2d565b617449602083018661741a565b6174566040830185615c2d565b6174636060830184615c2d565b9594505050505056fe4b6579526573686172696e67566572696669636174696f6e2875696e7432353620636f6e74657874496429
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R`\x046\x10a\x02\x03W_5`\xE0\x1C\x80c\x83\xB4 \xC4\x11a\x01\x17W\x80c\xD8\xE3\xAE\x01\x11a\0\x9FW\x80c\xE3\xB2\xA8t\x11a\0nW\x80c\xE3\xB2\xA8t\x14a\x06\xAFW\x80c\xE7\xB1\xEC9\x14a\x06\xEBW\x80c\xEB\x84<\xF6\x14a\x07\x13W\x80c\xF2|\xB9W\x14a\x07;W\x80c\xF2\xFD\xE3\x8B\x14a\x07QWa\x02\x03V[\x80c\xD8\xE3\xAE\x01\x14a\x06\x0BW\x80c\xDE\xFB\xA0j\x14a\x065W\x80c\xDF\xE3j\xEE\x14a\x06]W\x80c\xE3\x0C9x\x14a\x06\x85Wa\x02\x03V[\x80c\x8D\xA5\xCB[\x11a\0\xE6W\x80c\x8D\xA5\xCB[\x14a\x05+W\x80c\x9E\xE7z\xF3\x14a\x05UW\x80c\xAD<\xB1\xCC\x14a\x05}W\x80c\xB8q]M\x14a\x05\xA7W\x80c\xC0\xAEd\xF7\x14a\x05\xE3Wa\x02\x03V[\x80c\x83\xB4 \xC4\x14a\x04\xA7W\x80c\x84V\xCBY\x14a\x04\xCFW\x80c\x84\xB0\x19n\x14a\x04\xE5W\x80c\x8C\xB9gQ\x14a\x05\x15Wa\x02\x03V[\x80cMiB`\x11a\x01\x9AW\x80cd\xB0\x0C\xC5\x11a\x01iW\x80cd\xB0\x0C\xC5\x14a\x03\xEBW\x80cqP\x18\xA6\x14a\x04'W\x80ct \xF3\xD4\x14a\x04=W\x80cy\xBAP\x97\x14a\x04gW\x80c~\xAA\xC8\xF2\x14a\x04}Wa\x02\x03V[\x80cMiB`\x14a\x03?W\x80cO\x1E\xF2\x86\x14a\x03{W\x80cR\xD1\x90-\x14a\x03\x97W\x80c\\\x97Z\xBB\x14a\x03\xC1Wa\x02\x03V[\x80c.-:\x82\x11a\x01\xD6W\x80c.-:\x82\x14a\x02\xADW\x80c?K\xA8:\x14a\x02\xD5W\x80cC\xE3~\x8A\x14a\x02\xEBW\x80cIe\xE4U\x14a\x03\x15Wa\x02\x03V[\x80c\nP\xE3\x18\x14a\x02\x07W\x80c\r\x8En,\x14a\x021W\x80c\r\xD4\x86\xC0\x14a\x02[W\x80c\x10y\xEB\xEB\x14a\x02\x85W[_\x80\xFD[4\x80\x15a\x02\x12W_\x80\xFD[Pa\x02\x1Ba\x07yV[`@Qa\x02(\x91\x90aT\xCCV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x02<W_\x80\xFD[Pa\x02Ea\x07\x92V[`@Qa\x02R\x91\x90aUoV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x02fW_\x80\xFD[Pa\x02oa\x08\rV[`@Qa\x02|\x91\x90aX\xA8V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x02\x90W_\x80\xFD[Pa\x02\xAB`\x04\x806\x03\x81\x01\x90a\x02\xA6\x91\x90aYdV[a\x0C\x99V[\0[4\x80\x15a\x02\xB8W_\x80\xFD[Pa\x02\xD3`\x04\x806\x03\x81\x01\x90a\x02\xCE\x91\x90aY\xC1V[a\x12VV[\0[4\x80\x15a\x02\xE0W_\x80\xFD[Pa\x02\xE9a\x12\xBFV[\0[4\x80\x15a\x02\xF6W_\x80\xFD[Pa\x02\xFFa\x12\xD1V[`@Qa\x03\x0C\x91\x90aT\xCCV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x03 W_\x80\xFD[Pa\x03)a\x12\xEAV[`@Qa\x036\x91\x90aT\xCCV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x03JW_\x80\xFD[Pa\x03e`\x04\x806\x03\x81\x01\x90a\x03`\x91\x90aY\xC1V[a\x13\x01V[`@Qa\x03r\x91\x90aZ_V[`@Q\x80\x91\x03\x90\xF3[a\x03\x95`\x04\x806\x03\x81\x01\x90a\x03\x90\x91\x90a[\xCAV[a\x13!V[\0[4\x80\x15a\x03\xA2W_\x80\xFD[Pa\x03\xABa\x13@V[`@Qa\x03\xB8\x91\x90a\\<V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x03\xCCW_\x80\xFD[Pa\x03\xD5a\x13qV[`@Qa\x03\xE2\x91\x90a\\oV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x03\xF6W_\x80\xFD[Pa\x04\x11`\x04\x806\x03\x81\x01\x90a\x04\x0C\x91\x90aY\xC1V[a\x13\x93V[`@Qa\x04\x1E\x91\x90aT\xCCV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x042W_\x80\xFD[Pa\x04;a\x14\"V[\0[4\x80\x15a\x04HW_\x80\xFD[Pa\x04Qa\x145V[`@Qa\x04^\x91\x90a]0V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x04rW_\x80\xFD[Pa\x04{a\x14\xE9V[\0[4\x80\x15a\x04\x88W_\x80\xFD[Pa\x04\x91a\x15wV[`@Qa\x04\x9E\x91\x90a]0V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x04\xB2W_\x80\xFD[Pa\x04\xCD`\x04\x806\x03\x81\x01\x90a\x04\xC8\x91\x90a]\xF1V[a\x16+V[\0[4\x80\x15a\x04\xDAW_\x80\xFD[Pa\x04\xE3a\x18\x98V[\0[4\x80\x15a\x04\xF0W_\x80\xFD[Pa\x04\xF9a\x19\xD3V[`@Qa\x05\x0C\x97\x96\x95\x94\x93\x92\x91\x90a_fV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x05 W_\x80\xFD[Pa\x05)a\x1A\xDCV[\0[4\x80\x15a\x056W_\x80\xFD[Pa\x05?a\x1D\x13V[`@Qa\x05L\x91\x90a_\xE8V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x05`W_\x80\xFD[Pa\x05{`\x04\x806\x03\x81\x01\x90a\x05v\x91\x90aY\xC1V[a\x1DHV[\0[4\x80\x15a\x05\x88W_\x80\xFD[Pa\x05\x91a\x1EWV[`@Qa\x05\x9E\x91\x90aUoV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x05\xB2W_\x80\xFD[Pa\x05\xCD`\x04\x806\x03\x81\x01\x90a\x05\xC8\x91\x90aY\xC1V[a\x1E\x90V[`@Qa\x05\xDA\x91\x90aT\xCCV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x05\xEEW_\x80\xFD[Pa\x06\t`\x04\x806\x03\x81\x01\x90a\x06\x04\x91\x90aY\xC1V[a\x1F\x1FV[\0[4\x80\x15a\x06\x16W_\x80\xFD[Pa\x06\x1Fa .V[`@Qa\x06,\x91\x90aT\xCCV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x06@W_\x80\xFD[Pa\x06[`\x04\x806\x03\x81\x01\x90a\x06V\x91\x90a`\x01V[a EV[\0[4\x80\x15a\x06hW_\x80\xFD[Pa\x06\x83`\x04\x806\x03\x81\x01\x90a\x06~\x91\x90a`\x01V[a!ZV[\0[4\x80\x15a\x06\x90W_\x80\xFD[Pa\x06\x99a\"oV[`@Qa\x06\xA6\x91\x90a_\xE8V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x06\xBAW_\x80\xFD[Pa\x06\xD5`\x04\x806\x03\x81\x01\x90a\x06\xD0\x91\x90a`?V[a\"\xA4V[`@Qa\x06\xE2\x91\x90aa3V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x06\xF6W_\x80\xFD[Pa\x07\x11`\x04\x806\x03\x81\x01\x90a\x07\x0C\x91\x90aa\x9BV[a'#V[\0[4\x80\x15a\x07\x1EW_\x80\xFD[Pa\x079`\x04\x806\x03\x81\x01\x90a\x074\x91\x90aY\xC1V[a)\x13V[\0[4\x80\x15a\x07FW_\x80\xFD[Pa\x07Oa)|V[\0[4\x80\x15a\x07\\W_\x80\xFD[Pa\x07w`\x04\x806\x03\x81\x01\x90a\x07r\x91\x90a`?V[a*iV[\0[_\x80a\x07\x83a+\"V[\x90P\x80_\x01`\x04\x01T\x91PP\x90V[```@Q\x80`@\x01`@R\x80`\x0B\x81R` \x01\x7FKmsContexts\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81RPa\x07\xD3_a+IV[a\x07\xDD`\x01a+IV[a\x07\xE6_a+IV[`@Q` \x01a\x07\xF9\x94\x93\x92\x91\x90ac\x14V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x90P\x90V[a\x08\x15aT\0V[_a\x08\x1Ea+\"V[\x90P_a\x08)a\x12\xD1V[\x90P\x81`\x07\x01_\x82\x81R` \x01\x90\x81R` \x01_ `@Q\x80`\xA0\x01`@R\x90\x81_\x82\x01T\x81R` \x01`\x01\x82\x01T\x81R` \x01`\x02\x82\x01_\x90T\x90a\x01\0\n\x90\x04`\xC0\x1Bw\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16w\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x81R` \x01`\x03\x82\x01T\x81R` \x01`\x04\x82\x01\x80T\x80` \x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01_\x90[\x82\x82\x10\x15a\x0C\x8AW\x83\x82\x90_R` _ \x90`\x08\x02\x01`@Q\x80a\x01\0\x01`@R\x90\x81_\x82\x01\x80Ta\t\x07\x90ac\x9FV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\t3\x90ac\x9FV[\x80\x15a\t~W\x80`\x1F\x10a\tUWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\t~V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\taW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x01\x82\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01`\x02\x82\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01`\x03\x82\x01T\x81R` \x01`\x04\x82\x01\x80Ta\nK\x90ac\x9FV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\nw\x90ac\x9FV[\x80\x15a\n\xC2W\x80`\x1F\x10a\n\x99Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\n\xC2V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\n\xA5W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x05\x82\x01\x80Ta\n\xDB\x90ac\x9FV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x0B\x07\x90ac\x9FV[\x80\x15a\x0BRW\x80`\x1F\x10a\x0B)Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x0BRV[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x0B5W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x06\x82\x01\x80Ta\x0Bk\x90ac\x9FV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x0B\x97\x90ac\x9FV[\x80\x15a\x0B\xE2W\x80`\x1F\x10a\x0B\xB9Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x0B\xE2V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x0B\xC5W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x07\x82\x01\x80Ta\x0B\xFB\x90ac\x9FV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x0C'\x90ac\x9FV[\x80\x15a\x0CrW\x80`\x1F\x10a\x0CIWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x0CrV[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x0CUW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81RPP\x81R` \x01\x90`\x01\x01\x90a\x08\xD6V[PPPP\x81RPP\x92PPP\x90V[a\x0C\xA3\x833a EV[_a\x0C\xACa+\"V[\x90Pa\x0C\xBA\x81_\x01\x85a,\x13V[a\x0C\xFBW\x83`@Q\x7F^Q\xA2\xE1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x0C\xF2\x91\x90aT\xCCV[`@Q\x80\x91\x03\x90\xFD[_`@Q\x80` \x01`@R\x80\x86\x81RP\x90P_a\r\x17\x82a,bV[\x90Pa\r%\x86\x82\x87\x87a,\xBDV[_\x83`\n\x01_\x88\x81R` \x01\x90\x81R` \x01_ \x90P\x80\x86\x86\x90\x91\x80`\x01\x81T\x01\x80\x82U\x80\x91PP`\x01\x90\x03\x90_R` _ \x01_\x90\x91\x92\x90\x91\x92\x90\x91\x92\x90\x91\x92P\x91\x82a\rt\x92\x91\x90aevV[P_\x84`\x07\x01_\x89\x81R` \x01\x90\x81R` \x01_ `@Q\x80`\xA0\x01`@R\x90\x81_\x82\x01T\x81R` \x01`\x01\x82\x01T\x81R` \x01`\x02\x82\x01_\x90T\x90a\x01\0\n\x90\x04`\xC0\x1Bw\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16w\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x81R` \x01`\x03\x82\x01T\x81R` \x01`\x04\x82\x01\x80T\x80` \x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01_\x90[\x82\x82\x10\x15a\x11\xD5W\x83\x82\x90_R` _ \x90`\x08\x02\x01`@Q\x80a\x01\0\x01`@R\x90\x81_\x82\x01\x80Ta\x0ER\x90ac\x9FV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x0E~\x90ac\x9FV[\x80\x15a\x0E\xC9W\x80`\x1F\x10a\x0E\xA0Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x0E\xC9V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x0E\xACW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x01\x82\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01`\x02\x82\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01`\x03\x82\x01T\x81R` \x01`\x04\x82\x01\x80Ta\x0F\x96\x90ac\x9FV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x0F\xC2\x90ac\x9FV[\x80\x15a\x10\rW\x80`\x1F\x10a\x0F\xE4Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x10\rV[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x0F\xF0W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x05\x82\x01\x80Ta\x10&\x90ac\x9FV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x10R\x90ac\x9FV[\x80\x15a\x10\x9DW\x80`\x1F\x10a\x10tWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x10\x9DV[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x10\x80W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x06\x82\x01\x80Ta\x10\xB6\x90ac\x9FV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x10\xE2\x90ac\x9FV[\x80\x15a\x11-W\x80`\x1F\x10a\x11\x04Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x11-V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x11\x10W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x07\x82\x01\x80Ta\x11F\x90ac\x9FV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x11r\x90ac\x9FV[\x80\x15a\x11\xBDW\x80`\x1F\x10a\x11\x94Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x11\xBDV[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x11\xA0W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81RPP\x81R` \x01\x90`\x01\x01\x90a\x0E!V[PPPP\x81RPP\x90Pa\x11\xED\x81\x83\x80T\x90Pa./V[\x15a\x12LW_\x85`\x13\x01_\x8A\x81R` \x01\x90\x81R` \x01_ T\x90Pa\x12\x13\x82\x82a.FV[\x7Fh\x89\x8A\x98\x93k\xF2:V\xE8\xEDK#\xDC\xC9\x8C\xEF\x92k\xD9\xAC,\xE5\"\xF1\xF9B>8d\xF2\xF5\x82`@Qa\x12B\x91\x90aX\xA8V[`@Q\x80\x91\x03\x90\xA1P[PPPPPPPPV[a\x12^a.\xC9V[a\x12fa/PV[_a\x12oa\x08\rV[\x90Pa\x12\x84\x81_\x01Q\x83\x83`\x80\x01QQa/\x91V[\x7F\xE4\x18\x02\xAFrW)\xAD\xCB\x8C\x15\x1E)78\n%\xC6\x91Uu~:\xF5\xD3\x97\x9A\xDA\xB5\x03X\0\x82`@Qa\x12\xB3\x91\x90aT\xCCV[`@Q\x80\x91\x03\x90\xA1PPV[a\x12\xC7a.\xC9V[a\x12\xCFa0:V[V[_\x80a\x12\xDBa+\"V[\x90P\x80_\x01`\x03\x01T\x91PP\x90V[_\x80a\x12\xF4a+\"V[\x90P\x80`\x05\x01T\x91PP\x90V[_\x80a\x13\x0Ba+\"V[\x90Pa\x13\x19\x81_\x01\x84a0\xA8V[\x91PP\x91\x90PV[a\x13)a0\xD0V[a\x132\x82a1\xB6V[a\x13<\x82\x82a1\xC1V[PPV[_a\x13Ia2\xDFV[\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC_\x1B\x90P\x90V[_\x80a\x13{a3fV[\x90P\x80_\x01_\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x91PP\x90V[_\x81_a\x13\x9Ea+\"V[\x90P_\x81`\x07\x01_\x84\x81R` \x01\x90\x81R` \x01_ _\x01T\x03a\x13\xF9W\x81`@Q\x7F\x82\xB1\xFB\xDA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x13\xF0\x91\x90aT\xCCV[`@Q\x80\x91\x03\x90\xFD[_a\x14\x02a+\"V[\x90P\x80`\x16\x01_\x86\x81R` \x01\x90\x81R` \x01_ T\x93PPPP\x91\x90PV[a\x14*a.\xC9V[a\x143_a3\x8DV[V[``_a\x14@a\x12\xD1V[\x90P_a\x14Ka+\"V[\x90P\x80`\x0E\x01_\x83\x81R` \x01\x90\x81R` \x01_ \x80T\x80` \x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80T\x80\x15a\x14\xDDW` \x02\x82\x01\x91\x90_R` _ \x90[\x81_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90`\x01\x01\x90\x80\x83\x11a\x14\x94W[PPPPP\x92PPP\x90V[_a\x14\xF2a3\xCAV[\x90P\x80s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x15\x13a\"oV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x15kW\x80`@Q\x7F\x11\x8C\xDA\xA7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x15b\x91\x90a_\xE8V[`@Q\x80\x91\x03\x90\xFD[a\x15t\x81a3\x8DV[PV[``_a\x15\x82a\x12\xD1V[\x90P_a\x15\x8Da+\"V[\x90P\x80`\x0F\x01_\x83\x81R` \x01\x90\x81R` \x01_ \x80T\x80` \x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80T\x80\x15a\x16\x1FW` \x02\x82\x01\x91\x90_R` _ \x90[\x81_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90`\x01\x01\x90\x80\x83\x11a\x15\xD6W[PPPPP\x92PPP\x90V[`\x01a\x165a3\xD1V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x16vW`@Q\x7FoOs\x1F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x02_a\x16\x81a3\xF5V[\x90P\x80_\x01`\x08\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x80a\x16\xC9WP\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81_\x01_\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x10\x15[\x15a\x17\0W`@Q\x7F\xF9.\xE8\xA9\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x81\x81_\x01_a\x01\0\n\x81T\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP`\x01\x81_\x01`\x08a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UPa\x17\xB9`@Q\x80`@\x01`@R\x80`\x0B\x81R` \x01\x7FKmsContexts\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81RP`@Q\x80`@\x01`@R\x80`\x01\x81R` \x01\x7F1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81RPa4\x1CV[a\x17\xC9a\x17\xC4a\x1D\x13V[a42V[a\x17\xD1a4FV[_a\x17\xE0_\x89\x89\x89\x89\x89a4XV[\x90P_a\x17\xEBa+\"V[\x90Pa\x17\xFC\x81_\x01\x83_\x01Qa=\xA6V[\x7FTHun\xE1?\x8E^\x9A\x81\xF5t\xACh\xC8\x81J\x16a+\xEE\x06\xFE\xA0\xFD\x80\xC6\x16\x10Cm\xCD\x85\x8A\x8A\x8A\x8A`@Qa\x183\x95\x94\x93\x92\x91\x90ai\xC8V[`@Q\x80\x91\x03\x90\xA1PP_\x81_\x01`\x08a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP\x7F\xC7\xF5\x05\xB2\xF3q\xAE!u\xEEI\x13\xF4I\x9E\x1F&3\xA7\xB5\x93c!\xEE\xD1\xCD\xAE\xB6\x11Q\x81\xD2\x82`@Qa\x18\x87\x91\x90aj6V[`@Q\x80\x91\x03\x90\xA1PPPPPPPV[a\x18\xA0a\x1D\x13V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14\x15\x80\x15a\x19\x87WPs\xC7\xD4Va\xA3E\xEC\\\xA0\xE8R\x1C\xFE\xF7\xE3/\xDA\r\xAAhs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16cp\x08\xB5H`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x193W=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x19W\x91\x90ajcV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14\x15[\x15a\x19\xC9W3`@Q\x7FF\xC0\xD9\xAF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x19\xC0\x91\x90a_\xE8V[`@Q\x80\x91\x03\x90\xFD[a\x19\xD1a>\xA1V[V[_``\x80_\x80_``_a\x19\xE5a?\x10V[\x90P_\x80\x1B\x81_\x01T\x14\x80\x15a\x1A\0WP_\x80\x1B\x81`\x01\x01T\x14[a\x1A?W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x1A6\x90aj\xD8V[`@Q\x80\x91\x03\x90\xFD[a\x1AGa?7V[a\x1AOa?\xD5V[F0_\x80\x1B_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x1AnWa\x1AmaZ\xA6V[[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a\x1A\x9CW\x81` \x01` \x82\x02\x806\x837\x80\x82\x01\x91PP\x90P[P\x7F\x0F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x95\x94\x93\x92\x91\x90\x97P\x97P\x97P\x97P\x97P\x97P\x97PP\x90\x91\x92\x93\x94\x95\x96V[a\x1A\xE4a/PV[_a\x1A\xEDa+\"V[\x90P_\x81_\x01`\x01\x01T\x90P_\x81\x14\x15\x80\x15a\x1B\x1CWP\x81`\x10\x01_\x82\x81R` \x01\x90\x81R` \x01_ TC\x10\x15[\x15a\x1B\x9BW~\x9F\xE8\xF0\xDBE\x99m\xEC\xF7\xB0o\xC7\xB6\xEC_\x88}_\x04\xDB.\x0CJ\xD7\xF4\xE4\xEE^\xEF\xC5\xA3\x81`@Qa\x1BO\x91\x90aT\xCCV[`@Q\x80\x91\x03\x90\xA1a\x1Bc\x82_\x01\x82a@sV[\x7F>\x8F\x02\xDCz\xF6\xE3\xA6\x7F:\xF0\xBC\x99\xBC\xF1\x1BM\xEBF\x10^\x9B\xA7\xF1\xACm\xA8#\"\xE9\x02^\x81`@Qa\x1B\x92\x91\x90aT\xCCV[`@Q\x80\x91\x03\x90\xA1[_\x82_\x01`\x02\x01T\x90P_\x81\x14\x15\x80\x15a\x1B\xC8WP\x82`\x11\x01_\x82\x81R` \x01\x90\x81R` \x01_ TC\x10\x15[\x15a\x1C\x9BW_a\x1B\xD6a\x12\xD1V[\x90P_\x84`\x14\x01_\x83\x81R` \x01\x90\x81R` \x01_ TCa\x1B\xF8\x91\x90ak#V[\x90P\x80\x85`\x12\x01_\x84\x81R` \x01\x90\x81R` \x01_ \x81\x90UPa\x1C\x1E\x85_\x01\x83aA@V[\x7F\x85\x1A\x08\xC1k\x15\x95\x9C3\x8A\xC4\xB5df\xD0l\x9F\x9D_\xF8\xD7\x15\x16\x8A\xA1%\xD5\xCC\xAFS\x83 \x82`@Qa\x1CM\x91\x90aT\xCCV[`@Q\x80\x91\x03\x90\xA1a\x1Ca\x85_\x01\x84a=\xA6V[\x7FOT\xA6\xAC\x98\x1C\xC8\xDC\x83\x14+>\xB4\xD1 \xBE|p\xFC]\xE6Gz\x14\xEA\xE3\xE9\xCAdvD\xBC\x83`@Qa\x1C\x90\x91\x90aT\xCCV[`@Q\x80\x91\x03\x90\xA1PP[_a\x1C\xA4a\x07yV[\x90P_\x81\x14a\x1D\rW\x83`\x12\x01_\x82\x81R` \x01\x90\x81R` \x01_ TC\x11\x15a\x1D\x0CWa\x1C\xD4\x84_\x01\x82aB\x16V[\x7F\x8F\xB7XX\xA5e\xAE\xE1\x174-\x93\x19j\x7F\x0BT\xC1\xC8Q\x98\x85\xED\xDD\xA6\xA0\x1FGsY\xB3c\x81`@Qa\x1D\x03\x91\x90aT\xCCV[`@Q\x80\x91\x03\x90\xA1[[PPPPV[_\x80a\x1D\x1DaC\x18V[\x90P\x80_\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x91PP\x90V[a\x1DPa.\xC9V[\x80_a\x1DZa+\"V[\x90P_\x81`\x07\x01_\x84\x81R` \x01\x90\x81R` \x01_ _\x01T\x03a\x1D\xB5W\x81`@Q\x7F\x82\xB1\xFB\xDA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x1D\xAC\x91\x90aT\xCCV[`@Q\x80\x91\x03\x90\xFD[_a\x1D\xBEa+\"V[\x90Pa\x1D\xCC\x81_\x01\x85aC?V[\x15a\x1E\x0EW\x83`@Q\x7Fw\xD0^\xA7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x1E\x05\x91\x90aT\xCCV[`@Q\x80\x91\x03\x90\xFD[a\x1E\x1A\x81_\x01\x85aC\x8EV[\x7F\xBC\x11\x14\xFA\x9Awd\x8C\xD0\x97\xEEl\xF1I\xC3D\xFA'\x8B\x9B\x98?0\xDDe\xB6\xFDj\x9DFJ\x07\x84`@Qa\x1EI\x91\x90aT\xCCV[`@Q\x80\x91\x03\x90\xA1PPPPV[`@Q\x80`@\x01`@R\x80`\x05\x81R` \x01\x7F5.0.0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81RP\x81V[_\x81_a\x1E\x9Ba+\"V[\x90P_\x81`\x07\x01_\x84\x81R` \x01\x90\x81R` \x01_ _\x01T\x03a\x1E\xF6W\x81`@Q\x7F\x82\xB1\xFB\xDA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x1E\xED\x91\x90aT\xCCV[`@Q\x80\x91\x03\x90\xFD[_a\x1E\xFFa+\"V[\x90P\x80`\x15\x01_\x86\x81R` \x01\x90\x81R` \x01_ T\x93PPPP\x91\x90PV[a\x1F'a.\xC9V[\x80_a\x1F1a+\"V[\x90P_\x81`\x07\x01_\x84\x81R` \x01\x90\x81R` \x01_ _\x01T\x03a\x1F\x8CW\x81`@Q\x7F\x82\xB1\xFB\xDA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x1F\x83\x91\x90aT\xCCV[`@Q\x80\x91\x03\x90\xFD[_a\x1F\x95a+\"V[\x90Pa\x1F\xA3\x81_\x01\x85aC?V[\x15a\x1F\xE5W\x83`@Q\x7F\xB2^N\xB3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x1F\xDC\x91\x90aT\xCCV[`@Q\x80\x91\x03\x90\xFD[a\x1F\xF1\x81_\x01\x85a@sV[\x7F>\x8F\x02\xDCz\xF6\xE3\xA6\x7F:\xF0\xBC\x99\xBC\xF1\x1BM\xEBF\x10^\x9B\xA7\xF1\xACm\xA8#\"\xE9\x02^\x84`@Qa  \x91\x90aT\xCCV[`@Q\x80\x91\x03\x90\xA1PPPPV[_\x80a 8a+\"V[\x90P\x80`\x06\x01T\x91PP\x90V[\x81_a Oa+\"V[\x90P_\x81`\x07\x01_\x84\x81R` \x01\x90\x81R` \x01_ _\x01T\x03a \xAAW\x81`@Q\x7F\x82\xB1\xFB\xDA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a \xA1\x91\x90aT\xCCV[`@Q\x80\x91\x03\x90\xFD[_a \xB3a+\"V[\x90P\x80`\x0C\x01_\x86\x81R` \x01\x90\x81R` \x01_ _\x85s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16a!SW\x84\x84`@Q\x7F\xFD\xF8\xA0]\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a!J\x92\x91\x90akVV[`@Q\x80\x91\x03\x90\xFD[PPPPPV[\x81_a!da+\"V[\x90P_\x81`\x07\x01_\x84\x81R` \x01\x90\x81R` \x01_ _\x01T\x03a!\xBFW\x81`@Q\x7F\x82\xB1\xFB\xDA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a!\xB6\x91\x90aT\xCCV[`@Q\x80\x91\x03\x90\xFD[_a!\xC8a+\"V[\x90P\x80`\r\x01_\x86\x81R` \x01\x90\x81R` \x01_ _\x85s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16a\"hW\x84\x84`@Q\x7F\x89\xB4^]\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\"_\x92\x91\x90akVV[`@Q\x80\x91\x03\x90\xFD[PPPPPV[_\x80a\"yaD\xA3V[\x90P\x80_\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x91PP\x90V[a\"\xACaTFV[_a\"\xB5a\x12\xD1V[\x90P_a\"\xC0a+\"V[\x90P_\x81`\x0B\x01_\x84\x81R` \x01\x90\x81R` \x01_ _\x86s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ `@Q\x80a\x01\0\x01`@R\x90\x81_\x82\x01\x80Ta#,\x90ac\x9FV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta#X\x90ac\x9FV[\x80\x15a#\xA3W\x80`\x1F\x10a#zWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a#\xA3V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a#\x86W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x01\x82\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01`\x02\x82\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01`\x03\x82\x01T\x81R` \x01`\x04\x82\x01\x80Ta$p\x90ac\x9FV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta$\x9C\x90ac\x9FV[\x80\x15a$\xE7W\x80`\x1F\x10a$\xBEWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a$\xE7V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a$\xCAW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x05\x82\x01\x80Ta%\0\x90ac\x9FV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta%,\x90ac\x9FV[\x80\x15a%wW\x80`\x1F\x10a%NWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a%wV[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a%ZW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x06\x82\x01\x80Ta%\x90\x90ac\x9FV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta%\xBC\x90ac\x9FV[\x80\x15a&\x07W\x80`\x1F\x10a%\xDEWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a&\x07V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a%\xEAW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x07\x82\x01\x80Ta& \x90ac\x9FV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta&L\x90ac\x9FV[\x80\x15a&\x97W\x80`\x1F\x10a&nWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a&\x97V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a&zW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81RPP\x90P_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81`@\x01Qs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x03a'\x18W\x82\x85`@Q\x7F\x04\x94\xD3\xC0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a'\x0F\x92\x91\x90akVV[`@Q\x80\x91\x03\x90\xFD[\x80\x93PPPP\x91\x90PV[a'+a.\xC9V[_a'4a+\"V[\x90P_a'?a\x08\rV[\x90P_\x81`\x80\x01QQ\x90P_\x87\x87\x90P\x90P\x81\x81\x14a'\x97W\x81\x81`@Q\x7F\xD5\x95\xA9b\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a'\x8E\x92\x91\x90ak}V[`@Q\x80\x91\x03\x90\xFD[_a'\xA0a\x07yV[\x90P_\x81\x14a'\xE6W\x80`@Q\x7Fv#\xD3W\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a'\xDD\x91\x90aT\xCCV[`@Q\x80\x91\x03\x90\xFD[_a'\xF8\x85_\x01Q\x8E\x8D\x8D\x8D\x8Ca4XV[\x90P\x87`@\x015\x86`\x14\x01_\x87_\x01Q\x81R` \x01\x90\x81R` \x01_ \x81\x90UP\x7F\xA6\x9AL\x93A\xCD}E\x8F\xDE\x12\xC3\x1A\x1FX/}L\xAE\xDB'\xC4\xA7\xC3L\xC9\x92 \x8A<\xE4\xC5\x85\x82\x8A`@Qa(L\x93\x92\x91\x90ak\xFCV[`@Q\x80\x91\x03\x90\xA1a(c\x86_\x01\x82_\x01QaD\xCAV[\x8B\x15a(\xF6W\x87_\x015\x86`\x13\x01_\x83_\x01Q\x81R` \x01\x90\x81R` \x01_ \x81\x90UP_\x88` \x015Ca(\x98\x91\x90ak#V[\x90P\x80\x87`\x10\x01_\x84_\x01Q\x81R` \x01\x90\x81R` \x01_ \x81\x90UP\x7F]\xC6\x01\x06Z\x03]x0\\\xD9\xEF'\xC9\x1A\0\x9C\xD8\xD3r\x97\xE4;\xB7c\x19I\x08\x95\xA0\xD0X\x86\x83\x83`@Qa(\xE8\x93\x92\x91\x90al?V[`@Q\x80\x91\x03\x90\xA1Pa)\x04V[a)\x03\x81\x89_\x015a.FV[[PPPPPPPPPPPPPV[a)\x1Ba.\xC9V[a)#a/PV[_a),a\x08\rV[\x90Pa)A\x81_\x01Q\x83\x83`\x80\x01QQaE\x97V[\x7F\x83~\ne(\xDA\xDF\xA2\xDCy&\x92\xC5\x18.R\xA9\xF5\xBB\xDE\xED{#r\x92z&\xC6\x95\x83\x96\x13\x82`@Qa)p\x91\x90aT\xCCV[`@Q\x80\x91\x03\x90\xA1PPV[a)\x84a.\xC9V[_a)\x8Da+\"V[\x90P_a)\x98a\x07yV[\x90P_\x81\x03a)\xD3W`@Q\x7F ~\xA3\xF3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_a)\xDCa\x12\xD1V[\x90Pa)\xEA\x83_\x01\x82aB\x16V[\x7F\x8F\xB7XX\xA5e\xAE\xE1\x174-\x93\x19j\x7F\x0BT\xC1\xC8Q\x98\x85\xED\xDD\xA6\xA0\x1FGsY\xB3c\x81`@Qa*\x19\x91\x90aT\xCCV[`@Q\x80\x91\x03\x90\xA1a*-\x83_\x01\x83a=\xA6V[\x7FOT\xA6\xAC\x98\x1C\xC8\xDC\x83\x14+>\xB4\xD1 \xBE|p\xFC]\xE6Gz\x14\xEA\xE3\xE9\xCAdvD\xBC\x82`@Qa*\\\x91\x90aT\xCCV[`@Q\x80\x91\x03\x90\xA1PPPV[a*qa.\xC9V[_a*zaD\xA3V[\x90P\x81\x81_\x01_a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a*\xDCa\x1D\x13V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F8\xD1k\x8C\xAC\"\xD9\x9F\xC7\xC1$\xB9\xCD\r\xE2\xD3\xFA\x1F\xAE\xF4 \xBF\xE7\x91\xD8\xC3b\xD7e\xE2'\0`@Q`@Q\x80\x91\x03\x90\xA3PPV[_\x7F}\x81Y\x81\n~\xBF\x94N\x8F\xA9<\xC4\xFB\xD1\xCA\xDElq\xF8\xB0\xB8k7\x18z\xC7\x99\x17w\xB1\0\x90P\x90V[``_`\x01a+W\x84aF@V[\x01\x90P_\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a+uWa+taZ\xA6V[[`@Q\x90\x80\x82R\x80`\x1F\x01`\x1F\x19\x16` \x01\x82\x01`@R\x80\x15a+\xA7W\x81` \x01`\x01\x82\x02\x806\x837\x80\x82\x01\x91PP\x90P[P\x90P_\x82` \x01\x82\x01\x90P[`\x01\x15a,\x08W\x80\x80`\x01\x90\x03\x91PP\x7F0123456789abcdef\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\n\x86\x06\x1A\x81S`\n\x85\x81a+\xFDWa+\xFCal\x82V[[\x04\x94P_\x85\x03a+\xB4W[\x81\x93PPPP\x91\x90PV[_`\x01`\x07\x81\x11\x15a,(Wa,'aY\xECV[[\x83_\x01_\x84\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16`\x07\x81\x11\x15a,YWa,XaY\xECV[[\x14\x90P\x92\x91PPV[_a,\xB6`@Q\x80``\x01`@R\x80`+\x81R` \x01atm`+\x919\x80Q\x90` \x01 \x83_\x01Q`@Q` \x01a,\x9B\x92\x91\x90al\xAFV[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 aG\x91V[\x90P\x91\x90PV[_a,\xC6a+\"V[\x90P_a-\x16\x85\x85\x85\x80\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x93\x92\x91\x90\x81\x81R` \x01\x83\x83\x80\x82\x847_\x81\x84\x01R`\x1F\x19`\x1F\x82\x01\x16\x90P\x80\x83\x01\x92PPPPPPPaG\xAAV[\x90Pa-\"\x86\x82a!ZV[\x81`\t\x01_\x87\x81R` \x01\x90\x81R` \x01_ _\x82s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x15a-\xC1W\x85\x81`@Q\x7F\x99\xB1X\xC1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a-\xB8\x92\x91\x90akVV[`@Q\x80\x91\x03\x90\xFD[`\x01\x82`\t\x01_\x88\x81R` \x01\x90\x81R` \x01_ _\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UPPPPPPPV[_\x80\x83`\x80\x01QQ\x90P\x80\x83\x10\x15\x91PP\x92\x91PPV[_a.Oa+\"V[\x90Pa.`\x81_\x01\x84_\x01QaG\xD4V[_\x82Ca.m\x91\x90ak#V[\x90P\x80\x82`\x11\x01_\x86_\x01Q\x81R` \x01\x90\x81R` \x01_ \x81\x90UP\x7FE@\xF7\x80\x8F\xCA\xEC\x86\xC3v\xA8\x9D,\x0C\x93\xA5\x05l!h\r\xB5C2\xC7\xF2\x95\x9D\x87\xFE\xFC\x8B\x84\x82`@Qa.\xBB\x92\x91\x90al\xD6V[`@Q\x80\x91\x03\x90\xA1PPPPV[a.\xD1a3\xCAV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a.\xEFa\x1D\x13V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a/NWa/\x12a3\xCAV[`@Q\x7F\x11\x8C\xDA\xA7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a/E\x91\x90a_\xE8V[`@Q\x80\x91\x03\x90\xFD[V[a/Xa\x13qV[\x15a/\x8FW`@Q\x7F\xD9<\x06e\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[V[_a/\x9Aa+\"V[\x90P_\x83\x03a/\xD5W`@Q\x7F\xB1\xAE\x92\xEA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x81\x83\x11\x15a0\x1CW\x82\x82`@Q\x7F\x84 \x8F#\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a0\x13\x92\x91\x90ak}V[`@Q\x80\x91\x03\x90\xFD[\x82\x81`\x15\x01_\x86\x81R` \x01\x90\x81R` \x01_ \x81\x90UPPPPPV[a0BaH\xAAV[_a0Ka3fV[\x90P_\x81_\x01_a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP\x7F]\xB9\xEE\nI[\xF2\xE6\xFF\x9C\x91\xA7\x83L\x1B\xA4\xFD\xD2D\xA5\xE8\xAANS{\xD3\x8A\xEA\xE4\xB0s\xAAa0\x90a3\xCAV[`@Qa0\x9D\x91\x90a_\xE8V[`@Q\x80\x91\x03\x90\xA1PV[_\x82_\x01_\x83\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x90P\x92\x91PPV[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x160s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14\x80a1}WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a1daH\xEAV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14\x15[\x15a1\xB4W`@Q\x7F\xE0|\x8D\xBA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[V[a1\xBEa.\xC9V[PV[\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16cR\xD1\x90-`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x92PPP\x80\x15a2)WP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a2&\x91\x90am.V[`\x01[a2jW\x81`@Q\x7FL\x9C\x8C\xE3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a2a\x91\x90a_\xE8V[`@Q\x80\x91\x03\x90\xFD[\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC_\x1B\x81\x14a2\xD0W\x80`@Q\x7F\xAA\x1DI\xA4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a2\xC7\x91\x90a\\<V[`@Q\x80\x91\x03\x90\xFD[a2\xDA\x83\x83aI=V[PPPV[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x160s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a3dW`@Q\x7F\xE0|\x8D\xBA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[V[_\x7F\xCD^\xD1\\n\x18~w\xE9\xAE\xE8\x81\x84\xC2\x1FO!\x82\xABX'\xCB;~\x07\xFB\xED\xCDc\xF03\0\x90P\x90V[_a3\x96aD\xA3V[\x90P\x80_\x01_a\x01\0\n\x81T\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90Ua3\xC6\x82aI\xAFV[PPV[_3\x90P\x90V[_a3\xDAa3\xF5V[_\x01_\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P\x90V[_\x7F\xF0\xC5~\x16\x84\r\xF0@\xF1P\x88\xDC/\x81\xFE9\x1C9#\xBE\xC7>#\xA9f.\xFC\x9C\"\x9Cj\0\x90P\x90V[a4$aJ\x80V[a4.\x82\x82aJ\xC0V[PPV[a4:aJ\x80V[a4C\x81aK\x11V[PV[a4NaJ\x80V[a4VaK\x95V[V[a4`aT\0V[_a4ia+\"V[\x90P_\x85\x85\x90P\x03a4\xA7W`@Q\x7F\x06\x8C\x8D@\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x80`\x08\x01_\x81T\x80\x92\x91\x90a4\xBB\x90amYV[\x91\x90PUP_\x81`\x08\x01T\x90P\x80\x82`\x07\x01_\x83\x81R` \x01\x90\x81R` \x01_ _\x01\x81\x90UP\x88\x82`\x07\x01_\x83\x81R` \x01\x90\x81R` \x01_ `\x01\x01\x81\x90UP\x87\x82`\x07\x01_\x83\x81R` \x01\x90\x81R` \x01_ `\x02\x01_a\x01\0\n\x81T\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83`\xC0\x1C\x02\x17\x90UPa5@\x81\x88\x88\x88\x90PaK\xC5V[_[\x86\x86\x90P\x81\x10\x15a5\xC9W\x82`\x07\x01_\x83\x81R` \x01\x90\x81R` \x01_ `\x04\x01\x87\x87\x83\x81\x81\x10a5vWa5uam\xA0V[[\x90P` \x02\x81\x01\x90a5\x88\x91\x90am\xD9V[\x90\x80`\x01\x81T\x01\x80\x82U\x80\x91PP`\x01\x90\x03\x90_R` _ \x90`\x08\x02\x01_\x90\x91\x90\x91\x90\x91P\x81\x81a5\xBA\x91\x90ar[V[PP\x80\x80`\x01\x01\x91PPa5BV[P_[\x86\x86\x90P\x81\x10\x15a9\"W\x86\x86\x82\x81\x81\x10a5\xEAWa5\xE9am\xA0V[[\x90P` \x02\x81\x01\x90a5\xFC\x91\x90am\xD9V[\x83`\x0B\x01_\x84\x81R` \x01\x90\x81R` \x01_ _\x89\x89\x85\x81\x81\x10a6#Wa6\"am\xA0V[[\x90P` \x02\x81\x01\x90a65\x91\x90am\xD9V[`@\x01` \x81\x01\x90a6G\x91\x90a`?V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ \x81\x81a6\x8C\x91\x90ar[V[\x90PP`\x01\x83`\x0C\x01_\x84\x81R` \x01\x90\x81R` \x01_ _\x89\x89\x85\x81\x81\x10a6\xB8Wa6\xB7am\xA0V[[\x90P` \x02\x81\x01\x90a6\xCA\x91\x90am\xD9V[`@\x01` \x81\x01\x90a6\xDC\x91\x90a`?V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP\x82`\x0E\x01_\x83\x81R` \x01\x90\x81R` \x01_ \x87\x87\x83\x81\x81\x10a7QWa7Pam\xA0V[[\x90P` \x02\x81\x01\x90a7c\x91\x90am\xD9V[`@\x01` \x81\x01\x90a7u\x91\x90a`?V[\x90\x80`\x01\x81T\x01\x80\x82U\x80\x91PP`\x01\x90\x03\x90_R` _ \x01_\x90\x91\x90\x91\x90\x91a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP`\x01\x83`\r\x01_\x84\x81R` \x01\x90\x81R` \x01_ _\x89\x89\x85\x81\x81\x10a7\xFBWa7\xFAam\xA0V[[\x90P` \x02\x81\x01\x90a8\r\x91\x90am\xD9V[` \x01` \x81\x01\x90a8\x1F\x91\x90a`?V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP\x82`\x0F\x01_\x83\x81R` \x01\x90\x81R` \x01_ \x87\x87\x83\x81\x81\x10a8\x94Wa8\x93am\xA0V[[\x90P` \x02\x81\x01\x90a8\xA6\x91\x90am\xD9V[` \x01` \x81\x01\x90a8\xB8\x91\x90a`?V[\x90\x80`\x01\x81T\x01\x80\x82U\x80\x91PP`\x01\x90\x03\x90_R` _ \x01_\x90\x91\x90\x91\x90\x91a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP\x80\x80`\x01\x01\x91PPa5\xCCV[Pa91\x81\x85\x88\x88\x90PaL9V[\x81`\x07\x01_\x82\x81R` \x01\x90\x81R` \x01_ `@Q\x80`\xA0\x01`@R\x90\x81_\x82\x01T\x81R` \x01`\x01\x82\x01T\x81R` \x01`\x02\x82\x01_\x90T\x90a\x01\0\n\x90\x04`\xC0\x1Bw\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16w\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x81R` \x01`\x03\x82\x01T\x81R` \x01`\x04\x82\x01\x80T\x80` \x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01_\x90[\x82\x82\x10\x15a=\x90W\x83\x82\x90_R` _ \x90`\x08\x02\x01`@Q\x80a\x01\0\x01`@R\x90\x81_\x82\x01\x80Ta:\r\x90ac\x9FV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta:9\x90ac\x9FV[\x80\x15a:\x84W\x80`\x1F\x10a:[Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a:\x84V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a:gW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x01\x82\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01`\x02\x82\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01`\x03\x82\x01T\x81R` \x01`\x04\x82\x01\x80Ta;Q\x90ac\x9FV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta;}\x90ac\x9FV[\x80\x15a;\xC8W\x80`\x1F\x10a;\x9FWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a;\xC8V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a;\xABW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x05\x82\x01\x80Ta;\xE1\x90ac\x9FV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta<\r\x90ac\x9FV[\x80\x15a<XW\x80`\x1F\x10a</Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a<XV[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a<;W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x06\x82\x01\x80Ta<q\x90ac\x9FV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta<\x9D\x90ac\x9FV[\x80\x15a<\xE8W\x80`\x1F\x10a<\xBFWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a<\xE8V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a<\xCBW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x07\x82\x01\x80Ta=\x01\x90ac\x9FV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta=-\x90ac\x9FV[\x80\x15a=xW\x80`\x1F\x10a=OWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a=xV[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a=[W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81RPP\x81R` \x01\x90`\x01\x01\x90a9\xDCV[PPPP\x81RPP\x92PPP\x96\x95PPPPPPV[\x80_\x81\x03a=\xE0W`@Q\x7F\xCB\x17\xB7\xA5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a=\xEA\x83\x83aL[V[\x15\x80\x15a=\xFEWPa=\xFC\x83\x83aL\xAAV[\x15[\x80\x15a>\x0EWP_\x83`\x03\x01T\x14\x15[\x15a>PW\x81`@Q\x7F\x12\xB4\x9E=\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a>G\x91\x90aT\xCCV[`@Q\x80\x91\x03\x90\xFD[`\x03\x83_\x01_\x84\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83`\x07\x81\x11\x15a>\x85Wa>\x84aY\xECV[[\x02\x17\x90UP\x81\x83`\x03\x01\x81\x90UP_\x83`\x02\x01\x81\x90UPPPPV[a>\xA9a/PV[_a>\xB2a3fV[\x90P`\x01\x81_\x01_a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP\x7Fb\xE7\x8C\xEA\x01\xBE\xE3 \xCDNB\x02p\xB5\xEAt\0\r\x11\xB0\xC9\xF7GT\xEB\xDB\xFCTK\x05\xA2Xa>\xF8a3\xCAV[`@Qa?\x05\x91\x90a_\xE8V[`@Q\x80\x91\x03\x90\xA1PV[_\x7F\xA1jF\xD9Ba\xC7Q|\xC8\xFF\x89\xF6\x1C\x0C\xE95\x98\xE3\xC8I\x80\x10\x11\xDE\xE6I\xA6\xA5W\xD1\0\x90P\x90V[``_a?Ba?\x10V[\x90P\x80`\x02\x01\x80Ta?S\x90ac\x9FV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta?\x7F\x90ac\x9FV[\x80\x15a?\xCAW\x80`\x1F\x10a?\xA1Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a?\xCAV[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a?\xADW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x91PP\x90V[``_a?\xE0a?\x10V[\x90P\x80`\x03\x01\x80Ta?\xF1\x90ac\x9FV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta@\x1D\x90ac\x9FV[\x80\x15a@hW\x80`\x1F\x10a@?Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a@hV[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a@KW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x91PP\x90V[\x80_\x81\x03a@\xADW`@Q\x7F\xCB\x17\xB7\xA5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x07\x83_\x01_\x84\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83`\x07\x81\x11\x15a@\xE2Wa@\xE1aY\xECV[[\x02\x17\x90UP\x81\x83`\x01\x01T\x03a@\xFCW_\x83`\x01\x01\x81\x90UP[\x81\x83`\x02\x01T\x03aA\x11W_\x83`\x02\x01\x81\x90UP[\x81\x83`\x03\x01T\x03aA&W_\x83`\x03\x01\x81\x90UP[\x81\x83`\x04\x01T\x03aA;W_\x83`\x04\x01\x81\x90UP[PPPV[\x80_\x81\x03aAzW`@Q\x7F\xCB\x17\xB7\xA5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[aA\x84\x83\x83aC?V[aA\xC5W\x81`@Q\x7F3\x14\x86\xB3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aA\xBC\x91\x90aT\xCCV[`@Q\x80\x91\x03\x90\xFD[`\x04\x83_\x01_\x84\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83`\x07\x81\x11\x15aA\xFAWaA\xF9aY\xECV[[\x02\x17\x90UP\x81\x83`\x04\x01\x81\x90UP_\x83`\x03\x01\x81\x90UPPPPV[\x80_\x81\x03aBPW`@Q\x7F\xCB\x17\xB7\xA5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[aBZ\x83\x83aC?V[\x15\x80aBmWPaBk\x83\x83aL\xAAV[\x15[\x15aB\xAFW\x81`@Q\x7F+6R\xD1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aB\xA6\x91\x90aT\xCCV[`@Q\x80\x91\x03\x90\xFD[`\x05\x83_\x01_\x84\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83`\x07\x81\x11\x15aB\xE4WaB\xE3aY\xECV[[\x02\x17\x90UP\x81\x83`\x03\x01T\x03aB\xFEW_\x83`\x03\x01\x81\x90UP[\x81\x83`\x04\x01T\x03aC\x13W_\x83`\x04\x01\x81\x90UP[PPPV[_\x7F\x90\x16\xD0\x9Dr\xD4\x0F\xDA\xE2\xFD\x8C\xEA\xC6\xB6#Lw\x06!O\xD3\x9C\x1C\xD1\xE6\t\xA0R\x8C\x19\x93\0\x90P\x90V[_`\x03`\x07\x81\x11\x15aCTWaCSaY\xECV[[\x83_\x01_\x84\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16`\x07\x81\x11\x15aC\x85WaC\x84aY\xECV[[\x14\x90P\x92\x91PPV[\x80_\x81\x03aC\xC8W`@Q\x7F\xCB\x17\xB7\xA5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[aC\xD2\x83\x83aL\xF9V[\x80aC\xE3WPaC\xE2\x83\x83a,\x13V[[\x15aD%W\x81`@Q\x7F\xB0\xC5\x15\x1D\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aD\x1C\x91\x90aT\xCCV[`@Q\x80\x91\x03\x90\xFD[`\x06\x83_\x01_\x84\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83`\x07\x81\x11\x15aDZWaDYaY\xECV[[\x02\x17\x90UP\x81\x83`\x02\x01T\x03aDtW_\x83`\x02\x01\x81\x90UP[\x81\x83`\x03\x01T\x03aD\x89W_\x83`\x03\x01\x81\x90UP[\x81\x83`\x04\x01T\x03aD\x9EW_\x83`\x04\x01\x81\x90UP[PPPV[_\x7F#~\x15\x82\"\xE3\xE6\x96\x8Br\xB9\xDB\r\x80C\xAA\xCF\x07J\xD9\xF6P\xF0\xD1`kM\x82\xEEC,\0\x90P\x90V[\x80_\x81\x03aE\x04W`@Q\x7F\xCB\x17\xB7\xA5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[aE\x0E\x83\x83aL\xF9V[aEOW\x81`@Q\x7FfS\xF6\xD7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aEF\x91\x90aT\xCCV[`@Q\x80\x91\x03\x90\xFD[`\x01\x83_\x01_\x84\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83`\x07\x81\x11\x15aE\x84WaE\x83aY\xECV[[\x02\x17\x90UP\x81\x83`\x01\x01\x81\x90UPPPPV[_aE\xA0a+\"V[\x90P_\x83\x03aE\xDBW`@Q\x7F\xE6\nrq\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x81\x83\x11\x15aF\"W\x82\x82`@Q\x7F\xD2S^\x11\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aF\x19\x92\x91\x90ak}V[`@Q\x80\x91\x03\x90\xFD[\x82\x81`\x16\x01_\x86\x81R` \x01\x90\x81R` \x01_ \x81\x90UPPPPPV[_\x80_\x90Pz\x18O\x03\xE9?\xF9\xF4\xDA\xA7\x97\xEDn8\xEDd\xBFj\x1F\x01\0\0\0\0\0\0\0\0\x83\x10aF\x9CWz\x18O\x03\xE9?\xF9\xF4\xDA\xA7\x97\xEDn8\xEDd\xBFj\x1F\x01\0\0\0\0\0\0\0\0\x83\x81aF\x92WaF\x91al\x82V[[\x04\x92P`@\x81\x01\x90P[m\x04\xEE-mA[\x85\xAC\xEF\x81\0\0\0\0\x83\x10aF\xD9Wm\x04\xEE-mA[\x85\xAC\xEF\x81\0\0\0\0\x83\x81aF\xCFWaF\xCEal\x82V[[\x04\x92P` \x81\x01\x90P[f#\x86\xF2o\xC1\0\0\x83\x10aG\x08Wf#\x86\xF2o\xC1\0\0\x83\x81aF\xFEWaF\xFDal\x82V[[\x04\x92P`\x10\x81\x01\x90P[c\x05\xF5\xE1\0\x83\x10aG1Wc\x05\xF5\xE1\0\x83\x81aG'WaG&al\x82V[[\x04\x92P`\x08\x81\x01\x90P[a'\x10\x83\x10aGVWa'\x10\x83\x81aGLWaGKal\x82V[[\x04\x92P`\x04\x81\x01\x90P[`d\x83\x10aGyW`d\x83\x81aGoWaGnal\x82V[[\x04\x92P`\x02\x81\x01\x90P[`\n\x83\x10aG\x88W`\x01\x81\x01\x90P[\x80\x91PP\x91\x90PV[_aG\xA3aG\x9DaMGV[\x83aMUV[\x90P\x91\x90PV[_\x80_\x80aG\xB8\x86\x86aM\x95V[\x92P\x92P\x92PaG\xC8\x82\x82aM\xEAV[\x82\x93PPPP\x92\x91PPV[\x80_\x81\x03aH\x0EW`@Q\x7F\xCB\x17\xB7\xA5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[aH\x18\x83\x83a,\x13V[aHYW\x81`@Q\x7F\xC0\xB5\xEEf\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aHP\x91\x90aT\xCCV[`@Q\x80\x91\x03\x90\xFD[`\x02\x83_\x01_\x84\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83`\x07\x81\x11\x15aH\x8EWaH\x8DaY\xECV[[\x02\x17\x90UP\x81\x83`\x02\x01\x81\x90UP_\x83`\x01\x01\x81\x90UPPPPV[aH\xB2a\x13qV[aH\xE8W`@Q\x7F\x8D\xFC +\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[V[_aI\x16\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC_\x1BaOLV[_\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P\x90V[aIF\x82aOUV[\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xBC|\xD7Z \xEE'\xFD\x9A\xDE\xBA\xB3 A\xF7U!M\xBCk\xFF\xA9\x0C\xC0\"[9\xDA.\\-;`@Q`@Q\x80\x91\x03\x90\xA2_\x81Q\x11\x15aI\xA2WaI\x9C\x82\x82aP\x1EV[PaI\xABV[aI\xAAaP\x9EV[[PPV[_aI\xB8aC\x18V[\x90P_\x81_\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P\x82\x82_\x01_a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP\x82s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\x8B\xE0\x07\x9CS\x16Y\x14\x13D\xCD\x1F\xD0\xA4\xF2\x84\x19I\x7F\x97\"\xA3\xDA\xAF\xE3\xB4\x18okdW\xE0`@Q`@Q\x80\x91\x03\x90\xA3PPPV[aJ\x88aP\xDAV[aJ\xBEW`@Q\x7F\xD7\xE6\xBC\xF8\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[V[aJ\xC8aJ\x80V[_aJ\xD1a?\x10V[\x90P\x82\x81`\x02\x01\x90\x81aJ\xE4\x91\x90ariV[P\x81\x81`\x03\x01\x90\x81aJ\xF6\x91\x90ariV[P_\x80\x1B\x81_\x01\x81\x90UP_\x80\x1B\x81`\x01\x01\x81\x90UPPPPV[aK\x19aJ\x80V[_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x03aK\x89W_`@Q\x7F\x1EO\xBD\xF7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aK\x80\x91\x90a_\xE8V[`@Q\x80\x91\x03\x90\xFD[aK\x92\x81a3\x8DV[PV[aK\x9DaJ\x80V[_aK\xA6a3fV[\x90P_\x81_\x01_a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UPPV[_aK\xCEa+\"V[\x90P\x81\x83\x10aL\x18W\x83\x83\x83`@Q\x7F\x87\x89\xA6\xCA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aL\x0F\x93\x92\x91\x90as8V[`@Q\x80\x91\x03\x90\xFD[\x82\x81`\x07\x01_\x86\x81R` \x01\x90\x81R` \x01_ `\x03\x01\x81\x90UPPPPPV[aLG\x83\x83_\x015\x83a/\x91V[aLV\x83\x83` \x015\x83aE\x97V[PPPV[_`\x02`\x07\x81\x11\x15aLpWaLoaY\xECV[[\x83_\x01_\x84\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16`\x07\x81\x11\x15aL\xA1WaL\xA0aY\xECV[[\x14\x90P\x92\x91PPV[_`\x04`\x07\x81\x11\x15aL\xBFWaL\xBEaY\xECV[[\x83_\x01_\x84\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16`\x07\x81\x11\x15aL\xF0WaL\xEFaY\xECV[[\x14\x90P\x92\x91PPV[_\x80`\x07\x81\x11\x15aM\rWaM\x0CaY\xECV[[\x83_\x01_\x84\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16`\x07\x81\x11\x15aM>WaM=aY\xECV[[\x14\x90P\x92\x91PPV[_aMPaP\xF8V[\x90P\x90V[_`@Q\x7F\x19\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R\x83`\x02\x82\x01R\x82`\"\x82\x01R`B\x81 \x91PP\x92\x91PPV[_\x80_`A\x84Q\x03aM\xD5W_\x80_` \x87\x01Q\x92P`@\x87\x01Q\x91P``\x87\x01Q_\x1A\x90PaM\xC7\x88\x82\x85\x85aQ[V[\x95P\x95P\x95PPPPaM\xE3V[_`\x02\x85Q_\x1B\x92P\x92P\x92P[\x92P\x92P\x92V[_`\x03\x81\x11\x15aM\xFDWaM\xFCaY\xECV[[\x82`\x03\x81\x11\x15aN\x10WaN\x0FaY\xECV[[\x03\x15aOHW`\x01`\x03\x81\x11\x15aN*WaN)aY\xECV[[\x82`\x03\x81\x11\x15aN=WaN<aY\xECV[[\x03aNtW`@Q\x7F\xF6E\xEE\xDF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x02`\x03\x81\x11\x15aN\x88WaN\x87aY\xECV[[\x82`\x03\x81\x11\x15aN\x9BWaN\x9AaY\xECV[[\x03aN\xDFW\x80_\x1C`@Q\x7F\xFC\xE6\x98\xF7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aN\xD6\x91\x90aT\xCCV[`@Q\x80\x91\x03\x90\xFD[`\x03\x80\x81\x11\x15aN\xF2WaN\xF1aY\xECV[[\x82`\x03\x81\x11\x15aO\x05WaO\x04aY\xECV[[\x03aOGW\x80`@Q\x7F\xD7\x8B\xCE\x0C\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aO>\x91\x90a\\<V[`@Q\x80\x91\x03\x90\xFD[[PPV[_\x81\x90P\x91\x90PV[_\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16;\x03aO\xB0W\x80`@Q\x7FL\x9C\x8C\xE3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aO\xA7\x91\x90a_\xE8V[`@Q\x80\x91\x03\x90\xFD[\x80aO\xDC\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC_\x1BaOLV[_\x01_a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UPPV[``_\x80\x84s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x84`@QaPG\x91\x90as\xA7V[_`@Q\x80\x83\x03\x81\x85Z\xF4\x91PP=\x80_\x81\x14aP\x7FW`@Q\x91P`\x1F\x19`?=\x01\x16\x82\x01`@R=\x82R=_` \x84\x01>aP\x84V[``\x91P[P\x91P\x91PaP\x94\x85\x83\x83aRBV[\x92PPP\x92\x91PPV[_4\x11\x15aP\xD8W`@Q\x7F\xB3\x98\x97\x9F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[V[_aP\xE3a3\xF5V[_\x01`\x08\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x90P\x90V[_\x7F\x8Bs\xC3\xC6\x9B\xB8\xFE=Q.\xCCL\xF7Y\xCCy#\x9F{\x17\x9B\x0F\xFA\xCA\xA9\xA7]R+9@\x0FaQ\"aR\xCFV[aQ*aSEV[F0`@Q` \x01aQ@\x95\x94\x93\x92\x91\x90as\xBDV[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x90P\x90V[_\x80_\x7F\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF]WnsW\xA4P\x1D\xDF\xE9/Fh\x1B \xA0\x84_\x1C\x11\x15aQ\x97W_`\x03\x85\x92P\x92P\x92PaR8V[_`\x01\x88\x88\x88\x88`@Q_\x81R` \x01`@R`@QaQ\xBA\x94\x93\x92\x91\x90at)V[` `@Q` \x81\x03\x90\x80\x84\x03\x90\x85Z\xFA\x15\x80\x15aQ\xDAW=_\x80>=_\xFD[PPP` `@Q\x03Q\x90P_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x03aR+W_`\x01_\x80\x1B\x93P\x93P\x93PPaR8V[\x80_\x80_\x1B\x93P\x93P\x93PP[\x94P\x94P\x94\x91PPV[``\x82aRWWaRR\x82aS\xBCV[aR\xC7V[_\x82Q\x14\x80\x15aR}WP_\x84s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16;\x14[\x15aR\xBFW\x83`@Q\x7F\x99\x96\xB3\x15\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aR\xB6\x91\x90a_\xE8V[`@Q\x80\x91\x03\x90\xFD[\x81\x90PaR\xC8V[[\x93\x92PPPV[_\x80aR\xD9a?\x10V[\x90P_aR\xE4a?7V[\x90P_\x81Q\x11\x15aS\0W\x80\x80Q\x90` \x01 \x92PPPaSBV[_\x82_\x01T\x90P_\x80\x1B\x81\x14aS\x1BW\x80\x93PPPPaSBV[\x7F\xC5\xD2F\x01\x86\xF7#<\x92~}\xB2\xDC\xC7\x03\xC0\xE5\0\xB6S\xCA\x82';{\xFA\xD8\x04]\x85\xA4p\x93PPPP[\x90V[_\x80aSOa?\x10V[\x90P_aSZa?\xD5V[\x90P_\x81Q\x11\x15aSvW\x80\x80Q\x90` \x01 \x92PPPaS\xB9V[_\x82`\x01\x01T\x90P_\x80\x1B\x81\x14aS\x92W\x80\x93PPPPaS\xB9V[\x7F\xC5\xD2F\x01\x86\xF7#<\x92~}\xB2\xDC\xC7\x03\xC0\xE5\0\xB6S\xCA\x82';{\xFA\xD8\x04]\x85\xA4p\x93PPPP[\x90V[_\x81Q\x11\x15aS\xCEW\x80Q\x80\x82` \x01\xFD[`@Q\x7F\xD6\xBD\xA2u\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`@Q\x80`\xA0\x01`@R\x80_\x81R` \x01_\x81R` \x01_w\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x81R` \x01_\x81R` \x01``\x81RP\x90V[`@Q\x80a\x01\0\x01`@R\x80``\x81R` \x01_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01_\x81R` \x01``\x81R` \x01``\x81R` \x01``\x81R` \x01``\x81RP\x90V[_\x81\x90P\x91\x90PV[aT\xC6\x81aT\xB4V[\x82RPPV[_` \x82\x01\x90PaT\xDF_\x83\x01\x84aT\xBDV[\x92\x91PPV[_\x81Q\x90P\x91\x90PV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[_[\x83\x81\x10\x15aU\x1CW\x80\x82\x01Q\x81\x84\x01R` \x81\x01\x90PaU\x01V[_\x84\x84\x01RPPPPV[_`\x1F\x19`\x1F\x83\x01\x16\x90P\x91\x90PV[_aUA\x82aT\xE5V[aUK\x81\x85aT\xEFV[\x93PaU[\x81\x85` \x86\x01aT\xFFV[aUd\x81aU'V[\x84\x01\x91PP\x92\x91PPV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01RaU\x87\x81\x84aU7V[\x90P\x92\x91PPV[aU\x98\x81aT\xB4V[\x82RPPV[_\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\x16\x90P\x91\x90PV[aU\xD2\x81aU\x9EV[\x82RPPV[_\x81Q\x90P\x91\x90PV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[_\x81\x90P` \x82\x01\x90P\x91\x90PV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[_aV\x1B\x82aT\xE5V[aV%\x81\x85aV\x01V[\x93PaV5\x81\x85` \x86\x01aT\xFFV[aV>\x81aU'V[\x84\x01\x91PP\x92\x91PPV[_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[_aVr\x82aVIV[\x90P\x91\x90PV[aV\x82\x81aVhV[\x82RPPV[_\x81Q\x90P\x91\x90PV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[_aV\xAC\x82aV\x88V[aV\xB6\x81\x85aV\x92V[\x93PaV\xC6\x81\x85` \x86\x01aT\xFFV[aV\xCF\x81aU'V[\x84\x01\x91PP\x92\x91PPV[_a\x01\0\x83\x01_\x83\x01Q\x84\x82\x03_\x86\x01RaV\xF5\x82\x82aV\x11V[\x91PP` \x83\x01QaW\n` \x86\x01\x82aVyV[P`@\x83\x01QaW\x1D`@\x86\x01\x82aVyV[P``\x83\x01QaW0``\x86\x01\x82aU\x8FV[P`\x80\x83\x01Q\x84\x82\x03`\x80\x86\x01RaWH\x82\x82aV\xA2V[\x91PP`\xA0\x83\x01Q\x84\x82\x03`\xA0\x86\x01RaWb\x82\x82aV\x11V[\x91PP`\xC0\x83\x01Q\x84\x82\x03`\xC0\x86\x01RaW|\x82\x82aV\x11V[\x91PP`\xE0\x83\x01Q\x84\x82\x03`\xE0\x86\x01RaW\x96\x82\x82aV\xA2V[\x91PP\x80\x91PP\x92\x91PPV[_aW\xAE\x83\x83aV\xDAV[\x90P\x92\x91PPV[_` \x82\x01\x90P\x91\x90PV[_aW\xCC\x82aU\xD8V[aW\xD6\x81\x85aU\xE2V[\x93P\x83` \x82\x02\x85\x01aW\xE8\x85aU\xF2V[\x80_[\x85\x81\x10\x15aX#W\x84\x84\x03\x89R\x81QaX\x04\x85\x82aW\xA3V[\x94PaX\x0F\x83aW\xB6V[\x92P` \x8A\x01\x99PP`\x01\x81\x01\x90PaW\xEBV[P\x82\x97P\x87\x95PPPPPP\x92\x91PPV[_`\xA0\x83\x01_\x83\x01QaXJ_\x86\x01\x82aU\x8FV[P` \x83\x01QaX]` \x86\x01\x82aU\x8FV[P`@\x83\x01QaXp`@\x86\x01\x82aU\xC9V[P``\x83\x01QaX\x83``\x86\x01\x82aU\x8FV[P`\x80\x83\x01Q\x84\x82\x03`\x80\x86\x01RaX\x9B\x82\x82aW\xC2V[\x91PP\x80\x91PP\x92\x91PPV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01RaX\xC0\x81\x84aX5V[\x90P\x92\x91PPV[_`@Q\x90P\x90V[_\x80\xFD[_\x80\xFD[aX\xE2\x81aT\xB4V[\x81\x14aX\xECW_\x80\xFD[PV[_\x815\x90PaX\xFD\x81aX\xD9V[\x92\x91PPV[_\x80\xFD[_\x80\xFD[_\x80\xFD[_\x80\x83`\x1F\x84\x01\x12aY$WaY#aY\x03V[[\x825\x90Pg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15aYAWaY@aY\x07V[[` \x83\x01\x91P\x83`\x01\x82\x02\x83\x01\x11\x15aY]WaY\\aY\x0BV[[\x92P\x92\x90PV[_\x80_`@\x84\x86\x03\x12\x15aY{WaYzaX\xD1V[[_aY\x88\x86\x82\x87\x01aX\xEFV[\x93PP` \x84\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15aY\xA9WaY\xA8aX\xD5V[[aY\xB5\x86\x82\x87\x01aY\x0FV[\x92P\x92PP\x92P\x92P\x92V[_` \x82\x84\x03\x12\x15aY\xD6WaY\xD5aX\xD1V[[_aY\xE3\x84\x82\x85\x01aX\xEFV[\x91PP\x92\x91PPV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`!`\x04R`$_\xFD[`\x08\x81\x10aZ*WaZ)aY\xECV[[PV[_\x81\x90PaZ:\x82aZ\x19V[\x91\x90PV[_aZI\x82aZ-V[\x90P\x91\x90PV[aZY\x81aZ?V[\x82RPPV[_` \x82\x01\x90PaZr_\x83\x01\x84aZPV[\x92\x91PPV[aZ\x81\x81aVhV[\x81\x14aZ\x8BW_\x80\xFD[PV[_\x815\x90PaZ\x9C\x81aZxV[\x92\x91PPV[_\x80\xFD[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`A`\x04R`$_\xFD[aZ\xDC\x82aU'V[\x81\x01\x81\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17\x15aZ\xFBWaZ\xFAaZ\xA6V[[\x80`@RPPPV[_a[\raX\xC8V[\x90Pa[\x19\x82\x82aZ\xD3V[\x91\x90PV[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15a[8Wa[7aZ\xA6V[[a[A\x82aU'V[\x90P` \x81\x01\x90P\x91\x90PV[\x82\x81\x837_\x83\x83\x01RPPPV[_a[na[i\x84a[\x1EV[a[\x04V[\x90P\x82\x81R` \x81\x01\x84\x84\x84\x01\x11\x15a[\x8AWa[\x89aZ\xA2V[[a[\x95\x84\x82\x85a[NV[P\x93\x92PPPV[_\x82`\x1F\x83\x01\x12a[\xB1Wa[\xB0aY\x03V[[\x815a[\xC1\x84\x82` \x86\x01a[\\V[\x91PP\x92\x91PPV[_\x80`@\x83\x85\x03\x12\x15a[\xE0Wa[\xDFaX\xD1V[[_a[\xED\x85\x82\x86\x01aZ\x8EV[\x92PP` \x83\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\\\x0EWa\\\raX\xD5V[[a\\\x1A\x85\x82\x86\x01a[\x9DV[\x91PP\x92P\x92\x90PV[_\x81\x90P\x91\x90PV[a\\6\x81a\\$V[\x82RPPV[_` \x82\x01\x90Pa\\O_\x83\x01\x84a\\-V[\x92\x91PPV[_\x81\x15\x15\x90P\x91\x90PV[a\\i\x81a\\UV[\x82RPPV[_` \x82\x01\x90Pa\\\x82_\x83\x01\x84a\\`V[\x92\x91PPV[_\x81Q\x90P\x91\x90PV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[_\x81\x90P` \x82\x01\x90P\x91\x90PV[_a\\\xBC\x83\x83aVyV[` \x83\x01\x90P\x92\x91PPV[_` \x82\x01\x90P\x91\x90PV[_a\\\xDE\x82a\\\x88V[a\\\xE8\x81\x85a\\\x92V[\x93Pa\\\xF3\x83a\\\xA2V[\x80_[\x83\x81\x10\x15a]#W\x81Qa]\n\x88\x82a\\\xB1V[\x97Pa]\x15\x83a\\\xC8V[\x92PP`\x01\x81\x01\x90Pa\\\xF6V[P\x85\x93PPPP\x92\x91PPV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra]H\x81\x84a\\\xD4V[\x90P\x92\x91PPV[a]Y\x81aU\x9EV[\x81\x14a]cW_\x80\xFD[PV[_\x815\x90Pa]t\x81a]PV[\x92\x91PPV[_\x80\x83`\x1F\x84\x01\x12a]\x8FWa]\x8EaY\x03V[[\x825\x90Pg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a]\xACWa]\xABaY\x07V[[` \x83\x01\x91P\x83` \x82\x02\x83\x01\x11\x15a]\xC8Wa]\xC7aY\x0BV[[\x92P\x92\x90PV[_\x80\xFD[_`@\x82\x84\x03\x12\x15a]\xE8Wa]\xE7a]\xCFV[[\x81\x90P\x92\x91PPV[_\x80_\x80_`\xA0\x86\x88\x03\x12\x15a^\nWa^\taX\xD1V[[_a^\x17\x88\x82\x89\x01a]fV[\x95PP` a^(\x88\x82\x89\x01aX\xEFV[\x94PP`@\x86\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a^IWa^HaX\xD5V[[a^U\x88\x82\x89\x01a]zV[\x93P\x93PP``a^h\x88\x82\x89\x01a]\xD3V[\x91PP\x92\x95P\x92\x95\x90\x93PV[_\x7F\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\x16\x90P\x91\x90PV[a^\xA9\x81a^uV[\x82RPPV[a^\xB8\x81aVhV[\x82RPPV[_\x81Q\x90P\x91\x90PV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[_\x81\x90P` \x82\x01\x90P\x91\x90PV[_a^\xF2\x83\x83aU\x8FV[` \x83\x01\x90P\x92\x91PPV[_` \x82\x01\x90P\x91\x90PV[_a_\x14\x82a^\xBEV[a_\x1E\x81\x85a^\xC8V[\x93Pa_)\x83a^\xD8V[\x80_[\x83\x81\x10\x15a_YW\x81Qa_@\x88\x82a^\xE7V[\x97Pa_K\x83a^\xFEV[\x92PP`\x01\x81\x01\x90Pa_,V[P\x85\x93PPPP\x92\x91PPV[_`\xE0\x82\x01\x90Pa_y_\x83\x01\x8Aa^\xA0V[\x81\x81\x03` \x83\x01Ra_\x8B\x81\x89aU7V[\x90P\x81\x81\x03`@\x83\x01Ra_\x9F\x81\x88aU7V[\x90Pa_\xAE``\x83\x01\x87aT\xBDV[a_\xBB`\x80\x83\x01\x86a^\xAFV[a_\xC8`\xA0\x83\x01\x85a\\-V[\x81\x81\x03`\xC0\x83\x01Ra_\xDA\x81\x84a_\nV[\x90P\x98\x97PPPPPPPPV[_` \x82\x01\x90Pa_\xFB_\x83\x01\x84a^\xAFV[\x92\x91PPV[_\x80`@\x83\x85\x03\x12\x15a`\x17Wa`\x16aX\xD1V[[_a`$\x85\x82\x86\x01aX\xEFV[\x92PP` a`5\x85\x82\x86\x01aZ\x8EV[\x91PP\x92P\x92\x90PV[_` \x82\x84\x03\x12\x15a`TWa`SaX\xD1V[[_a`a\x84\x82\x85\x01aZ\x8EV[\x91PP\x92\x91PPV[_a\x01\0\x83\x01_\x83\x01Q\x84\x82\x03_\x86\x01Ra`\x85\x82\x82aV\x11V[\x91PP` \x83\x01Qa`\x9A` \x86\x01\x82aVyV[P`@\x83\x01Qa`\xAD`@\x86\x01\x82aVyV[P``\x83\x01Qa`\xC0``\x86\x01\x82aU\x8FV[P`\x80\x83\x01Q\x84\x82\x03`\x80\x86\x01Ra`\xD8\x82\x82aV\xA2V[\x91PP`\xA0\x83\x01Q\x84\x82\x03`\xA0\x86\x01Ra`\xF2\x82\x82aV\x11V[\x91PP`\xC0\x83\x01Q\x84\x82\x03`\xC0\x86\x01Raa\x0C\x82\x82aV\x11V[\x91PP`\xE0\x83\x01Q\x84\x82\x03`\xE0\x86\x01Raa&\x82\x82aV\xA2V[\x91PP\x80\x91PP\x92\x91PPV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01RaaK\x81\x84a`jV[\x90P\x92\x91PPV[aa\\\x81a\\UV[\x81\x14aafW_\x80\xFD[PV[_\x815\x90Paaw\x81aaSV[\x92\x91PPV[_``\x82\x84\x03\x12\x15aa\x92Waa\x91a]\xCFV[[\x81\x90P\x92\x91PPV[_\x80_\x80_\x80_a\x01 \x88\x8A\x03\x12\x15aa\xB7Waa\xB6aX\xD1V[[_aa\xC4\x8A\x82\x8B\x01a]fV[\x97PP` aa\xD5\x8A\x82\x8B\x01aaiV[\x96PP`@aa\xE6\x8A\x82\x8B\x01aX\xEFV[\x95PP``\x88\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15ab\x07Wab\x06aX\xD5V[[ab\x13\x8A\x82\x8B\x01a]zV[\x94P\x94PP`\x80ab&\x8A\x82\x8B\x01aa}V[\x92PP`\xE0ab7\x8A\x82\x8B\x01a]\xD3V[\x91PP\x92\x95\x98\x91\x94\x97P\x92\x95PV[_\x81\x90P\x92\x91PPV[_abZ\x82aT\xE5V[abd\x81\x85abFV[\x93Pabt\x81\x85` \x86\x01aT\xFFV[\x80\x84\x01\x91PP\x92\x91PPV[\x7F v\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_ab\xB4`\x02\x83abFV[\x91Pab\xBF\x82ab\x80V[`\x02\x82\x01\x90P\x91\x90PV[\x7F.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_ab\xFE`\x01\x83abFV[\x91Pac\t\x82ab\xCAV[`\x01\x82\x01\x90P\x91\x90PV[_ac\x1F\x82\x87abPV[\x91Pac*\x82ab\xA8V[\x91Pac6\x82\x86abPV[\x91PacA\x82ab\xF2V[\x91PacM\x82\x85abPV[\x91PacX\x82ab\xF2V[\x91Pacd\x82\x84abPV[\x91P\x81\x90P\x95\x94PPPPPV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\"`\x04R`$_\xFD[_`\x02\x82\x04\x90P`\x01\x82\x16\x80ac\xB6W`\x7F\x82\x16\x91P[` \x82\x10\x81\x03ac\xC9Wac\xC8acrV[[P\x91\x90PV[_\x82\x90P\x92\x91PPV[_\x81\x90P\x81_R` _ \x90P\x91\x90PV[_` `\x1F\x83\x01\x04\x90P\x91\x90PV[_\x82\x82\x1B\x90P\x92\x91PPV[_`\x08\x83\x02ad5\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82ac\xFAV[ad?\x86\x83ac\xFAV[\x95P\x80\x19\x84\x16\x93P\x80\x86\x16\x84\x17\x92PPP\x93\x92PPPV[_\x81\x90P\x91\x90PV[_adzaduadp\x84aT\xB4V[adWV[aT\xB4V[\x90P\x91\x90PV[_\x81\x90P\x91\x90PV[ad\x93\x83ad`V[ad\xA7ad\x9F\x82ad\x81V[\x84\x84Tad\x06V[\x82UPPPPV[_\x90V[ad\xBBad\xAFV[ad\xC6\x81\x84\x84ad\x8AV[PPPV[[\x81\x81\x10\x15ad\xE9Wad\xDE_\x82ad\xB3V[`\x01\x81\x01\x90Pad\xCCV[PPV[`\x1F\x82\x11\x15ae.Wad\xFF\x81ac\xD9V[ae\x08\x84ac\xEBV[\x81\x01` \x85\x10\x15ae\x17W\x81\x90P[ae+ae#\x85ac\xEBV[\x83\x01\x82ad\xCBV[PP[PPPV[_\x82\x82\x1C\x90P\x92\x91PPV[_aeN_\x19\x84`\x08\x02ae3V[\x19\x80\x83\x16\x91PP\x92\x91PPV[_aef\x83\x83ae?V[\x91P\x82`\x02\x02\x82\x17\x90P\x92\x91PPV[ae\x80\x83\x83ac\xCFV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15ae\x99Wae\x98aZ\xA6V[[ae\xA3\x82Tac\x9FV[ae\xAE\x82\x82\x85ad\xEDV[_`\x1F\x83\x11`\x01\x81\x14ae\xDBW_\x84\x15ae\xC9W\x82\x87\x015\x90P[ae\xD3\x85\x82ae[V[\x86UPaf:V[`\x1F\x19\x84\x16ae\xE9\x86ac\xD9V[_[\x82\x81\x10\x15af\x10W\x84\x89\x015\x82U`\x01\x82\x01\x91P` \x85\x01\x94P` \x81\x01\x90Pae\xEBV[\x86\x83\x10\x15af-W\x84\x89\x015af)`\x1F\x89\x16\x82ae?V[\x83UP[`\x01`\x02\x88\x02\x01\x88UPPP[PPPPPPPV[_afQ` \x84\x01\x84aX\xEFV[\x90P\x92\x91PPV[`@\x82\x01afi_\x83\x01\x83afCV[afu_\x85\x01\x82aU\x8FV[Paf\x83` \x83\x01\x83afCV[af\x90` \x85\x01\x82aU\x8FV[PPPPV[af\x9F\x81aU\x9EV[\x82RPPV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[_\x81\x90P\x91\x90PV[_\x80\xFD[_\x80\xFD[_\x80\xFD[_\x80\x835`\x01` \x03\x846\x03\x03\x81\x12af\xE6Waf\xE5af\xC6V[[\x83\x81\x01\x92P\x825\x91P` \x83\x01\x92Pg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15ag\x0EWag\raf\xBEV[[`\x01\x82\x026\x03\x83\x13\x15ag$Wag#af\xC2V[[P\x92P\x92\x90PV[_ag7\x83\x85aV\x01V[\x93PagD\x83\x85\x84a[NV[agM\x83aU'V[\x84\x01\x90P\x93\x92PPPV[_agf` \x84\x01\x84aZ\x8EV[\x90P\x92\x91PPV[_\x80\x835`\x01` \x03\x846\x03\x03\x81\x12ag\x8AWag\x89af\xC6V[[\x83\x81\x01\x92P\x825\x91P` \x83\x01\x92Pg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15ag\xB2Wag\xB1af\xBEV[[`\x01\x82\x026\x03\x83\x13\x15ag\xC8Wag\xC7af\xC2V[[P\x92P\x92\x90PV[_ag\xDB\x83\x85aV\x92V[\x93Pag\xE8\x83\x85\x84a[NV[ag\xF1\x83aU'V[\x84\x01\x90P\x93\x92PPPV[_a\x01\0\x83\x01ah\x0E_\x84\x01\x84af\xCAV[\x85\x83\x03_\x87\x01Rah \x83\x82\x84ag,V[\x92PPPah1` \x84\x01\x84agXV[ah>` \x86\x01\x82aVyV[PahL`@\x84\x01\x84agXV[ahY`@\x86\x01\x82aVyV[Pahg``\x84\x01\x84afCV[aht``\x86\x01\x82aU\x8FV[Pah\x82`\x80\x84\x01\x84agnV[\x85\x83\x03`\x80\x87\x01Rah\x95\x83\x82\x84ag\xD0V[\x92PPPah\xA6`\xA0\x84\x01\x84af\xCAV[\x85\x83\x03`\xA0\x87\x01Rah\xB9\x83\x82\x84ag,V[\x92PPPah\xCA`\xC0\x84\x01\x84af\xCAV[\x85\x83\x03`\xC0\x87\x01Rah\xDD\x83\x82\x84ag,V[\x92PPPah\xEE`\xE0\x84\x01\x84agnV[\x85\x83\x03`\xE0\x87\x01Rai\x01\x83\x82\x84ag\xD0V[\x92PPP\x80\x91PP\x92\x91PPV[_ai\x1A\x83\x83ag\xFCV[\x90P\x92\x91PPV[_\x825`\x01a\x01\0\x03\x836\x03\x03\x81\x12ai>Wai=af\xC6V[[\x82\x81\x01\x91PP\x92\x91PPV[_` \x82\x01\x90P\x91\x90PV[_aia\x83\x85af\xA5V[\x93P\x83` \x84\x02\x85\x01ais\x84af\xB5V[\x80_[\x87\x81\x10\x15ai\xB6W\x84\x84\x03\x89Rai\x8D\x82\x84ai\"V[ai\x97\x85\x82ai\x0FV[\x94Pai\xA2\x83aiJV[\x92P` \x8A\x01\x99PP`\x01\x81\x01\x90PaivV[P\x82\x97P\x87\x94PPPPP\x93\x92PPPV[_`\xA0\x82\x01\x90Pai\xDB_\x83\x01\x88afYV[ai\xE8`@\x83\x01\x87af\x96V[ai\xF5``\x83\x01\x86aT\xBDV[\x81\x81\x03`\x80\x83\x01Raj\x08\x81\x84\x86aiVV[\x90P\x96\x95PPPPPPV[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[aj0\x81aj\x14V[\x82RPPV[_` \x82\x01\x90PajI_\x83\x01\x84aj'V[\x92\x91PPV[_\x81Q\x90Paj]\x81aZxV[\x92\x91PPV[_` \x82\x84\x03\x12\x15ajxWajwaX\xD1V[[_aj\x85\x84\x82\x85\x01ajOV[\x91PP\x92\x91PPV[\x7FEIP712: Uninitialized\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_aj\xC2`\x15\x83aT\xEFV[\x91Paj\xCD\x82aj\x8EV[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Raj\xEF\x81aj\xB6V[\x90P\x91\x90PV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x11`\x04R`$_\xFD[_ak-\x82aT\xB4V[\x91Pak8\x83aT\xB4V[\x92P\x82\x82\x01\x90P\x80\x82\x11\x15akPWakOaj\xF6V[[\x92\x91PPV[_`@\x82\x01\x90Paki_\x83\x01\x85aT\xBDV[akv` \x83\x01\x84a^\xAFV[\x93\x92PPPV[_`@\x82\x01\x90Pak\x90_\x83\x01\x85aT\xBDV[ak\x9D` \x83\x01\x84aT\xBDV[\x93\x92PPPV[``\x82\x01ak\xB4_\x83\x01\x83afCV[ak\xC0_\x85\x01\x82aU\x8FV[Pak\xCE` \x83\x01\x83afCV[ak\xDB` \x85\x01\x82aU\x8FV[Pak\xE9`@\x83\x01\x83afCV[ak\xF6`@\x85\x01\x82aU\x8FV[PPPPV[_`\xA0\x82\x01\x90P\x81\x81\x03_\x83\x01Ral\x14\x81\x86aX5V[\x90P\x81\x81\x03` \x83\x01Ral(\x81\x85aX5V[\x90Pal7`@\x83\x01\x84ak\xA4V[\x94\x93PPPPV[_``\x82\x01\x90P\x81\x81\x03_\x83\x01RalW\x81\x86aX5V[\x90P\x81\x81\x03` \x83\x01Ralk\x81\x85aX5V[\x90Palz`@\x83\x01\x84aT\xBDV[\x94\x93PPPPV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x12`\x04R`$_\xFD[_`@\x82\x01\x90Pal\xC2_\x83\x01\x85a\\-V[al\xCF` \x83\x01\x84aT\xBDV[\x93\x92PPPV[_`@\x82\x01\x90P\x81\x81\x03_\x83\x01Ral\xEE\x81\x85aX5V[\x90Pal\xFD` \x83\x01\x84aT\xBDV[\x93\x92PPPV[am\r\x81a\\$V[\x81\x14am\x17W_\x80\xFD[PV[_\x81Q\x90Pam(\x81am\x04V[\x92\x91PPV[_` \x82\x84\x03\x12\x15amCWamBaX\xD1V[[_amP\x84\x82\x85\x01am\x1AV[\x91PP\x92\x91PPV[_amc\x82aT\xB4V[\x91P\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x03am\x95Wam\x94aj\xF6V[[`\x01\x82\x01\x90P\x91\x90PV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`2`\x04R`$_\xFD[_\x80\xFD[_\x80\xFD[_\x80\xFD[_\x825`\x01a\x01\0\x03\x836\x03\x03\x81\x12am\xF5Wam\xF4am\xCDV[[\x80\x83\x01\x91PP\x92\x91PPV[_\x80\x835`\x01` \x03\x846\x03\x03\x81\x12an\x1DWan\x1Cam\xCDV[[\x80\x84\x01\x92P\x825\x91Pg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15an?Wan>am\xD1V[[` \x83\x01\x92P`\x01\x82\x026\x03\x83\x13\x15an[WanZam\xD5V[[P\x92P\x92\x90PV[_\x82\x90P\x92\x91PPV[_\x81\x90P\x81_R` _ \x90P\x91\x90PV[`\x1F\x82\x11\x15an\xC0Wan\x91\x81anmV[an\x9A\x84ac\xEBV[\x81\x01` \x85\x10\x15an\xA9W\x81\x90P[an\xBDan\xB5\x85ac\xEBV[\x83\x01\x82ad\xCBV[PP[PPPV[an\xCF\x83\x83ancV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15an\xE8Wan\xE7aZ\xA6V[[an\xF2\x82Tac\x9FV[an\xFD\x82\x82\x85an\x7FV[_`\x1F\x83\x11`\x01\x81\x14ao*W_\x84\x15ao\x18W\x82\x87\x015\x90P[ao\"\x85\x82ae[V[\x86UPao\x89V[`\x1F\x19\x84\x16ao8\x86anmV[_[\x82\x81\x10\x15ao_W\x84\x89\x015\x82U`\x01\x82\x01\x91P` \x85\x01\x94P` \x81\x01\x90Pao:V[\x86\x83\x10\x15ao|W\x84\x89\x015aox`\x1F\x89\x16\x82ae?V[\x83UP[`\x01`\x02\x88\x02\x01\x88UPPP[PPPPPPPV[ao\x9D\x83\x83\x83an\xC5V[PPPV[_\x815ao\xAE\x81aZxV[\x80\x91PP\x91\x90PV[_\x81_\x1B\x90P\x91\x90PV[_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFao\xE1\x84ao\xB7V[\x93P\x80\x19\x83\x16\x92P\x80\x84\x16\x83\x17\x91PP\x92\x91PPV[_ap\x11ap\x0Cap\x07\x84aVIV[adWV[aVIV[\x90P\x91\x90PV[_ap\"\x82ao\xF7V[\x90P\x91\x90PV[_ap3\x82ap\x18V[\x90P\x91\x90PV[_\x81\x90P\x91\x90PV[apL\x82ap)V[ap_apX\x82ap:V[\x83Tao\xC2V[\x82UPPPV[_\x815apr\x81aX\xD9V[\x80\x91PP\x91\x90PV[_\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFap\xA6\x84ao\xB7V[\x93P\x80\x19\x83\x16\x92P\x80\x84\x16\x83\x17\x91PP\x92\x91PPV[ap\xC5\x82ad`V[ap\xD8ap\xD1\x82ad\x81V[\x83Tap{V[\x82UPPPV[_\x80\x835`\x01` \x03\x846\x03\x03\x81\x12ap\xFBWap\xFAam\xCDV[[\x80\x84\x01\x92P\x825\x91Pg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15aq\x1DWaq\x1Cam\xD1V[[` \x83\x01\x92P`\x01\x82\x026\x03\x83\x13\x15aq9Waq8am\xD5V[[P\x92P\x92\x90PV[aqL\x83\x83\x83aevV[PPPV[_\x81\x01_\x83\x01aqa\x81\x85an\x01V[aql\x81\x83\x86ao\x92V[PPPP`\x01\x81\x01` \x83\x01\x80aq\x82\x81ao\xA2V[\x90Paq\x8E\x81\x84apCV[PPP`\x02\x81\x01`@\x83\x01\x80aq\xA3\x81ao\xA2V[\x90Paq\xAF\x81\x84apCV[PPP`\x03\x81\x01``\x83\x01\x80aq\xC4\x81apfV[\x90Paq\xD0\x81\x84ap\xBCV[PPP`\x04\x81\x01`\x80\x83\x01aq\xE5\x81\x85ap\xDFV[aq\xF0\x81\x83\x86aqAV[PPPP`\x05\x81\x01`\xA0\x83\x01ar\x06\x81\x85an\x01V[ar\x11\x81\x83\x86ao\x92V[PPPP`\x06\x81\x01`\xC0\x83\x01ar'\x81\x85an\x01V[ar2\x81\x83\x86ao\x92V[PPPP`\x07\x81\x01`\xE0\x83\x01arH\x81\x85ap\xDFV[arS\x81\x83\x86aqAV[PPPPPPV[are\x82\x82aqQV[PPV[arr\x82aT\xE5V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15ar\x8BWar\x8AaZ\xA6V[[ar\x95\x82Tac\x9FV[ar\xA0\x82\x82\x85an\x7FV[_` \x90P`\x1F\x83\x11`\x01\x81\x14ar\xD1W_\x84\x15ar\xBFW\x82\x87\x01Q\x90P[ar\xC9\x85\x82ae[V[\x86UPas0V[`\x1F\x19\x84\x16ar\xDF\x86anmV[_[\x82\x81\x10\x15as\x06W\x84\x89\x01Q\x82U`\x01\x82\x01\x91P` \x85\x01\x94P` \x81\x01\x90Par\xE1V[\x86\x83\x10\x15as#W\x84\x89\x01Qas\x1F`\x1F\x89\x16\x82ae?V[\x83UP[`\x01`\x02\x88\x02\x01\x88UPPP[PPPPPPV[_``\x82\x01\x90PasK_\x83\x01\x86aT\xBDV[asX` \x83\x01\x85aT\xBDV[ase`@\x83\x01\x84aT\xBDV[\x94\x93PPPPV[_\x81\x90P\x92\x91PPV[_as\x81\x82aV\x88V[as\x8B\x81\x85asmV[\x93Pas\x9B\x81\x85` \x86\x01aT\xFFV[\x80\x84\x01\x91PP\x92\x91PPV[_as\xB2\x82\x84aswV[\x91P\x81\x90P\x92\x91PPV[_`\xA0\x82\x01\x90Pas\xD0_\x83\x01\x88a\\-V[as\xDD` \x83\x01\x87a\\-V[as\xEA`@\x83\x01\x86a\\-V[as\xF7``\x83\x01\x85aT\xBDV[at\x04`\x80\x83\x01\x84a^\xAFV[\x96\x95PPPPPPV[_`\xFF\x82\x16\x90P\x91\x90PV[at#\x81at\x0EV[\x82RPPV[_`\x80\x82\x01\x90Pat<_\x83\x01\x87a\\-V[atI` \x83\x01\x86at\x1AV[atV`@\x83\x01\x85a\\-V[atc``\x83\x01\x84a\\-V[\x95\x94PPPPPV\xFEKeyResharingVerification(uint256 contextId)",
    );
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ContextStatus(u8);
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<ContextStatus> for u8 {
            #[inline]
            fn stv_to_tokens(
                &self,
            ) -> <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::Token<'_> {
                alloy_sol_types::private::SolTypeValue::<
                    alloy::sol_types::sol_data::Uint<8>,
                >::stv_to_tokens(self)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::tokenize(self)
                    .0
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(self, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::abi_encoded_size(self)
            }
        }
        #[automatically_derived]
        impl ContextStatus {
            /// The Solidity type name.
            pub const NAME: &'static str = stringify!(@ name);
            /// Convert from the underlying value type.
            #[inline]
            pub const fn from(value: u8) -> Self {
                Self(value)
            }
            /// Return the underlying value.
            #[inline]
            pub const fn into(self) -> u8 {
                self.0
            }
            /// Return the single encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode(&self.0)
            }
            /// Return the packed encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode_packed(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode_packed(&self.0)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for ContextStatus {
            type RustType = u8;
            type Token<'a> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = Self::NAME;
            const ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                Self::type_check(token).is_ok()
            }
            #[inline]
            fn type_check(token: &Self::Token<'_>) -> alloy_sol_types::Result<()> {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::type_check(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::detokenize(token)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for ContextStatus {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::topic_preimage_length(rust)
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(rust, out)
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic(rust)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**```solidity
struct DecryptionThresholds { uint256 publicDecryptionThreshold; uint256 userDecryptionThreshold; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DecryptionThresholds {
        #[allow(missing_docs)]
        pub publicDecryptionThreshold: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub userDecryptionThreshold: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<DecryptionThresholds> for UnderlyingRustTuple<'_> {
            fn from(value: DecryptionThresholds) -> Self {
                (value.publicDecryptionThreshold, value.userDecryptionThreshold)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for DecryptionThresholds {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    publicDecryptionThreshold: tuple.0,
                    userDecryptionThreshold: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for DecryptionThresholds {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for DecryptionThresholds {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.publicDecryptionThreshold,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.userDecryptionThreshold,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for DecryptionThresholds {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for DecryptionThresholds {
            const NAME: &'static str = "DecryptionThresholds";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "DecryptionThresholds(uint256 publicDecryptionThreshold,uint256 userDecryptionThreshold)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.publicDecryptionThreshold,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.userDecryptionThreshold,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for DecryptionThresholds {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.publicDecryptionThreshold,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.userDecryptionThreshold,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.publicDecryptionThreshold,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.userDecryptionThreshold,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**```solidity
struct KmsBlockPeriods { uint256 preActivationBlockPeriod; uint256 generationBlockPeriod; uint256 suspendedBlockPeriod; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct KmsBlockPeriods {
        #[allow(missing_docs)]
        pub preActivationBlockPeriod: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub generationBlockPeriod: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub suspendedBlockPeriod: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<KmsBlockPeriods> for UnderlyingRustTuple<'_> {
            fn from(value: KmsBlockPeriods) -> Self {
                (
                    value.preActivationBlockPeriod,
                    value.generationBlockPeriod,
                    value.suspendedBlockPeriod,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for KmsBlockPeriods {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    preActivationBlockPeriod: tuple.0,
                    generationBlockPeriod: tuple.1,
                    suspendedBlockPeriod: tuple.2,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for KmsBlockPeriods {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for KmsBlockPeriods {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.preActivationBlockPeriod,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.generationBlockPeriod,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.suspendedBlockPeriod),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for KmsBlockPeriods {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for KmsBlockPeriods {
            const NAME: &'static str = "KmsBlockPeriods";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "KmsBlockPeriods(uint256 preActivationBlockPeriod,uint256 generationBlockPeriod,uint256 suspendedBlockPeriod)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.preActivationBlockPeriod,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.generationBlockPeriod,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.suspendedBlockPeriod,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for KmsBlockPeriods {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.preActivationBlockPeriod,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.generationBlockPeriod,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.suspendedBlockPeriod,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.preActivationBlockPeriod,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.generationBlockPeriod,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.suspendedBlockPeriod,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**```solidity
struct KmsContext { uint256 contextId; uint256 previousContextId; bytes8 softwareVersion; uint256 mpcThreshold; KmsNode[] kmsNodes; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct KmsContext {
        #[allow(missing_docs)]
        pub contextId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub previousContextId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub softwareVersion: alloy::sol_types::private::FixedBytes<8>,
        #[allow(missing_docs)]
        pub mpcThreshold: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub kmsNodes: alloy::sol_types::private::Vec<
            <KmsNode as alloy::sol_types::SolType>::RustType,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::FixedBytes<8>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Array<KmsNode>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::FixedBytes<8>,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Vec<
                <KmsNode as alloy::sol_types::SolType>::RustType,
            >,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<KmsContext> for UnderlyingRustTuple<'_> {
            fn from(value: KmsContext) -> Self {
                (
                    value.contextId,
                    value.previousContextId,
                    value.softwareVersion,
                    value.mpcThreshold,
                    value.kmsNodes,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for KmsContext {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    contextId: tuple.0,
                    previousContextId: tuple.1,
                    softwareVersion: tuple.2,
                    mpcThreshold: tuple.3,
                    kmsNodes: tuple.4,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for KmsContext {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for KmsContext {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.contextId),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.previousContextId),
                    <alloy::sol_types::sol_data::FixedBytes<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.softwareVersion),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.mpcThreshold),
                    <alloy::sol_types::sol_data::Array<
                        KmsNode,
                    > as alloy_sol_types::SolType>::tokenize(&self.kmsNodes),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for KmsContext {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for KmsContext {
            const NAME: &'static str = "KmsContext";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "KmsContext(uint256 contextId,uint256 previousContextId,bytes8 softwareVersion,uint256 mpcThreshold,KmsNode[] kmsNodes)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(<KmsNode as alloy_sol_types::SolStruct>::eip712_root_type());
                components
                    .extend(
                        <KmsNode as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.contextId)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.previousContextId,
                        )
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        8,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.softwareVersion,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.mpcThreshold)
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        KmsNode,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.kmsNodes)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for KmsContext {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.contextId,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.previousContextId,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        8,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.softwareVersion,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.mpcThreshold,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        KmsNode,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.kmsNodes,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.contextId,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.previousContextId,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.softwareVersion,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.mpcThreshold,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    KmsNode,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.kmsNodes,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**```solidity
struct KmsNode { string name; address signerAddress; address txSenderAddress; uint256 partyId; bytes backupEncryptionKey; string externalUrl; string publicStorageUrl; bytes tlsCertificate; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct KmsNode {
        #[allow(missing_docs)]
        pub name: alloy::sol_types::private::String,
        #[allow(missing_docs)]
        pub signerAddress: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub txSenderAddress: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub partyId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub backupEncryptionKey: alloy::sol_types::private::Bytes,
        #[allow(missing_docs)]
        pub externalUrl: alloy::sol_types::private::String,
        #[allow(missing_docs)]
        pub publicStorageUrl: alloy::sol_types::private::String,
        #[allow(missing_docs)]
        pub tlsCertificate: alloy::sol_types::private::Bytes,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::String,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::String,
            alloy::sol_types::sol_data::String,
            alloy::sol_types::sol_data::Bytes,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::String,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::String,
            alloy::sol_types::private::String,
            alloy::sol_types::private::Bytes,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<KmsNode> for UnderlyingRustTuple<'_> {
            fn from(value: KmsNode) -> Self {
                (
                    value.name,
                    value.signerAddress,
                    value.txSenderAddress,
                    value.partyId,
                    value.backupEncryptionKey,
                    value.externalUrl,
                    value.publicStorageUrl,
                    value.tlsCertificate,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for KmsNode {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    name: tuple.0,
                    signerAddress: tuple.1,
                    txSenderAddress: tuple.2,
                    partyId: tuple.3,
                    backupEncryptionKey: tuple.4,
                    externalUrl: tuple.5,
                    publicStorageUrl: tuple.6,
                    tlsCertificate: tuple.7,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for KmsNode {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for KmsNode {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.name,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.signerAddress,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.txSenderAddress,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.partyId),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.backupEncryptionKey,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.externalUrl,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.publicStorageUrl,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.tlsCertificate,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for KmsNode {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for KmsNode {
            const NAME: &'static str = "KmsNode";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "KmsNode(string name,address signerAddress,address txSenderAddress,uint256 partyId,bytes backupEncryptionKey,string externalUrl,string publicStorageUrl,bytes tlsCertificate)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::eip712_data_word(
                            &self.name,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.signerAddress,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.txSenderAddress,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.partyId)
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.backupEncryptionKey,
                        )
                        .0,
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::eip712_data_word(
                            &self.externalUrl,
                        )
                        .0,
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::eip712_data_word(
                            &self.publicStorageUrl,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.tlsCertificate,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for KmsNode {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.name,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.signerAddress,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.txSenderAddress,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.partyId,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.backupEncryptionKey,
                    )
                    + <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.externalUrl,
                    )
                    + <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.publicStorageUrl,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.tlsCertificate,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.name,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.signerAddress,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.txSenderAddress,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.partyId,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.backupEncryptionKey,
                    out,
                );
                <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.externalUrl,
                    out,
                );
                <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.publicStorageUrl,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.tlsCertificate,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `AddressEmptyCode(address)` and selector `0x9996b315`.
```solidity
error AddressEmptyCode(address target);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AddressEmptyCode {
        #[allow(missing_docs)]
        pub target: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AddressEmptyCode> for UnderlyingRustTuple<'_> {
            fn from(value: AddressEmptyCode) -> Self {
                (value.target,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for AddressEmptyCode {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { target: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AddressEmptyCode {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AddressEmptyCode(address)";
            const SELECTOR: [u8; 4] = [153u8, 150u8, 179u8, 21u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.target,
                    ),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `CompromiseActiveKmsContextNotAllowed(uint256)` and selector `0x77d05ea7`.
```solidity
error CompromiseActiveKmsContextNotAllowed(uint256 contextId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct CompromiseActiveKmsContextNotAllowed {
        #[allow(missing_docs)]
        pub contextId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<CompromiseActiveKmsContextNotAllowed>
        for UnderlyingRustTuple<'_> {
            fn from(value: CompromiseActiveKmsContextNotAllowed) -> Self {
                (value.contextId,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for CompromiseActiveKmsContextNotAllowed {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { contextId: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for CompromiseActiveKmsContextNotAllowed {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "CompromiseActiveKmsContextNotAllowed(uint256)";
            const SELECTOR: [u8; 4] = [119u8, 208u8, 94u8, 167u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.contextId),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `ContextAlreadyExists(uint256)` and selector `0x6653f6d7`.
```solidity
error ContextAlreadyExists(uint256 contextId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ContextAlreadyExists {
        #[allow(missing_docs)]
        pub contextId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ContextAlreadyExists> for UnderlyingRustTuple<'_> {
            fn from(value: ContextAlreadyExists) -> Self {
                (value.contextId,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ContextAlreadyExists {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { contextId: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ContextAlreadyExists {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ContextAlreadyExists(uint256)";
            const SELECTOR: [u8; 4] = [102u8, 83u8, 246u8, 215u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.contextId),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `ContextNotActive(uint256)` and selector `0x331486b3`.
```solidity
error ContextNotActive(uint256 contextId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ContextNotActive {
        #[allow(missing_docs)]
        pub contextId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ContextNotActive> for UnderlyingRustTuple<'_> {
            fn from(value: ContextNotActive) -> Self {
                (value.contextId,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ContextNotActive {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { contextId: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ContextNotActive {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ContextNotActive(uint256)";
            const SELECTOR: [u8; 4] = [51u8, 20u8, 134u8, 179u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.contextId),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `ContextNotActiveOrSuspended(uint256)` and selector `0x2b3652d1`.
```solidity
error ContextNotActiveOrSuspended(uint256 contextId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ContextNotActiveOrSuspended {
        #[allow(missing_docs)]
        pub contextId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ContextNotActiveOrSuspended>
        for UnderlyingRustTuple<'_> {
            fn from(value: ContextNotActiveOrSuspended) -> Self {
                (value.contextId,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ContextNotActiveOrSuspended {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { contextId: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ContextNotActiveOrSuspended {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ContextNotActiveOrSuspended(uint256)";
            const SELECTOR: [u8; 4] = [43u8, 54u8, 82u8, 209u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.contextId),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `ContextNotGenerated(uint256)` and selector `0xc0b5ee66`.
```solidity
error ContextNotGenerated(uint256 contextId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ContextNotGenerated {
        #[allow(missing_docs)]
        pub contextId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ContextNotGenerated> for UnderlyingRustTuple<'_> {
            fn from(value: ContextNotGenerated) -> Self {
                (value.contextId,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ContextNotGenerated {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { contextId: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ContextNotGenerated {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ContextNotGenerated(uint256)";
            const SELECTOR: [u8; 4] = [192u8, 181u8, 238u8, 102u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.contextId),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `ContextNotInitializedOrIsGenerating(uint256)` and selector `0xb0c5151d`.
```solidity
error ContextNotInitializedOrIsGenerating(uint256 contextId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ContextNotInitializedOrIsGenerating {
        #[allow(missing_docs)]
        pub contextId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ContextNotInitializedOrIsGenerating>
        for UnderlyingRustTuple<'_> {
            fn from(value: ContextNotInitializedOrIsGenerating) -> Self {
                (value.contextId,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ContextNotInitializedOrIsGenerating {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { contextId: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ContextNotInitializedOrIsGenerating {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ContextNotInitializedOrIsGenerating(uint256)";
            const SELECTOR: [u8; 4] = [176u8, 197u8, 21u8, 29u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.contextId),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `ContextNotPreActivatedOrSuspended(uint256)` and selector `0x12b49e3d`.
```solidity
error ContextNotPreActivatedOrSuspended(uint256 contextId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ContextNotPreActivatedOrSuspended {
        #[allow(missing_docs)]
        pub contextId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ContextNotPreActivatedOrSuspended>
        for UnderlyingRustTuple<'_> {
            fn from(value: ContextNotPreActivatedOrSuspended) -> Self {
                (value.contextId,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ContextNotPreActivatedOrSuspended {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { contextId: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ContextNotPreActivatedOrSuspended {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ContextNotPreActivatedOrSuspended(uint256)";
            const SELECTOR: [u8; 4] = [18u8, 180u8, 158u8, 61u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.contextId),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `DestroyActiveKmsContextNotAllowed(uint256)` and selector `0xb25e4eb3`.
```solidity
error DestroyActiveKmsContextNotAllowed(uint256 contextId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DestroyActiveKmsContextNotAllowed {
        #[allow(missing_docs)]
        pub contextId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<DestroyActiveKmsContextNotAllowed>
        for UnderlyingRustTuple<'_> {
            fn from(value: DestroyActiveKmsContextNotAllowed) -> Self {
                (value.contextId,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for DestroyActiveKmsContextNotAllowed {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { contextId: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for DestroyActiveKmsContextNotAllowed {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "DestroyActiveKmsContextNotAllowed(uint256)";
            const SELECTOR: [u8; 4] = [178u8, 94u8, 78u8, 179u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.contextId),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `ECDSAInvalidSignature()` and selector `0xf645eedf`.
```solidity
error ECDSAInvalidSignature();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ECDSAInvalidSignature {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ECDSAInvalidSignature> for UnderlyingRustTuple<'_> {
            fn from(value: ECDSAInvalidSignature) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ECDSAInvalidSignature {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ECDSAInvalidSignature {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ECDSAInvalidSignature()";
            const SELECTOR: [u8; 4] = [246u8, 69u8, 238u8, 223u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `ECDSAInvalidSignatureLength(uint256)` and selector `0xfce698f7`.
```solidity
error ECDSAInvalidSignatureLength(uint256 length);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ECDSAInvalidSignatureLength {
        #[allow(missing_docs)]
        pub length: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ECDSAInvalidSignatureLength>
        for UnderlyingRustTuple<'_> {
            fn from(value: ECDSAInvalidSignatureLength) -> Self {
                (value.length,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ECDSAInvalidSignatureLength {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { length: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ECDSAInvalidSignatureLength {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ECDSAInvalidSignatureLength(uint256)";
            const SELECTOR: [u8; 4] = [252u8, 230u8, 152u8, 247u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.length),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `ECDSAInvalidSignatureS(bytes32)` and selector `0xd78bce0c`.
```solidity
error ECDSAInvalidSignatureS(bytes32 s);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ECDSAInvalidSignatureS {
        #[allow(missing_docs)]
        pub s: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ECDSAInvalidSignatureS> for UnderlyingRustTuple<'_> {
            fn from(value: ECDSAInvalidSignatureS) -> Self {
                (value.s,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ECDSAInvalidSignatureS {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { s: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ECDSAInvalidSignatureS {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ECDSAInvalidSignatureS(bytes32)";
            const SELECTOR: [u8; 4] = [215u8, 139u8, 206u8, 12u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.s),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `ERC1967InvalidImplementation(address)` and selector `0x4c9c8ce3`.
```solidity
error ERC1967InvalidImplementation(address implementation);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC1967InvalidImplementation {
        #[allow(missing_docs)]
        pub implementation: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC1967InvalidImplementation>
        for UnderlyingRustTuple<'_> {
            fn from(value: ERC1967InvalidImplementation) -> Self {
                (value.implementation,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ERC1967InvalidImplementation {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { implementation: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC1967InvalidImplementation {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC1967InvalidImplementation(address)";
            const SELECTOR: [u8; 4] = [76u8, 156u8, 140u8, 227u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.implementation,
                    ),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `ERC1967NonPayable()` and selector `0xb398979f`.
```solidity
error ERC1967NonPayable();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC1967NonPayable {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC1967NonPayable> for UnderlyingRustTuple<'_> {
            fn from(value: ERC1967NonPayable) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ERC1967NonPayable {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC1967NonPayable {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC1967NonPayable()";
            const SELECTOR: [u8; 4] = [179u8, 152u8, 151u8, 159u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `EmptyKmsNodes()` and selector `0x068c8d40`.
```solidity
error EmptyKmsNodes();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EmptyKmsNodes {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EmptyKmsNodes> for UnderlyingRustTuple<'_> {
            fn from(value: EmptyKmsNodes) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EmptyKmsNodes {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EmptyKmsNodes {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EmptyKmsNodes()";
            const SELECTOR: [u8; 4] = [6u8, 140u8, 141u8, 64u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `EnforcedPause()` and selector `0xd93c0665`.
```solidity
error EnforcedPause();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EnforcedPause {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EnforcedPause> for UnderlyingRustTuple<'_> {
            fn from(value: EnforcedPause) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EnforcedPause {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EnforcedPause {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EnforcedPause()";
            const SELECTOR: [u8; 4] = [217u8, 60u8, 6u8, 101u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `ExpectedPause()` and selector `0x8dfc202b`.
```solidity
error ExpectedPause();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ExpectedPause {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ExpectedPause> for UnderlyingRustTuple<'_> {
            fn from(value: ExpectedPause) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ExpectedPause {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ExpectedPause {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ExpectedPause()";
            const SELECTOR: [u8; 4] = [141u8, 252u8, 32u8, 43u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `FailedCall()` and selector `0xd6bda275`.
```solidity
error FailedCall();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct FailedCall {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<FailedCall> for UnderlyingRustTuple<'_> {
            fn from(value: FailedCall) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for FailedCall {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for FailedCall {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "FailedCall()";
            const SELECTOR: [u8; 4] = [214u8, 189u8, 162u8, 117u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidHighMpcThreshold(uint256,uint256,uint256)` and selector `0x8789a6ca`.
```solidity
error InvalidHighMpcThreshold(uint256 contextId, uint256 mpcThreshold, uint256 nKmsNodes);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidHighMpcThreshold {
        #[allow(missing_docs)]
        pub contextId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub mpcThreshold: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub nKmsNodes: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidHighMpcThreshold> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidHighMpcThreshold) -> Self {
                (value.contextId, value.mpcThreshold, value.nKmsNodes)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidHighMpcThreshold {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    contextId: tuple.0,
                    mpcThreshold: tuple.1,
                    nKmsNodes: tuple.2,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidHighMpcThreshold {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidHighMpcThreshold(uint256,uint256,uint256)";
            const SELECTOR: [u8; 4] = [135u8, 137u8, 166u8, 202u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.contextId),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.mpcThreshold),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nKmsNodes),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidHighPublicDecryptionThreshold(uint256,uint256)` and selector `0x84208f23`.
```solidity
error InvalidHighPublicDecryptionThreshold(uint256 publicDecryptionThreshold, uint256 nKmsNodes);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidHighPublicDecryptionThreshold {
        #[allow(missing_docs)]
        pub publicDecryptionThreshold: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub nKmsNodes: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidHighPublicDecryptionThreshold>
        for UnderlyingRustTuple<'_> {
            fn from(value: InvalidHighPublicDecryptionThreshold) -> Self {
                (value.publicDecryptionThreshold, value.nKmsNodes)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for InvalidHighPublicDecryptionThreshold {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    publicDecryptionThreshold: tuple.0,
                    nKmsNodes: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidHighPublicDecryptionThreshold {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidHighPublicDecryptionThreshold(uint256,uint256)";
            const SELECTOR: [u8; 4] = [132u8, 32u8, 143u8, 35u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.publicDecryptionThreshold,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nKmsNodes),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidHighUserDecryptionThreshold(uint256,uint256)` and selector `0xd2535e11`.
```solidity
error InvalidHighUserDecryptionThreshold(uint256 userDecryptionThreshold, uint256 nKmsNodes);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidHighUserDecryptionThreshold {
        #[allow(missing_docs)]
        pub userDecryptionThreshold: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub nKmsNodes: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidHighUserDecryptionThreshold>
        for UnderlyingRustTuple<'_> {
            fn from(value: InvalidHighUserDecryptionThreshold) -> Self {
                (value.userDecryptionThreshold, value.nKmsNodes)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for InvalidHighUserDecryptionThreshold {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    userDecryptionThreshold: tuple.0,
                    nKmsNodes: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidHighUserDecryptionThreshold {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidHighUserDecryptionThreshold(uint256,uint256)";
            const SELECTOR: [u8; 4] = [210u8, 83u8, 94u8, 17u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.userDecryptionThreshold,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nKmsNodes),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidInitialization()` and selector `0xf92ee8a9`.
```solidity
error InvalidInitialization();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidInitialization {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidInitialization> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidInitialization) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidInitialization {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidInitialization {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidInitialization()";
            const SELECTOR: [u8; 4] = [249u8, 46u8, 232u8, 169u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidNullContextId()` and selector `0xcb17b7a5`.
```solidity
error InvalidNullContextId();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidNullContextId {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidNullContextId> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidNullContextId) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidNullContextId {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidNullContextId {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidNullContextId()";
            const SELECTOR: [u8; 4] = [203u8, 23u8, 183u8, 165u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidNullPublicDecryptionThreshold()` and selector `0xb1ae92ea`.
```solidity
error InvalidNullPublicDecryptionThreshold();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidNullPublicDecryptionThreshold {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidNullPublicDecryptionThreshold>
        for UnderlyingRustTuple<'_> {
            fn from(value: InvalidNullPublicDecryptionThreshold) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for InvalidNullPublicDecryptionThreshold {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidNullPublicDecryptionThreshold {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidNullPublicDecryptionThreshold()";
            const SELECTOR: [u8; 4] = [177u8, 174u8, 146u8, 234u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidNullUserDecryptionThreshold()` and selector `0xe60a7271`.
```solidity
error InvalidNullUserDecryptionThreshold();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidNullUserDecryptionThreshold {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidNullUserDecryptionThreshold>
        for UnderlyingRustTuple<'_> {
            fn from(value: InvalidNullUserDecryptionThreshold) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for InvalidNullUserDecryptionThreshold {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidNullUserDecryptionThreshold {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidNullUserDecryptionThreshold()";
            const SELECTOR: [u8; 4] = [230u8, 10u8, 114u8, 113u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `KmsContextNotGenerating(uint256)` and selector `0x5e51a2e1`.
```solidity
error KmsContextNotGenerating(uint256 contextId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct KmsContextNotGenerating {
        #[allow(missing_docs)]
        pub contextId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<KmsContextNotGenerating> for UnderlyingRustTuple<'_> {
            fn from(value: KmsContextNotGenerating) -> Self {
                (value.contextId,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for KmsContextNotGenerating {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { contextId: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for KmsContextNotGenerating {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "KmsContextNotGenerating(uint256)";
            const SELECTOR: [u8; 4] = [94u8, 81u8, 162u8, 225u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.contextId),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `KmsContextNotInitialized(uint256)` and selector `0x82b1fbda`.
```solidity
error KmsContextNotInitialized(uint256 contextId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct KmsContextNotInitialized {
        #[allow(missing_docs)]
        pub contextId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<KmsContextNotInitialized>
        for UnderlyingRustTuple<'_> {
            fn from(value: KmsContextNotInitialized) -> Self {
                (value.contextId,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for KmsContextNotInitialized {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { contextId: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for KmsContextNotInitialized {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "KmsContextNotInitialized(uint256)";
            const SELECTOR: [u8; 4] = [130u8, 177u8, 251u8, 218u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.contextId),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `KmsNodeAlreadyValidatedKeyResharing(uint256,address)` and selector `0x99b158c1`.
```solidity
error KmsNodeAlreadyValidatedKeyResharing(uint256 contextId, address kmsSigner);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct KmsNodeAlreadyValidatedKeyResharing {
        #[allow(missing_docs)]
        pub contextId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub kmsSigner: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Address,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Address,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<KmsNodeAlreadyValidatedKeyResharing>
        for UnderlyingRustTuple<'_> {
            fn from(value: KmsNodeAlreadyValidatedKeyResharing) -> Self {
                (value.contextId, value.kmsSigner)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for KmsNodeAlreadyValidatedKeyResharing {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    contextId: tuple.0,
                    kmsSigner: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for KmsNodeAlreadyValidatedKeyResharing {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "KmsNodeAlreadyValidatedKeyResharing(uint256,address)";
            const SELECTOR: [u8; 4] = [153u8, 177u8, 88u8, 193u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.contextId),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.kmsSigner,
                    ),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `NoSuspendedKmsContext()` and selector `0x207ea3f3`.
```solidity
error NoSuspendedKmsContext();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NoSuspendedKmsContext {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NoSuspendedKmsContext> for UnderlyingRustTuple<'_> {
            fn from(value: NoSuspendedKmsContext) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NoSuspendedKmsContext {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NoSuspendedKmsContext {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NoSuspendedKmsContext()";
            const SELECTOR: [u8; 4] = [32u8, 126u8, 163u8, 243u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `NotInitializing()` and selector `0xd7e6bcf8`.
```solidity
error NotInitializing();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NotInitializing {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NotInitializing> for UnderlyingRustTuple<'_> {
            fn from(value: NotInitializing) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NotInitializing {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NotInitializing {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NotInitializing()";
            const SELECTOR: [u8; 4] = [215u8, 230u8, 188u8, 248u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `NotInitializingFromEmptyProxy()` and selector `0x6f4f731f`.
```solidity
error NotInitializingFromEmptyProxy();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NotInitializingFromEmptyProxy {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NotInitializingFromEmptyProxy>
        for UnderlyingRustTuple<'_> {
            fn from(value: NotInitializingFromEmptyProxy) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for NotInitializingFromEmptyProxy {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NotInitializingFromEmptyProxy {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NotInitializingFromEmptyProxy()";
            const SELECTOR: [u8; 4] = [111u8, 79u8, 115u8, 31u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `NotKmsNodeFromContext(uint256,address)` and selector `0x0494d3c0`.
```solidity
error NotKmsNodeFromContext(uint256 contextId, address kmsTxSenderAddress);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NotKmsNodeFromContext {
        #[allow(missing_docs)]
        pub contextId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub kmsTxSenderAddress: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Address,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Address,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NotKmsNodeFromContext> for UnderlyingRustTuple<'_> {
            fn from(value: NotKmsNodeFromContext) -> Self {
                (value.contextId, value.kmsTxSenderAddress)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NotKmsNodeFromContext {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    contextId: tuple.0,
                    kmsTxSenderAddress: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NotKmsNodeFromContext {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NotKmsNodeFromContext(uint256,address)";
            const SELECTOR: [u8; 4] = [4u8, 148u8, 211u8, 192u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.contextId),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.kmsTxSenderAddress,
                    ),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `NotKmsSignerFromContext(uint256,address)` and selector `0x89b45e5d`.
```solidity
error NotKmsSignerFromContext(uint256 contextId, address signerAddress);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NotKmsSignerFromContext {
        #[allow(missing_docs)]
        pub contextId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub signerAddress: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Address,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Address,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NotKmsSignerFromContext> for UnderlyingRustTuple<'_> {
            fn from(value: NotKmsSignerFromContext) -> Self {
                (value.contextId, value.signerAddress)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NotKmsSignerFromContext {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    contextId: tuple.0,
                    signerAddress: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NotKmsSignerFromContext {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NotKmsSignerFromContext(uint256,address)";
            const SELECTOR: [u8; 4] = [137u8, 180u8, 94u8, 93u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.contextId),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.signerAddress,
                    ),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `NotKmsTxSenderFromContext(uint256,address)` and selector `0xfdf8a05d`.
```solidity
error NotKmsTxSenderFromContext(uint256 contextId, address txSenderAddress);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NotKmsTxSenderFromContext {
        #[allow(missing_docs)]
        pub contextId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub txSenderAddress: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Address,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Address,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NotKmsTxSenderFromContext>
        for UnderlyingRustTuple<'_> {
            fn from(value: NotKmsTxSenderFromContext) -> Self {
                (value.contextId, value.txSenderAddress)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for NotKmsTxSenderFromContext {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    contextId: tuple.0,
                    txSenderAddress: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NotKmsTxSenderFromContext {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NotKmsTxSenderFromContext(uint256,address)";
            const SELECTOR: [u8; 4] = [253u8, 248u8, 160u8, 93u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.contextId),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.txSenderAddress,
                    ),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `NotOwnerOrPauser(address)` and selector `0x46c0d9af`.
```solidity
error NotOwnerOrPauser(address notOwnerOrPauser);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NotOwnerOrPauser {
        #[allow(missing_docs)]
        pub notOwnerOrPauser: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NotOwnerOrPauser> for UnderlyingRustTuple<'_> {
            fn from(value: NotOwnerOrPauser) -> Self {
                (value.notOwnerOrPauser,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NotOwnerOrPauser {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { notOwnerOrPauser: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NotOwnerOrPauser {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NotOwnerOrPauser(address)";
            const SELECTOR: [u8; 4] = [70u8, 192u8, 217u8, 175u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.notOwnerOrPauser,
                    ),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `NumberOfKmsNodesChanged(uint256,uint256)` and selector `0xd595a962`.
```solidity
error NumberOfKmsNodesChanged(uint256 activeKmsNodesLength, uint256 newKmsNodesLength);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NumberOfKmsNodesChanged {
        #[allow(missing_docs)]
        pub activeKmsNodesLength: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub newKmsNodesLength: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NumberOfKmsNodesChanged> for UnderlyingRustTuple<'_> {
            fn from(value: NumberOfKmsNodesChanged) -> Self {
                (value.activeKmsNodesLength, value.newKmsNodesLength)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NumberOfKmsNodesChanged {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    activeKmsNodesLength: tuple.0,
                    newKmsNodesLength: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NumberOfKmsNodesChanged {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NumberOfKmsNodesChanged(uint256,uint256)";
            const SELECTOR: [u8; 4] = [213u8, 149u8, 169u8, 98u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.activeKmsNodesLength),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.newKmsNodesLength),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `OwnableInvalidOwner(address)` and selector `0x1e4fbdf7`.
```solidity
error OwnableInvalidOwner(address owner);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct OwnableInvalidOwner {
        #[allow(missing_docs)]
        pub owner: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<OwnableInvalidOwner> for UnderlyingRustTuple<'_> {
            fn from(value: OwnableInvalidOwner) -> Self {
                (value.owner,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for OwnableInvalidOwner {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { owner: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for OwnableInvalidOwner {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "OwnableInvalidOwner(address)";
            const SELECTOR: [u8; 4] = [30u8, 79u8, 189u8, 247u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.owner,
                    ),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `OwnableUnauthorizedAccount(address)` and selector `0x118cdaa7`.
```solidity
error OwnableUnauthorizedAccount(address account);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct OwnableUnauthorizedAccount {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<OwnableUnauthorizedAccount>
        for UnderlyingRustTuple<'_> {
            fn from(value: OwnableUnauthorizedAccount) -> Self {
                (value.account,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for OwnableUnauthorizedAccount {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { account: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for OwnableUnauthorizedAccount {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "OwnableUnauthorizedAccount(address)";
            const SELECTOR: [u8; 4] = [17u8, 140u8, 218u8, 167u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `SuspendedKmsContextOngoing(uint256)` and selector `0x7623d357`.
```solidity
error SuspendedKmsContextOngoing(uint256 suspendedContextId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SuspendedKmsContextOngoing {
        #[allow(missing_docs)]
        pub suspendedContextId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<SuspendedKmsContextOngoing>
        for UnderlyingRustTuple<'_> {
            fn from(value: SuspendedKmsContextOngoing) -> Self {
                (value.suspendedContextId,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for SuspendedKmsContextOngoing {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    suspendedContextId: tuple.0,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for SuspendedKmsContextOngoing {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "SuspendedKmsContextOngoing(uint256)";
            const SELECTOR: [u8; 4] = [118u8, 35u8, 211u8, 87u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.suspendedContextId),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `UUPSUnauthorizedCallContext()` and selector `0xe07c8dba`.
```solidity
error UUPSUnauthorizedCallContext();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct UUPSUnauthorizedCallContext {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UUPSUnauthorizedCallContext>
        for UnderlyingRustTuple<'_> {
            fn from(value: UUPSUnauthorizedCallContext) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for UUPSUnauthorizedCallContext {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for UUPSUnauthorizedCallContext {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "UUPSUnauthorizedCallContext()";
            const SELECTOR: [u8; 4] = [224u8, 124u8, 141u8, 186u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `UUPSUnsupportedProxiableUUID(bytes32)` and selector `0xaa1d49a4`.
```solidity
error UUPSUnsupportedProxiableUUID(bytes32 slot);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct UUPSUnsupportedProxiableUUID {
        #[allow(missing_docs)]
        pub slot: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UUPSUnsupportedProxiableUUID>
        for UnderlyingRustTuple<'_> {
            fn from(value: UUPSUnsupportedProxiableUUID) -> Self {
                (value.slot,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for UUPSUnsupportedProxiableUUID {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { slot: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for UUPSUnsupportedProxiableUUID {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "UUPSUnsupportedProxiableUUID(bytes32)";
            const SELECTOR: [u8; 4] = [170u8, 29u8, 73u8, 164u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.slot),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `ActivateKmsContext(uint256)` and selector `0x4f54a6ac981cc8dc83142b3eb4d120be7c70fc5de6477a14eae3e9ca647644bc`.
```solidity
event ActivateKmsContext(uint256 contextId);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct ActivateKmsContext {
        #[allow(missing_docs)]
        pub contextId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for ActivateKmsContext {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "ActivateKmsContext(uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                79u8, 84u8, 166u8, 172u8, 152u8, 28u8, 200u8, 220u8, 131u8, 20u8, 43u8,
                62u8, 180u8, 209u8, 32u8, 190u8, 124u8, 112u8, 252u8, 93u8, 230u8, 71u8,
                122u8, 20u8, 234u8, 227u8, 233u8, 202u8, 100u8, 118u8, 68u8, 188u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { contextId: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.contextId),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for ActivateKmsContext {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&ActivateKmsContext> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &ActivateKmsContext) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `CompromiseKmsContext(uint256)` and selector `0xbc1114fa9a77648cd097ee6cf149c344fa278b9b983f30dd65b6fd6a9d464a07`.
```solidity
event CompromiseKmsContext(uint256 contextId);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct CompromiseKmsContext {
        #[allow(missing_docs)]
        pub contextId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for CompromiseKmsContext {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "CompromiseKmsContext(uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                188u8, 17u8, 20u8, 250u8, 154u8, 119u8, 100u8, 140u8, 208u8, 151u8,
                238u8, 108u8, 241u8, 73u8, 195u8, 68u8, 250u8, 39u8, 139u8, 155u8, 152u8,
                63u8, 48u8, 221u8, 101u8, 182u8, 253u8, 106u8, 157u8, 70u8, 74u8, 7u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { contextId: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.contextId),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for CompromiseKmsContext {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&CompromiseKmsContext> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &CompromiseKmsContext) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `DeactivateKmsContext(uint256)` and selector `0x8fb75858a565aee117342d93196a7f0b54c1c8519885eddda6a01f477359b363`.
```solidity
event DeactivateKmsContext(uint256 contextId);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct DeactivateKmsContext {
        #[allow(missing_docs)]
        pub contextId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for DeactivateKmsContext {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "DeactivateKmsContext(uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                143u8, 183u8, 88u8, 88u8, 165u8, 101u8, 174u8, 225u8, 23u8, 52u8, 45u8,
                147u8, 25u8, 106u8, 127u8, 11u8, 84u8, 193u8, 200u8, 81u8, 152u8, 133u8,
                237u8, 221u8, 166u8, 160u8, 31u8, 71u8, 115u8, 89u8, 179u8, 99u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { contextId: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.contextId),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for DeactivateKmsContext {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&DeactivateKmsContext> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &DeactivateKmsContext) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `DestroyKmsContext(uint256)` and selector `0x3e8f02dc7af6e3a67f3af0bc99bcf11b4deb46105e9ba7f1ac6da82322e9025e`.
```solidity
event DestroyKmsContext(uint256 contextId);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct DestroyKmsContext {
        #[allow(missing_docs)]
        pub contextId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for DestroyKmsContext {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "DestroyKmsContext(uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                62u8, 143u8, 2u8, 220u8, 122u8, 246u8, 227u8, 166u8, 127u8, 58u8, 240u8,
                188u8, 153u8, 188u8, 241u8, 27u8, 77u8, 235u8, 70u8, 16u8, 94u8, 155u8,
                167u8, 241u8, 172u8, 109u8, 168u8, 35u8, 34u8, 233u8, 2u8, 94u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { contextId: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.contextId),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for DestroyKmsContext {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&DestroyKmsContext> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &DestroyKmsContext) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `EIP712DomainChanged()` and selector `0x0a6387c9ea3628b88a633bb4f3b151770f70085117a15f9bf3787cda53f13d31`.
```solidity
event EIP712DomainChanged();
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct EIP712DomainChanged {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for EIP712DomainChanged {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "EIP712DomainChanged()";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                10u8, 99u8, 135u8, 201u8, 234u8, 54u8, 40u8, 184u8, 138u8, 99u8, 59u8,
                180u8, 243u8, 177u8, 81u8, 119u8, 15u8, 112u8, 8u8, 81u8, 23u8, 161u8,
                95u8, 155u8, 243u8, 120u8, 124u8, 218u8, 83u8, 241u8, 61u8, 49u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {}
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for EIP712DomainChanged {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&EIP712DomainChanged> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &EIP712DomainChanged) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `InitializeKmsContexts((uint256,uint256),bytes8,uint256,(string,address,address,uint256,bytes,string,string,bytes)[])` and selector `0x5448756ee13f8e5e9a81f574ac68c8814a16612bee06fea0fd80c61610436dcd`.
```solidity
event InitializeKmsContexts(DecryptionThresholds decryptionThresholds, bytes8 softwareVersion, uint256 mpcThreshold, KmsNode[] kmsNodes);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct InitializeKmsContexts {
        #[allow(missing_docs)]
        pub decryptionThresholds: <DecryptionThresholds as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub softwareVersion: alloy::sol_types::private::FixedBytes<8>,
        #[allow(missing_docs)]
        pub mpcThreshold: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub kmsNodes: alloy::sol_types::private::Vec<
            <KmsNode as alloy::sol_types::SolType>::RustType,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for InitializeKmsContexts {
            type DataTuple<'a> = (
                DecryptionThresholds,
                alloy::sol_types::sol_data::FixedBytes<8>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Array<KmsNode>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "InitializeKmsContexts((uint256,uint256),bytes8,uint256,(string,address,address,uint256,bytes,string,string,bytes)[])";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                84u8, 72u8, 117u8, 110u8, 225u8, 63u8, 142u8, 94u8, 154u8, 129u8, 245u8,
                116u8, 172u8, 104u8, 200u8, 129u8, 74u8, 22u8, 97u8, 43u8, 238u8, 6u8,
                254u8, 160u8, 253u8, 128u8, 198u8, 22u8, 16u8, 67u8, 109u8, 205u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    decryptionThresholds: data.0,
                    softwareVersion: data.1,
                    mpcThreshold: data.2,
                    kmsNodes: data.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <DecryptionThresholds as alloy_sol_types::SolType>::tokenize(
                        &self.decryptionThresholds,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.softwareVersion),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.mpcThreshold),
                    <alloy::sol_types::sol_data::Array<
                        KmsNode,
                    > as alloy_sol_types::SolType>::tokenize(&self.kmsNodes),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for InitializeKmsContexts {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&InitializeKmsContexts> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &InitializeKmsContexts) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `Initialized(uint64)` and selector `0xc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d2`.
```solidity
event Initialized(uint64 version);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Initialized {
        #[allow(missing_docs)]
        pub version: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Initialized {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "Initialized(uint64)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                199u8, 245u8, 5u8, 178u8, 243u8, 113u8, 174u8, 33u8, 117u8, 238u8, 73u8,
                19u8, 244u8, 73u8, 158u8, 31u8, 38u8, 51u8, 167u8, 181u8, 147u8, 99u8,
                33u8, 238u8, 209u8, 205u8, 174u8, 182u8, 17u8, 81u8, 129u8, 210u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { version: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.version),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Initialized {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Initialized> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Initialized) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `InvalidateKeyResharing(uint256)` and selector `0x009fe8f0db45996decf7b06fc7b6ec5f887d5f04db2e0c4ad7f4e4ee5eefc5a3`.
```solidity
event InvalidateKeyResharing(uint256 contextId);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct InvalidateKeyResharing {
        #[allow(missing_docs)]
        pub contextId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for InvalidateKeyResharing {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "InvalidateKeyResharing(uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                0u8, 159u8, 232u8, 240u8, 219u8, 69u8, 153u8, 109u8, 236u8, 247u8, 176u8,
                111u8, 199u8, 182u8, 236u8, 95u8, 136u8, 125u8, 95u8, 4u8, 219u8, 46u8,
                12u8, 74u8, 215u8, 244u8, 228u8, 238u8, 94u8, 239u8, 197u8, 163u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { contextId: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.contextId),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for InvalidateKeyResharing {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&InvalidateKeyResharing> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &InvalidateKeyResharing) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `NewKmsContext((uint256,uint256,bytes8,uint256,(string,address,address,uint256,bytes,string,string,bytes)[]),(uint256,uint256,bytes8,uint256,(string,address,address,uint256,bytes,string,string,bytes)[]),(uint256,uint256,uint256))` and selector `0xa69a4c9341cd7d458fde12c31a1f582f7d4caedb27c4a7c34cc992208a3ce4c5`.
```solidity
event NewKmsContext(KmsContext activeKmsContext, KmsContext newKmsContext, KmsBlockPeriods blockPeriods);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct NewKmsContext {
        #[allow(missing_docs)]
        pub activeKmsContext: <KmsContext as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub newKmsContext: <KmsContext as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub blockPeriods: <KmsBlockPeriods as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for NewKmsContext {
            type DataTuple<'a> = (KmsContext, KmsContext, KmsBlockPeriods);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "NewKmsContext((uint256,uint256,bytes8,uint256,(string,address,address,uint256,bytes,string,string,bytes)[]),(uint256,uint256,bytes8,uint256,(string,address,address,uint256,bytes,string,string,bytes)[]),(uint256,uint256,uint256))";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                166u8, 154u8, 76u8, 147u8, 65u8, 205u8, 125u8, 69u8, 143u8, 222u8, 18u8,
                195u8, 26u8, 31u8, 88u8, 47u8, 125u8, 76u8, 174u8, 219u8, 39u8, 196u8,
                167u8, 195u8, 76u8, 201u8, 146u8, 32u8, 138u8, 60u8, 228u8, 197u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    activeKmsContext: data.0,
                    newKmsContext: data.1,
                    blockPeriods: data.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <KmsContext as alloy_sol_types::SolType>::tokenize(
                        &self.activeKmsContext,
                    ),
                    <KmsContext as alloy_sol_types::SolType>::tokenize(
                        &self.newKmsContext,
                    ),
                    <KmsBlockPeriods as alloy_sol_types::SolType>::tokenize(
                        &self.blockPeriods,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for NewKmsContext {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&NewKmsContext> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &NewKmsContext) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `OwnershipTransferStarted(address,address)` and selector `0x38d16b8cac22d99fc7c124b9cd0de2d3fa1faef420bfe791d8c362d765e22700`.
```solidity
event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct OwnershipTransferStarted {
        #[allow(missing_docs)]
        pub previousOwner: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub newOwner: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for OwnershipTransferStarted {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "OwnershipTransferStarted(address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                56u8, 209u8, 107u8, 140u8, 172u8, 34u8, 217u8, 159u8, 199u8, 193u8, 36u8,
                185u8, 205u8, 13u8, 226u8, 211u8, 250u8, 31u8, 174u8, 244u8, 32u8, 191u8,
                231u8, 145u8, 216u8, 195u8, 98u8, 215u8, 101u8, 226u8, 39u8, 0u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    previousOwner: topics.1,
                    newOwner: topics.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.previousOwner.clone(),
                    self.newOwner.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.previousOwner,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.newOwner,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for OwnershipTransferStarted {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&OwnershipTransferStarted> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(
                this: &OwnershipTransferStarted,
            ) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `OwnershipTransferred(address,address)` and selector `0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0`.
```solidity
event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct OwnershipTransferred {
        #[allow(missing_docs)]
        pub previousOwner: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub newOwner: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for OwnershipTransferred {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "OwnershipTransferred(address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                139u8, 224u8, 7u8, 156u8, 83u8, 22u8, 89u8, 20u8, 19u8, 68u8, 205u8,
                31u8, 208u8, 164u8, 242u8, 132u8, 25u8, 73u8, 127u8, 151u8, 34u8, 163u8,
                218u8, 175u8, 227u8, 180u8, 24u8, 111u8, 107u8, 100u8, 87u8, 224u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    previousOwner: topics.1,
                    newOwner: topics.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.previousOwner.clone(),
                    self.newOwner.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.previousOwner,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.newOwner,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for OwnershipTransferred {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&OwnershipTransferred> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &OwnershipTransferred) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `Paused(address)` and selector `0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258`.
```solidity
event Paused(address account);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Paused {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Paused {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "Paused(address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                98u8, 231u8, 140u8, 234u8, 1u8, 190u8, 227u8, 32u8, 205u8, 78u8, 66u8,
                2u8, 112u8, 181u8, 234u8, 116u8, 0u8, 13u8, 17u8, 176u8, 201u8, 247u8,
                71u8, 84u8, 235u8, 219u8, 252u8, 84u8, 75u8, 5u8, 162u8, 88u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { account: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Paused {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Paused> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Paused) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `PreActivateKmsContext((uint256,uint256,bytes8,uint256,(string,address,address,uint256,bytes,string,string,bytes)[]),uint256)` and selector `0x4540f7808fcaec86c376a89d2c0c93a5056c21680db54332c7f2959d87fefc8b`.
```solidity
event PreActivateKmsContext(KmsContext newKmsContext, uint256 preActivationBlockNumber);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct PreActivateKmsContext {
        #[allow(missing_docs)]
        pub newKmsContext: <KmsContext as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub preActivationBlockNumber: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for PreActivateKmsContext {
            type DataTuple<'a> = (KmsContext, alloy::sol_types::sol_data::Uint<256>);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "PreActivateKmsContext((uint256,uint256,bytes8,uint256,(string,address,address,uint256,bytes,string,string,bytes)[]),uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                69u8, 64u8, 247u8, 128u8, 143u8, 202u8, 236u8, 134u8, 195u8, 118u8,
                168u8, 157u8, 44u8, 12u8, 147u8, 165u8, 5u8, 108u8, 33u8, 104u8, 13u8,
                181u8, 67u8, 50u8, 199u8, 242u8, 149u8, 157u8, 135u8, 254u8, 252u8, 139u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    newKmsContext: data.0,
                    preActivationBlockNumber: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <KmsContext as alloy_sol_types::SolType>::tokenize(
                        &self.newKmsContext,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.preActivationBlockNumber,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for PreActivateKmsContext {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&PreActivateKmsContext> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &PreActivateKmsContext) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `StartKeyResharing((uint256,uint256,bytes8,uint256,(string,address,address,uint256,bytes,string,string,bytes)[]),(uint256,uint256,bytes8,uint256,(string,address,address,uint256,bytes,string,string,bytes)[]),uint256)` and selector `0x5dc601065a035d78305cd9ef27c91a009cd8d37297e43bb76319490895a0d058`.
```solidity
event StartKeyResharing(KmsContext activeKmsContext, KmsContext newKmsContext, uint256 generationBlockNumber);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct StartKeyResharing {
        #[allow(missing_docs)]
        pub activeKmsContext: <KmsContext as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub newKmsContext: <KmsContext as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub generationBlockNumber: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for StartKeyResharing {
            type DataTuple<'a> = (
                KmsContext,
                KmsContext,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "StartKeyResharing((uint256,uint256,bytes8,uint256,(string,address,address,uint256,bytes,string,string,bytes)[]),(uint256,uint256,bytes8,uint256,(string,address,address,uint256,bytes,string,string,bytes)[]),uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                93u8, 198u8, 1u8, 6u8, 90u8, 3u8, 93u8, 120u8, 48u8, 92u8, 217u8, 239u8,
                39u8, 201u8, 26u8, 0u8, 156u8, 216u8, 211u8, 114u8, 151u8, 228u8, 59u8,
                183u8, 99u8, 25u8, 73u8, 8u8, 149u8, 160u8, 208u8, 88u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    activeKmsContext: data.0,
                    newKmsContext: data.1,
                    generationBlockNumber: data.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <KmsContext as alloy_sol_types::SolType>::tokenize(
                        &self.activeKmsContext,
                    ),
                    <KmsContext as alloy_sol_types::SolType>::tokenize(
                        &self.newKmsContext,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.generationBlockNumber),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for StartKeyResharing {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&StartKeyResharing> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &StartKeyResharing) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `SuspendKmsContext(uint256)` and selector `0x851a08c16b15959c338ac4b56466d06c9f9d5ff8d715168aa125d5ccaf538320`.
```solidity
event SuspendKmsContext(uint256 contextId);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct SuspendKmsContext {
        #[allow(missing_docs)]
        pub contextId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for SuspendKmsContext {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "SuspendKmsContext(uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                133u8, 26u8, 8u8, 193u8, 107u8, 21u8, 149u8, 156u8, 51u8, 138u8, 196u8,
                181u8, 100u8, 102u8, 208u8, 108u8, 159u8, 157u8, 95u8, 248u8, 215u8,
                21u8, 22u8, 138u8, 161u8, 37u8, 213u8, 204u8, 175u8, 83u8, 131u8, 32u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { contextId: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.contextId),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for SuspendKmsContext {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&SuspendKmsContext> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &SuspendKmsContext) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `Unpaused(address)` and selector `0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa`.
```solidity
event Unpaused(address account);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Unpaused {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Unpaused {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "Unpaused(address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                93u8, 185u8, 238u8, 10u8, 73u8, 91u8, 242u8, 230u8, 255u8, 156u8, 145u8,
                167u8, 131u8, 76u8, 27u8, 164u8, 253u8, 210u8, 68u8, 165u8, 232u8, 170u8,
                78u8, 83u8, 123u8, 211u8, 138u8, 234u8, 228u8, 176u8, 115u8, 170u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { account: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Unpaused {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Unpaused> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Unpaused) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `UpdatePublicDecryptionThreshold(uint256)` and selector `0xe41802af725729adcb8c151e2937380a25c69155757e3af5d3979adab5035800`.
```solidity
event UpdatePublicDecryptionThreshold(uint256 newPublicDecryptionThreshold);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct UpdatePublicDecryptionThreshold {
        #[allow(missing_docs)]
        pub newPublicDecryptionThreshold: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for UpdatePublicDecryptionThreshold {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "UpdatePublicDecryptionThreshold(uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                228u8, 24u8, 2u8, 175u8, 114u8, 87u8, 41u8, 173u8, 203u8, 140u8, 21u8,
                30u8, 41u8, 55u8, 56u8, 10u8, 37u8, 198u8, 145u8, 85u8, 117u8, 126u8,
                58u8, 245u8, 211u8, 151u8, 154u8, 218u8, 181u8, 3u8, 88u8, 0u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    newPublicDecryptionThreshold: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.newPublicDecryptionThreshold,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for UpdatePublicDecryptionThreshold {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&UpdatePublicDecryptionThreshold>
        for alloy_sol_types::private::LogData {
            #[inline]
            fn from(
                this: &UpdatePublicDecryptionThreshold,
            ) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `UpdateUserDecryptionThreshold(uint256)` and selector `0x837e0a6528dadfa2dc792692c5182e52a9f5bbdeed7b2372927a26c695839613`.
```solidity
event UpdateUserDecryptionThreshold(uint256 newUserDecryptionThreshold);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct UpdateUserDecryptionThreshold {
        #[allow(missing_docs)]
        pub newUserDecryptionThreshold: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for UpdateUserDecryptionThreshold {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "UpdateUserDecryptionThreshold(uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                131u8, 126u8, 10u8, 101u8, 40u8, 218u8, 223u8, 162u8, 220u8, 121u8, 38u8,
                146u8, 197u8, 24u8, 46u8, 82u8, 169u8, 245u8, 187u8, 222u8, 237u8, 123u8,
                35u8, 114u8, 146u8, 122u8, 38u8, 198u8, 149u8, 131u8, 150u8, 19u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    newUserDecryptionThreshold: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.newUserDecryptionThreshold,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for UpdateUserDecryptionThreshold {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&UpdateUserDecryptionThreshold> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(
                this: &UpdateUserDecryptionThreshold,
            ) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `Upgraded(address)` and selector `0xbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b`.
```solidity
event Upgraded(address indexed implementation);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Upgraded {
        #[allow(missing_docs)]
        pub implementation: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Upgraded {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "Upgraded(address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                188u8, 124u8, 215u8, 90u8, 32u8, 238u8, 39u8, 253u8, 154u8, 222u8, 186u8,
                179u8, 32u8, 65u8, 247u8, 85u8, 33u8, 77u8, 188u8, 107u8, 255u8, 169u8,
                12u8, 192u8, 34u8, 91u8, 57u8, 218u8, 46u8, 92u8, 45u8, 59u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { implementation: topics.1 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.implementation.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.implementation,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Upgraded {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Upgraded> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Upgraded) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `ValidateKeyResharing((uint256,uint256,bytes8,uint256,(string,address,address,uint256,bytes,string,string,bytes)[]))` and selector `0x68898a98936bf23a56e8ed4b23dcc98cef926bd9ac2ce522f1f9423e3864f2f5`.
```solidity
event ValidateKeyResharing(KmsContext newKmsContext);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct ValidateKeyResharing {
        #[allow(missing_docs)]
        pub newKmsContext: <KmsContext as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for ValidateKeyResharing {
            type DataTuple<'a> = (KmsContext,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "ValidateKeyResharing((uint256,uint256,bytes8,uint256,(string,address,address,uint256,bytes,string,string,bytes)[]))";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                104u8, 137u8, 138u8, 152u8, 147u8, 107u8, 242u8, 58u8, 86u8, 232u8,
                237u8, 75u8, 35u8, 220u8, 201u8, 140u8, 239u8, 146u8, 107u8, 217u8,
                172u8, 44u8, 229u8, 34u8, 241u8, 249u8, 66u8, 62u8, 56u8, 100u8, 242u8,
                245u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { newKmsContext: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <KmsContext as alloy_sol_types::SolType>::tokenize(
                        &self.newKmsContext,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for ValidateKeyResharing {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&ValidateKeyResharing> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &ValidateKeyResharing) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Constructor`.
```solidity
constructor();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct constructorCall {}
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<constructorCall> for UnderlyingRustTuple<'_> {
                fn from(value: constructorCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for constructorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolConstructor for constructorCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `UPGRADE_INTERFACE_VERSION()` and selector `0xad3cb1cc`.
```solidity
function UPGRADE_INTERFACE_VERSION() external view returns (string memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct UPGRADE_INTERFACE_VERSIONCall {}
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`UPGRADE_INTERFACE_VERSION()`](UPGRADE_INTERFACE_VERSIONCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct UPGRADE_INTERFACE_VERSIONReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UPGRADE_INTERFACE_VERSIONCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: UPGRADE_INTERFACE_VERSIONCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for UPGRADE_INTERFACE_VERSIONCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UPGRADE_INTERFACE_VERSIONReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: UPGRADE_INTERFACE_VERSIONReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for UPGRADE_INTERFACE_VERSIONReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for UPGRADE_INTERFACE_VERSIONCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = UPGRADE_INTERFACE_VERSIONReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "UPGRADE_INTERFACE_VERSION()";
            const SELECTOR: [u8; 4] = [173u8, 60u8, 177u8, 204u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `acceptOwnership()` and selector `0x79ba5097`.
```solidity
function acceptOwnership() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct acceptOwnershipCall {}
    ///Container type for the return parameters of the [`acceptOwnership()`](acceptOwnershipCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct acceptOwnershipReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<acceptOwnershipCall> for UnderlyingRustTuple<'_> {
                fn from(value: acceptOwnershipCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for acceptOwnershipCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<acceptOwnershipReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: acceptOwnershipReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for acceptOwnershipReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for acceptOwnershipCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = acceptOwnershipReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "acceptOwnership()";
            const SELECTOR: [u8; 4] = [121u8, 186u8, 80u8, 151u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `addKmsContext(bytes8,bool,uint256,(string,address,address,uint256,bytes,string,string,bytes)[],(uint256,uint256,uint256),(uint256,uint256))` and selector `0xe7b1ec39`.
```solidity
function addKmsContext(bytes8 softwareVersion, bool reshareKeys, uint256 mpcThreshold, KmsNode[] memory kmsNodes, KmsBlockPeriods memory blockPeriods, DecryptionThresholds memory decryptionThresholds) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct addKmsContextCall {
        #[allow(missing_docs)]
        pub softwareVersion: alloy::sol_types::private::FixedBytes<8>,
        #[allow(missing_docs)]
        pub reshareKeys: bool,
        #[allow(missing_docs)]
        pub mpcThreshold: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub kmsNodes: alloy::sol_types::private::Vec<
            <KmsNode as alloy::sol_types::SolType>::RustType,
        >,
        #[allow(missing_docs)]
        pub blockPeriods: <KmsBlockPeriods as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub decryptionThresholds: <DecryptionThresholds as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`addKmsContext(bytes8,bool,uint256,(string,address,address,uint256,bytes,string,string,bytes)[],(uint256,uint256,uint256),(uint256,uint256))`](addKmsContextCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct addKmsContextReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<8>,
                alloy::sol_types::sol_data::Bool,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Array<KmsNode>,
                KmsBlockPeriods,
                DecryptionThresholds,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<8>,
                bool,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Vec<
                    <KmsNode as alloy::sol_types::SolType>::RustType,
                >,
                <KmsBlockPeriods as alloy::sol_types::SolType>::RustType,
                <DecryptionThresholds as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<addKmsContextCall> for UnderlyingRustTuple<'_> {
                fn from(value: addKmsContextCall) -> Self {
                    (
                        value.softwareVersion,
                        value.reshareKeys,
                        value.mpcThreshold,
                        value.kmsNodes,
                        value.blockPeriods,
                        value.decryptionThresholds,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for addKmsContextCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        softwareVersion: tuple.0,
                        reshareKeys: tuple.1,
                        mpcThreshold: tuple.2,
                        kmsNodes: tuple.3,
                        blockPeriods: tuple.4,
                        decryptionThresholds: tuple.5,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<addKmsContextReturn> for UnderlyingRustTuple<'_> {
                fn from(value: addKmsContextReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for addKmsContextReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for addKmsContextCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<8>,
                alloy::sol_types::sol_data::Bool,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Array<KmsNode>,
                KmsBlockPeriods,
                DecryptionThresholds,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = addKmsContextReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "addKmsContext(bytes8,bool,uint256,(string,address,address,uint256,bytes,string,string,bytes)[],(uint256,uint256,uint256),(uint256,uint256))";
            const SELECTOR: [u8; 4] = [231u8, 177u8, 236u8, 57u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.softwareVersion),
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.reshareKeys,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.mpcThreshold),
                    <alloy::sol_types::sol_data::Array<
                        KmsNode,
                    > as alloy_sol_types::SolType>::tokenize(&self.kmsNodes),
                    <KmsBlockPeriods as alloy_sol_types::SolType>::tokenize(
                        &self.blockPeriods,
                    ),
                    <DecryptionThresholds as alloy_sol_types::SolType>::tokenize(
                        &self.decryptionThresholds,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `checkIsKmsSignerFromContext(uint256,address)` and selector `0xdfe36aee`.
```solidity
function checkIsKmsSignerFromContext(uint256 contextId, address signerAddress) external view;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkIsKmsSignerFromContextCall {
        #[allow(missing_docs)]
        pub contextId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub signerAddress: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`checkIsKmsSignerFromContext(uint256,address)`](checkIsKmsSignerFromContextCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkIsKmsSignerFromContextReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkIsKmsSignerFromContextCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkIsKmsSignerFromContextCall) -> Self {
                    (value.contextId, value.signerAddress)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkIsKmsSignerFromContextCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        contextId: tuple.0,
                        signerAddress: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkIsKmsSignerFromContextReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkIsKmsSignerFromContextReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkIsKmsSignerFromContextReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for checkIsKmsSignerFromContextCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = checkIsKmsSignerFromContextReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "checkIsKmsSignerFromContext(uint256,address)";
            const SELECTOR: [u8; 4] = [223u8, 227u8, 106u8, 238u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.contextId),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.signerAddress,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `checkIsKmsTxSenderFromContext(uint256,address)` and selector `0xdefba06a`.
```solidity
function checkIsKmsTxSenderFromContext(uint256 contextId, address txSenderAddress) external view;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkIsKmsTxSenderFromContextCall {
        #[allow(missing_docs)]
        pub contextId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub txSenderAddress: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`checkIsKmsTxSenderFromContext(uint256,address)`](checkIsKmsTxSenderFromContextCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkIsKmsTxSenderFromContextReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkIsKmsTxSenderFromContextCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkIsKmsTxSenderFromContextCall) -> Self {
                    (value.contextId, value.txSenderAddress)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkIsKmsTxSenderFromContextCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        contextId: tuple.0,
                        txSenderAddress: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkIsKmsTxSenderFromContextReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkIsKmsTxSenderFromContextReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkIsKmsTxSenderFromContextReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for checkIsKmsTxSenderFromContextCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = checkIsKmsTxSenderFromContextReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "checkIsKmsTxSenderFromContext(uint256,address)";
            const SELECTOR: [u8; 4] = [222u8, 251u8, 160u8, 106u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.contextId),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.txSenderAddress,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `compromiseKmsContext(uint256)` and selector `0x9ee77af3`.
```solidity
function compromiseKmsContext(uint256 contextId) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct compromiseKmsContextCall {
        #[allow(missing_docs)]
        pub contextId: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`compromiseKmsContext(uint256)`](compromiseKmsContextCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct compromiseKmsContextReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<compromiseKmsContextCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: compromiseKmsContextCall) -> Self {
                    (value.contextId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for compromiseKmsContextCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { contextId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<compromiseKmsContextReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: compromiseKmsContextReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for compromiseKmsContextReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for compromiseKmsContextCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = compromiseKmsContextReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "compromiseKmsContext(uint256)";
            const SELECTOR: [u8; 4] = [158u8, 231u8, 122u8, 243u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.contextId),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `destroyKmsContext(uint256)` and selector `0xc0ae64f7`.
```solidity
function destroyKmsContext(uint256 contextId) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct destroyKmsContextCall {
        #[allow(missing_docs)]
        pub contextId: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`destroyKmsContext(uint256)`](destroyKmsContextCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct destroyKmsContextReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<destroyKmsContextCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: destroyKmsContextCall) -> Self {
                    (value.contextId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for destroyKmsContextCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { contextId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<destroyKmsContextReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: destroyKmsContextReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for destroyKmsContextReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for destroyKmsContextCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = destroyKmsContextReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "destroyKmsContext(uint256)";
            const SELECTOR: [u8; 4] = [192u8, 174u8, 100u8, 247u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.contextId),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `eip712Domain()` and selector `0x84b0196e`.
```solidity
function eip712Domain() external view returns (bytes1 fields, string memory name, string memory version, uint256 chainId, address verifyingContract, bytes32 salt, uint256[] memory extensions);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct eip712DomainCall {}
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`eip712Domain()`](eip712DomainCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct eip712DomainReturn {
        #[allow(missing_docs)]
        pub fields: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub name: alloy::sol_types::private::String,
        #[allow(missing_docs)]
        pub version: alloy::sol_types::private::String,
        #[allow(missing_docs)]
        pub chainId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub verifyingContract: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub salt: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub extensions: alloy::sol_types::private::Vec<
            alloy::sol_types::private::primitives::aliases::U256,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<eip712DomainCall> for UnderlyingRustTuple<'_> {
                fn from(value: eip712DomainCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for eip712DomainCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<1>,
                alloy::sol_types::private::String,
                alloy::sol_types::private::String,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::primitives::aliases::U256,
                >,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<eip712DomainReturn> for UnderlyingRustTuple<'_> {
                fn from(value: eip712DomainReturn) -> Self {
                    (
                        value.fields,
                        value.name,
                        value.version,
                        value.chainId,
                        value.verifyingContract,
                        value.salt,
                        value.extensions,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for eip712DomainReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        fields: tuple.0,
                        name: tuple.1,
                        version: tuple.2,
                        chainId: tuple.3,
                        verifyingContract: tuple.4,
                        salt: tuple.5,
                        extensions: tuple.6,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for eip712DomainCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = eip712DomainReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "eip712Domain()";
            const SELECTOR: [u8; 4] = [132u8, 176u8, 25u8, 110u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getActiveKmsContext()` and selector `0x0dd486c0`.
```solidity
function getActiveKmsContext() external view returns (KmsContext memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getActiveKmsContextCall {}
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getActiveKmsContext()`](getActiveKmsContextCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getActiveKmsContextReturn {
        #[allow(missing_docs)]
        pub _0: <KmsContext as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getActiveKmsContextCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getActiveKmsContextCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getActiveKmsContextCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (KmsContext,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <KmsContext as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getActiveKmsContextReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getActiveKmsContextReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getActiveKmsContextReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getActiveKmsContextCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getActiveKmsContextReturn;
            type ReturnTuple<'a> = (KmsContext,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getActiveKmsContext()";
            const SELECTOR: [u8; 4] = [13u8, 212u8, 134u8, 192u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getActiveKmsContextId()` and selector `0x43e37e8a`.
```solidity
function getActiveKmsContextId() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getActiveKmsContextIdCall {}
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getActiveKmsContextId()`](getActiveKmsContextIdCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getActiveKmsContextIdReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getActiveKmsContextIdCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getActiveKmsContextIdCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getActiveKmsContextIdCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getActiveKmsContextIdReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getActiveKmsContextIdReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getActiveKmsContextIdReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getActiveKmsContextIdCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getActiveKmsContextIdReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getActiveKmsContextId()";
            const SELECTOR: [u8; 4] = [67u8, 227u8, 126u8, 138u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getKmsContextGenerationBlockPeriod()` and selector `0x4965e455`.
```solidity
function getKmsContextGenerationBlockPeriod() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getKmsContextGenerationBlockPeriodCall {}
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getKmsContextGenerationBlockPeriod()`](getKmsContextGenerationBlockPeriodCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getKmsContextGenerationBlockPeriodReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getKmsContextGenerationBlockPeriodCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getKmsContextGenerationBlockPeriodCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getKmsContextGenerationBlockPeriodCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getKmsContextGenerationBlockPeriodReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getKmsContextGenerationBlockPeriodReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getKmsContextGenerationBlockPeriodReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getKmsContextGenerationBlockPeriodCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getKmsContextGenerationBlockPeriodReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getKmsContextGenerationBlockPeriod()";
            const SELECTOR: [u8; 4] = [73u8, 101u8, 228u8, 85u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getKmsContextStatus(uint256)` and selector `0x4d694260`.
```solidity
function getKmsContextStatus(uint256 contextId) external view returns (ContextStatus);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getKmsContextStatusCall {
        #[allow(missing_docs)]
        pub contextId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getKmsContextStatus(uint256)`](getKmsContextStatusCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getKmsContextStatusReturn {
        #[allow(missing_docs)]
        pub _0: <ContextStatus as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getKmsContextStatusCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getKmsContextStatusCall) -> Self {
                    (value.contextId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getKmsContextStatusCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { contextId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (ContextStatus,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <ContextStatus as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getKmsContextStatusReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getKmsContextStatusReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getKmsContextStatusReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getKmsContextStatusCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getKmsContextStatusReturn;
            type ReturnTuple<'a> = (ContextStatus,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getKmsContextStatus(uint256)";
            const SELECTOR: [u8; 4] = [77u8, 105u8, 66u8, 96u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.contextId),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getKmsContextSuspensionBlockPeriod()` and selector `0xd8e3ae01`.
```solidity
function getKmsContextSuspensionBlockPeriod() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getKmsContextSuspensionBlockPeriodCall {}
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getKmsContextSuspensionBlockPeriod()`](getKmsContextSuspensionBlockPeriodCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getKmsContextSuspensionBlockPeriodReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getKmsContextSuspensionBlockPeriodCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getKmsContextSuspensionBlockPeriodCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getKmsContextSuspensionBlockPeriodCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getKmsContextSuspensionBlockPeriodReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getKmsContextSuspensionBlockPeriodReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getKmsContextSuspensionBlockPeriodReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getKmsContextSuspensionBlockPeriodCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getKmsContextSuspensionBlockPeriodReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getKmsContextSuspensionBlockPeriod()";
            const SELECTOR: [u8; 4] = [216u8, 227u8, 174u8, 1u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getKmsNode(address)` and selector `0xe3b2a874`.
```solidity
function getKmsNode(address kmsTxSenderAddress) external view returns (KmsNode memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getKmsNodeCall {
        #[allow(missing_docs)]
        pub kmsTxSenderAddress: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getKmsNode(address)`](getKmsNodeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getKmsNodeReturn {
        #[allow(missing_docs)]
        pub _0: <KmsNode as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getKmsNodeCall> for UnderlyingRustTuple<'_> {
                fn from(value: getKmsNodeCall) -> Self {
                    (value.kmsTxSenderAddress,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getKmsNodeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        kmsTxSenderAddress: tuple.0,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (KmsNode,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <KmsNode as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getKmsNodeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getKmsNodeReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getKmsNodeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getKmsNodeCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getKmsNodeReturn;
            type ReturnTuple<'a> = (KmsNode,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getKmsNode(address)";
            const SELECTOR: [u8; 4] = [227u8, 178u8, 168u8, 116u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.kmsTxSenderAddress,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getKmsSigners()` and selector `0x7eaac8f2`.
```solidity
function getKmsSigners() external view returns (address[] memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getKmsSignersCall {}
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getKmsSigners()`](getKmsSignersCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getKmsSignersReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getKmsSignersCall> for UnderlyingRustTuple<'_> {
                fn from(value: getKmsSignersCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getKmsSignersCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getKmsSignersReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getKmsSignersReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getKmsSignersReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getKmsSignersCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getKmsSignersReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getKmsSigners()";
            const SELECTOR: [u8; 4] = [126u8, 170u8, 200u8, 242u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getKmsTxSenders()` and selector `0x7420f3d4`.
```solidity
function getKmsTxSenders() external view returns (address[] memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getKmsTxSendersCall {}
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getKmsTxSenders()`](getKmsTxSendersCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getKmsTxSendersReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getKmsTxSendersCall> for UnderlyingRustTuple<'_> {
                fn from(value: getKmsTxSendersCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getKmsTxSendersCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getKmsTxSendersReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getKmsTxSendersReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getKmsTxSendersReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getKmsTxSendersCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getKmsTxSendersReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getKmsTxSenders()";
            const SELECTOR: [u8; 4] = [116u8, 32u8, 243u8, 212u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getPublicDecryptionThresholdFromContext(uint256)` and selector `0xb8715d4d`.
```solidity
function getPublicDecryptionThresholdFromContext(uint256 contextId) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getPublicDecryptionThresholdFromContextCall {
        #[allow(missing_docs)]
        pub contextId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getPublicDecryptionThresholdFromContext(uint256)`](getPublicDecryptionThresholdFromContextCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getPublicDecryptionThresholdFromContextReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getPublicDecryptionThresholdFromContextCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getPublicDecryptionThresholdFromContextCall) -> Self {
                    (value.contextId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getPublicDecryptionThresholdFromContextCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { contextId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getPublicDecryptionThresholdFromContextReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getPublicDecryptionThresholdFromContextReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getPublicDecryptionThresholdFromContextReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getPublicDecryptionThresholdFromContextCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getPublicDecryptionThresholdFromContextReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getPublicDecryptionThresholdFromContext(uint256)";
            const SELECTOR: [u8; 4] = [184u8, 113u8, 93u8, 77u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.contextId),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getSuspendedKmsContextId()` and selector `0x0a50e318`.
```solidity
function getSuspendedKmsContextId() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getSuspendedKmsContextIdCall {}
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getSuspendedKmsContextId()`](getSuspendedKmsContextIdCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getSuspendedKmsContextIdReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getSuspendedKmsContextIdCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getSuspendedKmsContextIdCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getSuspendedKmsContextIdCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getSuspendedKmsContextIdReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getSuspendedKmsContextIdReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getSuspendedKmsContextIdReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getSuspendedKmsContextIdCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getSuspendedKmsContextIdReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getSuspendedKmsContextId()";
            const SELECTOR: [u8; 4] = [10u8, 80u8, 227u8, 24u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getUserDecryptionThresholdFromContext(uint256)` and selector `0x64b00cc5`.
```solidity
function getUserDecryptionThresholdFromContext(uint256 contextId) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getUserDecryptionThresholdFromContextCall {
        #[allow(missing_docs)]
        pub contextId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getUserDecryptionThresholdFromContext(uint256)`](getUserDecryptionThresholdFromContextCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getUserDecryptionThresholdFromContextReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getUserDecryptionThresholdFromContextCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getUserDecryptionThresholdFromContextCall) -> Self {
                    (value.contextId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getUserDecryptionThresholdFromContextCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { contextId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getUserDecryptionThresholdFromContextReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getUserDecryptionThresholdFromContextReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getUserDecryptionThresholdFromContextReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getUserDecryptionThresholdFromContextCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getUserDecryptionThresholdFromContextReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getUserDecryptionThresholdFromContext(uint256)";
            const SELECTOR: [u8; 4] = [100u8, 176u8, 12u8, 197u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.contextId),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getVersion()` and selector `0x0d8e6e2c`.
```solidity
function getVersion() external pure returns (string memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getVersionCall {}
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getVersion()`](getVersionCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getVersionReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getVersionCall> for UnderlyingRustTuple<'_> {
                fn from(value: getVersionCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getVersionCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getVersionReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getVersionReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getVersionReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getVersionCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getVersionReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getVersion()";
            const SELECTOR: [u8; 4] = [13u8, 142u8, 110u8, 44u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `initializeFromEmptyProxy(bytes8,uint256,(string,address,address,uint256,bytes,string,string,bytes)[],(uint256,uint256))` and selector `0x83b420c4`.
```solidity
function initializeFromEmptyProxy(bytes8 initialSoftwareVersion, uint256 initialMpcThreshold, KmsNode[] memory initialKmsNodes, DecryptionThresholds memory initialDecryptionThresholds) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct initializeFromEmptyProxyCall {
        #[allow(missing_docs)]
        pub initialSoftwareVersion: alloy::sol_types::private::FixedBytes<8>,
        #[allow(missing_docs)]
        pub initialMpcThreshold: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub initialKmsNodes: alloy::sol_types::private::Vec<
            <KmsNode as alloy::sol_types::SolType>::RustType,
        >,
        #[allow(missing_docs)]
        pub initialDecryptionThresholds: <DecryptionThresholds as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`initializeFromEmptyProxy(bytes8,uint256,(string,address,address,uint256,bytes,string,string,bytes)[],(uint256,uint256))`](initializeFromEmptyProxyCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct initializeFromEmptyProxyReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<8>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Array<KmsNode>,
                DecryptionThresholds,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<8>,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Vec<
                    <KmsNode as alloy::sol_types::SolType>::RustType,
                >,
                <DecryptionThresholds as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<initializeFromEmptyProxyCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: initializeFromEmptyProxyCall) -> Self {
                    (
                        value.initialSoftwareVersion,
                        value.initialMpcThreshold,
                        value.initialKmsNodes,
                        value.initialDecryptionThresholds,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for initializeFromEmptyProxyCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        initialSoftwareVersion: tuple.0,
                        initialMpcThreshold: tuple.1,
                        initialKmsNodes: tuple.2,
                        initialDecryptionThresholds: tuple.3,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<initializeFromEmptyProxyReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: initializeFromEmptyProxyReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for initializeFromEmptyProxyReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for initializeFromEmptyProxyCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<8>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Array<KmsNode>,
                DecryptionThresholds,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = initializeFromEmptyProxyReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "initializeFromEmptyProxy(bytes8,uint256,(string,address,address,uint256,bytes,string,string,bytes)[],(uint256,uint256))";
            const SELECTOR: [u8; 4] = [131u8, 180u8, 32u8, 196u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.initialSoftwareVersion,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.initialMpcThreshold),
                    <alloy::sol_types::sol_data::Array<
                        KmsNode,
                    > as alloy_sol_types::SolType>::tokenize(&self.initialKmsNodes),
                    <DecryptionThresholds as alloy_sol_types::SolType>::tokenize(
                        &self.initialDecryptionThresholds,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `moveSuspendedKmsContextToActive()` and selector `0xf27cb957`.
```solidity
function moveSuspendedKmsContextToActive() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct moveSuspendedKmsContextToActiveCall {}
    ///Container type for the return parameters of the [`moveSuspendedKmsContextToActive()`](moveSuspendedKmsContextToActiveCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct moveSuspendedKmsContextToActiveReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<moveSuspendedKmsContextToActiveCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: moveSuspendedKmsContextToActiveCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for moveSuspendedKmsContextToActiveCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<moveSuspendedKmsContextToActiveReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: moveSuspendedKmsContextToActiveReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for moveSuspendedKmsContextToActiveReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for moveSuspendedKmsContextToActiveCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = moveSuspendedKmsContextToActiveReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "moveSuspendedKmsContextToActive()";
            const SELECTOR: [u8; 4] = [242u8, 124u8, 185u8, 87u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `owner()` and selector `0x8da5cb5b`.
```solidity
function owner() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ownerCall {}
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`owner()`](ownerCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ownerReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ownerCall> for UnderlyingRustTuple<'_> {
                fn from(value: ownerCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for ownerCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ownerReturn> for UnderlyingRustTuple<'_> {
                fn from(value: ownerReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for ownerReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for ownerCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = ownerReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "owner()";
            const SELECTOR: [u8; 4] = [141u8, 165u8, 203u8, 91u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `pause()` and selector `0x8456cb59`.
```solidity
function pause() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pauseCall {}
    ///Container type for the return parameters of the [`pause()`](pauseCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pauseReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pauseCall> for UnderlyingRustTuple<'_> {
                fn from(value: pauseCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pauseCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pauseReturn> for UnderlyingRustTuple<'_> {
                fn from(value: pauseReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pauseReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for pauseCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = pauseReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "pause()";
            const SELECTOR: [u8; 4] = [132u8, 86u8, 203u8, 89u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `paused()` and selector `0x5c975abb`.
```solidity
function paused() external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pausedCall {}
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`paused()`](pausedCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pausedReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pausedCall> for UnderlyingRustTuple<'_> {
                fn from(value: pausedCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pausedCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pausedReturn> for UnderlyingRustTuple<'_> {
                fn from(value: pausedReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pausedReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for pausedCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = pausedReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "paused()";
            const SELECTOR: [u8; 4] = [92u8, 151u8, 90u8, 187u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `pendingOwner()` and selector `0xe30c3978`.
```solidity
function pendingOwner() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pendingOwnerCall {}
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`pendingOwner()`](pendingOwnerCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pendingOwnerReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pendingOwnerCall> for UnderlyingRustTuple<'_> {
                fn from(value: pendingOwnerCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pendingOwnerCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pendingOwnerReturn> for UnderlyingRustTuple<'_> {
                fn from(value: pendingOwnerReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pendingOwnerReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for pendingOwnerCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = pendingOwnerReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "pendingOwner()";
            const SELECTOR: [u8; 4] = [227u8, 12u8, 57u8, 120u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `proxiableUUID()` and selector `0x52d1902d`.
```solidity
function proxiableUUID() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct proxiableUUIDCall {}
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`proxiableUUID()`](proxiableUUIDCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct proxiableUUIDReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<proxiableUUIDCall> for UnderlyingRustTuple<'_> {
                fn from(value: proxiableUUIDCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for proxiableUUIDCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<proxiableUUIDReturn> for UnderlyingRustTuple<'_> {
                fn from(value: proxiableUUIDReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for proxiableUUIDReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for proxiableUUIDCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = proxiableUUIDReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "proxiableUUID()";
            const SELECTOR: [u8; 4] = [82u8, 209u8, 144u8, 45u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `refreshKmsContextStatuses()` and selector `0x8cb96751`.
```solidity
function refreshKmsContextStatuses() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct refreshKmsContextStatusesCall {}
    ///Container type for the return parameters of the [`refreshKmsContextStatuses()`](refreshKmsContextStatusesCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct refreshKmsContextStatusesReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<refreshKmsContextStatusesCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: refreshKmsContextStatusesCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for refreshKmsContextStatusesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<refreshKmsContextStatusesReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: refreshKmsContextStatusesReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for refreshKmsContextStatusesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for refreshKmsContextStatusesCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = refreshKmsContextStatusesReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "refreshKmsContextStatuses()";
            const SELECTOR: [u8; 4] = [140u8, 185u8, 103u8, 81u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `renounceOwnership()` and selector `0x715018a6`.
```solidity
function renounceOwnership() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct renounceOwnershipCall {}
    ///Container type for the return parameters of the [`renounceOwnership()`](renounceOwnershipCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct renounceOwnershipReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<renounceOwnershipCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: renounceOwnershipCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for renounceOwnershipCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<renounceOwnershipReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: renounceOwnershipReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for renounceOwnershipReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for renounceOwnershipCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = renounceOwnershipReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "renounceOwnership()";
            const SELECTOR: [u8; 4] = [113u8, 80u8, 24u8, 166u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `transferOwnership(address)` and selector `0xf2fde38b`.
```solidity
function transferOwnership(address newOwner) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct transferOwnershipCall {
        #[allow(missing_docs)]
        pub newOwner: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`transferOwnership(address)`](transferOwnershipCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct transferOwnershipReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferOwnershipCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: transferOwnershipCall) -> Self {
                    (value.newOwner,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for transferOwnershipCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { newOwner: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferOwnershipReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: transferOwnershipReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for transferOwnershipReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for transferOwnershipCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = transferOwnershipReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "transferOwnership(address)";
            const SELECTOR: [u8; 4] = [242u8, 253u8, 227u8, 139u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.newOwner,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `unpause()` and selector `0x3f4ba83a`.
```solidity
function unpause() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct unpauseCall {}
    ///Container type for the return parameters of the [`unpause()`](unpauseCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct unpauseReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<unpauseCall> for UnderlyingRustTuple<'_> {
                fn from(value: unpauseCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for unpauseCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<unpauseReturn> for UnderlyingRustTuple<'_> {
                fn from(value: unpauseReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for unpauseReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for unpauseCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = unpauseReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "unpause()";
            const SELECTOR: [u8; 4] = [63u8, 75u8, 168u8, 58u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `updatePublicDecryptionThreshold(uint256)` and selector `0x2e2d3a82`.
```solidity
function updatePublicDecryptionThreshold(uint256 newPublicDecryptionThreshold) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct updatePublicDecryptionThresholdCall {
        #[allow(missing_docs)]
        pub newPublicDecryptionThreshold: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`updatePublicDecryptionThreshold(uint256)`](updatePublicDecryptionThresholdCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct updatePublicDecryptionThresholdReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<updatePublicDecryptionThresholdCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: updatePublicDecryptionThresholdCall) -> Self {
                    (value.newPublicDecryptionThreshold,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for updatePublicDecryptionThresholdCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        newPublicDecryptionThreshold: tuple.0,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<updatePublicDecryptionThresholdReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: updatePublicDecryptionThresholdReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for updatePublicDecryptionThresholdReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for updatePublicDecryptionThresholdCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = updatePublicDecryptionThresholdReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "updatePublicDecryptionThreshold(uint256)";
            const SELECTOR: [u8; 4] = [46u8, 45u8, 58u8, 130u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.newPublicDecryptionThreshold,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `updateUserDecryptionThreshold(uint256)` and selector `0xeb843cf6`.
```solidity
function updateUserDecryptionThreshold(uint256 newUserDecryptionThreshold) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct updateUserDecryptionThresholdCall {
        #[allow(missing_docs)]
        pub newUserDecryptionThreshold: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`updateUserDecryptionThreshold(uint256)`](updateUserDecryptionThresholdCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct updateUserDecryptionThresholdReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<updateUserDecryptionThresholdCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: updateUserDecryptionThresholdCall) -> Self {
                    (value.newUserDecryptionThreshold,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for updateUserDecryptionThresholdCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        newUserDecryptionThreshold: tuple.0,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<updateUserDecryptionThresholdReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: updateUserDecryptionThresholdReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for updateUserDecryptionThresholdReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for updateUserDecryptionThresholdCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = updateUserDecryptionThresholdReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "updateUserDecryptionThreshold(uint256)";
            const SELECTOR: [u8; 4] = [235u8, 132u8, 60u8, 246u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.newUserDecryptionThreshold,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `upgradeToAndCall(address,bytes)` and selector `0x4f1ef286`.
```solidity
function upgradeToAndCall(address newImplementation, bytes memory data) external payable;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct upgradeToAndCallCall {
        #[allow(missing_docs)]
        pub newImplementation: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub data: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`upgradeToAndCall(address,bytes)`](upgradeToAndCallCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct upgradeToAndCallReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<upgradeToAndCallCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: upgradeToAndCallCall) -> Self {
                    (value.newImplementation, value.data)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for upgradeToAndCallCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        newImplementation: tuple.0,
                        data: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<upgradeToAndCallReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: upgradeToAndCallReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for upgradeToAndCallReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for upgradeToAndCallCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = upgradeToAndCallReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "upgradeToAndCall(address,bytes)";
            const SELECTOR: [u8; 4] = [79u8, 30u8, 242u8, 134u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.newImplementation,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.data,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `validateKeyResharing(uint256,bytes)` and selector `0x1079ebeb`.
```solidity
function validateKeyResharing(uint256 contextId, bytes memory signature) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct validateKeyResharingCall {
        #[allow(missing_docs)]
        pub contextId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub signature: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`validateKeyResharing(uint256,bytes)`](validateKeyResharingCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct validateKeyResharingReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<validateKeyResharingCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: validateKeyResharingCall) -> Self {
                    (value.contextId, value.signature)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for validateKeyResharingCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        contextId: tuple.0,
                        signature: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<validateKeyResharingReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: validateKeyResharingReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for validateKeyResharingReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for validateKeyResharingCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = validateKeyResharingReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "validateKeyResharing(uint256,bytes)";
            const SELECTOR: [u8; 4] = [16u8, 121u8, 235u8, 235u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.contextId),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.signature,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    ///Container for all the [`KmsContexts`](self) function calls.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive()]
    pub enum KmsContextsCalls {
        #[allow(missing_docs)]
        UPGRADE_INTERFACE_VERSION(UPGRADE_INTERFACE_VERSIONCall),
        #[allow(missing_docs)]
        acceptOwnership(acceptOwnershipCall),
        #[allow(missing_docs)]
        addKmsContext(addKmsContextCall),
        #[allow(missing_docs)]
        checkIsKmsSignerFromContext(checkIsKmsSignerFromContextCall),
        #[allow(missing_docs)]
        checkIsKmsTxSenderFromContext(checkIsKmsTxSenderFromContextCall),
        #[allow(missing_docs)]
        compromiseKmsContext(compromiseKmsContextCall),
        #[allow(missing_docs)]
        destroyKmsContext(destroyKmsContextCall),
        #[allow(missing_docs)]
        eip712Domain(eip712DomainCall),
        #[allow(missing_docs)]
        getActiveKmsContext(getActiveKmsContextCall),
        #[allow(missing_docs)]
        getActiveKmsContextId(getActiveKmsContextIdCall),
        #[allow(missing_docs)]
        getKmsContextGenerationBlockPeriod(getKmsContextGenerationBlockPeriodCall),
        #[allow(missing_docs)]
        getKmsContextStatus(getKmsContextStatusCall),
        #[allow(missing_docs)]
        getKmsContextSuspensionBlockPeriod(getKmsContextSuspensionBlockPeriodCall),
        #[allow(missing_docs)]
        getKmsNode(getKmsNodeCall),
        #[allow(missing_docs)]
        getKmsSigners(getKmsSignersCall),
        #[allow(missing_docs)]
        getKmsTxSenders(getKmsTxSendersCall),
        #[allow(missing_docs)]
        getPublicDecryptionThresholdFromContext(
            getPublicDecryptionThresholdFromContextCall,
        ),
        #[allow(missing_docs)]
        getSuspendedKmsContextId(getSuspendedKmsContextIdCall),
        #[allow(missing_docs)]
        getUserDecryptionThresholdFromContext(getUserDecryptionThresholdFromContextCall),
        #[allow(missing_docs)]
        getVersion(getVersionCall),
        #[allow(missing_docs)]
        initializeFromEmptyProxy(initializeFromEmptyProxyCall),
        #[allow(missing_docs)]
        moveSuspendedKmsContextToActive(moveSuspendedKmsContextToActiveCall),
        #[allow(missing_docs)]
        owner(ownerCall),
        #[allow(missing_docs)]
        pause(pauseCall),
        #[allow(missing_docs)]
        paused(pausedCall),
        #[allow(missing_docs)]
        pendingOwner(pendingOwnerCall),
        #[allow(missing_docs)]
        proxiableUUID(proxiableUUIDCall),
        #[allow(missing_docs)]
        refreshKmsContextStatuses(refreshKmsContextStatusesCall),
        #[allow(missing_docs)]
        renounceOwnership(renounceOwnershipCall),
        #[allow(missing_docs)]
        transferOwnership(transferOwnershipCall),
        #[allow(missing_docs)]
        unpause(unpauseCall),
        #[allow(missing_docs)]
        updatePublicDecryptionThreshold(updatePublicDecryptionThresholdCall),
        #[allow(missing_docs)]
        updateUserDecryptionThreshold(updateUserDecryptionThresholdCall),
        #[allow(missing_docs)]
        upgradeToAndCall(upgradeToAndCallCall),
        #[allow(missing_docs)]
        validateKeyResharing(validateKeyResharingCall),
    }
    #[automatically_derived]
    impl KmsContextsCalls {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [10u8, 80u8, 227u8, 24u8],
            [13u8, 142u8, 110u8, 44u8],
            [13u8, 212u8, 134u8, 192u8],
            [16u8, 121u8, 235u8, 235u8],
            [46u8, 45u8, 58u8, 130u8],
            [63u8, 75u8, 168u8, 58u8],
            [67u8, 227u8, 126u8, 138u8],
            [73u8, 101u8, 228u8, 85u8],
            [77u8, 105u8, 66u8, 96u8],
            [79u8, 30u8, 242u8, 134u8],
            [82u8, 209u8, 144u8, 45u8],
            [92u8, 151u8, 90u8, 187u8],
            [100u8, 176u8, 12u8, 197u8],
            [113u8, 80u8, 24u8, 166u8],
            [116u8, 32u8, 243u8, 212u8],
            [121u8, 186u8, 80u8, 151u8],
            [126u8, 170u8, 200u8, 242u8],
            [131u8, 180u8, 32u8, 196u8],
            [132u8, 86u8, 203u8, 89u8],
            [132u8, 176u8, 25u8, 110u8],
            [140u8, 185u8, 103u8, 81u8],
            [141u8, 165u8, 203u8, 91u8],
            [158u8, 231u8, 122u8, 243u8],
            [173u8, 60u8, 177u8, 204u8],
            [184u8, 113u8, 93u8, 77u8],
            [192u8, 174u8, 100u8, 247u8],
            [216u8, 227u8, 174u8, 1u8],
            [222u8, 251u8, 160u8, 106u8],
            [223u8, 227u8, 106u8, 238u8],
            [227u8, 12u8, 57u8, 120u8],
            [227u8, 178u8, 168u8, 116u8],
            [231u8, 177u8, 236u8, 57u8],
            [235u8, 132u8, 60u8, 246u8],
            [242u8, 124u8, 185u8, 87u8],
            [242u8, 253u8, 227u8, 139u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for KmsContextsCalls {
        const NAME: &'static str = "KmsContextsCalls";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 35usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::UPGRADE_INTERFACE_VERSION(_) => {
                    <UPGRADE_INTERFACE_VERSIONCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::acceptOwnership(_) => {
                    <acceptOwnershipCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::addKmsContext(_) => {
                    <addKmsContextCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::checkIsKmsSignerFromContext(_) => {
                    <checkIsKmsSignerFromContextCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::checkIsKmsTxSenderFromContext(_) => {
                    <checkIsKmsTxSenderFromContextCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::compromiseKmsContext(_) => {
                    <compromiseKmsContextCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::destroyKmsContext(_) => {
                    <destroyKmsContextCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::eip712Domain(_) => {
                    <eip712DomainCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getActiveKmsContext(_) => {
                    <getActiveKmsContextCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getActiveKmsContextId(_) => {
                    <getActiveKmsContextIdCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getKmsContextGenerationBlockPeriod(_) => {
                    <getKmsContextGenerationBlockPeriodCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getKmsContextStatus(_) => {
                    <getKmsContextStatusCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getKmsContextSuspensionBlockPeriod(_) => {
                    <getKmsContextSuspensionBlockPeriodCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getKmsNode(_) => {
                    <getKmsNodeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getKmsSigners(_) => {
                    <getKmsSignersCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getKmsTxSenders(_) => {
                    <getKmsTxSendersCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getPublicDecryptionThresholdFromContext(_) => {
                    <getPublicDecryptionThresholdFromContextCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getSuspendedKmsContextId(_) => {
                    <getSuspendedKmsContextIdCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getUserDecryptionThresholdFromContext(_) => {
                    <getUserDecryptionThresholdFromContextCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getVersion(_) => {
                    <getVersionCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::initializeFromEmptyProxy(_) => {
                    <initializeFromEmptyProxyCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::moveSuspendedKmsContextToActive(_) => {
                    <moveSuspendedKmsContextToActiveCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::owner(_) => <ownerCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::pause(_) => <pauseCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::paused(_) => <pausedCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::pendingOwner(_) => {
                    <pendingOwnerCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::proxiableUUID(_) => {
                    <proxiableUUIDCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::refreshKmsContextStatuses(_) => {
                    <refreshKmsContextStatusesCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::renounceOwnership(_) => {
                    <renounceOwnershipCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::transferOwnership(_) => {
                    <transferOwnershipCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::unpause(_) => <unpauseCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::updatePublicDecryptionThreshold(_) => {
                    <updatePublicDecryptionThresholdCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::updateUserDecryptionThreshold(_) => {
                    <updateUserDecryptionThresholdCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::upgradeToAndCall(_) => {
                    <upgradeToAndCallCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::validateKeyResharing(_) => {
                    <validateKeyResharingCall as alloy_sol_types::SolCall>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            ) -> alloy_sol_types::Result<KmsContextsCalls>] = &[
                {
                    fn getSuspendedKmsContextId(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <getSuspendedKmsContextIdCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::getSuspendedKmsContextId)
                    }
                    getSuspendedKmsContextId
                },
                {
                    fn getVersion(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <getVersionCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::getVersion)
                    }
                    getVersion
                },
                {
                    fn getActiveKmsContext(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <getActiveKmsContextCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::getActiveKmsContext)
                    }
                    getActiveKmsContext
                },
                {
                    fn validateKeyResharing(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <validateKeyResharingCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::validateKeyResharing)
                    }
                    validateKeyResharing
                },
                {
                    fn updatePublicDecryptionThreshold(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <updatePublicDecryptionThresholdCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::updatePublicDecryptionThreshold)
                    }
                    updatePublicDecryptionThreshold
                },
                {
                    fn unpause(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <unpauseCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::unpause)
                    }
                    unpause
                },
                {
                    fn getActiveKmsContextId(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <getActiveKmsContextIdCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::getActiveKmsContextId)
                    }
                    getActiveKmsContextId
                },
                {
                    fn getKmsContextGenerationBlockPeriod(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <getKmsContextGenerationBlockPeriodCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::getKmsContextGenerationBlockPeriod)
                    }
                    getKmsContextGenerationBlockPeriod
                },
                {
                    fn getKmsContextStatus(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <getKmsContextStatusCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::getKmsContextStatus)
                    }
                    getKmsContextStatus
                },
                {
                    fn upgradeToAndCall(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <upgradeToAndCallCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::upgradeToAndCall)
                    }
                    upgradeToAndCall
                },
                {
                    fn proxiableUUID(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <proxiableUUIDCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::proxiableUUID)
                    }
                    proxiableUUID
                },
                {
                    fn paused(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <pausedCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::paused)
                    }
                    paused
                },
                {
                    fn getUserDecryptionThresholdFromContext(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <getUserDecryptionThresholdFromContextCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::getUserDecryptionThresholdFromContext)
                    }
                    getUserDecryptionThresholdFromContext
                },
                {
                    fn renounceOwnership(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <renounceOwnershipCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::renounceOwnership)
                    }
                    renounceOwnership
                },
                {
                    fn getKmsTxSenders(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <getKmsTxSendersCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::getKmsTxSenders)
                    }
                    getKmsTxSenders
                },
                {
                    fn acceptOwnership(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <acceptOwnershipCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::acceptOwnership)
                    }
                    acceptOwnership
                },
                {
                    fn getKmsSigners(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <getKmsSignersCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::getKmsSigners)
                    }
                    getKmsSigners
                },
                {
                    fn initializeFromEmptyProxy(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <initializeFromEmptyProxyCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::initializeFromEmptyProxy)
                    }
                    initializeFromEmptyProxy
                },
                {
                    fn pause(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <pauseCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::pause)
                    }
                    pause
                },
                {
                    fn eip712Domain(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <eip712DomainCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::eip712Domain)
                    }
                    eip712Domain
                },
                {
                    fn refreshKmsContextStatuses(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <refreshKmsContextStatusesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::refreshKmsContextStatuses)
                    }
                    refreshKmsContextStatuses
                },
                {
                    fn owner(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <ownerCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::owner)
                    }
                    owner
                },
                {
                    fn compromiseKmsContext(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <compromiseKmsContextCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::compromiseKmsContext)
                    }
                    compromiseKmsContext
                },
                {
                    fn UPGRADE_INTERFACE_VERSION(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <UPGRADE_INTERFACE_VERSIONCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::UPGRADE_INTERFACE_VERSION)
                    }
                    UPGRADE_INTERFACE_VERSION
                },
                {
                    fn getPublicDecryptionThresholdFromContext(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <getPublicDecryptionThresholdFromContextCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(
                                KmsContextsCalls::getPublicDecryptionThresholdFromContext,
                            )
                    }
                    getPublicDecryptionThresholdFromContext
                },
                {
                    fn destroyKmsContext(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <destroyKmsContextCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::destroyKmsContext)
                    }
                    destroyKmsContext
                },
                {
                    fn getKmsContextSuspensionBlockPeriod(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <getKmsContextSuspensionBlockPeriodCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::getKmsContextSuspensionBlockPeriod)
                    }
                    getKmsContextSuspensionBlockPeriod
                },
                {
                    fn checkIsKmsTxSenderFromContext(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <checkIsKmsTxSenderFromContextCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::checkIsKmsTxSenderFromContext)
                    }
                    checkIsKmsTxSenderFromContext
                },
                {
                    fn checkIsKmsSignerFromContext(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <checkIsKmsSignerFromContextCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::checkIsKmsSignerFromContext)
                    }
                    checkIsKmsSignerFromContext
                },
                {
                    fn pendingOwner(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <pendingOwnerCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::pendingOwner)
                    }
                    pendingOwner
                },
                {
                    fn getKmsNode(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <getKmsNodeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::getKmsNode)
                    }
                    getKmsNode
                },
                {
                    fn addKmsContext(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <addKmsContextCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::addKmsContext)
                    }
                    addKmsContext
                },
                {
                    fn updateUserDecryptionThreshold(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <updateUserDecryptionThresholdCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::updateUserDecryptionThreshold)
                    }
                    updateUserDecryptionThreshold
                },
                {
                    fn moveSuspendedKmsContextToActive(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <moveSuspendedKmsContextToActiveCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::moveSuspendedKmsContextToActive)
                    }
                    moveSuspendedKmsContextToActive
                },
                {
                    fn transferOwnership(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <transferOwnershipCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::transferOwnership)
                    }
                    transferOwnership
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::UPGRADE_INTERFACE_VERSION(inner) => {
                    <UPGRADE_INTERFACE_VERSIONCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::acceptOwnership(inner) => {
                    <acceptOwnershipCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::addKmsContext(inner) => {
                    <addKmsContextCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::checkIsKmsSignerFromContext(inner) => {
                    <checkIsKmsSignerFromContextCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::checkIsKmsTxSenderFromContext(inner) => {
                    <checkIsKmsTxSenderFromContextCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::compromiseKmsContext(inner) => {
                    <compromiseKmsContextCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::destroyKmsContext(inner) => {
                    <destroyKmsContextCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::eip712Domain(inner) => {
                    <eip712DomainCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getActiveKmsContext(inner) => {
                    <getActiveKmsContextCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getActiveKmsContextId(inner) => {
                    <getActiveKmsContextIdCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getKmsContextGenerationBlockPeriod(inner) => {
                    <getKmsContextGenerationBlockPeriodCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getKmsContextStatus(inner) => {
                    <getKmsContextStatusCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getKmsContextSuspensionBlockPeriod(inner) => {
                    <getKmsContextSuspensionBlockPeriodCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getKmsNode(inner) => {
                    <getKmsNodeCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::getKmsSigners(inner) => {
                    <getKmsSignersCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getKmsTxSenders(inner) => {
                    <getKmsTxSendersCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getPublicDecryptionThresholdFromContext(inner) => {
                    <getPublicDecryptionThresholdFromContextCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getSuspendedKmsContextId(inner) => {
                    <getSuspendedKmsContextIdCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getUserDecryptionThresholdFromContext(inner) => {
                    <getUserDecryptionThresholdFromContextCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getVersion(inner) => {
                    <getVersionCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::initializeFromEmptyProxy(inner) => {
                    <initializeFromEmptyProxyCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::moveSuspendedKmsContextToActive(inner) => {
                    <moveSuspendedKmsContextToActiveCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::owner(inner) => {
                    <ownerCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::pause(inner) => {
                    <pauseCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::paused(inner) => {
                    <pausedCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::pendingOwner(inner) => {
                    <pendingOwnerCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::proxiableUUID(inner) => {
                    <proxiableUUIDCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::refreshKmsContextStatuses(inner) => {
                    <refreshKmsContextStatusesCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::renounceOwnership(inner) => {
                    <renounceOwnershipCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::transferOwnership(inner) => {
                    <transferOwnershipCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::unpause(inner) => {
                    <unpauseCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::updatePublicDecryptionThreshold(inner) => {
                    <updatePublicDecryptionThresholdCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::updateUserDecryptionThreshold(inner) => {
                    <updateUserDecryptionThresholdCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::upgradeToAndCall(inner) => {
                    <upgradeToAndCallCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::validateKeyResharing(inner) => {
                    <validateKeyResharingCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::UPGRADE_INTERFACE_VERSION(inner) => {
                    <UPGRADE_INTERFACE_VERSIONCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::acceptOwnership(inner) => {
                    <acceptOwnershipCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::addKmsContext(inner) => {
                    <addKmsContextCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::checkIsKmsSignerFromContext(inner) => {
                    <checkIsKmsSignerFromContextCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::checkIsKmsTxSenderFromContext(inner) => {
                    <checkIsKmsTxSenderFromContextCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::compromiseKmsContext(inner) => {
                    <compromiseKmsContextCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::destroyKmsContext(inner) => {
                    <destroyKmsContextCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::eip712Domain(inner) => {
                    <eip712DomainCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getActiveKmsContext(inner) => {
                    <getActiveKmsContextCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getActiveKmsContextId(inner) => {
                    <getActiveKmsContextIdCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getKmsContextGenerationBlockPeriod(inner) => {
                    <getKmsContextGenerationBlockPeriodCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getKmsContextStatus(inner) => {
                    <getKmsContextStatusCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getKmsContextSuspensionBlockPeriod(inner) => {
                    <getKmsContextSuspensionBlockPeriodCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getKmsNode(inner) => {
                    <getKmsNodeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getKmsSigners(inner) => {
                    <getKmsSignersCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getKmsTxSenders(inner) => {
                    <getKmsTxSendersCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getPublicDecryptionThresholdFromContext(inner) => {
                    <getPublicDecryptionThresholdFromContextCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getSuspendedKmsContextId(inner) => {
                    <getSuspendedKmsContextIdCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getUserDecryptionThresholdFromContext(inner) => {
                    <getUserDecryptionThresholdFromContextCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getVersion(inner) => {
                    <getVersionCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::initializeFromEmptyProxy(inner) => {
                    <initializeFromEmptyProxyCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::moveSuspendedKmsContextToActive(inner) => {
                    <moveSuspendedKmsContextToActiveCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::owner(inner) => {
                    <ownerCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::pause(inner) => {
                    <pauseCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::paused(inner) => {
                    <pausedCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::pendingOwner(inner) => {
                    <pendingOwnerCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::proxiableUUID(inner) => {
                    <proxiableUUIDCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::refreshKmsContextStatuses(inner) => {
                    <refreshKmsContextStatusesCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::renounceOwnership(inner) => {
                    <renounceOwnershipCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::transferOwnership(inner) => {
                    <transferOwnershipCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::unpause(inner) => {
                    <unpauseCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::updatePublicDecryptionThreshold(inner) => {
                    <updatePublicDecryptionThresholdCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::updateUserDecryptionThreshold(inner) => {
                    <updateUserDecryptionThresholdCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::upgradeToAndCall(inner) => {
                    <upgradeToAndCallCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::validateKeyResharing(inner) => {
                    <validateKeyResharingCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`KmsContexts`](self) custom errors.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub enum KmsContextsErrors {
        #[allow(missing_docs)]
        AddressEmptyCode(AddressEmptyCode),
        #[allow(missing_docs)]
        CompromiseActiveKmsContextNotAllowed(CompromiseActiveKmsContextNotAllowed),
        #[allow(missing_docs)]
        ContextAlreadyExists(ContextAlreadyExists),
        #[allow(missing_docs)]
        ContextNotActive(ContextNotActive),
        #[allow(missing_docs)]
        ContextNotActiveOrSuspended(ContextNotActiveOrSuspended),
        #[allow(missing_docs)]
        ContextNotGenerated(ContextNotGenerated),
        #[allow(missing_docs)]
        ContextNotInitializedOrIsGenerating(ContextNotInitializedOrIsGenerating),
        #[allow(missing_docs)]
        ContextNotPreActivatedOrSuspended(ContextNotPreActivatedOrSuspended),
        #[allow(missing_docs)]
        DestroyActiveKmsContextNotAllowed(DestroyActiveKmsContextNotAllowed),
        #[allow(missing_docs)]
        ECDSAInvalidSignature(ECDSAInvalidSignature),
        #[allow(missing_docs)]
        ECDSAInvalidSignatureLength(ECDSAInvalidSignatureLength),
        #[allow(missing_docs)]
        ECDSAInvalidSignatureS(ECDSAInvalidSignatureS),
        #[allow(missing_docs)]
        ERC1967InvalidImplementation(ERC1967InvalidImplementation),
        #[allow(missing_docs)]
        ERC1967NonPayable(ERC1967NonPayable),
        #[allow(missing_docs)]
        EmptyKmsNodes(EmptyKmsNodes),
        #[allow(missing_docs)]
        EnforcedPause(EnforcedPause),
        #[allow(missing_docs)]
        ExpectedPause(ExpectedPause),
        #[allow(missing_docs)]
        FailedCall(FailedCall),
        #[allow(missing_docs)]
        InvalidHighMpcThreshold(InvalidHighMpcThreshold),
        #[allow(missing_docs)]
        InvalidHighPublicDecryptionThreshold(InvalidHighPublicDecryptionThreshold),
        #[allow(missing_docs)]
        InvalidHighUserDecryptionThreshold(InvalidHighUserDecryptionThreshold),
        #[allow(missing_docs)]
        InvalidInitialization(InvalidInitialization),
        #[allow(missing_docs)]
        InvalidNullContextId(InvalidNullContextId),
        #[allow(missing_docs)]
        InvalidNullPublicDecryptionThreshold(InvalidNullPublicDecryptionThreshold),
        #[allow(missing_docs)]
        InvalidNullUserDecryptionThreshold(InvalidNullUserDecryptionThreshold),
        #[allow(missing_docs)]
        KmsContextNotGenerating(KmsContextNotGenerating),
        #[allow(missing_docs)]
        KmsContextNotInitialized(KmsContextNotInitialized),
        #[allow(missing_docs)]
        KmsNodeAlreadyValidatedKeyResharing(KmsNodeAlreadyValidatedKeyResharing),
        #[allow(missing_docs)]
        NoSuspendedKmsContext(NoSuspendedKmsContext),
        #[allow(missing_docs)]
        NotInitializing(NotInitializing),
        #[allow(missing_docs)]
        NotInitializingFromEmptyProxy(NotInitializingFromEmptyProxy),
        #[allow(missing_docs)]
        NotKmsNodeFromContext(NotKmsNodeFromContext),
        #[allow(missing_docs)]
        NotKmsSignerFromContext(NotKmsSignerFromContext),
        #[allow(missing_docs)]
        NotKmsTxSenderFromContext(NotKmsTxSenderFromContext),
        #[allow(missing_docs)]
        NotOwnerOrPauser(NotOwnerOrPauser),
        #[allow(missing_docs)]
        NumberOfKmsNodesChanged(NumberOfKmsNodesChanged),
        #[allow(missing_docs)]
        OwnableInvalidOwner(OwnableInvalidOwner),
        #[allow(missing_docs)]
        OwnableUnauthorizedAccount(OwnableUnauthorizedAccount),
        #[allow(missing_docs)]
        SuspendedKmsContextOngoing(SuspendedKmsContextOngoing),
        #[allow(missing_docs)]
        UUPSUnauthorizedCallContext(UUPSUnauthorizedCallContext),
        #[allow(missing_docs)]
        UUPSUnsupportedProxiableUUID(UUPSUnsupportedProxiableUUID),
    }
    #[automatically_derived]
    impl KmsContextsErrors {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [4u8, 148u8, 211u8, 192u8],
            [6u8, 140u8, 141u8, 64u8],
            [17u8, 140u8, 218u8, 167u8],
            [18u8, 180u8, 158u8, 61u8],
            [30u8, 79u8, 189u8, 247u8],
            [32u8, 126u8, 163u8, 243u8],
            [43u8, 54u8, 82u8, 209u8],
            [51u8, 20u8, 134u8, 179u8],
            [70u8, 192u8, 217u8, 175u8],
            [76u8, 156u8, 140u8, 227u8],
            [94u8, 81u8, 162u8, 225u8],
            [102u8, 83u8, 246u8, 215u8],
            [111u8, 79u8, 115u8, 31u8],
            [118u8, 35u8, 211u8, 87u8],
            [119u8, 208u8, 94u8, 167u8],
            [130u8, 177u8, 251u8, 218u8],
            [132u8, 32u8, 143u8, 35u8],
            [135u8, 137u8, 166u8, 202u8],
            [137u8, 180u8, 94u8, 93u8],
            [141u8, 252u8, 32u8, 43u8],
            [153u8, 150u8, 179u8, 21u8],
            [153u8, 177u8, 88u8, 193u8],
            [170u8, 29u8, 73u8, 164u8],
            [176u8, 197u8, 21u8, 29u8],
            [177u8, 174u8, 146u8, 234u8],
            [178u8, 94u8, 78u8, 179u8],
            [179u8, 152u8, 151u8, 159u8],
            [192u8, 181u8, 238u8, 102u8],
            [203u8, 23u8, 183u8, 165u8],
            [210u8, 83u8, 94u8, 17u8],
            [213u8, 149u8, 169u8, 98u8],
            [214u8, 189u8, 162u8, 117u8],
            [215u8, 139u8, 206u8, 12u8],
            [215u8, 230u8, 188u8, 248u8],
            [217u8, 60u8, 6u8, 101u8],
            [224u8, 124u8, 141u8, 186u8],
            [230u8, 10u8, 114u8, 113u8],
            [246u8, 69u8, 238u8, 223u8],
            [249u8, 46u8, 232u8, 169u8],
            [252u8, 230u8, 152u8, 247u8],
            [253u8, 248u8, 160u8, 93u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for KmsContextsErrors {
        const NAME: &'static str = "KmsContextsErrors";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 41usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::AddressEmptyCode(_) => {
                    <AddressEmptyCode as alloy_sol_types::SolError>::SELECTOR
                }
                Self::CompromiseActiveKmsContextNotAllowed(_) => {
                    <CompromiseActiveKmsContextNotAllowed as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ContextAlreadyExists(_) => {
                    <ContextAlreadyExists as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ContextNotActive(_) => {
                    <ContextNotActive as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ContextNotActiveOrSuspended(_) => {
                    <ContextNotActiveOrSuspended as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ContextNotGenerated(_) => {
                    <ContextNotGenerated as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ContextNotInitializedOrIsGenerating(_) => {
                    <ContextNotInitializedOrIsGenerating as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ContextNotPreActivatedOrSuspended(_) => {
                    <ContextNotPreActivatedOrSuspended as alloy_sol_types::SolError>::SELECTOR
                }
                Self::DestroyActiveKmsContextNotAllowed(_) => {
                    <DestroyActiveKmsContextNotAllowed as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ECDSAInvalidSignature(_) => {
                    <ECDSAInvalidSignature as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ECDSAInvalidSignatureLength(_) => {
                    <ECDSAInvalidSignatureLength as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ECDSAInvalidSignatureS(_) => {
                    <ECDSAInvalidSignatureS as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC1967InvalidImplementation(_) => {
                    <ERC1967InvalidImplementation as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC1967NonPayable(_) => {
                    <ERC1967NonPayable as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EmptyKmsNodes(_) => {
                    <EmptyKmsNodes as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EnforcedPause(_) => {
                    <EnforcedPause as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ExpectedPause(_) => {
                    <ExpectedPause as alloy_sol_types::SolError>::SELECTOR
                }
                Self::FailedCall(_) => {
                    <FailedCall as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidHighMpcThreshold(_) => {
                    <InvalidHighMpcThreshold as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidHighPublicDecryptionThreshold(_) => {
                    <InvalidHighPublicDecryptionThreshold as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidHighUserDecryptionThreshold(_) => {
                    <InvalidHighUserDecryptionThreshold as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidInitialization(_) => {
                    <InvalidInitialization as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidNullContextId(_) => {
                    <InvalidNullContextId as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidNullPublicDecryptionThreshold(_) => {
                    <InvalidNullPublicDecryptionThreshold as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidNullUserDecryptionThreshold(_) => {
                    <InvalidNullUserDecryptionThreshold as alloy_sol_types::SolError>::SELECTOR
                }
                Self::KmsContextNotGenerating(_) => {
                    <KmsContextNotGenerating as alloy_sol_types::SolError>::SELECTOR
                }
                Self::KmsContextNotInitialized(_) => {
                    <KmsContextNotInitialized as alloy_sol_types::SolError>::SELECTOR
                }
                Self::KmsNodeAlreadyValidatedKeyResharing(_) => {
                    <KmsNodeAlreadyValidatedKeyResharing as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NoSuspendedKmsContext(_) => {
                    <NoSuspendedKmsContext as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NotInitializing(_) => {
                    <NotInitializing as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NotInitializingFromEmptyProxy(_) => {
                    <NotInitializingFromEmptyProxy as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NotKmsNodeFromContext(_) => {
                    <NotKmsNodeFromContext as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NotKmsSignerFromContext(_) => {
                    <NotKmsSignerFromContext as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NotKmsTxSenderFromContext(_) => {
                    <NotKmsTxSenderFromContext as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NotOwnerOrPauser(_) => {
                    <NotOwnerOrPauser as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NumberOfKmsNodesChanged(_) => {
                    <NumberOfKmsNodesChanged as alloy_sol_types::SolError>::SELECTOR
                }
                Self::OwnableInvalidOwner(_) => {
                    <OwnableInvalidOwner as alloy_sol_types::SolError>::SELECTOR
                }
                Self::OwnableUnauthorizedAccount(_) => {
                    <OwnableUnauthorizedAccount as alloy_sol_types::SolError>::SELECTOR
                }
                Self::SuspendedKmsContextOngoing(_) => {
                    <SuspendedKmsContextOngoing as alloy_sol_types::SolError>::SELECTOR
                }
                Self::UUPSUnauthorizedCallContext(_) => {
                    <UUPSUnauthorizedCallContext as alloy_sol_types::SolError>::SELECTOR
                }
                Self::UUPSUnsupportedProxiableUUID(_) => {
                    <UUPSUnsupportedProxiableUUID as alloy_sol_types::SolError>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            ) -> alloy_sol_types::Result<KmsContextsErrors>] = &[
                {
                    fn NotKmsNodeFromContext(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <NotKmsNodeFromContext as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::NotKmsNodeFromContext)
                    }
                    NotKmsNodeFromContext
                },
                {
                    fn EmptyKmsNodes(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <EmptyKmsNodes as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::EmptyKmsNodes)
                    }
                    EmptyKmsNodes
                },
                {
                    fn OwnableUnauthorizedAccount(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <OwnableUnauthorizedAccount as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::OwnableUnauthorizedAccount)
                    }
                    OwnableUnauthorizedAccount
                },
                {
                    fn ContextNotPreActivatedOrSuspended(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <ContextNotPreActivatedOrSuspended as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::ContextNotPreActivatedOrSuspended)
                    }
                    ContextNotPreActivatedOrSuspended
                },
                {
                    fn OwnableInvalidOwner(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <OwnableInvalidOwner as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::OwnableInvalidOwner)
                    }
                    OwnableInvalidOwner
                },
                {
                    fn NoSuspendedKmsContext(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <NoSuspendedKmsContext as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::NoSuspendedKmsContext)
                    }
                    NoSuspendedKmsContext
                },
                {
                    fn ContextNotActiveOrSuspended(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <ContextNotActiveOrSuspended as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::ContextNotActiveOrSuspended)
                    }
                    ContextNotActiveOrSuspended
                },
                {
                    fn ContextNotActive(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <ContextNotActive as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::ContextNotActive)
                    }
                    ContextNotActive
                },
                {
                    fn NotOwnerOrPauser(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <NotOwnerOrPauser as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::NotOwnerOrPauser)
                    }
                    NotOwnerOrPauser
                },
                {
                    fn ERC1967InvalidImplementation(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <ERC1967InvalidImplementation as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::ERC1967InvalidImplementation)
                    }
                    ERC1967InvalidImplementation
                },
                {
                    fn KmsContextNotGenerating(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <KmsContextNotGenerating as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::KmsContextNotGenerating)
                    }
                    KmsContextNotGenerating
                },
                {
                    fn ContextAlreadyExists(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <ContextAlreadyExists as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::ContextAlreadyExists)
                    }
                    ContextAlreadyExists
                },
                {
                    fn NotInitializingFromEmptyProxy(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <NotInitializingFromEmptyProxy as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::NotInitializingFromEmptyProxy)
                    }
                    NotInitializingFromEmptyProxy
                },
                {
                    fn SuspendedKmsContextOngoing(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <SuspendedKmsContextOngoing as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::SuspendedKmsContextOngoing)
                    }
                    SuspendedKmsContextOngoing
                },
                {
                    fn CompromiseActiveKmsContextNotAllowed(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <CompromiseActiveKmsContextNotAllowed as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::CompromiseActiveKmsContextNotAllowed)
                    }
                    CompromiseActiveKmsContextNotAllowed
                },
                {
                    fn KmsContextNotInitialized(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <KmsContextNotInitialized as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::KmsContextNotInitialized)
                    }
                    KmsContextNotInitialized
                },
                {
                    fn InvalidHighPublicDecryptionThreshold(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <InvalidHighPublicDecryptionThreshold as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::InvalidHighPublicDecryptionThreshold)
                    }
                    InvalidHighPublicDecryptionThreshold
                },
                {
                    fn InvalidHighMpcThreshold(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <InvalidHighMpcThreshold as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::InvalidHighMpcThreshold)
                    }
                    InvalidHighMpcThreshold
                },
                {
                    fn NotKmsSignerFromContext(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <NotKmsSignerFromContext as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::NotKmsSignerFromContext)
                    }
                    NotKmsSignerFromContext
                },
                {
                    fn ExpectedPause(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <ExpectedPause as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::ExpectedPause)
                    }
                    ExpectedPause
                },
                {
                    fn AddressEmptyCode(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <AddressEmptyCode as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::AddressEmptyCode)
                    }
                    AddressEmptyCode
                },
                {
                    fn KmsNodeAlreadyValidatedKeyResharing(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <KmsNodeAlreadyValidatedKeyResharing as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::KmsNodeAlreadyValidatedKeyResharing)
                    }
                    KmsNodeAlreadyValidatedKeyResharing
                },
                {
                    fn UUPSUnsupportedProxiableUUID(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <UUPSUnsupportedProxiableUUID as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::UUPSUnsupportedProxiableUUID)
                    }
                    UUPSUnsupportedProxiableUUID
                },
                {
                    fn ContextNotInitializedOrIsGenerating(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <ContextNotInitializedOrIsGenerating as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::ContextNotInitializedOrIsGenerating)
                    }
                    ContextNotInitializedOrIsGenerating
                },
                {
                    fn InvalidNullPublicDecryptionThreshold(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <InvalidNullPublicDecryptionThreshold as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::InvalidNullPublicDecryptionThreshold)
                    }
                    InvalidNullPublicDecryptionThreshold
                },
                {
                    fn DestroyActiveKmsContextNotAllowed(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <DestroyActiveKmsContextNotAllowed as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::DestroyActiveKmsContextNotAllowed)
                    }
                    DestroyActiveKmsContextNotAllowed
                },
                {
                    fn ERC1967NonPayable(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <ERC1967NonPayable as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::ERC1967NonPayable)
                    }
                    ERC1967NonPayable
                },
                {
                    fn ContextNotGenerated(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <ContextNotGenerated as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::ContextNotGenerated)
                    }
                    ContextNotGenerated
                },
                {
                    fn InvalidNullContextId(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <InvalidNullContextId as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::InvalidNullContextId)
                    }
                    InvalidNullContextId
                },
                {
                    fn InvalidHighUserDecryptionThreshold(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <InvalidHighUserDecryptionThreshold as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::InvalidHighUserDecryptionThreshold)
                    }
                    InvalidHighUserDecryptionThreshold
                },
                {
                    fn NumberOfKmsNodesChanged(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <NumberOfKmsNodesChanged as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::NumberOfKmsNodesChanged)
                    }
                    NumberOfKmsNodesChanged
                },
                {
                    fn FailedCall(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <FailedCall as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::FailedCall)
                    }
                    FailedCall
                },
                {
                    fn ECDSAInvalidSignatureS(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <ECDSAInvalidSignatureS as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::ECDSAInvalidSignatureS)
                    }
                    ECDSAInvalidSignatureS
                },
                {
                    fn NotInitializing(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <NotInitializing as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::NotInitializing)
                    }
                    NotInitializing
                },
                {
                    fn EnforcedPause(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <EnforcedPause as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::EnforcedPause)
                    }
                    EnforcedPause
                },
                {
                    fn UUPSUnauthorizedCallContext(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <UUPSUnauthorizedCallContext as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::UUPSUnauthorizedCallContext)
                    }
                    UUPSUnauthorizedCallContext
                },
                {
                    fn InvalidNullUserDecryptionThreshold(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <InvalidNullUserDecryptionThreshold as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::InvalidNullUserDecryptionThreshold)
                    }
                    InvalidNullUserDecryptionThreshold
                },
                {
                    fn ECDSAInvalidSignature(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <ECDSAInvalidSignature as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::ECDSAInvalidSignature)
                    }
                    ECDSAInvalidSignature
                },
                {
                    fn InvalidInitialization(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <InvalidInitialization as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::InvalidInitialization)
                    }
                    InvalidInitialization
                },
                {
                    fn ECDSAInvalidSignatureLength(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <ECDSAInvalidSignatureLength as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::ECDSAInvalidSignatureLength)
                    }
                    ECDSAInvalidSignatureLength
                },
                {
                    fn NotKmsTxSenderFromContext(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <NotKmsTxSenderFromContext as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::NotKmsTxSenderFromContext)
                    }
                    NotKmsTxSenderFromContext
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::AddressEmptyCode(inner) => {
                    <AddressEmptyCode as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::CompromiseActiveKmsContextNotAllowed(inner) => {
                    <CompromiseActiveKmsContextNotAllowed as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ContextAlreadyExists(inner) => {
                    <ContextAlreadyExists as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ContextNotActive(inner) => {
                    <ContextNotActive as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ContextNotActiveOrSuspended(inner) => {
                    <ContextNotActiveOrSuspended as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ContextNotGenerated(inner) => {
                    <ContextNotGenerated as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ContextNotInitializedOrIsGenerating(inner) => {
                    <ContextNotInitializedOrIsGenerating as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ContextNotPreActivatedOrSuspended(inner) => {
                    <ContextNotPreActivatedOrSuspended as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::DestroyActiveKmsContextNotAllowed(inner) => {
                    <DestroyActiveKmsContextNotAllowed as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ECDSAInvalidSignature(inner) => {
                    <ECDSAInvalidSignature as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ECDSAInvalidSignatureLength(inner) => {
                    <ECDSAInvalidSignatureLength as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ECDSAInvalidSignatureS(inner) => {
                    <ECDSAInvalidSignatureS as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC1967InvalidImplementation(inner) => {
                    <ERC1967InvalidImplementation as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC1967NonPayable(inner) => {
                    <ERC1967NonPayable as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EmptyKmsNodes(inner) => {
                    <EmptyKmsNodes as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::EnforcedPause(inner) => {
                    <EnforcedPause as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::ExpectedPause(inner) => {
                    <ExpectedPause as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::FailedCall(inner) => {
                    <FailedCall as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::InvalidHighMpcThreshold(inner) => {
                    <InvalidHighMpcThreshold as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidHighPublicDecryptionThreshold(inner) => {
                    <InvalidHighPublicDecryptionThreshold as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidHighUserDecryptionThreshold(inner) => {
                    <InvalidHighUserDecryptionThreshold as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidInitialization(inner) => {
                    <InvalidInitialization as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidNullContextId(inner) => {
                    <InvalidNullContextId as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidNullPublicDecryptionThreshold(inner) => {
                    <InvalidNullPublicDecryptionThreshold as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidNullUserDecryptionThreshold(inner) => {
                    <InvalidNullUserDecryptionThreshold as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::KmsContextNotGenerating(inner) => {
                    <KmsContextNotGenerating as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::KmsContextNotInitialized(inner) => {
                    <KmsContextNotInitialized as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::KmsNodeAlreadyValidatedKeyResharing(inner) => {
                    <KmsNodeAlreadyValidatedKeyResharing as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NoSuspendedKmsContext(inner) => {
                    <NoSuspendedKmsContext as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NotInitializing(inner) => {
                    <NotInitializing as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NotInitializingFromEmptyProxy(inner) => {
                    <NotInitializingFromEmptyProxy as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NotKmsNodeFromContext(inner) => {
                    <NotKmsNodeFromContext as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NotKmsSignerFromContext(inner) => {
                    <NotKmsSignerFromContext as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NotKmsTxSenderFromContext(inner) => {
                    <NotKmsTxSenderFromContext as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NotOwnerOrPauser(inner) => {
                    <NotOwnerOrPauser as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NumberOfKmsNodesChanged(inner) => {
                    <NumberOfKmsNodesChanged as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::OwnableInvalidOwner(inner) => {
                    <OwnableInvalidOwner as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::OwnableUnauthorizedAccount(inner) => {
                    <OwnableUnauthorizedAccount as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::SuspendedKmsContextOngoing(inner) => {
                    <SuspendedKmsContextOngoing as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::UUPSUnauthorizedCallContext(inner) => {
                    <UUPSUnauthorizedCallContext as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::UUPSUnsupportedProxiableUUID(inner) => {
                    <UUPSUnsupportedProxiableUUID as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::AddressEmptyCode(inner) => {
                    <AddressEmptyCode as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::CompromiseActiveKmsContextNotAllowed(inner) => {
                    <CompromiseActiveKmsContextNotAllowed as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ContextAlreadyExists(inner) => {
                    <ContextAlreadyExists as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ContextNotActive(inner) => {
                    <ContextNotActive as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ContextNotActiveOrSuspended(inner) => {
                    <ContextNotActiveOrSuspended as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ContextNotGenerated(inner) => {
                    <ContextNotGenerated as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ContextNotInitializedOrIsGenerating(inner) => {
                    <ContextNotInitializedOrIsGenerating as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ContextNotPreActivatedOrSuspended(inner) => {
                    <ContextNotPreActivatedOrSuspended as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::DestroyActiveKmsContextNotAllowed(inner) => {
                    <DestroyActiveKmsContextNotAllowed as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ECDSAInvalidSignature(inner) => {
                    <ECDSAInvalidSignature as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ECDSAInvalidSignatureLength(inner) => {
                    <ECDSAInvalidSignatureLength as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ECDSAInvalidSignatureS(inner) => {
                    <ECDSAInvalidSignatureS as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC1967InvalidImplementation(inner) => {
                    <ERC1967InvalidImplementation as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC1967NonPayable(inner) => {
                    <ERC1967NonPayable as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EmptyKmsNodes(inner) => {
                    <EmptyKmsNodes as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EnforcedPause(inner) => {
                    <EnforcedPause as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ExpectedPause(inner) => {
                    <ExpectedPause as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::FailedCall(inner) => {
                    <FailedCall as alloy_sol_types::SolError>::abi_encode_raw(inner, out)
                }
                Self::InvalidHighMpcThreshold(inner) => {
                    <InvalidHighMpcThreshold as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidHighPublicDecryptionThreshold(inner) => {
                    <InvalidHighPublicDecryptionThreshold as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidHighUserDecryptionThreshold(inner) => {
                    <InvalidHighUserDecryptionThreshold as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidInitialization(inner) => {
                    <InvalidInitialization as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidNullContextId(inner) => {
                    <InvalidNullContextId as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidNullPublicDecryptionThreshold(inner) => {
                    <InvalidNullPublicDecryptionThreshold as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidNullUserDecryptionThreshold(inner) => {
                    <InvalidNullUserDecryptionThreshold as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::KmsContextNotGenerating(inner) => {
                    <KmsContextNotGenerating as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::KmsContextNotInitialized(inner) => {
                    <KmsContextNotInitialized as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::KmsNodeAlreadyValidatedKeyResharing(inner) => {
                    <KmsNodeAlreadyValidatedKeyResharing as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NoSuspendedKmsContext(inner) => {
                    <NoSuspendedKmsContext as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NotInitializing(inner) => {
                    <NotInitializing as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NotInitializingFromEmptyProxy(inner) => {
                    <NotInitializingFromEmptyProxy as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NotKmsNodeFromContext(inner) => {
                    <NotKmsNodeFromContext as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NotKmsSignerFromContext(inner) => {
                    <NotKmsSignerFromContext as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NotKmsTxSenderFromContext(inner) => {
                    <NotKmsTxSenderFromContext as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NotOwnerOrPauser(inner) => {
                    <NotOwnerOrPauser as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NumberOfKmsNodesChanged(inner) => {
                    <NumberOfKmsNodesChanged as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::OwnableInvalidOwner(inner) => {
                    <OwnableInvalidOwner as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::OwnableUnauthorizedAccount(inner) => {
                    <OwnableUnauthorizedAccount as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::SuspendedKmsContextOngoing(inner) => {
                    <SuspendedKmsContextOngoing as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::UUPSUnauthorizedCallContext(inner) => {
                    <UUPSUnauthorizedCallContext as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::UUPSUnsupportedProxiableUUID(inner) => {
                    <UUPSUnsupportedProxiableUUID as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`KmsContexts`](self) events.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub enum KmsContextsEvents {
        #[allow(missing_docs)]
        ActivateKmsContext(ActivateKmsContext),
        #[allow(missing_docs)]
        CompromiseKmsContext(CompromiseKmsContext),
        #[allow(missing_docs)]
        DeactivateKmsContext(DeactivateKmsContext),
        #[allow(missing_docs)]
        DestroyKmsContext(DestroyKmsContext),
        #[allow(missing_docs)]
        EIP712DomainChanged(EIP712DomainChanged),
        #[allow(missing_docs)]
        InitializeKmsContexts(InitializeKmsContexts),
        #[allow(missing_docs)]
        Initialized(Initialized),
        #[allow(missing_docs)]
        InvalidateKeyResharing(InvalidateKeyResharing),
        #[allow(missing_docs)]
        NewKmsContext(NewKmsContext),
        #[allow(missing_docs)]
        OwnershipTransferStarted(OwnershipTransferStarted),
        #[allow(missing_docs)]
        OwnershipTransferred(OwnershipTransferred),
        #[allow(missing_docs)]
        Paused(Paused),
        #[allow(missing_docs)]
        PreActivateKmsContext(PreActivateKmsContext),
        #[allow(missing_docs)]
        StartKeyResharing(StartKeyResharing),
        #[allow(missing_docs)]
        SuspendKmsContext(SuspendKmsContext),
        #[allow(missing_docs)]
        Unpaused(Unpaused),
        #[allow(missing_docs)]
        UpdatePublicDecryptionThreshold(UpdatePublicDecryptionThreshold),
        #[allow(missing_docs)]
        UpdateUserDecryptionThreshold(UpdateUserDecryptionThreshold),
        #[allow(missing_docs)]
        Upgraded(Upgraded),
        #[allow(missing_docs)]
        ValidateKeyResharing(ValidateKeyResharing),
    }
    #[automatically_derived]
    impl KmsContextsEvents {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 32usize]] = &[
            [
                0u8, 159u8, 232u8, 240u8, 219u8, 69u8, 153u8, 109u8, 236u8, 247u8, 176u8,
                111u8, 199u8, 182u8, 236u8, 95u8, 136u8, 125u8, 95u8, 4u8, 219u8, 46u8,
                12u8, 74u8, 215u8, 244u8, 228u8, 238u8, 94u8, 239u8, 197u8, 163u8,
            ],
            [
                10u8, 99u8, 135u8, 201u8, 234u8, 54u8, 40u8, 184u8, 138u8, 99u8, 59u8,
                180u8, 243u8, 177u8, 81u8, 119u8, 15u8, 112u8, 8u8, 81u8, 23u8, 161u8,
                95u8, 155u8, 243u8, 120u8, 124u8, 218u8, 83u8, 241u8, 61u8, 49u8,
            ],
            [
                56u8, 209u8, 107u8, 140u8, 172u8, 34u8, 217u8, 159u8, 199u8, 193u8, 36u8,
                185u8, 205u8, 13u8, 226u8, 211u8, 250u8, 31u8, 174u8, 244u8, 32u8, 191u8,
                231u8, 145u8, 216u8, 195u8, 98u8, 215u8, 101u8, 226u8, 39u8, 0u8,
            ],
            [
                62u8, 143u8, 2u8, 220u8, 122u8, 246u8, 227u8, 166u8, 127u8, 58u8, 240u8,
                188u8, 153u8, 188u8, 241u8, 27u8, 77u8, 235u8, 70u8, 16u8, 94u8, 155u8,
                167u8, 241u8, 172u8, 109u8, 168u8, 35u8, 34u8, 233u8, 2u8, 94u8,
            ],
            [
                69u8, 64u8, 247u8, 128u8, 143u8, 202u8, 236u8, 134u8, 195u8, 118u8,
                168u8, 157u8, 44u8, 12u8, 147u8, 165u8, 5u8, 108u8, 33u8, 104u8, 13u8,
                181u8, 67u8, 50u8, 199u8, 242u8, 149u8, 157u8, 135u8, 254u8, 252u8, 139u8,
            ],
            [
                79u8, 84u8, 166u8, 172u8, 152u8, 28u8, 200u8, 220u8, 131u8, 20u8, 43u8,
                62u8, 180u8, 209u8, 32u8, 190u8, 124u8, 112u8, 252u8, 93u8, 230u8, 71u8,
                122u8, 20u8, 234u8, 227u8, 233u8, 202u8, 100u8, 118u8, 68u8, 188u8,
            ],
            [
                84u8, 72u8, 117u8, 110u8, 225u8, 63u8, 142u8, 94u8, 154u8, 129u8, 245u8,
                116u8, 172u8, 104u8, 200u8, 129u8, 74u8, 22u8, 97u8, 43u8, 238u8, 6u8,
                254u8, 160u8, 253u8, 128u8, 198u8, 22u8, 16u8, 67u8, 109u8, 205u8,
            ],
            [
                93u8, 185u8, 238u8, 10u8, 73u8, 91u8, 242u8, 230u8, 255u8, 156u8, 145u8,
                167u8, 131u8, 76u8, 27u8, 164u8, 253u8, 210u8, 68u8, 165u8, 232u8, 170u8,
                78u8, 83u8, 123u8, 211u8, 138u8, 234u8, 228u8, 176u8, 115u8, 170u8,
            ],
            [
                93u8, 198u8, 1u8, 6u8, 90u8, 3u8, 93u8, 120u8, 48u8, 92u8, 217u8, 239u8,
                39u8, 201u8, 26u8, 0u8, 156u8, 216u8, 211u8, 114u8, 151u8, 228u8, 59u8,
                183u8, 99u8, 25u8, 73u8, 8u8, 149u8, 160u8, 208u8, 88u8,
            ],
            [
                98u8, 231u8, 140u8, 234u8, 1u8, 190u8, 227u8, 32u8, 205u8, 78u8, 66u8,
                2u8, 112u8, 181u8, 234u8, 116u8, 0u8, 13u8, 17u8, 176u8, 201u8, 247u8,
                71u8, 84u8, 235u8, 219u8, 252u8, 84u8, 75u8, 5u8, 162u8, 88u8,
            ],
            [
                104u8, 137u8, 138u8, 152u8, 147u8, 107u8, 242u8, 58u8, 86u8, 232u8,
                237u8, 75u8, 35u8, 220u8, 201u8, 140u8, 239u8, 146u8, 107u8, 217u8,
                172u8, 44u8, 229u8, 34u8, 241u8, 249u8, 66u8, 62u8, 56u8, 100u8, 242u8,
                245u8,
            ],
            [
                131u8, 126u8, 10u8, 101u8, 40u8, 218u8, 223u8, 162u8, 220u8, 121u8, 38u8,
                146u8, 197u8, 24u8, 46u8, 82u8, 169u8, 245u8, 187u8, 222u8, 237u8, 123u8,
                35u8, 114u8, 146u8, 122u8, 38u8, 198u8, 149u8, 131u8, 150u8, 19u8,
            ],
            [
                133u8, 26u8, 8u8, 193u8, 107u8, 21u8, 149u8, 156u8, 51u8, 138u8, 196u8,
                181u8, 100u8, 102u8, 208u8, 108u8, 159u8, 157u8, 95u8, 248u8, 215u8,
                21u8, 22u8, 138u8, 161u8, 37u8, 213u8, 204u8, 175u8, 83u8, 131u8, 32u8,
            ],
            [
                139u8, 224u8, 7u8, 156u8, 83u8, 22u8, 89u8, 20u8, 19u8, 68u8, 205u8,
                31u8, 208u8, 164u8, 242u8, 132u8, 25u8, 73u8, 127u8, 151u8, 34u8, 163u8,
                218u8, 175u8, 227u8, 180u8, 24u8, 111u8, 107u8, 100u8, 87u8, 224u8,
            ],
            [
                143u8, 183u8, 88u8, 88u8, 165u8, 101u8, 174u8, 225u8, 23u8, 52u8, 45u8,
                147u8, 25u8, 106u8, 127u8, 11u8, 84u8, 193u8, 200u8, 81u8, 152u8, 133u8,
                237u8, 221u8, 166u8, 160u8, 31u8, 71u8, 115u8, 89u8, 179u8, 99u8,
            ],
            [
                166u8, 154u8, 76u8, 147u8, 65u8, 205u8, 125u8, 69u8, 143u8, 222u8, 18u8,
                195u8, 26u8, 31u8, 88u8, 47u8, 125u8, 76u8, 174u8, 219u8, 39u8, 196u8,
                167u8, 195u8, 76u8, 201u8, 146u8, 32u8, 138u8, 60u8, 228u8, 197u8,
            ],
            [
                188u8, 17u8, 20u8, 250u8, 154u8, 119u8, 100u8, 140u8, 208u8, 151u8,
                238u8, 108u8, 241u8, 73u8, 195u8, 68u8, 250u8, 39u8, 139u8, 155u8, 152u8,
                63u8, 48u8, 221u8, 101u8, 182u8, 253u8, 106u8, 157u8, 70u8, 74u8, 7u8,
            ],
            [
                188u8, 124u8, 215u8, 90u8, 32u8, 238u8, 39u8, 253u8, 154u8, 222u8, 186u8,
                179u8, 32u8, 65u8, 247u8, 85u8, 33u8, 77u8, 188u8, 107u8, 255u8, 169u8,
                12u8, 192u8, 34u8, 91u8, 57u8, 218u8, 46u8, 92u8, 45u8, 59u8,
            ],
            [
                199u8, 245u8, 5u8, 178u8, 243u8, 113u8, 174u8, 33u8, 117u8, 238u8, 73u8,
                19u8, 244u8, 73u8, 158u8, 31u8, 38u8, 51u8, 167u8, 181u8, 147u8, 99u8,
                33u8, 238u8, 209u8, 205u8, 174u8, 182u8, 17u8, 81u8, 129u8, 210u8,
            ],
            [
                228u8, 24u8, 2u8, 175u8, 114u8, 87u8, 41u8, 173u8, 203u8, 140u8, 21u8,
                30u8, 41u8, 55u8, 56u8, 10u8, 37u8, 198u8, 145u8, 85u8, 117u8, 126u8,
                58u8, 245u8, 211u8, 151u8, 154u8, 218u8, 181u8, 3u8, 88u8, 0u8,
            ],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolEventInterface for KmsContextsEvents {
        const NAME: &'static str = "KmsContextsEvents";
        const COUNT: usize = 20usize;
        fn decode_raw_log(
            topics: &[alloy_sol_types::Word],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            match topics.first().copied() {
                Some(
                    <ActivateKmsContext as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <ActivateKmsContext as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::ActivateKmsContext)
                }
                Some(
                    <CompromiseKmsContext as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <CompromiseKmsContext as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::CompromiseKmsContext)
                }
                Some(
                    <DeactivateKmsContext as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <DeactivateKmsContext as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::DeactivateKmsContext)
                }
                Some(
                    <DestroyKmsContext as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <DestroyKmsContext as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::DestroyKmsContext)
                }
                Some(
                    <EIP712DomainChanged as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <EIP712DomainChanged as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::EIP712DomainChanged)
                }
                Some(
                    <InitializeKmsContexts as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <InitializeKmsContexts as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::InitializeKmsContexts)
                }
                Some(<Initialized as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Initialized as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::Initialized)
                }
                Some(
                    <InvalidateKeyResharing as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <InvalidateKeyResharing as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::InvalidateKeyResharing)
                }
                Some(<NewKmsContext as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <NewKmsContext as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::NewKmsContext)
                }
                Some(
                    <OwnershipTransferStarted as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <OwnershipTransferStarted as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::OwnershipTransferStarted)
                }
                Some(
                    <OwnershipTransferred as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <OwnershipTransferred as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::OwnershipTransferred)
                }
                Some(<Paused as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Paused as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::Paused)
                }
                Some(
                    <PreActivateKmsContext as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <PreActivateKmsContext as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::PreActivateKmsContext)
                }
                Some(
                    <StartKeyResharing as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <StartKeyResharing as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::StartKeyResharing)
                }
                Some(
                    <SuspendKmsContext as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <SuspendKmsContext as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::SuspendKmsContext)
                }
                Some(<Unpaused as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Unpaused as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::Unpaused)
                }
                Some(
                    <UpdatePublicDecryptionThreshold as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <UpdatePublicDecryptionThreshold as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::UpdatePublicDecryptionThreshold)
                }
                Some(
                    <UpdateUserDecryptionThreshold as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <UpdateUserDecryptionThreshold as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::UpdateUserDecryptionThreshold)
                }
                Some(<Upgraded as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Upgraded as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::Upgraded)
                }
                Some(
                    <ValidateKeyResharing as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <ValidateKeyResharing as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::ValidateKeyResharing)
                }
                _ => {
                    alloy_sol_types::private::Err(alloy_sol_types::Error::InvalidLog {
                        name: <Self as alloy_sol_types::SolEventInterface>::NAME,
                        log: alloy_sol_types::private::Box::new(
                            alloy_sol_types::private::LogData::new_unchecked(
                                topics.to_vec(),
                                data.to_vec().into(),
                            ),
                        ),
                    })
                }
            }
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::private::IntoLogData for KmsContextsEvents {
        fn to_log_data(&self) -> alloy_sol_types::private::LogData {
            match self {
                Self::ActivateKmsContext(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::CompromiseKmsContext(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::DeactivateKmsContext(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::DestroyKmsContext(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::EIP712DomainChanged(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::InitializeKmsContexts(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Initialized(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::InvalidateKeyResharing(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::NewKmsContext(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::OwnershipTransferStarted(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::OwnershipTransferred(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Paused(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::PreActivateKmsContext(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::StartKeyResharing(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::SuspendKmsContext(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Unpaused(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::UpdatePublicDecryptionThreshold(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::UpdateUserDecryptionThreshold(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Upgraded(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::ValidateKeyResharing(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
            }
        }
        fn into_log_data(self) -> alloy_sol_types::private::LogData {
            match self {
                Self::ActivateKmsContext(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::CompromiseKmsContext(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::DeactivateKmsContext(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::DestroyKmsContext(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::EIP712DomainChanged(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::InitializeKmsContexts(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Initialized(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::InvalidateKeyResharing(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::NewKmsContext(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::OwnershipTransferStarted(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::OwnershipTransferred(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Paused(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::PreActivateKmsContext(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::StartKeyResharing(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::SuspendKmsContext(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Unpaused(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::UpdatePublicDecryptionThreshold(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::UpdateUserDecryptionThreshold(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Upgraded(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::ValidateKeyResharing(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`KmsContexts`](self) contract instance.

See the [wrapper's documentation](`KmsContextsInstance`) for more details.*/
    #[inline]
    pub const fn new<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> KmsContextsInstance<T, P, N> {
        KmsContextsInstance::<T, P, N>::new(address, provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
    ) -> impl ::core::future::Future<
        Output = alloy_contract::Result<KmsContextsInstance<T, P, N>>,
    > {
        KmsContextsInstance::<T, P, N>::deploy(provider)
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(provider: P) -> alloy_contract::RawCallBuilder<T, P, N> {
        KmsContextsInstance::<T, P, N>::deploy_builder(provider)
    }
    /**A [`KmsContexts`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`KmsContexts`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct KmsContextsInstance<T, P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network_transport: ::core::marker::PhantomData<(N, T)>,
    }
    #[automatically_derived]
    impl<T, P, N> ::core::fmt::Debug for KmsContextsInstance<T, P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("KmsContextsInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > KmsContextsInstance<T, P, N> {
        /**Creates a new wrapper around an on-chain [`KmsContexts`](self) contract instance.

See the [wrapper's documentation](`KmsContextsInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            provider: P,
        ) -> Self {
            Self {
                address,
                provider,
                _network_transport: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            provider: P,
        ) -> alloy_contract::Result<KmsContextsInstance<T, P, N>> {
            let call_builder = Self::deploy_builder(provider);
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(provider: P) -> alloy_contract::RawCallBuilder<T, P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                provider,
                ::core::clone::Clone::clone(&BYTECODE),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<T, P: ::core::clone::Clone, N> KmsContextsInstance<T, &P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> KmsContextsInstance<T, P, N> {
            KmsContextsInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network_transport: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > KmsContextsInstance<T, P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<T, &P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        ///Creates a new call builder for the [`UPGRADE_INTERFACE_VERSION`] function.
        pub fn UPGRADE_INTERFACE_VERSION(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, UPGRADE_INTERFACE_VERSIONCall, N> {
            self.call_builder(&UPGRADE_INTERFACE_VERSIONCall {})
        }
        ///Creates a new call builder for the [`acceptOwnership`] function.
        pub fn acceptOwnership(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, acceptOwnershipCall, N> {
            self.call_builder(&acceptOwnershipCall {})
        }
        ///Creates a new call builder for the [`addKmsContext`] function.
        pub fn addKmsContext(
            &self,
            softwareVersion: alloy::sol_types::private::FixedBytes<8>,
            reshareKeys: bool,
            mpcThreshold: alloy::sol_types::private::primitives::aliases::U256,
            kmsNodes: alloy::sol_types::private::Vec<
                <KmsNode as alloy::sol_types::SolType>::RustType,
            >,
            blockPeriods: <KmsBlockPeriods as alloy::sol_types::SolType>::RustType,
            decryptionThresholds: <DecryptionThresholds as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, addKmsContextCall, N> {
            self.call_builder(
                &addKmsContextCall {
                    softwareVersion,
                    reshareKeys,
                    mpcThreshold,
                    kmsNodes,
                    blockPeriods,
                    decryptionThresholds,
                },
            )
        }
        ///Creates a new call builder for the [`checkIsKmsSignerFromContext`] function.
        pub fn checkIsKmsSignerFromContext(
            &self,
            contextId: alloy::sol_types::private::primitives::aliases::U256,
            signerAddress: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, checkIsKmsSignerFromContextCall, N> {
            self.call_builder(
                &checkIsKmsSignerFromContextCall {
                    contextId,
                    signerAddress,
                },
            )
        }
        ///Creates a new call builder for the [`checkIsKmsTxSenderFromContext`] function.
        pub fn checkIsKmsTxSenderFromContext(
            &self,
            contextId: alloy::sol_types::private::primitives::aliases::U256,
            txSenderAddress: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<
            T,
            &P,
            checkIsKmsTxSenderFromContextCall,
            N,
        > {
            self.call_builder(
                &checkIsKmsTxSenderFromContextCall {
                    contextId,
                    txSenderAddress,
                },
            )
        }
        ///Creates a new call builder for the [`compromiseKmsContext`] function.
        pub fn compromiseKmsContext(
            &self,
            contextId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, compromiseKmsContextCall, N> {
            self.call_builder(
                &compromiseKmsContextCall {
                    contextId,
                },
            )
        }
        ///Creates a new call builder for the [`destroyKmsContext`] function.
        pub fn destroyKmsContext(
            &self,
            contextId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, destroyKmsContextCall, N> {
            self.call_builder(&destroyKmsContextCall { contextId })
        }
        ///Creates a new call builder for the [`eip712Domain`] function.
        pub fn eip712Domain(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, eip712DomainCall, N> {
            self.call_builder(&eip712DomainCall {})
        }
        ///Creates a new call builder for the [`getActiveKmsContext`] function.
        pub fn getActiveKmsContext(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getActiveKmsContextCall, N> {
            self.call_builder(&getActiveKmsContextCall {})
        }
        ///Creates a new call builder for the [`getActiveKmsContextId`] function.
        pub fn getActiveKmsContextId(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getActiveKmsContextIdCall, N> {
            self.call_builder(&getActiveKmsContextIdCall {})
        }
        ///Creates a new call builder for the [`getKmsContextGenerationBlockPeriod`] function.
        pub fn getKmsContextGenerationBlockPeriod(
            &self,
        ) -> alloy_contract::SolCallBuilder<
            T,
            &P,
            getKmsContextGenerationBlockPeriodCall,
            N,
        > {
            self.call_builder(
                &getKmsContextGenerationBlockPeriodCall {
                },
            )
        }
        ///Creates a new call builder for the [`getKmsContextStatus`] function.
        pub fn getKmsContextStatus(
            &self,
            contextId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, getKmsContextStatusCall, N> {
            self.call_builder(
                &getKmsContextStatusCall {
                    contextId,
                },
            )
        }
        ///Creates a new call builder for the [`getKmsContextSuspensionBlockPeriod`] function.
        pub fn getKmsContextSuspensionBlockPeriod(
            &self,
        ) -> alloy_contract::SolCallBuilder<
            T,
            &P,
            getKmsContextSuspensionBlockPeriodCall,
            N,
        > {
            self.call_builder(
                &getKmsContextSuspensionBlockPeriodCall {
                },
            )
        }
        ///Creates a new call builder for the [`getKmsNode`] function.
        pub fn getKmsNode(
            &self,
            kmsTxSenderAddress: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, getKmsNodeCall, N> {
            self.call_builder(
                &getKmsNodeCall {
                    kmsTxSenderAddress,
                },
            )
        }
        ///Creates a new call builder for the [`getKmsSigners`] function.
        pub fn getKmsSigners(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getKmsSignersCall, N> {
            self.call_builder(&getKmsSignersCall {})
        }
        ///Creates a new call builder for the [`getKmsTxSenders`] function.
        pub fn getKmsTxSenders(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getKmsTxSendersCall, N> {
            self.call_builder(&getKmsTxSendersCall {})
        }
        ///Creates a new call builder for the [`getPublicDecryptionThresholdFromContext`] function.
        pub fn getPublicDecryptionThresholdFromContext(
            &self,
            contextId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<
            T,
            &P,
            getPublicDecryptionThresholdFromContextCall,
            N,
        > {
            self.call_builder(
                &getPublicDecryptionThresholdFromContextCall {
                    contextId,
                },
            )
        }
        ///Creates a new call builder for the [`getSuspendedKmsContextId`] function.
        pub fn getSuspendedKmsContextId(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getSuspendedKmsContextIdCall, N> {
            self.call_builder(&getSuspendedKmsContextIdCall {})
        }
        ///Creates a new call builder for the [`getUserDecryptionThresholdFromContext`] function.
        pub fn getUserDecryptionThresholdFromContext(
            &self,
            contextId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<
            T,
            &P,
            getUserDecryptionThresholdFromContextCall,
            N,
        > {
            self.call_builder(
                &getUserDecryptionThresholdFromContextCall {
                    contextId,
                },
            )
        }
        ///Creates a new call builder for the [`getVersion`] function.
        pub fn getVersion(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getVersionCall, N> {
            self.call_builder(&getVersionCall {})
        }
        ///Creates a new call builder for the [`initializeFromEmptyProxy`] function.
        pub fn initializeFromEmptyProxy(
            &self,
            initialSoftwareVersion: alloy::sol_types::private::FixedBytes<8>,
            initialMpcThreshold: alloy::sol_types::private::primitives::aliases::U256,
            initialKmsNodes: alloy::sol_types::private::Vec<
                <KmsNode as alloy::sol_types::SolType>::RustType,
            >,
            initialDecryptionThresholds: <DecryptionThresholds as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, initializeFromEmptyProxyCall, N> {
            self.call_builder(
                &initializeFromEmptyProxyCall {
                    initialSoftwareVersion,
                    initialMpcThreshold,
                    initialKmsNodes,
                    initialDecryptionThresholds,
                },
            )
        }
        ///Creates a new call builder for the [`moveSuspendedKmsContextToActive`] function.
        pub fn moveSuspendedKmsContextToActive(
            &self,
        ) -> alloy_contract::SolCallBuilder<
            T,
            &P,
            moveSuspendedKmsContextToActiveCall,
            N,
        > {
            self.call_builder(
                &moveSuspendedKmsContextToActiveCall {
                },
            )
        }
        ///Creates a new call builder for the [`owner`] function.
        pub fn owner(&self) -> alloy_contract::SolCallBuilder<T, &P, ownerCall, N> {
            self.call_builder(&ownerCall {})
        }
        ///Creates a new call builder for the [`pause`] function.
        pub fn pause(&self) -> alloy_contract::SolCallBuilder<T, &P, pauseCall, N> {
            self.call_builder(&pauseCall {})
        }
        ///Creates a new call builder for the [`paused`] function.
        pub fn paused(&self) -> alloy_contract::SolCallBuilder<T, &P, pausedCall, N> {
            self.call_builder(&pausedCall {})
        }
        ///Creates a new call builder for the [`pendingOwner`] function.
        pub fn pendingOwner(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, pendingOwnerCall, N> {
            self.call_builder(&pendingOwnerCall {})
        }
        ///Creates a new call builder for the [`proxiableUUID`] function.
        pub fn proxiableUUID(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, proxiableUUIDCall, N> {
            self.call_builder(&proxiableUUIDCall {})
        }
        ///Creates a new call builder for the [`refreshKmsContextStatuses`] function.
        pub fn refreshKmsContextStatuses(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, refreshKmsContextStatusesCall, N> {
            self.call_builder(&refreshKmsContextStatusesCall {})
        }
        ///Creates a new call builder for the [`renounceOwnership`] function.
        pub fn renounceOwnership(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, renounceOwnershipCall, N> {
            self.call_builder(&renounceOwnershipCall {})
        }
        ///Creates a new call builder for the [`transferOwnership`] function.
        pub fn transferOwnership(
            &self,
            newOwner: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, transferOwnershipCall, N> {
            self.call_builder(&transferOwnershipCall { newOwner })
        }
        ///Creates a new call builder for the [`unpause`] function.
        pub fn unpause(&self) -> alloy_contract::SolCallBuilder<T, &P, unpauseCall, N> {
            self.call_builder(&unpauseCall {})
        }
        ///Creates a new call builder for the [`updatePublicDecryptionThreshold`] function.
        pub fn updatePublicDecryptionThreshold(
            &self,
            newPublicDecryptionThreshold: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<
            T,
            &P,
            updatePublicDecryptionThresholdCall,
            N,
        > {
            self.call_builder(
                &updatePublicDecryptionThresholdCall {
                    newPublicDecryptionThreshold,
                },
            )
        }
        ///Creates a new call builder for the [`updateUserDecryptionThreshold`] function.
        pub fn updateUserDecryptionThreshold(
            &self,
            newUserDecryptionThreshold: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<
            T,
            &P,
            updateUserDecryptionThresholdCall,
            N,
        > {
            self.call_builder(
                &updateUserDecryptionThresholdCall {
                    newUserDecryptionThreshold,
                },
            )
        }
        ///Creates a new call builder for the [`upgradeToAndCall`] function.
        pub fn upgradeToAndCall(
            &self,
            newImplementation: alloy::sol_types::private::Address,
            data: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, upgradeToAndCallCall, N> {
            self.call_builder(
                &upgradeToAndCallCall {
                    newImplementation,
                    data,
                },
            )
        }
        ///Creates a new call builder for the [`validateKeyResharing`] function.
        pub fn validateKeyResharing(
            &self,
            contextId: alloy::sol_types::private::primitives::aliases::U256,
            signature: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, validateKeyResharingCall, N> {
            self.call_builder(
                &validateKeyResharingCall {
                    contextId,
                    signature,
                },
            )
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > KmsContextsInstance<T, P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<T, &P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
        ///Creates a new event filter for the [`ActivateKmsContext`] event.
        pub fn ActivateKmsContext_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, ActivateKmsContext, N> {
            self.event_filter::<ActivateKmsContext>()
        }
        ///Creates a new event filter for the [`CompromiseKmsContext`] event.
        pub fn CompromiseKmsContext_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, CompromiseKmsContext, N> {
            self.event_filter::<CompromiseKmsContext>()
        }
        ///Creates a new event filter for the [`DeactivateKmsContext`] event.
        pub fn DeactivateKmsContext_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, DeactivateKmsContext, N> {
            self.event_filter::<DeactivateKmsContext>()
        }
        ///Creates a new event filter for the [`DestroyKmsContext`] event.
        pub fn DestroyKmsContext_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, DestroyKmsContext, N> {
            self.event_filter::<DestroyKmsContext>()
        }
        ///Creates a new event filter for the [`EIP712DomainChanged`] event.
        pub fn EIP712DomainChanged_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, EIP712DomainChanged, N> {
            self.event_filter::<EIP712DomainChanged>()
        }
        ///Creates a new event filter for the [`InitializeKmsContexts`] event.
        pub fn InitializeKmsContexts_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, InitializeKmsContexts, N> {
            self.event_filter::<InitializeKmsContexts>()
        }
        ///Creates a new event filter for the [`Initialized`] event.
        pub fn Initialized_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, Initialized, N> {
            self.event_filter::<Initialized>()
        }
        ///Creates a new event filter for the [`InvalidateKeyResharing`] event.
        pub fn InvalidateKeyResharing_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, InvalidateKeyResharing, N> {
            self.event_filter::<InvalidateKeyResharing>()
        }
        ///Creates a new event filter for the [`NewKmsContext`] event.
        pub fn NewKmsContext_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, NewKmsContext, N> {
            self.event_filter::<NewKmsContext>()
        }
        ///Creates a new event filter for the [`OwnershipTransferStarted`] event.
        pub fn OwnershipTransferStarted_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, OwnershipTransferStarted, N> {
            self.event_filter::<OwnershipTransferStarted>()
        }
        ///Creates a new event filter for the [`OwnershipTransferred`] event.
        pub fn OwnershipTransferred_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, OwnershipTransferred, N> {
            self.event_filter::<OwnershipTransferred>()
        }
        ///Creates a new event filter for the [`Paused`] event.
        pub fn Paused_filter(&self) -> alloy_contract::Event<T, &P, Paused, N> {
            self.event_filter::<Paused>()
        }
        ///Creates a new event filter for the [`PreActivateKmsContext`] event.
        pub fn PreActivateKmsContext_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, PreActivateKmsContext, N> {
            self.event_filter::<PreActivateKmsContext>()
        }
        ///Creates a new event filter for the [`StartKeyResharing`] event.
        pub fn StartKeyResharing_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, StartKeyResharing, N> {
            self.event_filter::<StartKeyResharing>()
        }
        ///Creates a new event filter for the [`SuspendKmsContext`] event.
        pub fn SuspendKmsContext_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, SuspendKmsContext, N> {
            self.event_filter::<SuspendKmsContext>()
        }
        ///Creates a new event filter for the [`Unpaused`] event.
        pub fn Unpaused_filter(&self) -> alloy_contract::Event<T, &P, Unpaused, N> {
            self.event_filter::<Unpaused>()
        }
        ///Creates a new event filter for the [`UpdatePublicDecryptionThreshold`] event.
        pub fn UpdatePublicDecryptionThreshold_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, UpdatePublicDecryptionThreshold, N> {
            self.event_filter::<UpdatePublicDecryptionThreshold>()
        }
        ///Creates a new event filter for the [`UpdateUserDecryptionThreshold`] event.
        pub fn UpdateUserDecryptionThreshold_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, UpdateUserDecryptionThreshold, N> {
            self.event_filter::<UpdateUserDecryptionThreshold>()
        }
        ///Creates a new event filter for the [`Upgraded`] event.
        pub fn Upgraded_filter(&self) -> alloy_contract::Event<T, &P, Upgraded, N> {
            self.event_filter::<Upgraded>()
        }
        ///Creates a new event filter for the [`ValidateKeyResharing`] event.
        pub fn ValidateKeyResharing_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, ValidateKeyResharing, N> {
            self.event_filter::<ValidateKeyResharing>()
        }
    }
}
