#+title: Zaiffer Smart Contracts - Auditor Documentation
#+AUTHOR: Development Team
#+DATE: 2025-09-04
#+STARTUP: overview

* Executive Summary

This document provides comprehensive security and architectural documentation for the Zaiffer confidential token smart contract system built on Zama's FHEVM (Fully Homomorphic Encryption Virtual Machine). The system implements confidential fungible tokens where balances and transaction amounts are encrypted but can still be operated upon mathematically (ERC7984).

** Key Security Features
- All balances and transfer amounts are encrypted using FHE (euint64)
- Regulatory compliance with sanctioned address checking
- Upgradeable confidential tokens with admin controls
- Modular fee management with encrypted and plaintext fee calculations
- Isolated fund storage per token type via dedicated wrapper contracts

* Architecture Overview

** Double Factory Pattern

Due to Ethereum's 24KB contract size limit, the system employs a split factory architecture:

1. **DeploymentCoordinator**: Orchestrates deployment and maintains compatibility interface
2. **WrapperFactory**: Specialized factory for deploying Wrapper contracts (~12-15KB)
3. **RegulatedERC7984UpgradeableFactory**: Specialized factory for confidential tokens (~15-18KB)

This architecture solves the size constraint while maintaining clean separation of concerns.

** Core Components

1. **AdminProvider**: Centralized configuration hub
2. **FeeManager**: Handles all fee calculations (encrypted and plaintext)
3. **SanctionsList**: Manages sanctioned addresses
4. **Wrapper**: Per-token wrapper contract for fund custody
5. **RegulatedERC7984Upgradeable**: Confidential token with regulatory features

* Fund Custody and Security Architecture

** Wrapper Fund Isolation

Each underlying token (ERC20 or ETH) has its own dedicated Wrapper contract that:
- Holds all original tokens for that specific type
- Has exclusive mint/burn permissions on its paired confidential token
- Cannot interact with other token pools

** Security Implications of Fund Isolation

| Risk Factor                | Impact                                | Mitigation                                       |
|----------------------------+---------------------------------------+--------------------------------------------------|
| Smart Contract Bug         | LIMITED - affects only one token type | Fund isolation prevents cross-contamination      |
| Upgrade Risk               | LIMITED - independent upgrade cycles  | Each token pair can be upgraded separately       |
| Admin Key Compromise       | HIGH - all tokens affected            | Recommend multi-sig + timelock for AdminProvider |
| Individual Wrapper Exploit | MEDIUM - one token pool at risk       | Does not affect other token types                |

**Critical Security Benefit**: Unlike monolithic architectures where a single vulnerability could affect all token pools simultaneously, this design limits the "blast radius" of any exploit to a single token type.

* Permission Model and Access Control

** AdminProvider (Central Authority)
- **Owner**: Has full control over system configuration
- **Powers**: 
  - Update FeeManager contract reference
  - Update SanctionsList contract reference
  - Update regulator address
- **Security Note**: This is the most privileged role - compromise affects entire system

** FeeManager
- **Owner**: Zaiffer controlled wallet
- **Powers**:
  - Set transfer fee basis points (0-10,000 = 0-100%)
  - Set wrap/unwrap fee basis points
  - Set deployment fees
  - Set fee recipient address
  - Enable/disable transfer fees

** SanctionsList
Any contract that supports the [[https://go.chainalysis.com/chainalysis-oracle-docs.html][Chainalysis oracle]] ~isSanctioned~ interface. Initially, the oracle will be used. However, Zaiffer could later introduce a proxying contract to add rules.

** DeploymentCoordinator
- **Owner**: Zaiffer controlled wallet
- **Powers**:
  - Set admin provider
  - Set wrapper factory
  - Set confidential token factory
  - Accept factory ownerships

** RegulatedERC7984UpgradeableFactory
- **Owner**: Coordinator
- **Powers**:
  - deploy token

** WrapperFactory
- **Owner**: Coordinator
- **Powers**:
  - deploy wrapper

** Individual Wrapper Contracts
- **Owner**: DeploymentCoordinator
- **Permissions**:
  - WRAPPER_ROLE on paired confidential token (exclusive mint/burn)
  - References AdminProvider for fee and sanctions checking

** RegulatedERC7984Upgradeable Tokens
- **DEFAULT_ADMIN_ROLE**:
  - set to AdminProvider.owner() during deployment
- **WRAPPER_ROLE**:
  - Granted to associated Wrapper contract only
- **Upgradeability**:
  - Only DEFAULT_ADMIN_ROLE can authorize upgrades

* Administrative Hub Pattern

** Centralized Configuration Benefits

The AdminProvider pattern provides:

1. **Easy Updates**: Change FeeManager, SanctionsList or regulator address globally for all tokens
2. **Consistent Policies**: All tokens use same fee and sanctions configuration
3. **Flexibility**: Hot-swappable policy modules without touching individual contracts
4. **Gas Efficiency**: Single transaction updates policy for entire system

** Configuration Flow

#+begin_src
AdminProvider.setFeeManager(newFeeManager)
    ↓
All Wrappers automatically use new FeeManager
    ↓
All confidential tokens get new fee calculations
#+end_src

** Risk Assessment

- **Single Point of Configuration**: AdminProvider compromise affects all tokens
- **Upgrade Coordination**: Requires careful testing of new policy contracts
- **Gas Costs**: Administrative changes are one-time costs affecting all tokens

* RegulatedERC7984Upgradeable Features

** Upgradeability

- **Pattern**: UUPS (Universal Upgradeable Proxy Standard)
- **Authorization**: Only DEFAULT_ADMIN_ROLE can authorize upgrades via `_authorizeUpgrade()`
- **Storage**: Uses namespaced storage slots to prevent collisions
- **Risk**: Upgrade could introduce vulnerabilities & centralization

** Publicly Decryptable Total Supply

#+begin_src solidity
function _setTotalSupply(euint64 totalSupply) internal virtual override {
    ERC7984Storage storage $ = _getERC7984Storage();
    $._totalSupply = totalSupply;
    FHE.allowThis($._totalSupply);
    FHE.makePubliclyDecryptable($._totalSupply); // ← Public decryption
}
#+end_src

**Rationale**: Since wrapping/unwrapping are the only mint/burn mechanisms and these operations are necessarily public (interacting with non-confidential tokens), total supply is inferable anyway.

** Regulatory Features

*** Regulator Access
- **Address**: Set via AdminProvider.regulator
- **Permissions**: Can decrypt all balances and transfer amounts
- **Implementation**: `FHE.allow(balance, regulator())` called on every balance update
- **Purpose**: Regulatory compliance and monitoring

*** Sanctions Enforcement
- **Check Points**: All mint, burn, transfer, and approve operations
- **Implementation**: `_checkSanctions(address)` queries AdminProvider.sanctionsList
- **Effect**: Sanctioned addresses cannot participate in any token operations
- **Bypass**: No bypass mechanisms - enforcement is absolute

*** ERC20-Compatible Allowances

The system provides dual authorization models:

1. **Operator Model (ERC7984)**: Time-bounded delegation via `setOperator()`
2. **Allowance Model (ERC20)**: Amount-based delegation via `confidentialApprove()`

Both are implemented with encrypted amounts for confidentiality.

* Fee Management Architecture

** Fee Types and Formulas

*** Transfer Fees (Confidential)
- **Type**: euint64 (encrypted)
- **Formula**: `fee = (amount * transferFeeBasisPoints) / 10,000`
- **Range**: 0-10,000 basis points (0-100%)
- **Implementation**: Uses FHE operations for confidentiality
- **Note**: Cannot be `view` function due to FHE state mutations

#+begin_src solidity
function calculateTransferFee(euint64 amount) external returns (euint64) {
    euint64 feeAmount = FHE.asEuint64(0);
    if (transferFeeEnabled && transferFeeBasisPoints != 0) {
        feeAmount = FHE.mul(amount, uint64(transferFeeBasisPoints));
    }
    euint64 normalizedFeeAmount = FHE.div(feeAmount, 10_000);
    // ... access control setup
    return normalizedFeeAmount;
}
#+end_src

*** Wrap Fees (Plaintext)
- **Type**: uint64 (plaintext)
- **Formula**: `fee = (amount * wrapFeeBasisPoints) / 10,000`
- **Range**: 0-10,000 basis points (0-100%)
- **Rationale**: Plaintext because wrapping necessarily reveals amounts

*** Unwrap Fees (Plaintext)
- **Type**: uint64 (plaintext)
- **Formula**: `fee = (amount * unwrapFeeBasisPoints) / 10,000`
- **Range**: 0-10,000 basis points (0-100%)
- **Rationale**: Plaintext because unwrapping necessarily reveals amounts

*** Deploy Fees (Plaintext)
- **Type**: uint64 (wei)
- **Purpose**: ETH fee for deploying new wrapper/token pairs
- **Payment**: Required in ETH via `msg.value`
- **Recipient**: FeeManager.feeRecipient

** Fee Collection

- **Transfer Fees**: Collected to feeRecipient during encrypted transfers
- **Wrap/Unwrap Fees**: Minted to feeRecipient during wrap/unwrap operations
- **Deploy Fees**: Direct ETH transfer to feeRecipient
- **Recipient**: Single address configurable via FeeManager

** Fee Security Considerations

1. **Encrypted Fee Leakage**: Transfer fees maintain confidentiality via FHE
2. **Fee Recipient Trust**: Single recipient address must be trusted/multisig
3. **Maximum Fee Protection**: All fees capped at 100% (10,000 basis points)
4. **Fee Bypass**: WRAPPER_ROLE exempt from transfer fees (prevents double-charging)

* Critical Security Considerations

** FHE Access Control (ACL)

The system relies heavily on Zama's ACL for encrypted value access:

- **allowThis()**: Grants contract access to encrypted values
- **allow()**: Grants specific address access
- **allowTransient()**: Temporary access for cross-contract calls
- **Critical**: Improper ACL management could leak encrypted data

** Upgrade Risks

1. **Storage Layout**: Upgrades must maintain storage compatibility
2. **Admin Role**: DEFAULT_ADMIN_ROLE has unchecked upgrade authority

** Oracle Dependencies

- **Decryption Oracle**: Required for unwrap operations (async)
- **Signature Verification**: `FHE.checkSignatures()` validates oracle responses
- **Failure Handling**: Failed unwraps refund encrypted tokens to user

** Fund Recovery

No built-in fund recovery mechanisms exist. Lost private keys or inaccessible encrypted balances cannot be recovered, which is by design for confidentiality.

* Contract Interaction Diagrams

** System Deployment Flow

#+begin_src mermaid :file img/system-deployment-flow.png :width 2000 :exports results
sequenceDiagram
    participant Admin as Admin
    participant DC as DeploymentCoordinator
    participant WF as WrapperFactory
    participant TF as RegulatedERC7984UpgradeableFactory
    participant AP as AdminProvider
    participant FM as FeeManager
    participant SL as SanctionsList

    Admin->>+FM: deploy FeeManager
    Admin->>+SL: deploy SanctionsList
    Admin->>+AP: deploy AdminProvider
    Admin->>+WF: deploy WrapperFactory
    Admin->>+TF: deploy RegulatedERC7984UpgradeableFactory
    Admin->>+DC: deploy DeploymentCoordinator

    Admin->>WF: transferOwnership(DC)
    Admin->>TF: transferOwnership(DC)
    Admin->>DC: acceptOwnership(WF)
    Admin->>DC: acceptOwnership(TF)
#+end_src

#+RESULTS:
[[file:img/system-deployment-flow.png]]

** New Token Deployment Flow

Deploy Eth wrapper. For ERC20 wrappers, replace Eth transfer by a transfer from.

#+begin_src mermaid :file img/token-deployment-flow.png :width 2000 :exports results
sequenceDiagram
    participant User as User
    participant DC as DeploymentCoordinator
    participant WF as WrapperFactory
    participant TF as TokenFactory
    participant W as Wrapper
    participant CT as ConfidentialToken
    participant FM as FeeManager

    User->>+DC: deployNewToken(underlyingToken) {value: deployFee}

    DC->>FM: getDeployFee()
    FM-->>DC: fee amount

    alt Insufficient Fee
        DC-->>User: revert InsufficientFee
    end

    DC->>+WF: deployWrapper(underlyingToken, adminProvider)
    WF->>+W: deploy new Wrapper
    W-->>WF: wrapper address
    WF-->>DC: wrapper address

    DC->>+TF: deployConfidentialToken(name, symbol, adminProvider)
    TF->>+CT: deploy new RegulatedERC7984Upgradeable
    CT-->>TF: token address
    TF-->>DC: token address

    DC->>CT: grantRole(WRAPPER_ROLE, W)

    DC->>FM: transferDeployFee()

    DC-->>User: (wrapper, confidentialToken)
#+end_src

#+RESULTS:
[[file:img/token-deployment-flow.png]]

** Token Wrapping Flow

#+begin_src mermaid :file img/token-wrapping-flow.png :width 2000 :exports results
sequenceDiagram
    participant User as User
    participant ERC20 as UnderlyingToken
    participant W as Wrapper
    participant CT as ConfidentialToken
    participant FM as FeeManager
    participant SL as SanctionsList
    participant AP as AdminProvider

    User->>+W: wrap(amount, userAddress)

    W->>AP: sanctionsList()
    AP-->>W: SL address
    W->>SL: isSanctioned(User)
    SL-->>W: false

    alt User is Sanctioned
        W-->>User: revert SanctionedAddress
    end

    W->>AP: feeManager()
    AP-->>W: FM address
    W->>FM: calculateWrapFee(amount)
    FM-->>W: fee

    W->>+ERC20: transferFrom(User, W, amount)
    ERC20-->>W: success

    Note over W: mintAmount = amount - fee

    W->>+CT: mint(User, encryptedMintAmount, userPublicKey)
    CT-->>W: success

    alt Fee > 0
        W->>FM: feeRecipient()
        FM-->>W: recipient
        W->>CT: mint(recipient, encryptedFee, recipientPublicKey)
    end

    W-->>User: success
#+end_src

#+RESULTS:
[[file:img/token-wrapping-flow.png]]

** Token Unwrapping Flow (via transferAndCall)

The unwrapping process now uses the transferAndCall pattern instead of separate approve/transferFrom calls. Users call `confidentialTransferAndCall` on the confidential token, which triggers the unwrapping process:

#+begin_src mermaid :file img/token-unwrapping-flow.png :width 2000 :exports results
sequenceDiagram
    participant User as User
    participant CT as ConfidentialToken
    participant W as Wrapper
    participant FHE as FHE Oracle
    participant ERC20 as UnderlyingToken
    participant FM as FeeManager
    participant AP as AdminProvider
    participant SL as SanctionsList
    participant Receiver as IWrapperReceiver

    User->>+CT: confidentialTransferAndCall(wrapper, encryptedAmount, callbackData)
    Note over User,CT: callbackData = abi.encode(to, unwrapCallbackData)

    CT->>+W: onConfidentialTransferReceived(operator, from, amount, data)

    W->>AP: sanctionsList()
    AP-->>W: SL address
    W->>SL: isSanctioned(User)
    SL-->>W: false

    W->>AP: feeManager()
    AP-->>W: FM address
    W->>FM: getUnwrapFee(encryptedAmount)
    FM-->>W: encryptedFee

    Note over W: expectedBurnAmount = encryptedAmount - encryptedFee

    W->>CT: burn(expectedBurnAmount, from)
    CT-->>W: actualBurnAmount

    W->>CT: confidentialTransfer(feeRecipient, expectedFee)
    CT-->>W: actualFeeAmount

    W->>+FHE: requestDecryption([expectedBurnAmount, actualBurnAmount, expectedFee, actualFeeAmount, success])
    FHE-->>W: requestId

    Note over FHE: Async decryption process

    FHE->>+W: finalizeUnwrap(requestId, cleartexts, proof)

    alt Decryption Success && Amounts Match
        W->>+ERC20: transfer(to, actualBurnAmount * rate)
        ERC20-->>W: success

        alt Receiver is Contract
            W->>+Receiver: onUnwrapFinalizedReceived(sender, amount, callbackData)
        end
    else Failure or Mismatch
        Note over W: Refund tokens to user
        W->>CT: mint(to, actualBurnAmount)
        W->>CT: confidentialTransferFrom(feeRecipient, to, actualFeeAmount)
    end

    W-->>User: UnwrappedFinalized event
#+end_src

#+RESULTS:
[[file:img/token-unwrapping-flow.png]]

** Confidential Transfer Flow

#+begin_src mermaid :file img/confidential-transfer-flow.png :width 2000 :exports results
sequenceDiagram
    participant Alice as Alice
    participant Bob as Bob
    participant CT as ConfidentialToken
    participant FM as FeeManager
    participant AP as AdminProvider
    participant SL as SanctionsList
    participant Reg as Regulator

    Alice->>+CT: confidentialTransfer(Bob, encryptedAmount, aliceSignature)

    CT->>AP: sanctionsList()
    AP-->>CT: SL address
    CT->>SL: isSanctioned(Alice)
    SL-->>CT: false
    CT->>SL: isSanctioned(Bob)
    SL-->>CT: false

    alt Either party is sanctioned
        CT-->>Alice: revert SanctionedAddress
    end

    CT->>AP: feeManager()
    AP-->>CT: FM address
    CT->>FM: calculateTransferFee(encryptedAmount)
    FM-->>CT: encryptedFee

    Note over CT: Verify Alice has sufficient encrypted balance
    Note over CT: encryptedTransferAmount = encryptedAmount - encryptedFee

    CT->>CT: _updateBalance(Alice, -encryptedAmount)
    CT->>CT: _updateBalance(Bob, +encryptedTransferAmount)

    alt Fee > 0
        CT->>FM: feeRecipient()
        FM-->>CT: recipient
        CT->>CT: _updateBalance(recipient, +encryptedFee)
    end

    Note over CT: Grant regulator access to all encrypted values
    CT->>AP: regulator()
    AP-->>CT: Reg address
    CT->>+FHE: allow(encryptedAmount, Reg)
    CT->>FHE: allow(aliceNewBalance, Reg)
    CT->>FHE: allow(bobNewBalance, Reg)

    CT-->>Alice: Transfer event (with encrypted placeholders)
#+end_src

#+RESULTS:
[[file:img/confidential-transfer-flow.png]]

** Admin Configuration Flow

#+begin_src mermaid :file img/admin-configuration-flow.png :width 2000 :exports results
sequenceDiagram
    participant Admin as Admin
    participant AP as AdminProvider
    participant FM as FeeManager
    participant SL as SanctionsList
    participant W1 as Wrapper1
    participant W2 as Wrapper2
    participant Wn as WrapperN

    Admin->>+AP: setFeeManager(newFeeManager)
    AP-->>Admin: success

    Note over W1,Wn: All Wrappers automatically reference new FeeManager

    User->>W1: wrap(amount)
    W1->>AP: feeManager()
    AP-->>W1: newFeeManager address
    W1->>+NewFeeManager: calculateWrapFee(amount)

    Admin->>+AP: setSanctionsList(newSanctionsList)
    AP-->>Admin: success

    Note over W1,Wn: All operations now use new SanctionsList

    Admin->>+AP: setRegulator(newRegulator)
    AP-->>Admin: success

    Note over CT: All future balance updates grant access to newRegulator

    Admin->>+FM: setTransferFeeBasisPoints(500) // 5%
    FM-->>Admin: success

    Admin->>+FM: setFeeRecipient(newRecipient)
    FM-->>Admin: success
#+end_src

#+RESULTS:
[[file:img/admin-configuration-flow.png]]

* Batch Transfer System (ERC7984TransferBatcher)

The system includes a batch transfer contract that allows users to perform multiple confidential transfers in a single transaction, with retry functionality for failed transfers.

** Architecture

- **Contract**: `contracts/batcher/ERC7984TransferBatcher.sol`
- **Purpose**: Efficient batch processing of confidential transfers with fee collection
- **Features**: Retry mechanism for failed transactions, fee collection, sender tracking

** Batch Transfer Flow

#+begin_src mermaid :file img/batch-transfer-flow.png :width 2000 :exports results
sequenceDiagram
    participant User as User
    participant Batcher as ERC7984TransferBatcher
    participant CT as ConfidentialToken
    participant AP as AdminProvider
    participant FM as FeeManager

    User->>+Batcher: confidentialBatchTransfer(cToken, transfers[]) {value: batchFee}

    Batcher->>AP: feeManager()
    AP-->>Batcher: FM address
    Batcher->>FM: getBatchTransferFee()
    FM-->>Batcher: requiredFee

    alt Insufficient Fee
        Batcher-->>User: revert InsufficientFee
    end

    Batcher->>FM: getFeeRecipient()
    FM-->>Batcher: feeRecipient
    Batcher->>feeRecipient: transfer batch fee

    Note over Batcher: startTxId = cToken.nextTxId()

    loop For each transfer in transfers[]
        alt Retry Transfer
            Batcher->>Batcher: verify original sender == msg.sender
        end

        Note over Batcher: Decrypt external encrypted amount
        Batcher->>+CT: confidentialTransferFrom(sender, to, amount)
        CT-->>Batcher: success

        Note over Batcher: Record txId -> sender mapping

        alt Retry Transfer
            Batcher-->>User: RetryTransfer event
        end
    end

    Note over Batcher: endTxId = cToken.nextTxId() - 1
    Batcher-->>User: BatchTransfer event (startTxId, endTxId)
#+end_src

#+RESULTS:
[[file:img/batch-transfer-flow.png]]

** Key Features

- **Fee Management**: Fixed ETH fee for batch operations, paid upfront
- **Retry Mechanism**: Users can retry failed transfers by referencing original txId
- **Sender Tracking**: Maps transaction IDs to original senders for retry validation
- **External Encryption**: Supports encrypted inputs with proofs for confidentiality
- **Event Logging**: Comprehensive events for batch operations and retries

** Security Considerations

- **Retry Authorization**: Only original sender can retry their failed transfers
- **Fee Collection**: Batch fees collected upfront prevent partial execution without payment
- **Input Validation**: External encrypted amounts validated with zero-knowledge proofs

* Swap System (SwapV0)

The swap system enables confidential token holders to swap their tokens through external DEXs (like Uniswap) while maintaining confidentiality during the process.

** Architecture

- **Contract**: `contracts/swap/swap_v0.sol`
- **Pattern**: Receiver pattern with transferAndCall integration
- **DEX Integration**: Uniswap V2 Router support with extensible interface
- **Failure Handling**: Automatic rewrapping on swap failure

** Swap Flow

#+begin_src mermaid :file img/swap-flow.png :width 2000 :exports results
sequenceDiagram
    participant User as User
    participant cTokenA as ConfidentialTokenA
    participant SwapV0 as SwapV0
    participant WrapperA as WrapperA
    participant TokenA as UnderlyingTokenA
    participant Uniswap as UniswapV2Router
    participant TokenB as UnderlyingTokenB
    participant WrapperB as WrapperB
    participant cTokenB as ConfidentialTokenB
    participant FHE as FHE Oracle

    User->>+cTokenA: confidentialTransferAndCall(SwapV0, amount, swapData)
    Note over User,cTokenA: swapData = abi.encode(router, amountOutMin, path, deadline, to)

    cTokenA->>+SwapV0: onConfidentialTransferReceived(operator, from, amount, data)

    SwapV0->>SwapV0: decode swap parameters
    SwapV0->>+cTokenA: get nextTxId() for tracking

    Note over SwapV0: Prepare unwrap callback data
    SwapV0->>+cTokenA: confidentialTransferAndCall(WrapperA, amount, callbackData)

    cTokenA->>+WrapperA: onConfidentialTransferReceived(SwapV0, from, amount, data)

    Note over WrapperA: Calculate fees and burn tokens
    WrapperA->>+FHE: requestDecryption for unwrap amounts
    FHE-->>WrapperA: requestId

    Note over FHE: Async decryption (1 block latency)

    FHE->>+WrapperA: finalizeUnwrap(requestId, cleartexts, proof)

    WrapperA->>+TokenA: transfer(SwapV0, unwrapAmount)
    TokenA-->>WrapperA: success

    WrapperA->>+SwapV0: onUnwrapFinalizedReceived(operator, amount, callbackData)

    SwapV0->>+TokenA: approve(router, amountIn)
    TokenA-->>SwapV0: success

    SwapV0->>+Uniswap: swapExactTokensForTokens(amountIn, amountOutMin, path, SwapV0, deadline)

    alt Swap Success
        Uniswap-->>SwapV0: amounts[] (output amounts)

        SwapV0->>+TokenB: approve(WrapperB, amountOut)
        TokenB-->>SwapV0: success

        SwapV0->>+WrapperB: wrap(amountOut, to)
        WrapperB->>+cTokenB: mint(to, encryptedAmountOut)

        SwapV0-->>User: Swap event (success=true)
    else Swap Failure
        SwapV0->>+TokenA: approve(WrapperA, amountIn)
        TokenA-->>SwapV0: success

        SwapV0->>+WrapperA: wrap(amountIn, to) (rewrap original tokens)
        WrapperA->>+cTokenA: mint(to, encryptedAmountIn)

        SwapV0-->>User: Swap event (success=false)
    end
#+end_src

#+RESULTS:
[[file:img/swap-flow.png]]

** Key Features

- **Confidential Input**: Users send encrypted amounts that remain private during swap initiation
- **DEX Agnostic**: Supports any Uniswap V2-compatible router
- **Failure Recovery**: Failed swaps automatically rewrap original tokens back to user
- **Transaction Tracking**: Links unwrap and wrap operations for audit trails
- **Receiver Integration**: Uses IWrapperReceiver interface for seamless callbacks

** Security Considerations

- **MEV Protection**: Confidential amounts prevent sandwich attacks during swap setup
- **Slippage Protection**: Standard Uniswap slippage parameters (amountOutMin)
- **Deadline Protection**: Time-bound swaps prevent stale transactions
- **Atomic Recovery**: Failed swaps automatically return funds without manual intervention
- **Access Control**: Only confidential tokens can trigger swap operations

** Gas and Latency

- **Two-Block Process**: Unwrapping requires 1 block for FHE decryption, then swap execution
- **Gas Efficiency**: Single user transaction triggers entire swap flow
- **Event Tracking**: Comprehensive events link all transaction stages

* Conclusion

The Zaiffer system represents a sophisticated implementation of confidential tokens with regulatory compliance. The split factory architecture successfully addresses contract size limits while the AdminProvider pattern provides operational flexibility. Key security relies on proper FHE access control and careful upgrade management.

The addition of batch transfers and swap functionality extends the system's capabilities while maintaining confidentiality and security. The transferAndCall pattern eliminates the need for separate approval transactions, improving user experience and gas efficiency.
